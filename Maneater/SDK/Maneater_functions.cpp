#pragma once

// Dumped with Dumper-7!


#include "../SDK.hpp"

namespace SDK
{
//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------


// Class Maneater.ManeaterAIFunctionLibrary
// (None)

class UClass* UManeaterAIFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ManeaterAIFunctionLibrary");

	return Clss;
}


// ManeaterAIFunctionLibrary Maneater.Default__ManeaterAIFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UManeaterAIFunctionLibrary* UManeaterAIFunctionLibrary::GetDefaultObj()
{
	static class UManeaterAIFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UManeaterAIFunctionLibrary*>(UManeaterAIFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ManeaterAIFunctionLibrary.GetPawnAndAIController
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     InObject                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                       Out_Pawn                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_AIController*            Out_AIController                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManeaterAIFunctionLibrary::GetPawnAndAIController(class UObject* InObject, class APawn** Out_Pawn, class AME_AIController** Out_AIController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ManeaterAIFunctionLibrary", "GetPawnAndAIController");

	Params::UManeaterAIFunctionLibrary_GetPawnAndAIController_Params Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Out_Pawn != nullptr)
		*Out_Pawn = Parms.Out_Pawn;

	if (Out_AIController != nullptr)
		*Out_AIController = Parms.Out_AIController;

}


// Class Maneater.ME_AbilitySystemComponent
// (None)

class UClass* UME_AbilitySystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AbilitySystemComponent");

	return Clss;
}


// ME_AbilitySystemComponent Maneater.Default__ME_AbilitySystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AbilitySystemComponent* UME_AbilitySystemComponent::GetDefaultObj()
{
	static class UME_AbilitySystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AbilitySystemComponent*>(UME_AbilitySystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AbilitySystemComponent.SpawnEmitter
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMEGameplayEffectParticleSystemGameplayEffectParticleSystem                                     (Parm, OutParm, NativeAccessSpecifierPublic)
// class UParticleSystem*             ParticleSystem                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachComponent                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AbilitySystemComponent::SpawnEmitter(struct FMEGameplayEffectParticleSystem* GameplayEffectParticleSystem, class UParticleSystem* ParticleSystem, class USceneComponent* AttachComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AbilitySystemComponent", "SpawnEmitter");

	Params::UME_AbilitySystemComponent_SpawnEmitter_Params Parms{};

	Parms.ParticleSystem = ParticleSystem;
	Parms.AttachComponent = AttachComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (GameplayEffectParticleSystem != nullptr)
		*GameplayEffectParticleSystem = std::move(Parms.GameplayEffectParticleSystem);

}


// Function Maneater.ME_AbilitySystemComponent.GetAttributeSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UME_AttributeSet>AttributeSetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_AttributeSet*            ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AttributeSet* UME_AbilitySystemComponent::GetAttributeSet(TSubclassOf<class UME_AttributeSet> AttributeSetClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AbilitySystemComponent", "GetAttributeSet");

	Params::UME_AbilitySystemComponent_GetAttributeSet_Params Parms{};

	Parms.AttributeSetClass = AttributeSetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AbilitySystemInterface
// (None)

class UClass* IME_AbilitySystemInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AbilitySystemInterface");

	return Clss;
}


// ME_AbilitySystemInterface Maneater.Default__ME_AbilitySystemInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_AbilitySystemInterface* IME_AbilitySystemInterface::GetDefaultObj()
{
	static class IME_AbilitySystemInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_AbilitySystemInterface*>(IME_AbilitySystemInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ActorDamageInterface
// (None)

class UClass* IME_ActorDamageInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ActorDamageInterface");

	return Clss;
}


// ME_ActorDamageInterface Maneater.Default__ME_ActorDamageInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_ActorDamageInterface* IME_ActorDamageInterface::GetDefaultObj()
{
	static class IME_ActorDamageInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_ActorDamageInterface*>(IME_ActorDamageInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ActorDamageInterface.GetSizeLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IME_ActorDamageInterface::GetSizeLevel(class AME_AnimalCharacter* GrabbingAnimal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ActorDamageInterface", "GetSizeLevel");

	Params::IME_ActorDamageInterface_GetSizeLevel_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ActorDamageInterface.GetMaxHealth
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ActorDamageInterface::GetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ActorDamageInterface", "GetMaxHealth");

	Params::IME_ActorDamageInterface_GetMaxHealth_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ActorDamageInterface.GetCurrentHealth
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ActorDamageInterface::GetCurrentHealth()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ActorDamageInterface", "GetCurrentHealth");

	Params::IME_ActorDamageInterface_GetCurrentHealth_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AggroComponent
// (None)

class UClass* UME_AggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AggroComponent");

	return Clss;
}


// ME_AggroComponent Maneater.Default__ME_AggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AggroComponent* UME_AggroComponent::GetDefaultObj()
{
	static class UME_AggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AggroComponent*>(UME_AggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AggroComponent.Timer_OnSuspicionCooledDown
// (Final, Native, Protected)
// Parameters:

void UME_AggroComponent::Timer_OnSuspicionCooledDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AggroComponent", "Timer_OnSuspicionCooledDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AggroComponent.GetSuspicionLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_AggroComponent::GetSuspicionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AggroComponent", "GetSuspicionLevel");

	Params::UME_AggroComponent_GetSuspicionLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AggroComponent.GetAlertState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIThreatAlertState     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIThreatAlertState UME_AggroComponent::GetAlertState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AggroComponent", "GetAlertState");

	Params::UME_AggroComponent_GetAlertState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AICombatInterface
// (None)

class UClass* IME_AICombatInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AICombatInterface");

	return Clss;
}


// ME_AICombatInterface Maneater.Default__ME_AICombatInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_AICombatInterface* IME_AICombatInterface::GetDefaultObj()
{
	static class IME_AICombatInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_AICombatInterface*>(IME_AICombatInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AICombatInterface.CanAIAttackTarget
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FAttackTarget               PotentialTarget                                                  (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_AICombatInterface::CanAIAttackTarget(const struct FAttackTarget& PotentialTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AICombatInterface", "CanAIAttackTarget");

	Params::IME_AICombatInterface_CanAIAttackTarget_Params Parms{};

	Parms.PotentialTarget = PotentialTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AICombatInterface.AIAttackTarget
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FAttackTarget               NewTarget                                                        (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IME_AICombatInterface::AIAttackTarget(const struct FAttackTarget& NewTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AICombatInterface", "AIAttackTarget");

	Params::IME_AICombatInterface_AIAttackTarget_Params Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_AIController
// (Actor)

class UClass* AME_AIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AIController");

	return Clss;
}


// ME_AIController Maneater.Default__ME_AIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AIController* AME_AIController::GetDefaultObj()
{
	static class AME_AIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AIController*>(AME_AIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AIController.UseNearestPatrolPoint
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::UseNearestPatrolPoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "UseNearestPatrolPoint");

	Params::AME_AIController_UseNearestPatrolPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.UseAbility
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle  AbilityHandle                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::UseAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "UseAbility");

	Params::AME_AIController_UseAbility_Params Parms{};

	Parms.AbilityHandle = AbilityHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.TransferAlertKnowledge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::TransferAlertKnowledge(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "TransferAlertKnowledge");

	Params::AME_AIController_TransferAlertKnowledge_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.TickThreatTimer
// (Final, Native, Public)
// Parameters:

void AME_AIController::TickThreatTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "TickThreatTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetUseNearestPatrolPoint
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bUseNearest                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetUseNearestPatrolPoint(bool bUseNearest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetUseNearestPatrolPoint");

	Params::AME_AIController_SetUseNearestPatrolPoint_Params Parms{};

	Parms.bUseNearest = bUseNearest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetPatrolPlotter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATwAIPatrolPlotter*          InPatrolPlotter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetPatrolPlotter(class ATwAIPatrolPlotter* InPatrolPlotter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetPatrolPlotter");

	Params::AME_AIController_SetPatrolPlotter_Params Parms{};

	Parms.InPatrolPlotter = InPatrolPlotter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetLeashLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InLeashLocation                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetLeashLocation(struct FVector& InLeashLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetLeashLocation");

	Params::AME_AIController_SetLeashLocation_Params Parms{};

	Parms.InLeashLocation = InLeashLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetLeashActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bSetActive                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetLeashActive(bool bSetActive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetLeashActive");

	Params::AME_AIController_SetLeashActive_Params Parms{};

	Parms.bSetActive = bSetActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetCurrentDefinedPatrolIndex
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewPatrolIdx                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetCurrentDefinedPatrolIndex(int32 NewPatrolIdx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetCurrentDefinedPatrolIndex");

	Params::AME_AIController_SetCurrentDefinedPatrolIndex_Params Parms{};

	Parms.NewPatrolIdx = NewPatrolIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetBehaviorTreeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetBehaviorTreeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetBehaviorTreeEnabled");

	Params::AME_AIController_SetBehaviorTreeEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.SetAlertState
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EAIThreatAlertState     NewAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      AlertInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForced                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MillisecondDelayMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::SetAlertState(enum class EAIThreatAlertState NewAlertState, class AActor* AlertInstigator, bool bForced, int32 MillisecondDelayMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "SetAlertState");

	Params::AME_AIController_SetAlertState_Params Parms{};

	Parms.NewAlertState = NewAlertState;
	Parms.AlertInstigator = AlertInstigator;
	Parms.bForced = bForced;
	Parms.MillisecondDelayMax = MillisecondDelayMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnSuspicionIncreased
// (Final, Native, Protected)
// Parameters:
// float                              NewSuspicionLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      SuspicionInstigator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnSuspicionIncreased(float NewSuspicionLevel, class AActor* SuspicionInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnSuspicionIncreased");

	Params::AME_AIController_OnSuspicionIncreased_Params Parms{};

	Parms.NewSuspicionLevel = NewSuspicionLevel;
	Parms.SuspicionInstigator = SuspicionInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnReturnedToLeash
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_AIController::OnReturnedToLeash()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnReturnedToLeash");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnPlayerPawnStatusChanged
// (Native, Protected)
// Parameters:
// class AActor*                      PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnPlayerPawnStatusChanged(class AActor* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnPlayerPawnStatusChanged");

	Params::AME_AIController_OnPlayerPawnStatusChanged_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnHeardNoise
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                     NoiseOrigin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NoiseIntensity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      NoiseInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnHeardNoise(const struct FVector& NoiseOrigin, float NoiseIntensity, class AActor* NoiseInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnHeardNoise");

	Params::AME_AIController_OnHeardNoise_Params Parms{};

	Parms.NoiseOrigin = NoiseOrigin;
	Parms.NoiseIntensity = NoiseIntensity;
	Parms.NoiseInstigator = NoiseInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnDamagedPlayer
// (Final, Native, Public)
// Parameters:
// float                              DamageAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnDamagedPlayer(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnDamagedPlayer");

	Params::AME_AIController_OnDamagedPlayer_Params Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnDamaged
// (Final, Native, Public)
// Parameters:
// float                              DamageAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageInstigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnDamaged(float DamageAmount, class AActor* DamageInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnDamaged");

	Params::AME_AIController_OnDamaged_Params Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageInstigator = DamageInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.OnCombatStatusChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class ECombatStatus           Status                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::OnCombatStatusChanged(enum class ECombatStatus Status)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnCombatStatusChanged");

	Params::AME_AIController_OnCombatStatusChanged_Params Parms{};

	Parms.Status = Status;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_AIController.OnCombatCooldownExpired
// (Native, Protected)
// Parameters:

void AME_AIController::OnCombatCooldownExpired()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "OnCombatCooldownExpired");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.NotifyPawnHit
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                      SelfActor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AME_AIController::NotifyPawnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "NotifyPawnHit");

	Params::AME_AIController_NotifyPawnHit_Params Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.NotifyPawnDamaged
// (Native, Public)
// Parameters:
// class AActor*                      DamagedActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                 DamageType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InstigatedBy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::NotifyPawnDamaged(class AActor* DamagedActor, float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "NotifyPawnDamaged");

	Params::AME_AIController_NotifyPawnDamaged_Params Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.MakeAIAudibleNoise
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Origin                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Intensity                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      NoiseInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::MakeAIAudibleNoise(const struct FVector& Origin, float Intensity, class AActor* NoiseInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "MakeAIAudibleNoise");

	Params::AME_AIController_MakeAIAudibleNoise_Params Parms{};

	Parms.Origin = Origin;
	Parms.Intensity = Intensity;
	Parms.NoiseInstigator = NoiseInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.LookForThreats
// (Native, Public, BlueprintCallable)
// Parameters:

void AME_AIController::LookForThreats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "LookForThreats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.IsPlayerInstigatedAlert
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      AlertInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::IsPlayerInstigatedAlert(class AActor* AlertInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "IsPlayerInstigatedAlert");

	Params::AME_AIController_IsPlayerInstigatedAlert_Params Parms{};

	Parms.AlertInstigator = AlertInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.IsOnNavmesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::IsOnNavmesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "IsOnNavmesh");

	Params::AME_AIController_IsOnNavmesh_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.IsDormant
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::IsDormant()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "IsDormant");

	Params::AME_AIController_IsDormant_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.IsAlertedToPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::IsAlertedToPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "IsAlertedToPlayer");

	Params::AME_AIController_IsAlertedToPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.IncreaseSuspicion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              SuspicionAmount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      SuspcionInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::IncreaseSuspicion(float SuspicionAmount, class AActor* SuspcionInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "IncreaseSuspicion");

	Params::AME_AIController_IncreaseSuspicion_Params Parms{};

	Parms.SuspicionAmount = SuspicionAmount;
	Parms.SuspcionInstigator = SuspcionInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.GetTotalCombatPriority
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetTotalCombatPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetTotalCombatPriority");

	Params::AME_AIController_GetTotalCombatPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetSuspicion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetSuspicion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetSuspicion");

	Params::AME_AIController_GetSuspicion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetSightDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetSightDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetSightDistance");

	Params::AME_AIController_GetSightDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetPawnAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAbilitySystemComponent*     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* AME_AIController::GetPawnAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetPawnAbilitySystemComponent");

	Params::AME_AIController_GetPawnAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetPatrolPlotter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATwAIPatrolPlotter*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATwAIPatrolPlotter* AME_AIController::GetPatrolPlotter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetPatrolPlotter");

	Params::AME_AIController_GetPatrolPlotter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetLeashLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_AIController::GetLeashLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetLeashLocation");

	Params::AME_AIController_GetLeashLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetLeashDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetLeashDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetLeashDistance");

	Params::AME_AIController_GetLeashDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetLeashActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::GetLeashActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetLeashActive");

	Params::AME_AIController_GetLeashActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AME_AIController::GetEnemy()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetEnemy");

	Params::AME_AIController_GetEnemy_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCurrentDefinedPatrolIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_AIController::GetCurrentDefinedPatrolIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCurrentDefinedPatrolIndex");

	Params::AME_AIController_GetCurrentDefinedPatrolIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCurrentAlert
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIThreatAlertState     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIThreatAlertState AME_AIController::GetCurrentAlert()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCurrentAlert");

	Params::AME_AIController_GetCurrentAlert_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCombatStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECombatStatus           ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECombatStatus AME_AIController::GetCombatStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCombatStatus");

	Params::AME_AIController_GetCombatStatus_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCombatPriorityBuffs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetCombatPriorityBuffs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCombatPriorityBuffs");

	Params::AME_AIController_GetCombatPriorityBuffs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCombatPriority
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetCombatPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCombatPriority");

	Params::AME_AIController_GetCombatPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCombatLockTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetCombatLockTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCombatLockTime");

	Params::AME_AIController_GetCombatLockTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetCombatCooldownTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetCombatCooldownTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetCombatCooldownTime");

	Params::AME_AIController_GetCombatCooldownTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetClosestEscapeVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMEEscapeVolume*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMEEscapeVolume* AME_AIController::GetClosestEscapeVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetClosestEscapeVolume");

	Params::AME_AIController_GetClosestEscapeVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetBoatEscapeVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMEEscapeVolume*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMEEscapeVolume* AME_AIController::GetBoatEscapeVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetBoatEscapeVolume");

	Params::AME_AIController_GetBoatEscapeVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetBaseSightDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetBaseSightDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetBaseSightDistance");

	Params::AME_AIController_GetBaseSightDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.GetAbilityPriority
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AIController::GetAbilityPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "GetAbilityPriority");

	Params::AME_AIController_GetAbilityPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.CancelAllAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_AIController::CancelAllAbilities()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "CancelAllAbilities");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.CancelAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle  AbilityHandle                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::CancelAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "CancelAbility");

	Params::AME_AIController_CancelAbility_Params Parms{};

	Parms.AbilityHandle = AbilityHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.AttackTargetActor
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FAttackTarget               NewTarget                                                        (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AIController::AttackTargetActor(const struct FAttackTarget& NewTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "AttackTargetActor");

	Params::AME_AIController_AttackTargetActor_Params Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIController.AlertStateChangedInternal
// (Native, Protected)
// Parameters:
// enum class EAIThreatAlertState     OldAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAIThreatAlertState     NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ChangeInstigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIController::AlertStateChangedInternal(enum class EAIThreatAlertState OldAlertState, enum class EAIThreatAlertState NewState, class AActor* ChangeInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "AlertStateChangedInternal");

	Params::AME_AIController_AlertStateChangedInternal_Params Parms{};

	Parms.OldAlertState = OldAlertState;
	Parms.NewState = NewState;
	Parms.ChangeInstigator = ChangeInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.AddCombatPriorityBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCombatPriorityBuff         CombatPriorityBuff                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AME_AIController::AddCombatPriorityBuff(const struct FCombatPriorityBuff& CombatPriorityBuff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "AddCombatPriorityBuff");

	Params::AME_AIController_AddCombatPriorityBuff_Params Parms{};

	Parms.CombatPriorityBuff = CombatPriorityBuff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIController.AbilityEnded
// (Native, Public, HasOutParams)
// Parameters:
// struct FAbilityEndedData           AbilityData                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AME_AIController::AbilityEnded(struct FAbilityEndedData& AbilityData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIController", "AbilityEnded");

	Params::AME_AIController_AbilityEnded_Params Parms{};

	Parms.AbilityData = AbilityData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_AIDirector
// (Actor)

class UClass* AME_AIDirector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AIDirector");

	return Clss;
}


// ME_AIDirector Maneater.Default__ME_AIDirector
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AIDirector* AME_AIDirector::GetDefaultObj()
{
	static class AME_AIDirector* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AIDirector*>(AME_AIDirector::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AIDirector.UnregisterEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_AlertEvent*              AlertEvent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::UnregisterEvent(class UME_AlertEvent* AlertEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "UnregisterEvent");

	Params::AME_AIDirector_UnregisterEvent_Params Parms{};

	Parms.AlertEvent = AlertEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.UnregisterAllEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      LinkedActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::UnregisterAllEvents(class AActor* LinkedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "UnregisterAllEvents");

	Params::AME_AIDirector_UnregisterAllEvents_Params Parms{};

	Parms.LinkedActor = LinkedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.RegisterEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_AlertEvent*              AlertEvent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::RegisterEvent(class UME_AlertEvent* AlertEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "RegisterEvent");

	Params::AME_AIDirector_RegisterEvent_Params Parms{};

	Parms.AlertEvent = AlertEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.OnEventPulse
// (Final, Native, Public)
// Parameters:
// class UME_AlertEvent*              AlertEvent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::OnEventPulse(class UME_AlertEvent* AlertEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "OnEventPulse");

	Params::AME_AIDirector_OnEventPulse_Params Parms{};

	Parms.AlertEvent = AlertEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.OnEndAbility
// (Final, Native, Public)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_GameplayAbility*         Ability                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::OnEndAbility(class AME_AIController* AIC, class UME_GameplayAbility* Ability)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "OnEndAbility");

	Params::AME_AIDirector_OnEndAbility_Params Parms{};

	Parms.AIC = AIC;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.NotifyIncomingAttack
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                              BaseIncomingAttackDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsBite                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::NotifyIncomingAttack(float BaseIncomingAttackDistance, bool bIsBite)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "NotifyIncomingAttack");

	Params::AME_AIDirector_NotifyIncomingAttack_Params Parms{};

	Parms.BaseIncomingAttackDistance = BaseIncomingAttackDistance;
	Parms.bIsBite = bIsBite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.GetReleventWitnessEvents
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UME_AlertEvent_Witness*>Out_WitnessAlerts                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::GetReleventWitnessEvents(class AME_AIController* AIC, TArray<class UME_AlertEvent_Witness*>* Out_WitnessAlerts)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "GetReleventWitnessEvents");

	Params::AME_AIDirector_GetReleventWitnessEvents_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Out_WitnessAlerts != nullptr)
		*Out_WitnessAlerts = std::move(Parms.Out_WitnessAlerts);

}


// Function Maneater.ME_AIDirector.GetCombatManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_CombatManager*           ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_CombatManager* AME_AIDirector::GetCombatManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "GetCombatManager");

	Params::AME_AIDirector_GetCombatManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIDirector.ForceToAlertState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIThreatAlertState     NewAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>           PawnClass                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::ForceToAlertState(enum class EAIThreatAlertState NewAlertState, struct FVector& Origin, float Radius, TSubclassOf<class APawn> PawnClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "ForceToAlertState");

	Params::AME_AIDirector_ForceToAlertState_Params Parms{};

	Parms.NewAlertState = NewAlertState;
	Parms.Origin = Origin;
	Parms.Radius = Radius;
	Parms.PawnClass = PawnClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AIDirector.CreateAndRegisterWitnessEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      LinkedActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_AlertEvent_Witness*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AlertEvent_Witness* AME_AIDirector::CreateAndRegisterWitnessEvent(class AActor* LinkedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "CreateAndRegisterWitnessEvent");

	Params::AME_AIDirector_CreateAndRegisterWitnessEvent_Params Parms{};

	Parms.LinkedActor = LinkedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AIDirector.BroadcastNoise
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NoiseOrigin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NoiseIntensity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      NoiseInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AIDirector::BroadcastNoise(const struct FVector& NoiseOrigin, float NoiseIntensity, class AActor* NoiseInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AIDirector", "BroadcastNoise");

	Params::AME_AIDirector_BroadcastNoise_Params Parms{};

	Parms.NoiseOrigin = NoiseOrigin;
	Parms.NoiseIntensity = NoiseIntensity;
	Parms.NoiseInstigator = NoiseInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_VehicleMovementComponent
// (None)

class UClass* UME_VehicleMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehicleMovementComponent");

	return Clss;
}


// ME_VehicleMovementComponent Maneater.Default__ME_VehicleMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_VehicleMovementComponent* UME_VehicleMovementComponent::GetDefaultObj()
{
	static class UME_VehicleMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_VehicleMovementComponent*>(UME_VehicleMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_VehicleMovementComponent.GetLocalVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_VehicleMovementComponent::GetLocalVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehicleMovementComponent", "GetLocalVelocity");

	Params::UME_VehicleMovementComponent_GetLocalVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehicleMovementComponent.GetAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_VehicleMovementComponent::GetAngularVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehicleMovementComponent", "GetAngularVelocity");

	Params::UME_VehicleMovementComponent_GetAngularVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehicleMovementComponent.AddImpulse
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpulseLocation                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpulseNormal                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_VehicleMovementComponent::AddImpulse(struct FVector& Impulse, struct FVector& ImpulseLocation, struct FVector& ImpulseNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehicleMovementComponent", "AddImpulse");

	Params::UME_VehicleMovementComponent_AddImpulse_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.ImpulseLocation = ImpulseLocation;
	Parms.ImpulseNormal = ImpulseNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_AirVehicleMoveComponent
// (None)

class UClass* UME_AirVehicleMoveComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AirVehicleMoveComponent");

	return Clss;
}


// ME_AirVehicleMoveComponent Maneater.Default__ME_AirVehicleMoveComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AirVehicleMoveComponent* UME_AirVehicleMoveComponent::GetDefaultObj()
{
	static class UME_AirVehicleMoveComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AirVehicleMoveComponent*>(UME_AirVehicleMoveComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AITask_DirectMoveTo
// (None)

class UClass* UME_AITask_DirectMoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AITask_DirectMoveTo");

	return Clss;
}


// ME_AITask_DirectMoveTo Maneater.Default__ME_AITask_DirectMoveTo
// (Public, ClassDefaultObject, ArchetypeObject, StrongRefOnFrame)

class UME_AITask_DirectMoveTo* UME_AITask_DirectMoveTo::GetDefaultObj()
{
	static class UME_AITask_DirectMoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AITask_DirectMoveTo*>(UME_AITask_DirectMoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AITask_VehicleDirectMoveTo
// (None)

class UClass* UME_AITask_VehicleDirectMoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AITask_VehicleDirectMoveTo");

	return Clss;
}


// ME_AITask_VehicleDirectMoveTo Maneater.Default__ME_AITask_VehicleDirectMoveTo
// (Public, ClassDefaultObject, ArchetypeObject, StrongRefOnFrame)

class UME_AITask_VehicleDirectMoveTo* UME_AITask_VehicleDirectMoveTo::GetDefaultObj()
{
	static class UME_AITask_VehicleDirectMoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AITask_VehicleDirectMoveTo*>(UME_AITask_VehicleDirectMoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AlertEvent
// (None)

class UClass* UME_AlertEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AlertEvent");

	return Clss;
}


// ME_AlertEvent Maneater.Default__ME_AlertEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AlertEvent* UME_AlertEvent::GetDefaultObj()
{
	static class UME_AlertEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AlertEvent*>(UME_AlertEvent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AlertEvent.Timer_PeriodicPulse
// (Final, Native, Protected)
// Parameters:

void UME_AlertEvent::Timer_PeriodicPulse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "Timer_PeriodicPulse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AlertEvent.Timer_Lifetime
// (Final, Native, Protected)
// Parameters:

void UME_AlertEvent::Timer_Lifetime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "Timer_Lifetime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AlertEvent.SetEventLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InEventLocation                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AlertEvent::SetEventLocation(struct FVector& InEventLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "SetEventLocation");

	Params::UME_AlertEvent_SetEventLocation_Params Parms{};

	Parms.InEventLocation = InEventLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AlertEvent.LinkActorToEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ActorToLink                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AlertEvent::LinkActorToEvent(class AActor* ActorToLink)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "LinkActorToEvent");

	Params::UME_AlertEvent_LinkActorToEvent_Params Parms{};

	Parms.ActorToLink = ActorToLink;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AlertEvent.GetSuspicionAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_AlertEvent::GetSuspicionAmount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "GetSuspicionAmount");

	Params::UME_AlertEvent_GetSuspicionAmount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AlertEvent.GetLinkedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_AlertEvent::GetLinkedActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "GetLinkedActor");

	Params::UME_AlertEvent_GetLinkedActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AlertEvent.GetEventLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_AlertEvent::GetEventLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "GetEventLocation");

	Params::UME_AlertEvent_GetEventLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AlertEvent.CanProcessEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_AlertEvent::CanProcessEvent(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent", "CanProcessEvent");

	Params::UME_AlertEvent_CanProcessEvent_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AlertEvent_Witness
// (None)

class UClass* UME_AlertEvent_Witness::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AlertEvent_Witness");

	return Clss;
}


// ME_AlertEvent_Witness Maneater.Default__ME_AlertEvent_Witness
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AlertEvent_Witness* UME_AlertEvent_Witness::GetDefaultObj()
{
	static class UME_AlertEvent_Witness* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AlertEvent_Witness*>(UME_AlertEvent_Witness::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AlertEvent_Witness.GetCachedVisiblePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_AlertEvent_Witness::GetCachedVisiblePoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AlertEvent_Witness", "GetCachedVisiblePoint");

	Params::UME_AlertEvent_Witness_GetCachedVisiblePoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AmbientActivityComponent
// (None)

class UClass* UME_AmbientActivityComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AmbientActivityComponent");

	return Clss;
}


// ME_AmbientActivityComponent Maneater.Default__ME_AmbientActivityComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AmbientActivityComponent* UME_AmbientActivityComponent::GetDefaultObj()
{
	static class UME_AmbientActivityComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AmbientActivityComponent*>(UME_AmbientActivityComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ActivityProp
// (None)

class UClass* UME_ActivityProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ActivityProp");

	return Clss;
}


// ME_ActivityProp Maneater.Default__ME_ActivityProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ActivityProp* UME_ActivityProp::GetDefaultObj()
{
	static class UME_ActivityProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ActivityProp*>(UME_ActivityProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ActivityProp_Static
// (None)

class UClass* UME_ActivityProp_Static::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ActivityProp_Static");

	return Clss;
}


// ME_ActivityProp_Static Maneater.Default__ME_ActivityProp_Static
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ActivityProp_Static* UME_ActivityProp_Static::GetDefaultObj()
{
	static class UME_ActivityProp_Static* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ActivityProp_Static*>(UME_ActivityProp_Static::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ActivityProp_Skeletal
// (None)

class UClass* UME_ActivityProp_Skeletal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ActivityProp_Skeletal");

	return Clss;
}


// ME_ActivityProp_Skeletal Maneater.Default__ME_ActivityProp_Skeletal
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ActivityProp_Skeletal* UME_ActivityProp_Skeletal::GetDefaultObj()
{
	static class UME_ActivityProp_Skeletal* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ActivityProp_Skeletal*>(UME_ActivityProp_Skeletal::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ActivityProp_Decal
// (None)

class UClass* UME_ActivityProp_Decal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ActivityProp_Decal");

	return Clss;
}


// ME_ActivityProp_Decal Maneater.Default__ME_ActivityProp_Decal
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ActivityProp_Decal* UME_ActivityProp_Decal::GetDefaultObj()
{
	static class UME_ActivityProp_Decal* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ActivityProp_Decal*>(UME_ActivityProp_Decal::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AmbientActivityData
// (None)

class UClass* UME_AmbientActivityData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AmbientActivityData");

	return Clss;
}


// ME_AmbientActivityData Maneater.Default__ME_AmbientActivityData
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AmbientActivityData* UME_AmbientActivityData::GetDefaultObj()
{
	static class UME_AmbientActivityData* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AmbientActivityData*>(UME_AmbientActivityData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AmbientActivityPoint
// (Actor)

class UClass* AME_AmbientActivityPoint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AmbientActivityPoint");

	return Clss;
}


// ME_AmbientActivityPoint Maneater.Default__ME_AmbientActivityPoint
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AmbientActivityPoint* AME_AmbientActivityPoint::GetDefaultObj()
{
	static class AME_AmbientActivityPoint* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AmbientActivityPoint*>(AME_AmbientActivityPoint::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CharacterAIController
// (Actor)

class UClass* AME_CharacterAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterAIController");

	return Clss;
}


// ME_CharacterAIController Maneater.Default__ME_CharacterAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_CharacterAIController* AME_CharacterAIController::GetDefaultObj()
{
	static class AME_CharacterAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_CharacterAIController*>(AME_CharacterAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CharacterAIController.OnGameplayTagRemoved
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTagContainer       TagsRemoved                                                      (Parm, NativeAccessSpecifierPublic)

void AME_CharacterAIController::OnGameplayTagRemoved(const struct FGameplayTagContainer& TagsRemoved)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAIController", "OnGameplayTagRemoved");

	Params::AME_CharacterAIController_OnGameplayTagRemoved_Params Parms{};

	Parms.TagsRemoved = TagsRemoved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterAIController.OnGameplayTagAdded
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTagContainer       TagsAdded                                                        (Parm, NativeAccessSpecifierPublic)
// float                              TagDuration                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_CharacterAIController::OnGameplayTagAdded(const struct FGameplayTagContainer& TagsAdded, float TagDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAIController", "OnGameplayTagAdded");

	Params::AME_CharacterAIController_OnGameplayTagAdded_Params Parms{};

	Parms.TagsAdded = TagsAdded;
	Parms.TagDuration = TagDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterAIController.OnForceStopMoving
// (Native, Protected, HasOutParams)
// Parameters:
// enum class EThreeStateSwitch       MovementState                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EThreeStateSwitch       RotationState                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_CharacterAIController::OnForceStopMoving(enum class EThreeStateSwitch& MovementState, enum class EThreeStateSwitch& RotationState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAIController", "OnForceStopMoving");

	Params::AME_CharacterAIController_OnForceStopMoving_Params Parms{};

	Parms.MovementState = MovementState;
	Parms.RotationState = RotationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_AnimalAIController
// (Actor)

class UClass* AME_AnimalAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimalAIController");

	return Clss;
}


// ME_AnimalAIController Maneater.Default__ME_AnimalAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AnimalAIController* AME_AnimalAIController::GetDefaultObj()
{
	static class AME_AnimalAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AnimalAIController*>(AME_AnimalAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AnimalAIController.TriggerEvadeIfWithinRange
// (Final, Native, Private)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalAIController::TriggerEvadeIfWithinRange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalAIController", "TriggerEvadeIfWithinRange");

	Params::AME_AnimalAIController_TriggerEvadeIfWithinRange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalAIController.TriggerEvade
// (Final, Native, Private)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalAIController::TriggerEvade()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalAIController", "TriggerEvade");

	Params::AME_AnimalAIController_TriggerEvade_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalAIController.OnPreyGrabbed
// (Final, Native, Protected)
// Parameters:
// class AME_AnimalCharacter*         Grabber                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Prey                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalAIController::OnPreyGrabbed(class AME_AnimalCharacter* Grabber, class AActor* Prey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalAIController", "OnPreyGrabbed");

	Params::AME_AnimalAIController_OnPreyGrabbed_Params Parms{};

	Parms.Grabber = Grabber;
	Parms.Prey = Prey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_Character
// (Actor, Pawn)

class UClass* AME_Character::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_Character");

	return Clss;
}


// ME_Character Maneater.Default__ME_Character
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_Character* AME_Character::GetDefaultObj()
{
	static class AME_Character* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_Character*>(AME_Character::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_Character.UpdateVulnerability
// (Final, Native, Private)
// Parameters:

void AME_Character::UpdateVulnerability()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "UpdateVulnerability");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.StopVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_Character::StopVoice()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "StopVoice");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.StopAI
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                      StopReason                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::StopAI(const class FString& StopReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "StopAI");

	Params::AME_Character_StopAI_Params Parms{};

	Parms.StopReason = StopReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.SetRootMotionNonUniformTranslationScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InRootMotionScale                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::SetRootMotionNonUniformTranslationScale(struct FVector& InRootMotionScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "SetRootMotionNonUniformTranslationScale");

	Params::AME_Character_SetRootMotionNonUniformTranslationScale_Params Parms{};

	Parms.InRootMotionScale = InRootMotionScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.SetDesiredAnimDir
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDirOctant              AnimDir                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::SetDesiredAnimDir(enum class EDirOctant AnimDir)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "SetDesiredAnimDir");

	Params::AME_Character_SetDesiredAnimDir_Params Parms{};

	Parms.AnimDir = AnimDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.SetDeathPhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PhysicsBlendDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPartialPhysics                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::SetDeathPhysics(float PhysicsBlendDuration, bool bPartialPhysics)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "SetDeathPhysics");

	Params::AME_Character_SetDeathPhysics_Params Parms{};

	Parms.PhysicsBlendDuration = PhysicsBlendDuration;
	Parms.bPartialPhysics = bPartialPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.SetAIPatrolPlotter
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATwAIPatrolPlotter*          InPatrolPlotter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::SetAIPatrolPlotter(class ATwAIPatrolPlotter* InPatrolPlotter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "SetAIPatrolPlotter");

	Params::AME_Character_SetAIPatrolPlotter_Params Parms{};

	Parms.InPatrolPlotter = InPatrolPlotter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.RestartAI
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                               bMaintainAggroInfo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::RestartAI(bool bMaintainAggroInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "RestartAI");

	Params::AME_Character_RestartAI_Params Parms{};

	Parms.bMaintainAggroInfo = bMaintainAggroInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.PulseDynamicDialogueEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                        DialogueEventName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ArgumentValueNames                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::PulseDynamicDialogueEvent(class FName* DialogueEventName, const TArray<class FString>& ArgumentValueNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "PulseDynamicDialogueEvent");

	Params::AME_Character_PulseDynamicDialogueEvent_Params Parms{};

	Parms.ArgumentValueNames = ArgumentValueNames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DialogueEventName != nullptr)
		*DialogueEventName = Parms.DialogueEventName;

}


// Function Maneater.ME_Character.ProcessRagdollImpactResponse
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class UPhysicalMaterial*           InstigatorPM                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InstigatorComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::ProcessRagdollImpactResponse(class UPhysicalMaterial* InstigatorPM, class UPrimitiveComponent* InstigatorComp, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "ProcessRagdollImpactResponse");

	Params::AME_Character_ProcessRagdollImpactResponse_Params Parms{};

	Parms.InstigatorPM = InstigatorPM;
	Parms.InstigatorComp = InstigatorComp;
	Parms.OtherComp = OtherComp;
	Parms.HitLocation = HitLocation;
	Parms.HitNormal = HitNormal;
	Parms.NormalImpulse = NormalImpulse;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_Character.PostDynamicDialogueEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        DialogueEventName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ArgumentValueNames                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::PostDynamicDialogueEvent(class FName* DialogueEventName, TArray<class FString>* ArgumentValueNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "PostDynamicDialogueEvent");

	Params::AME_Character_PostDynamicDialogueEvent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DialogueEventName != nullptr)
		*DialogueEventName = Parms.DialogueEventName;

	if (ArgumentValueNames != nullptr)
		*ArgumentValueNames = std::move(Parms.ArgumentValueNames);

}


// Function Maneater.ME_Character.PlayVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECharacterVoiceEventTypeVoiceType                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              VoicePriority                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::PlayVoice(enum class ECharacterVoiceEventType VoiceType, int32 VoicePriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "PlayVoice");

	Params::AME_Character_PlayVoice_Params Parms{};

	Parms.VoiceType = VoiceType;
	Parms.VoicePriority = VoicePriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.PlayFootstep
// (Native, Public, BlueprintCallable)
// Parameters:

void AME_Character::PlayFootstep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "PlayFootstep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnStunArmorDepleted
// (Final, Native, Public)
// Parameters:

void AME_Character::OnStunArmorDepleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnStunArmorDepleted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnPlayerSharkGrowthLevelChanged
// (Native, Protected)
// Parameters:
// int32                              NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bChangeFromTheoretical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::OnPlayerSharkGrowthLevelChanged(int32 NewLevel, bool bChangeFromTheoretical)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnPlayerSharkGrowthLevelChanged");

	Params::AME_Character_OnPlayerSharkGrowthLevelChanged_Params Parms{};

	Parms.NewLevel = NewLevel;
	Parms.bChangeFromTheoretical = bChangeFromTheoretical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnPhysicsVolumeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APhysicsVolume*              NewVolume                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::OnPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnPhysicsVolumeChanged");

	Params::AME_Character_OnPhysicsVolumeChanged_Params Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnGameplayEffectRemoved
// (Native, Public, HasOutParams)
// Parameters:
// struct FActiveGameplayEffect       RemovedGameplayEffect                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AME_Character::OnGameplayEffectRemoved(struct FActiveGameplayEffect& RemovedGameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnGameplayEffectRemoved");

	Params::AME_Character_OnGameplayEffectRemoved_Params Parms{};

	Parms.RemovedGameplayEffect = RemovedGameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnGameplayEffectApplied
// (Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*     Source                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec         SpecApplied                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle ActiveHandle                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::OnGameplayEffectApplied(class UAbilitySystemComponent* Source, struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnGameplayEffectApplied");

	Params::AME_Character_OnGameplayEffectApplied_Params Parms{};

	Parms.Source = Source;
	Parms.SpecApplied = SpecApplied;
	Parms.ActiveHandle = ActiveHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.OnDied
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 Killer                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::OnDied(class AController* Killer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnDied");

	Params::AME_Character_OnDied_Params Parms{};

	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_Character.OnBump
// (Final, Native, Public)
// Parameters:

void AME_Character::OnBump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "OnBump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.IsVulnerable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsVulnerable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsVulnerable");

	Params::AME_Character_IsVulnerable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsUnderwater
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsUnderwater()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsUnderwater");

	Params::AME_Character_IsUnderwater_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsTagged
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsTagged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsTagged");

	Params::AME_Character_IsTagged_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsSilhouetted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsSilhouetted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsSilhouetted");

	Params::AME_Character_IsSilhouetted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsPhysicalAnimationActive
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsPhysicalAnimationActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsPhysicalAnimationActive");

	Params::AME_Character_IsPhysicalAnimationActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsPassenger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsPassenger()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsPassenger");

	Params::AME_Character_IsPassenger_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsInstigatingAnyAlerts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsInstigatingAnyAlerts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsInstigatingAnyAlerts");

	Params::AME_Character_IsInstigatingAnyAlerts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsDrowning
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsDrowning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsDrowning");

	Params::AME_Character_IsDrowning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsCritVulnerable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsCritVulnerable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsCritVulnerable");

	Params::AME_Character_IsCritVulnerable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsBeingThrashedByPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsBeingThrashedByPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsBeingThrashedByPlayer");

	Params::AME_Character_IsBeingThrashedByPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsBeingThrashed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsBeingThrashed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsBeingThrashed");

	Params::AME_Character_IsBeingThrashed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsAliveAndWell
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsAliveAndWell()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsAliveAndWell");

	Params::AME_Character_IsAliveAndWell_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.IsAbilitySystemComponentSetUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::IsAbilitySystemComponentSetUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "IsAbilitySystemComponentSetUp");

	Params::AME_Character_IsAbilitySystemComponentSetUp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.HasPassedVulnerabilityThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::HasPassedVulnerabilityThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "HasPassedVulnerabilityThreshold");

	Params::AME_Character_HasPassedVulnerabilityThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetWasRecentlyBumped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::GetWasRecentlyBumped()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetWasRecentlyBumped");

	Params::AME_Character_GetWasRecentlyBumped_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetVisionTypeAsDialogueString
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AME_Character::GetVisionTypeAsDialogueString()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetVisionTypeAsDialogueString");

	Params::AME_Character_GetVisionTypeAsDialogueString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetThrashEscapeDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AME_Character::GetThrashEscapeDirection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetThrashEscapeDirection");

	Params::AME_Character_GetThrashEscapeDirection_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetRootMotionNonUniformTranslationScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_Character::GetRootMotionNonUniformTranslationScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetRootMotionNonUniformTranslationScale");

	Params::AME_Character_GetRootMotionNonUniformTranslationScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetPassengerVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_VehiclePawn*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_VehiclePawn* AME_Character::GetPassengerVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetPassengerVehicle");

	Params::AME_Character_GetPassengerVehicle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetPassengerSeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_Character::GetPassengerSeat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetPassengerSeat");

	Params::AME_Character_GetPassengerSeat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetOriginalPhysicsAsset
// (Final, Native, Public)
// Parameters:
// class UPhysicsAsset*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicsAsset* AME_Character::GetOriginalPhysicsAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetOriginalPhysicsAsset");

	Params::AME_Character_GetOriginalPhysicsAsset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetNutritionData_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNutrientChunkList          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNutrientChunkList AME_Character::GetNutritionData_BP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetNutritionData_BP");

	Params::AME_Character_GetNutritionData_BP_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetMercunaObstacle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_MercunaObstacleComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_MercunaObstacleComponent* AME_Character::GetMercunaObstacle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetMercunaObstacle");

	Params::AME_Character_GetMercunaObstacle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetMercunaNavigation
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_MercunaNavigationComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_MercunaNavigationComponent* AME_Character::GetMercunaNavigation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetMercunaNavigation");

	Params::AME_Character_GetMercunaNavigation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetLocationAsDialogueString
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AME_Character::GetLocationAsDialogueString()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetLocationAsDialogueString");

	Params::AME_Character_GetLocationAsDialogueString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetHeadLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_Character::GetHeadLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetHeadLocation");

	Params::AME_Character_GetHeadLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetFloorPhysicalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UME_PhysicalMaterial*        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PhysicalMaterial* AME_Character::GetFloorPhysicalMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetFloorPhysicalMaterial");

	Params::AME_Character_GetFloorPhysicalMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetDesiredAnimDir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDirOctant              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDirOctant AME_Character::GetDesiredAnimDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetDesiredAnimDir");

	Params::AME_Character_GetDesiredAnimDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetCollisionComponent
// (Native, Public)
// Parameters:
// class UCapsuleComponent*           ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* AME_Character::GetCollisionComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetCollisionComponent");

	Params::AME_Character_GetCollisionComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetCharacterVisionType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EVisionType             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EVisionType AME_Character::GetCharacterVisionType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetCharacterVisionType");

	Params::AME_Character_GetCharacterVisionType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetAIPatrolPlotter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATwAIPatrolPlotter*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATwAIPatrolPlotter* AME_Character::GetAIPatrolPlotter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetAIPatrolPlotter");

	Params::AME_Character_GetAIPatrolPlotter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_AbilitySystemComponent*  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AbilitySystemComponent* AME_Character::GetAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "GetAbilitySystemComponent");

	Params::AME_Character_GetAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.Died
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 Killer                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPlayDeathAnimation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Character::Died(class AController* Killer, bool bPlayDeathAnimation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "Died");

	Params::AME_Character_Died_Params Parms{};

	Parms.Killer = Killer;
	Parms.bPlayDeathAnimation = bPlayDeathAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.Despawn
// (Native, Public, BlueprintCallable)
// Parameters:

void AME_Character::Despawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "Despawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.ClearAttachedProjectiles
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_Character::ClearAttachedProjectiles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "ClearAttachedProjectiles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Character.CanVisionTypeSeeCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EVisionType             VisionType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_Character::CanVisionTypeSeeCharacter(enum class EVisionType VisionType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "CanVisionTypeSeeCharacter");

	Params::AME_Character_CanVisionTypeSeeCharacter_Params Parms{};

	Parms.VisionType = VisionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_Character.BlendBackToDefault
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_Character::BlendBackToDefault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Character", "BlendBackToDefault");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.ME_AnimalCharacter
// (Actor, Pawn)

class UClass* AME_AnimalCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimalCharacter");

	return Clss;
}


// ME_AnimalCharacter Maneater.Default__ME_AnimalCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AnimalCharacter* AME_AnimalCharacter::GetDefaultObj()
{
	static class AME_AnimalCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AnimalCharacter*>(AME_AnimalCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AnimalCharacter.UseKnockbackRagdoll
// (Final, Native, Public)
// Parameters:

void AME_AnimalCharacter::UseKnockbackRagdoll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "UseKnockbackRagdoll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.UpdatePartialRagdoll
// (Final, Native, Public)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::UpdatePartialRagdoll(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "UpdatePartialRagdoll");

	Params::AME_AnimalCharacter_UpdatePartialRagdoll_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.UpdateJointBlendWeight
// (Final, Native, Public)
// Parameters:
// class USkeletalMeshComponent*      SKM                                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PartialPhysicsBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AnimBlendMultiplier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SpeedPercent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::UpdateJointBlendWeight(class USkeletalMeshComponent* SKM, class FName BoneName, float PartialPhysicsBase, float AnimBlendMultiplier, float SpeedPercent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "UpdateJointBlendWeight");

	Params::AME_AnimalCharacter_UpdateJointBlendWeight_Params Parms{};

	Parms.SKM = SKM;
	Parms.BoneName = BoneName;
	Parms.PartialPhysicsBase = PartialPhysicsBase;
	Parms.AnimBlendMultiplier = AnimBlendMultiplier;
	Parms.SpeedPercent = SpeedPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.TryUseEvadeAbility
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EComboDirection         InputDirection                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReversed                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::TryUseEvadeAbility(enum class EComboDirection InputDirection, bool bReversed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "TryUseEvadeAbility");

	Params::AME_AnimalCharacter_TryUseEvadeAbility_Params Parms{};

	Parms.InputDirection = InputDirection;
	Parms.bReversed = bReversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.StopThrashing
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_AnimalCharacter::StopThrashing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "StopThrashing");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.SetThreatLevel
// (Final, Native, Public)
// Parameters:
// enum class EAIThreatAlertState     NewAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InstigatingActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::SetThreatLevel(enum class EAIThreatAlertState NewAlertState, class AActor* InstigatingActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "SetThreatLevel");

	Params::AME_AnimalCharacter_SetThreatLevel_Params Parms{};

	Parms.NewAlertState = NewAlertState;
	Parms.InstigatingActor = InstigatingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.OnConsumedGrabPoint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FThrashGrabPoint            ConsumedGrabPoint                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::OnConsumedGrabPoint(struct FThrashGrabPoint& ConsumedGrabPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "OnConsumedGrabPoint");

	Params::AME_AnimalCharacter_OnConsumedGrabPoint_Params Parms{};

	Parms.ConsumedGrabPoint = ConsumedGrabPoint;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_AnimalCharacter.OnAbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EME_CharacterAbility    Ability                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::OnAbilityActivated(enum class EME_CharacterAbility Ability)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "OnAbilityActivated");

	Params::AME_AnimalCharacter_OnAbilityActivated_Params Parms{};

	Parms.Ability = Ability;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_AnimalCharacter.ModifyStamina
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Change                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_AnimalCharacter::ModifyStamina(float Change)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "ModifyStamina");

	Params::AME_AnimalCharacter_ModifyStamina_Params Parms{};

	Parms.Change = Change;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.IsTransitioning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::IsTransitioning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "IsTransitioning");

	Params::AME_AnimalCharacter_IsTransitioning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.IsThrashing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::IsThrashing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "IsThrashing");

	Params::AME_AnimalCharacter_IsThrashing_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.IsLunging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::IsLunging()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "IsLunging");

	Params::AME_AnimalCharacter_IsLunging_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.IsEvading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::IsEvading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "IsEvading");

	Params::AME_AnimalCharacter_IsEvading_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.HasAnyStamina
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::HasAnyStamina()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "HasAnyStamina");

	Params::AME_AnimalCharacter_HasAnyStamina_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetThrashDecayPct
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetThrashDecayPct()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetThrashDecayPct");

	Params::AME_AnimalCharacter_GetThrashDecayPct_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetThrashDamagePool
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetThrashDamagePool()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetThrashDamagePool");

	Params::AME_AnimalCharacter_GetThrashDamagePool_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetTailLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_AnimalCharacter::GetTailLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetTailLocation");

	Params::AME_AnimalCharacter_GetTailLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetTailControlStrength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetTailControlStrength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetTailControlStrength");

	Params::AME_AnimalCharacter_GetTailControlStrength_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetPreyAttachBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AME_AnimalCharacter::GetPreyAttachBoneName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetPreyAttachBoneName");

	Params::AME_AnimalCharacter_GetPreyAttachBoneName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetMaxMoveSpeed
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetMaxMoveSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetMaxMoveSpeed");

	Params::AME_AnimalCharacter_GetMaxMoveSpeed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetJawsLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_AnimalCharacter::GetJawsLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetJawsLocation");

	Params::AME_AnimalCharacter_GetJawsLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetJawSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetJawSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetJawSize");

	Params::AME_AnimalCharacter_GetJawSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetDrownSpeedModifier
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetDrownSpeedModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetDrownSpeedModifier");

	Params::AME_AnimalCharacter_GetDrownSpeedModifier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetDrownSpeedBase
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetDrownSpeedBase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetDrownSpeedBase");

	Params::AME_AnimalCharacter_GetDrownSpeedBase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetCurrentSpeedPct
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetCurrentSpeedPct()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetCurrentSpeedPct");

	Params::AME_AnimalCharacter_GetCurrentSpeedPct_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetBaseThrashDamage
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetBaseThrashDamage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetBaseThrashDamage");

	Params::AME_AnimalCharacter_GetBaseThrashDamage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetBaseTailwhipDamage
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetBaseTailwhipDamage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetBaseTailwhipDamage");

	Params::AME_AnimalCharacter_GetBaseTailwhipDamage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetBaseStrugglePower
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetBaseStrugglePower()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetBaseStrugglePower");

	Params::AME_AnimalCharacter_GetBaseStrugglePower_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetBaseStrikeDamage
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetBaseStrikeDamage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetBaseStrikeDamage");

	Params::AME_AnimalCharacter_GetBaseStrikeDamage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.GetBaseBiteDamage
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_AnimalCharacter::GetBaseBiteDamage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "GetBaseBiteDamage");

	Params::AME_AnimalCharacter_GetBaseBiteDamage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.EndKnockbackRagdoll
// (Final, Native, Public)
// Parameters:

void AME_AnimalCharacter::EndKnockbackRagdoll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "EndKnockbackRagdoll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimalCharacter.ConsumePreyWhole
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ThrashablePrey                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::ConsumePreyWhole(class AActor* ThrashablePrey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "ConsumePreyWhole");

	Params::AME_AnimalCharacter_ConsumePreyWhole_Params Parms{};

	Parms.ThrashablePrey = ThrashablePrey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.CanGrabPrey
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ThrashablePrey                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::CanGrabPrey(class AActor* ThrashablePrey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "CanGrabPrey");

	Params::AME_AnimalCharacter_CanGrabPrey_Params Parms{};

	Parms.ThrashablePrey = ThrashablePrey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimalCharacter.CanEnterCombatMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_AnimalCharacter::CanEnterCombatMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimalCharacter", "CanEnterCombatMovement");

	Params::AME_AnimalCharacter_CanEnterCombatMovement_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_CharacterMovementComponent
// (None)

class UClass* UME_CharacterMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterMovementComponent");

	return Clss;
}


// ME_CharacterMovementComponent Maneater.Default__ME_CharacterMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterMovementComponent* UME_CharacterMovementComponent::GetDefaultObj()
{
	static class UME_CharacterMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterMovementComponent*>(UME_CharacterMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CharacterMovementComponent.UpdateMercunaMovementProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_CharacterMovementComponent::UpdateMercunaMovementProperties()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterMovementComponent", "UpdateMercunaMovementProperties");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterMovementComponent.SetOverrideMercunaAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     OverrideAcceleration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CharacterMovementComponent::SetOverrideMercunaAcceleration(const struct FVector& OverrideAcceleration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterMovementComponent", "SetOverrideMercunaAcceleration");

	Params::UME_CharacterMovementComponent_SetOverrideMercunaAcceleration_Params Parms{};

	Parms.OverrideAcceleration = OverrideAcceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterMovementComponent.GetMercunaAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_CharacterMovementComponent::GetMercunaAcceleration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterMovementComponent", "GetMercunaAcceleration");

	Params::UME_CharacterMovementComponent_GetMercunaAcceleration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterMovementComponent.GetLocalVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_CharacterMovementComponent::GetLocalVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterMovementComponent", "GetLocalVelocity");

	Params::UME_CharacterMovementComponent_GetLocalVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterMovementComponent.AtSeaLevel
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CharacterMovementComponent::AtSeaLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterMovementComponent", "AtSeaLevel");

	Params::UME_CharacterMovementComponent_AtSeaLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AnimalMovementComponent
// (None)

class UClass* UME_AnimalMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimalMovementComponent");

	return Clss;
}


// ME_AnimalMovementComponent Maneater.Default__ME_AnimalMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimalMovementComponent* UME_AnimalMovementComponent::GetDefaultObj()
{
	static class UME_AnimalMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimalMovementComponent*>(UME_AnimalMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimInst_MenuShark
// (None)

class UClass* UME_AnimInst_MenuShark::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInst_MenuShark");

	return Clss;
}


// ME_AnimInst_MenuShark Maneater.Default__ME_AnimInst_MenuShark
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInst_MenuShark* UME_AnimInst_MenuShark::GetDefaultObj()
{
	static class UME_AnimInst_MenuShark* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInst_MenuShark*>(UME_AnimInst_MenuShark::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimInstance_Base
// (None)

class UClass* UME_AnimInstance_Base::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInstance_Base");

	return Clss;
}


// ME_AnimInstance_Base Maneater.Default__ME_AnimInstance_Base
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInstance_Base* UME_AnimInstance_Base::GetDefaultObj()
{
	static class UME_AnimInstance_Base* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInstance_Base*>(UME_AnimInstance_Base::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AnimInstance_Base.PlayLostLimbAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ESkeletonGrabbableJointsLostJoint                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_Base::PlayLostLimbAnimation(enum class ESkeletonGrabbableJoints LostJoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "PlayLostLimbAnimation");

	Params::UME_AnimInstance_Base_PlayLostLimbAnimation_Params Parms{};

	Parms.LostJoint = LostJoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_Base.PlayDeathAnimation
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_Base::PlayDeathAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "PlayDeathAnimation");

	Params::UME_AnimInstance_Base_PlayDeathAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_Base.K2_Reset
// (Event, Public, BlueprintEvent)
// Parameters:

void UME_AnimInstance_Base::K2_Reset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "K2_Reset");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_AnimInstance_Base.GetWhipshotRecoveryAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_Base::GetWhipshotRecoveryAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "GetWhipshotRecoveryAnimation");

	Params::UME_AnimInstance_Base_GetWhipshotRecoveryAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_Base.GetOwningCharacter
// (Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_Character* UME_AnimInstance_Base::GetOwningCharacter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "GetOwningCharacter");

	Params::UME_AnimInstance_Base_GetOwningCharacter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_Base.GetIsMoving
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_AnimInstance_Base::GetIsMoving()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_Base", "GetIsMoving");

	Params::UME_AnimInstance_Base_GetIsMoving_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AnimInstance_NPC
// (None)

class UClass* UME_AnimInstance_NPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInstance_NPC");

	return Clss;
}


// ME_AnimInstance_NPC Maneater.Default__ME_AnimInstance_NPC
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInstance_NPC* UME_AnimInstance_NPC::GetDefaultObj()
{
	static class UME_AnimInstance_NPC* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInstance_NPC*>(UME_AnimInstance_NPC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimInstance_HumanNPC
// (None)

class UClass* UME_AnimInstance_HumanNPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInstance_HumanNPC");

	return Clss;
}


// ME_AnimInstance_HumanNPC Maneater.Default__ME_AnimInstance_HumanNPC
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInstance_HumanNPC* UME_AnimInstance_HumanNPC::GetDefaultObj()
{
	static class UME_AnimInstance_HumanNPC* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInstance_HumanNPC*>(UME_AnimInstance_HumanNPC::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AnimInstance_HumanNPC.SetForcedHipsLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_AnimInstance_HumanNPC::SetForcedHipsLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SetForcedHipsLocation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveSoftWeaponReferences
// (Final, Native, Public, HasOutParams)
// Parameters:
// bool                               ValidSoft                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequence>LocalSoftReference                                               (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequence>SentSoftReference                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveSoftWeaponReferences(bool* ValidSoft, TSoftObjectPtr<class UAnimSequence>* LocalSoftReference, TSoftObjectPtr<class UAnimSequence>* SentSoftReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveSoftWeaponReferences");

	Params::UME_AnimInstance_HumanNPC_SaveSoftWeaponReferences_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ValidSoft != nullptr)
		*ValidSoft = Parms.ValidSoft;

	if (LocalSoftReference != nullptr)
		*LocalSoftReference = Parms.LocalSoftReference;

	if (SentSoftReference != nullptr)
		*SentSoftReference = Parms.SentSoftReference;

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveSoftWeaponArrayReferences
// (Final, Native, Public, HasOutParams)
// Parameters:
// bool                               ValidSoft                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UAnimMontage>>LocalSoftReference                                               (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UAnimMontage>>SentSoftReference                                                (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveSoftWeaponArrayReferences(bool* ValidSoft, TArray<TSoftObjectPtr<class UAnimMontage>>* LocalSoftReference, TArray<TSoftObjectPtr<class UAnimMontage>>* SentSoftReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveSoftWeaponArrayReferences");

	Params::UME_AnimInstance_HumanNPC_SaveSoftWeaponArrayReferences_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ValidSoft != nullptr)
		*ValidSoft = Parms.ValidSoft;

	if (LocalSoftReference != nullptr)
		*LocalSoftReference = std::move(Parms.LocalSoftReference);

	if (SentSoftReference != nullptr)
		*SentSoftReference = std::move(Parms.SentSoftReference);

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveSoftBlendSpaceReferences
// (Final, Native, Public, HasOutParams)
// Parameters:
// bool                               ValidSoft                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBlendSpace>  LocalSoftReference                                               (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBlendSpace>  SentSoftReference                                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveSoftBlendSpaceReferences(bool* ValidSoft, TSoftObjectPtr<class UBlendSpace>* LocalSoftReference, TSoftObjectPtr<class UBlendSpace>* SentSoftReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveSoftBlendSpaceReferences");

	Params::UME_AnimInstance_HumanNPC_SaveSoftBlendSpaceReferences_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ValidSoft != nullptr)
		*ValidSoft = Parms.ValidSoft;

	if (LocalSoftReference != nullptr)
		*LocalSoftReference = Parms.LocalSoftReference;

	if (SentSoftReference != nullptr)
		*SentSoftReference = Parms.SentSoftReference;

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveHardWeaponReferences
// (Final, Native, Public)
// Parameters:

void UME_AnimInstance_HumanNPC::SaveHardWeaponReferences()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveHardWeaponReferences");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveHardWeaponBlendspace
// (Final, Native, Public, HasOutParams)
// Parameters:
// TSoftObjectPtr<class UBlendSpace>  SoftRef                                                          (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpace*                 HardRef                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveHardWeaponBlendspace(TSoftObjectPtr<class UBlendSpace>* SoftRef, class UBlendSpace** HardRef)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveHardWeaponBlendspace");

	Params::UME_AnimInstance_HumanNPC_SaveHardWeaponBlendspace_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SoftRef != nullptr)
		*SoftRef = Parms.SoftRef;

	if (HardRef != nullptr)
		*HardRef = Parms.HardRef;

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveHardWeaponAnimationArray
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<TSoftObjectPtr<class UAnimMontage>>SoftArray                                                        (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimMontage*>        HardArray                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveHardWeaponAnimationArray(TArray<TSoftObjectPtr<class UAnimMontage>>* SoftArray, TArray<class UAnimMontage*>* HardArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveHardWeaponAnimationArray");

	Params::UME_AnimInstance_HumanNPC_SaveHardWeaponAnimationArray_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SoftArray != nullptr)
		*SoftArray = std::move(Parms.SoftArray);

	if (HardArray != nullptr)
		*HardArray = std::move(Parms.HardArray);

}


// Function Maneater.ME_AnimInstance_HumanNPC.SaveHardWeaponAnimation
// (Final, Native, Public, HasOutParams)
// Parameters:
// TSoftObjectPtr<class UAnimSequence>SoftRef                                                          (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*               HardRef                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::SaveHardWeaponAnimation(TSoftObjectPtr<class UAnimSequence>* SoftRef, class UAnimSequence** HardRef)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "SaveHardWeaponAnimation");

	Params::UME_AnimInstance_HumanNPC_SaveHardWeaponAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SoftRef != nullptr)
		*SoftRef = Parms.SoftRef;

	if (HardRef != nullptr)
		*HardRef = Parms.HardRef;

}


// Function Maneater.ME_AnimInstance_HumanNPC.PlayPassengerHitReaction
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitImpulse                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::PlayPassengerHitReaction(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& HitImpulse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "PlayPassengerHitReaction");

	Params::UME_AnimInstance_HumanNPC_PlayPassengerHitReaction_Params Parms{};

	Parms.HitLocation = HitLocation;
	Parms.HitNormal = HitNormal;
	Parms.HitImpulse = HitImpulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.PlayGetupAnimation
// (Final, Native, Public)
// Parameters:
// bool                               ChestUp                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::PlayGetupAnimation(bool ChestUp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "PlayGetupAnimation");

	Params::UME_AnimInstance_HumanNPC_PlayGetupAnimation_Params Parms{};

	Parms.ChestUp = ChestUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.PlayFiringMontage
// (Native, Public)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_HumanNPC::PlayFiringMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "PlayFiringMontage");

	Params::UME_AnimInstance_HumanNPC_PlayFiringMontage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.PassengerHitReactionDelay
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                MontageToPlay                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::PassengerHitReactionDelay(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "PassengerHitReactionDelay");

	Params::UME_AnimInstance_HumanNPC_PassengerHitReactionDelay_Params Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.LoadSoftWeaponAnimations
// (Final, Native, Public)
// Parameters:

void UME_AnimInstance_HumanNPC::LoadSoftWeaponAnimations()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "LoadSoftWeaponAnimations");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.GetupAnimationBlendingOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInterrupted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::GetupAnimationBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "GetupAnimationBlendingOut");

	Params::UME_AnimInstance_HumanNPC_GetupAnimationBlendingOut_Params Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.GetUninjuredChestUpGetupAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_HumanNPC::GetUninjuredChestUpGetupAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "GetUninjuredChestUpGetupAnimation");

	Params::UME_AnimInstance_HumanNPC_GetUninjuredChestUpGetupAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.GetUninjuredChestDownGetupAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_HumanNPC::GetUninjuredChestDownGetupAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "GetUninjuredChestDownGetupAnimation");

	Params::UME_AnimInstance_HumanNPC_GetUninjuredChestDownGetupAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.GetInjuredChestUpGetupAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_HumanNPC::GetInjuredChestUpGetupAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "GetInjuredChestUpGetupAnimation");

	Params::UME_AnimInstance_HumanNPC_GetInjuredChestUpGetupAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.GetInjuredChestDownGetupAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UME_AnimInstance_HumanNPC::GetInjuredChestDownGetupAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "GetInjuredChestDownGetupAnimation");

	Params::UME_AnimInstance_HumanNPC_GetInjuredChestDownGetupAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.FiringMontageBlendingOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInterrupted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::FiringMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "FiringMontageBlendingOut");

	Params::UME_AnimInstance_HumanNPC_FiringMontageBlendingOut_Params Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_HumanNPC.CarryingWeaponRequiresAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_AnimInstance_HumanNPC::CarryingWeaponRequiresAiming()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "CarryingWeaponRequiresAiming");

	Params::UME_AnimInstance_HumanNPC_CarryingWeaponRequiresAiming_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_HumanNPC.AddSoftWeaponAnimationArray
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FSoftObjectPath>     ArrayToLoad                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UAnimMontage>>SoftArray                                                        (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_HumanNPC::AddSoftWeaponAnimationArray(TArray<struct FSoftObjectPath>* ArrayToLoad, TArray<TSoftObjectPtr<class UAnimMontage>>* SoftArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_HumanNPC", "AddSoftWeaponAnimationArray");

	Params::UME_AnimInstance_HumanNPC_AddSoftWeaponAnimationArray_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ArrayToLoad != nullptr)
		*ArrayToLoad = std::move(Parms.ArrayToLoad);

	if (SoftArray != nullptr)
		*SoftArray = std::move(Parms.SoftArray);

}


// Class Maneater.ME_AnimInstance_PlayerShark
// (None)

class UClass* UME_AnimInstance_PlayerShark::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInstance_PlayerShark");

	return Clss;
}


// ME_AnimInstance_PlayerShark Maneater.Default__ME_AnimInstance_PlayerShark
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInstance_PlayerShark* UME_AnimInstance_PlayerShark::GetDefaultObj()
{
	static class UME_AnimInstance_PlayerShark* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInstance_PlayerShark*>(UME_AnimInstance_PlayerShark::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AnimInstance_PlayerShark.UpdateKnifingRotation
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FRotator                    MeshRotation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ActorRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UME_AnimInstance_PlayerShark::UpdateKnifingRotation(const struct FRotator& MeshRotation, const struct FRotator& ActorRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_PlayerShark", "UpdateKnifingRotation");

	Params::UME_AnimInstance_PlayerShark_UpdateKnifingRotation_Params Parms{};

	Parms.MeshRotation = MeshRotation;
	Parms.ActorRotation = ActorRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_PlayerShark.SetCruisingWaterLine
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               SetTo                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AnimInstance_PlayerShark::SetCruisingWaterLine(bool SetTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_PlayerShark", "SetCruisingWaterLine");

	Params::UME_AnimInstance_PlayerShark_SetCruisingWaterLine_Params Parms{};

	Parms.SetTo = SetTo;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_AnimInstance_PlayerShark.GetOwningShark
// (Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_PlayerSharkCharacter*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_PlayerSharkCharacter* UME_AnimInstance_PlayerShark::GetOwningShark()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_PlayerShark", "GetOwningShark");

	Params::UME_AnimInstance_PlayerShark_GetOwningShark_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AnimInstance_PlayerShark.FloppingTakeOff
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_AnimInstance_PlayerShark::FloppingTakeOff()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_PlayerShark", "FloppingTakeOff");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AnimInstance_PlayerShark.FloppingLanding
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_AnimInstance_PlayerShark::FloppingLanding()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AnimInstance_PlayerShark", "FloppingLanding");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_AnimInstance_WildlifeNPC
// (None)

class UClass* UME_AnimInstance_WildlifeNPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimInstance_WildlifeNPC");

	return Clss;
}


// ME_AnimInstance_WildlifeNPC Maneater.Default__ME_AnimInstance_WildlifeNPC
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimInstance_WildlifeNPC* UME_AnimInstance_WildlifeNPC::GetDefaultObj()
{
	static class UME_AnimInstance_WildlifeNPC* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimInstance_WildlifeNPC*>(UME_AnimInstance_WildlifeNPC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ApplyEffect
// (None)

class UClass* UME_AnimNotify_ApplyEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ApplyEffect");

	return Clss;
}


// ME_AnimNotify_ApplyEffect Maneater.Default__ME_AnimNotify_ApplyEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ApplyEffect* UME_AnimNotify_ApplyEffect::GetDefaultObj()
{
	static class UME_AnimNotify_ApplyEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ApplyEffect*>(UME_AnimNotify_ApplyEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_BroadcastAttack
// (None)

class UClass* UME_AnimNotify_BroadcastAttack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_BroadcastAttack");

	return Clss;
}


// ME_AnimNotify_BroadcastAttack Maneater.Default__ME_AnimNotify_BroadcastAttack
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_BroadcastAttack* UME_AnimNotify_BroadcastAttack::GetDefaultObj()
{
	static class UME_AnimNotify_BroadcastAttack* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_BroadcastAttack*>(UME_AnimNotify_BroadcastAttack::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ChunkVictim
// (None)

class UClass* UME_AnimNotify_ChunkVictim::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ChunkVictim");

	return Clss;
}


// ME_AnimNotify_ChunkVictim Maneater.Default__ME_AnimNotify_ChunkVictim
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ChunkVictim* UME_AnimNotify_ChunkVictim::GetDefaultObj()
{
	static class UME_AnimNotify_ChunkVictim* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ChunkVictim*>(UME_AnimNotify_ChunkVictim::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_DataTableAkEvent
// (None)

class UClass* UME_AnimNotify_DataTableAkEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_DataTableAkEvent");

	return Clss;
}


// ME_AnimNotify_DataTableAkEvent Maneater.Default__ME_AnimNotify_DataTableAkEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_DataTableAkEvent* UME_AnimNotify_DataTableAkEvent::GetDefaultObj()
{
	static class UME_AnimNotify_DataTableAkEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_DataTableAkEvent*>(UME_AnimNotify_DataTableAkEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_DialogueAkEvent
// (None)

class UClass* UME_AnimNotify_DialogueAkEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_DialogueAkEvent");

	return Clss;
}


// ME_AnimNotify_DialogueAkEvent Maneater.Default__ME_AnimNotify_DialogueAkEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_DialogueAkEvent* UME_AnimNotify_DialogueAkEvent::GetDefaultObj()
{
	static class UME_AnimNotify_DialogueAkEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_DialogueAkEvent*>(UME_AnimNotify_DialogueAkEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_DialogueFile
// (None)

class UClass* UME_AnimNotify_DialogueFile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_DialogueFile");

	return Clss;
}


// ME_AnimNotify_DialogueFile Maneater.Default__ME_AnimNotify_DialogueFile
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_DialogueFile* UME_AnimNotify_DialogueFile::GetDefaultObj()
{
	static class UME_AnimNotify_DialogueFile* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_DialogueFile*>(UME_AnimNotify_DialogueFile::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_DynamicDialogueEvent
// (None)

class UClass* UME_AnimNotify_DynamicDialogueEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_DynamicDialogueEvent");

	return Clss;
}


// ME_AnimNotify_DynamicDialogueEvent Maneater.Default__ME_AnimNotify_DynamicDialogueEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_DynamicDialogueEvent* UME_AnimNotify_DynamicDialogueEvent::GetDefaultObj()
{
	static class UME_AnimNotify_DynamicDialogueEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_DynamicDialogueEvent*>(UME_AnimNotify_DynamicDialogueEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_FireWeapon
// (None)

class UClass* UME_AnimNotify_FireWeapon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_FireWeapon");

	return Clss;
}


// ME_AnimNotify_FireWeapon Maneater.Default__ME_AnimNotify_FireWeapon
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_FireWeapon* UME_AnimNotify_FireWeapon::GetDefaultObj()
{
	static class UME_AnimNotify_FireWeapon* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_FireWeapon*>(UME_AnimNotify_FireWeapon::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_GibVictim
// (None)

class UClass* UME_AnimNotify_GibVictim::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_GibVictim");

	return Clss;
}


// ME_AnimNotify_GibVictim Maneater.Default__ME_AnimNotify_GibVictim
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_GibVictim* UME_AnimNotify_GibVictim::GetDefaultObj()
{
	static class UME_AnimNotify_GibVictim* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_GibVictim*>(UME_AnimNotify_GibVictim::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_PlayCameraAnimation
// (None)

class UClass* UME_AnimNotify_PlayCameraAnimation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_PlayCameraAnimation");

	return Clss;
}


// ME_AnimNotify_PlayCameraAnimation Maneater.Default__ME_AnimNotify_PlayCameraAnimation
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_PlayCameraAnimation* UME_AnimNotify_PlayCameraAnimation::GetDefaultObj()
{
	static class UME_AnimNotify_PlayCameraAnimation* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_PlayCameraAnimation*>(UME_AnimNotify_PlayCameraAnimation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ReleaseDamage
// (None)

class UClass* UME_AnimNotify_ReleaseDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ReleaseDamage");

	return Clss;
}


// ME_AnimNotify_ReleaseDamage Maneater.Default__ME_AnimNotify_ReleaseDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ReleaseDamage* UME_AnimNotify_ReleaseDamage::GetDefaultObj()
{
	static class UME_AnimNotify_ReleaseDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ReleaseDamage*>(UME_AnimNotify_ReleaseDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_SetAIMoveRotation
// (None)

class UClass* UME_AnimNotify_SetAIMoveRotation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_SetAIMoveRotation");

	return Clss;
}


// ME_AnimNotify_SetAIMoveRotation Maneater.Default__ME_AnimNotify_SetAIMoveRotation
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_SetAIMoveRotation* UME_AnimNotify_SetAIMoveRotation::GetDefaultObj()
{
	static class UME_AnimNotify_SetAIMoveRotation* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_SetAIMoveRotation*>(UME_AnimNotify_SetAIMoveRotation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_SpawnChunkParticles
// (None)

class UClass* UME_AnimNotify_SpawnChunkParticles::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_SpawnChunkParticles");

	return Clss;
}


// ME_AnimNotify_SpawnChunkParticles Maneater.Default__ME_AnimNotify_SpawnChunkParticles
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_SpawnChunkParticles* UME_AnimNotify_SpawnChunkParticles::GetDefaultObj()
{
	static class UME_AnimNotify_SpawnChunkParticles* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_SpawnChunkParticles*>(UME_AnimNotify_SpawnChunkParticles::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_SpawnLargeChunkParticle
// (None)

class UClass* UME_AnimNotify_SpawnLargeChunkParticle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_SpawnLargeChunkParticle");

	return Clss;
}


// ME_AnimNotify_SpawnLargeChunkParticle Maneater.Default__ME_AnimNotify_SpawnLargeChunkParticle
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_SpawnLargeChunkParticle* UME_AnimNotify_SpawnLargeChunkParticle::GetDefaultObj()
{
	static class UME_AnimNotify_SpawnLargeChunkParticle* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_SpawnLargeChunkParticle*>(UME_AnimNotify_SpawnLargeChunkParticle::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ThrashDamage
// (None)

class UClass* UME_AnimNotify_ThrashDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ThrashDamage");

	return Clss;
}


// ME_AnimNotify_ThrashDamage Maneater.Default__ME_AnimNotify_ThrashDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ThrashDamage* UME_AnimNotify_ThrashDamage::GetDefaultObj()
{
	static class UME_AnimNotify_ThrashDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ThrashDamage*>(UME_AnimNotify_ThrashDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ThrowPrey
// (None)

class UClass* UME_AnimNotify_ThrowPrey::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ThrowPrey");

	return Clss;
}


// ME_AnimNotify_ThrowPrey Maneater.Default__ME_AnimNotify_ThrowPrey
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ThrowPrey* UME_AnimNotify_ThrowPrey::GetDefaultObj()
{
	static class UME_AnimNotify_ThrowPrey* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ThrowPrey*>(UME_AnimNotify_ThrowPrey::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_TwAkEvent
// (None)

class UClass* UME_AnimNotify_TwAkEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_TwAkEvent");

	return Clss;
}


// ME_AnimNotify_TwAkEvent Maneater.Default__ME_AnimNotify_TwAkEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_TwAkEvent* UME_AnimNotify_TwAkEvent::GetDefaultObj()
{
	static class UME_AnimNotify_TwAkEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_TwAkEvent*>(UME_AnimNotify_TwAkEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_TwNarratorEvent
// (None)

class UClass* UME_AnimNotify_TwNarratorEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_TwNarratorEvent");

	return Clss;
}


// ME_AnimNotify_TwNarratorEvent Maneater.Default__ME_AnimNotify_TwNarratorEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_TwNarratorEvent* UME_AnimNotify_TwNarratorEvent::GetDefaultObj()
{
	static class UME_AnimNotify_TwNarratorEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_TwNarratorEvent*>(UME_AnimNotify_TwNarratorEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_UpdateAIFocus
// (None)

class UClass* UME_AnimNotify_UpdateAIFocus::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_UpdateAIFocus");

	return Clss;
}


// ME_AnimNotify_UpdateAIFocus Maneater.Default__ME_AnimNotify_UpdateAIFocus
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_UpdateAIFocus* UME_AnimNotify_UpdateAIFocus::GetDefaultObj()
{
	static class UME_AnimNotify_UpdateAIFocus* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_UpdateAIFocus*>(UME_AnimNotify_UpdateAIFocus::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyFootstep
// (None)

class UClass* UME_AnimNotifyFootstep::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyFootstep");

	return Clss;
}


// ME_AnimNotifyFootstep Maneater.Default__ME_AnimNotifyFootstep
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyFootstep* UME_AnimNotifyFootstep::GetDefaultObj()
{
	static class UME_AnimNotifyFootstep* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyFootstep*>(UME_AnimNotifyFootstep::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_DangerSense
// (None)

class UClass* UME_AnimNotifyState_DangerSense::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_DangerSense");

	return Clss;
}


// ME_AnimNotifyState_DangerSense Maneater.Default__ME_AnimNotifyState_DangerSense
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_DangerSense* UME_AnimNotifyState_DangerSense::GetDefaultObj()
{
	static class UME_AnimNotifyState_DangerSense* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_DangerSense*>(UME_AnimNotifyState_DangerSense::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_DeadPhysBlend
// (None)

class UClass* UME_AnimNotifyState_DeadPhysBlend::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_DeadPhysBlend");

	return Clss;
}


// ME_AnimNotifyState_DeadPhysBlend Maneater.Default__ME_AnimNotifyState_DeadPhysBlend
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_DeadPhysBlend* UME_AnimNotifyState_DeadPhysBlend::GetDefaultObj()
{
	static class UME_AnimNotifyState_DeadPhysBlend* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_DeadPhysBlend*>(UME_AnimNotifyState_DeadPhysBlend::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_ForceStopIK
// (None)

class UClass* UME_AnimNotifyState_ForceStopIK::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_ForceStopIK");

	return Clss;
}


// ME_AnimNotifyState_ForceStopIK Maneater.Default__ME_AnimNotifyState_ForceStopIK
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_ForceStopIK* UME_AnimNotifyState_ForceStopIK::GetDefaultObj()
{
	static class UME_AnimNotifyState_ForceStopIK* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_ForceStopIK*>(UME_AnimNotifyState_ForceStopIK::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_HideWeapon
// (None)

class UClass* UME_AnimNotifyState_HideWeapon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_HideWeapon");

	return Clss;
}


// ME_AnimNotifyState_HideWeapon Maneater.Default__ME_AnimNotifyState_HideWeapon
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_HideWeapon* UME_AnimNotifyState_HideWeapon::GetDefaultObj()
{
	static class UME_AnimNotifyState_HideWeapon* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_HideWeapon*>(UME_AnimNotifyState_HideWeapon::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotify_ManageGameplayTag
// (None)

class UClass* UME_AnimNotify_ManageGameplayTag::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotify_ManageGameplayTag");

	return Clss;
}


// ME_AnimNotify_ManageGameplayTag Maneater.Default__ME_AnimNotify_ManageGameplayTag
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotify_ManageGameplayTag* UME_AnimNotify_ManageGameplayTag::GetDefaultObj()
{
	static class UME_AnimNotify_ManageGameplayTag* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotify_ManageGameplayTag*>(UME_AnimNotify_ManageGameplayTag::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_MeleeAttack
// (None)

class UClass* UME_AnimNotifyState_MeleeAttack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_MeleeAttack");

	return Clss;
}


// ME_AnimNotifyState_MeleeAttack Maneater.Default__ME_AnimNotifyState_MeleeAttack
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_MeleeAttack* UME_AnimNotifyState_MeleeAttack::GetDefaultObj()
{
	static class UME_AnimNotifyState_MeleeAttack* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_MeleeAttack*>(UME_AnimNotifyState_MeleeAttack::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_MeleeAttackSimple
// (None)

class UClass* UME_AnimNotifyState_MeleeAttackSimple::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_MeleeAttackSimple");

	return Clss;
}


// ME_AnimNotifyState_MeleeAttackSimple Maneater.Default__ME_AnimNotifyState_MeleeAttackSimple
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_MeleeAttackSimple* UME_AnimNotifyState_MeleeAttackSimple::GetDefaultObj()
{
	static class UME_AnimNotifyState_MeleeAttackSimple* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_MeleeAttackSimple*>(UME_AnimNotifyState_MeleeAttackSimple::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_ScalePrey
// (None)

class UClass* UME_AnimNotifyState_ScalePrey::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_ScalePrey");

	return Clss;
}


// ME_AnimNotifyState_ScalePrey Maneater.Default__ME_AnimNotifyState_ScalePrey
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_ScalePrey* UME_AnimNotifyState_ScalePrey::GetDefaultObj()
{
	static class UME_AnimNotifyState_ScalePrey* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_ScalePrey*>(UME_AnimNotifyState_ScalePrey::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AnimNotifyState_TemporaryProp
// (None)

class UClass* UME_AnimNotifyState_TemporaryProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AnimNotifyState_TemporaryProp");

	return Clss;
}


// ME_AnimNotifyState_TemporaryProp Maneater.Default__ME_AnimNotifyState_TemporaryProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AnimNotifyState_TemporaryProp* UME_AnimNotifyState_TemporaryProp::GetDefaultObj()
{
	static class UME_AnimNotifyState_TemporaryProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AnimNotifyState_TemporaryProp*>(UME_AnimNotifyState_TemporaryProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AssetLoader
// (Actor)

class UClass* AME_AssetLoader::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AssetLoader");

	return Clss;
}


// ME_AssetLoader Maneater.Default__ME_AssetLoader
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AssetLoader* AME_AssetLoader::GetDefaultObj()
{
	static class AME_AssetLoader* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AssetLoader*>(AME_AssetLoader::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AssetLoader.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* AME_AssetLoader::GetSkeletalMesh(class FName SEventName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetSkeletalMesh");

	Params::AME_AssetLoader_GetSkeletalMesh_Params Parms{};

	Parms.SEventName = SEventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetParticleSystemList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                EventNames                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    EActionMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystem*>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UParticleSystem*> AME_AssetLoader::GetParticleSystemList(const TArray<class FName>& EventNames, enum class ECharacterActionMode EActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetParticleSystemList");

	Params::AME_AssetLoader_GetParticleSystemList_Params Parms{};

	Parms.EventNames = EventNames;
	Parms.EActionMode = EActionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetParticleSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    EActionMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* AME_AssetLoader::GetParticleSystem(class FName SEventName, enum class ECharacterActionMode EActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetParticleSystem");

	Params::AME_AssetLoader_GetParticleSystem_Params Parms{};

	Parms.SEventName = SEventName;
	Parms.EActionMode = EActionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* AME_AssetLoader::GetMaterial(class FName SEventName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetMaterial");

	Params::AME_AssetLoader_GetMaterial_Params Parms{};

	Parms.SEventName = SEventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetImpactEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SNameBase                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPhysicalSurface        ESurfaceType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactEffect               ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FImpactEffect AME_AssetLoader::GetImpactEffect(class FName SNameBase, enum class EPhysicalSurface ESurfaceType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetImpactEffect");

	Params::AME_AssetLoader_GetImpactEffect_Params Parms{};

	Parms.SNameBase = SNameBase;
	Parms.ESurfaceType = ESurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetEquippedEvolutionRowName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEvolutionSlot          SlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AME_AssetLoader::GetEquippedEvolutionRowName(enum class EEvolutionSlot SlotType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetEquippedEvolutionRowName");

	Params::AME_AssetLoader_GetEquippedEvolutionRowName_Params Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetAudioEventWithSurface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPhysicalSurface        ESurfaceType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* AME_AssetLoader::GetAudioEventWithSurface(class FName SEventName, enum class EPhysicalSurface ESurfaceType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetAudioEventWithSurface");

	Params::AME_AssetLoader_GetAudioEventWithSurface_Params Parms{};

	Parms.SEventName = SEventName;
	Parms.ESurfaceType = ESurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetAudioEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    EActionMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* AME_AssetLoader::GetAudioEvent(class FName SEventName, enum class ECharacterActionMode EActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetAudioEvent");

	Params::AME_AssetLoader_GetAudioEvent_Params Parms{};

	Parms.SEventName = SEventName;
	Parms.EActionMode = EActionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AssetLoader.GetAnimMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SEventName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    EActionMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* AME_AssetLoader::GetAnimMontage(class FName SEventName, enum class ECharacterActionMode EActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AssetLoader", "GetAnimMontage");

	Params::AME_AssetLoader_GetAnimMontage_Params Parms{};

	Parms.SEventName = SEventName;
	Parms.EActionMode = EActionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AttachmentAnimSet
// (None)

class UClass* UME_AttachmentAnimSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AttachmentAnimSet");

	return Clss;
}


// ME_AttachmentAnimSet Maneater.Default__ME_AttachmentAnimSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AttachmentAnimSet* UME_AttachmentAnimSet::GetDefaultObj()
{
	static class UME_AttachmentAnimSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AttachmentAnimSet*>(UME_AttachmentAnimSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayEffect
// (None)

class UClass* UME_GameplayEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayEffect");

	return Clss;
}


// ME_GameplayEffect Maneater.Default__ME_GameplayEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayEffect* UME_GameplayEffect::GetDefaultObj()
{
	static class UME_GameplayEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayEffect*>(UME_GameplayEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayEffectUIData
// (None)

class UClass* UME_GameplayEffectUIData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayEffectUIData");

	return Clss;
}


// ME_GameplayEffectUIData Maneater.Default__ME_GameplayEffectUIData
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayEffectUIData* UME_GameplayEffectUIData::GetDefaultObj()
{
	static class UME_GameplayEffectUIData* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayEffectUIData*>(UME_GameplayEffectUIData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AttributeSet
// (None)

class UClass* UME_AttributeSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AttributeSet");

	return Clss;
}


// ME_AttributeSet Maneater.Default__ME_AttributeSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AttributeSet* UME_AttributeSet::GetDefaultObj()
{
	static class UME_AttributeSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AttributeSet*>(UME_AttributeSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AudioEventManager
// (None)

class UClass* UME_AudioEventManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AudioEventManager");

	return Clss;
}


// ME_AudioEventManager Maneater.Default__ME_AudioEventManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AudioEventManager* UME_AudioEventManager::GetDefaultObj()
{
	static class UME_AudioEventManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AudioEventManager*>(UME_AudioEventManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_AudioEventManager.Trigger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        EventName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ForceMode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AudioEventManager::Trigger(class FName EventName, class UObject* WorldContextObject, int32 ForceMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "Trigger");

	Params::UME_AudioEventManager_Trigger_Params Parms{};

	Parms.EventName = EventName;
	Parms.WorldContextObject = WorldContextObject;
	Parms.ForceMode = ForceMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AudioEventManager.TickSwimAttenuation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               InCombat                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_AudioEventManager::TickSwimAttenuation(bool InCombat, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "TickSwimAttenuation");

	Params::UME_AudioEventManager_TickSwimAttenuation_Params Parms{};

	Parms.InCombat = InCombat;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AudioEventManager.PostWhizzbyIfInRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*               Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Projectile                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AudioEventManager::PostWhizzbyIfInRange(class UAkAudioEvent* Event, class AActor* Projectile, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "PostWhizzbyIfInRange");

	Params::UME_AudioEventManager_PostWhizzbyIfInRange_Params Parms{};

	Parms.Event = Event;
	Parms.Projectile = Projectile;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AudioEventManager.IsBankLoaded
// (Final, Native, Private)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_AudioEventManager::IsBankLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "IsBankLoaded");

	Params::UME_AudioEventManager_IsBankLoaded_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AudioEventManager.GetAudioEventManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_AudioEventManager*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AudioEventManager* UME_AudioEventManager::GetAudioEventManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "GetAudioEventManager");

	Params::UME_AudioEventManager_GetAudioEventManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_AudioEventManager.DelayStartEx
// (Final, Native, Private)
// Parameters:

void UME_AudioEventManager::DelayStartEx()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "DelayStartEx");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_AudioEventManager.BankWaitCheckEx
// (Final, Native, Private)
// Parameters:
// class UWorld*                      World                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_AudioEventManager::BankWaitCheckEx(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_AudioEventManager", "BankWaitCheckEx");

	Params::UME_AudioEventManager_BankWaitCheckEx_Params Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_ThrashableActor
// (Actor)

class UClass* AME_ThrashableActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ThrashableActor");

	return Clss;
}


// ME_ThrashableActor Maneater.Default__ME_ThrashableActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ThrashableActor* AME_ThrashableActor::GetDefaultObj()
{
	static class AME_ThrashableActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ThrashableActor*>(AME_ThrashableActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ThrashableActor.OnDied
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 Killer                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_ThrashableActor::OnDied(class AController* Killer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableActor", "OnDied");

	Params::AME_ThrashableActor_OnDied_Params Parms{};

	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_ThrashableActor.GetCurrentHealth_Implementation
// (Final, Native, Public)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_ThrashableActor::GetCurrentHealth_Implementation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableActor", "GetCurrentHealth_Implementation");

	Params::AME_ThrashableActor_GetCurrentHealth_Implementation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableActor.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_AbilitySystemComponent*  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AbilitySystemComponent* AME_ThrashableActor::GetAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableActor", "GetAbilitySystemComponent");

	Params::AME_ThrashableActor_GetAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_AuraDamageActor
// (Actor)

class UClass* AME_AuraDamageActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AuraDamageActor");

	return Clss;
}


// ME_AuraDamageActor Maneater.Default__ME_AuraDamageActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_AuraDamageActor* AME_AuraDamageActor::GetDefaultObj()
{
	static class AME_AuraDamageActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_AuraDamageActor*>(AME_AuraDamageActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BeachgoerEscapePlotter
// (Actor)

class UClass* AME_BeachgoerEscapePlotter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BeachgoerEscapePlotter");

	return Clss;
}


// ME_BeachgoerEscapePlotter Maneater.Default__ME_BeachgoerEscapePlotter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BeachgoerEscapePlotter* AME_BeachgoerEscapePlotter::GetDefaultObj()
{
	static class AME_BeachgoerEscapePlotter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BeachgoerEscapePlotter*>(AME_BeachgoerEscapePlotter::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnPointActor
// (Actor)

class UClass* AME_SpawnPointActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnPointActor");

	return Clss;
}


// ME_SpawnPointActor Maneater.Default__ME_SpawnPointActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SpawnPointActor* AME_SpawnPointActor::GetDefaultObj()
{
	static class AME_SpawnPointActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SpawnPointActor*>(AME_SpawnPointActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SpawnPointActor.TriggerSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_SpawnPointActor::TriggerSpawn(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPointActor", "TriggerSpawn");

	Params::AME_SpawnPointActor_TriggerSpawn_Params Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SpawnPointActor.GetCapsuleComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCapsuleComponent*           ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* AME_SpawnPointActor::GetCapsuleComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPointActor", "GetCapsuleComponent");

	Params::AME_SpawnPointActor_GetCapsuleComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SpawnPointActor.CanSpawnAI
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_SpawnPointActor::CanSpawnAI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPointActor", "CanSpawnAI");

	Params::AME_SpawnPointActor_CanSpawnAI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_BeachSpawner
// (Actor)

class UClass* AME_BeachSpawner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BeachSpawner");

	return Clss;
}


// ME_BeachSpawner Maneater.Default__ME_BeachSpawner
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BeachSpawner* AME_BeachSpawner::GetDefaultObj()
{
	static class AME_BeachSpawner* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BeachSpawner*>(AME_BeachSpawner::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BlueprintFunctionLibrary
// (None)

class UClass* UME_BlueprintFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BlueprintFunctionLibrary");

	return Clss;
}


// ME_BlueprintFunctionLibrary Maneater.Default__ME_BlueprintFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BlueprintFunctionLibrary* UME_BlueprintFunctionLibrary::GetDefaultObj()
{
	static class UME_BlueprintFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BlueprintFunctionLibrary*>(UME_BlueprintFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BlueprintFunctionLibrary.SetPrimitiveMinDrawDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         PrimitiveComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinDrawDistance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_BlueprintFunctionLibrary::SetPrimitiveMinDrawDistance(class UPrimitiveComponent* PrimitiveComponent, float MinDrawDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BlueprintFunctionLibrary", "SetPrimitiveMinDrawDistance");

	Params::UME_BlueprintFunctionLibrary_SetPrimitiveMinDrawDistance_Params Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.MinDrawDistance = MinDrawDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BlueprintFunctionLibrary.SetManeaterDefaultMinLOD
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                 StaticMesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_BlueprintFunctionLibrary::SetManeaterDefaultMinLOD(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BlueprintFunctionLibrary", "SetManeaterDefaultMinLOD");

	Params::UME_BlueprintFunctionLibrary_SetManeaterDefaultMinLOD_Params Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BlueprintFunctionLibrary.GetTriangleCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                 StaticMesh                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_BlueprintFunctionLibrary::GetTriangleCount(class UStaticMesh* StaticMesh, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BlueprintFunctionLibrary", "GetTriangleCount");

	Params::UME_BlueprintFunctionLibrary_GetTriangleCount_Params Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BlueprintFunctionLibrary.EnableOutlineRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UME_BlueprintFunctionLibrary::EnableOutlineRendering()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BlueprintFunctionLibrary", "EnableOutlineRendering");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BlueprintFunctionLibrary.DisableOutlineRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                              InDuration                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_BlueprintFunctionLibrary::DisableOutlineRendering(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BlueprintFunctionLibrary", "DisableOutlineRendering");

	Params::UME_BlueprintFunctionLibrary_DisableOutlineRendering_Params Parms{};

	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_VehicleAIController
// (Actor)

class UClass* AME_VehicleAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehicleAIController");

	return Clss;
}


// ME_VehicleAIController Maneater.Default__ME_VehicleAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_VehicleAIController* AME_VehicleAIController::GetDefaultObj()
{
	static class AME_VehicleAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_VehicleAIController*>(AME_VehicleAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_VehicleAIController.IsThreatUnderVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehicleAIController::IsThreatUnderVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehicleAIController", "IsThreatUnderVehicle");

	Params::AME_VehicleAIController_IsThreatUnderVehicle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_BoatAIController
// (Actor)

class UClass* AME_BoatAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BoatAIController");

	return Clss;
}


// ME_BoatAIController Maneater.Default__ME_BoatAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BoatAIController* AME_BoatAIController::GetDefaultObj()
{
	static class AME_BoatAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BoatAIController*>(AME_BoatAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BoatAIController.OnTrackedAIDied
// (Final, Native, Protected)
// Parameters:
// class AME_AIController*            KilledAIC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BoatAIController::OnTrackedAIDied(class AME_AIController* KilledAIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BoatAIController", "OnTrackedAIDied");

	Params::AME_BoatAIController_OnTrackedAIDied_Params Parms{};

	Parms.KilledAIC = KilledAIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_VehicleCollisionComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_VehicleCollisionComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehicleCollisionComponent");

	return Clss;
}


// ME_VehicleCollisionComponent Maneater.Default__ME_VehicleCollisionComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_VehicleCollisionComponent* UME_VehicleCollisionComponent::GetDefaultObj()
{
	static class UME_VehicleCollisionComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_VehicleCollisionComponent*>(UME_VehicleCollisionComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BoatCollisionComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_BoatCollisionComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BoatCollisionComponent");

	return Clss;
}


// ME_BoatCollisionComponent Maneater.Default__ME_BoatCollisionComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BoatCollisionComponent* UME_BoatCollisionComponent::GetDefaultObj()
{
	static class UME_BoatCollisionComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BoatCollisionComponent*>(UME_BoatCollisionComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BoatNameComponent
// (SceneComponent)

class UClass* UME_BoatNameComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BoatNameComponent");

	return Clss;
}


// ME_BoatNameComponent Maneater.Default__ME_BoatNameComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BoatNameComponent* UME_BoatNameComponent::GetDefaultObj()
{
	static class UME_BoatNameComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BoatNameComponent*>(UME_BoatNameComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_VehiclePawn
// (Actor, Pawn)

class UClass* AME_VehiclePawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehiclePawn");

	return Clss;
}


// ME_VehiclePawn Maneater.Default__ME_VehiclePawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_VehiclePawn* AME_VehiclePawn::GetDefaultObj()
{
	static class AME_VehiclePawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_VehiclePawn*>(AME_VehiclePawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_VehiclePawn.WallHit
// (Native, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         MyComp                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::WallHit(class UPrimitiveComponent* MyComp, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "WallHit");

	Params::AME_VehiclePawn_WallHit_Params Parms{};

	Parms.MyComp = MyComp;
	Parms.OtherComp = OtherComp;
	Parms.HitLocation = HitLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.Timer_EjectPassenger
// (Final, Native, Public)
// Parameters:
// int32                              PassengerIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 EjectInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEjectingAllPassengers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::Timer_EjectPassenger(int32 PassengerIndex, class AController* EjectInstigator, bool bEjectingAllPassengers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "Timer_EjectPassenger");

	Params::AME_VehiclePawn_Timer_EjectPassenger_Params Parms{};

	Parms.PassengerIndex = PassengerIndex;
	Parms.EjectInstigator = EjectInstigator;
	Parms.bEjectingAllPassengers = bEjectingAllPassengers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.Timer_AbandonPassenger
// (Final, Native, Public)
// Parameters:

void AME_VehiclePawn::Timer_AbandonPassenger()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "Timer_AbandonPassenger");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.Sink
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 SinkInstigator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::Sink(class AController* SinkInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "Sink");

	Params::AME_VehiclePawn_Sink_Params Parms{};

	Parms.SinkInstigator = SinkInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.SetPassengerWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              PassengerNum                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UME_WeaponComponent>NewWeapon                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::SetPassengerWeapon(int32 PassengerNum, TSubclassOf<class UME_WeaponComponent> NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "SetPassengerWeapon");

	Params::AME_VehiclePawn_SetPassengerWeapon_Params Parms{};

	Parms.PassengerNum = PassengerNum;
	Parms.NewWeapon = NewWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.SetPassengerThreatLevel
// (Final, Native, Public)
// Parameters:
// enum class EAIThreatAlertState     NewAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InstigatingActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::SetPassengerThreatLevel(enum class EAIThreatAlertState NewAlertState, class AActor* InstigatingActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "SetPassengerThreatLevel");

	Params::AME_VehiclePawn_SetPassengerThreatLevel_Params Parms{};

	Parms.NewAlertState = NewAlertState;
	Parms.InstigatingActor = InstigatingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.SetBossPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewPhaseNumber                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::SetBossPhase(int32 NewPhaseNumber)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "SetBossPhase");

	Params::AME_VehiclePawn_SetBossPhase_Params Parms{};

	Parms.NewPhaseNumber = NewPhaseNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.SetAIPatrolPlotter
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATwAIPatrolPlotter*          InPatrolPlotter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::SetAIPatrolPlotter(class ATwAIPatrolPlotter* InPatrolPlotter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "SetAIPatrolPlotter");

	Params::AME_VehiclePawn_SetAIPatrolPlotter_Params Parms{};

	Parms.InPatrolPlotter = InPatrolPlotter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.RockBoat
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              NewRamVerticalIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RamForce                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RotationOfRam                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ForceNormal                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::RockBoat(int32 NewRamVerticalIndex, float RamForce, float RotationOfRam, struct FVector& ForceNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "RockBoat");

	Params::AME_VehiclePawn_RockBoat_Params Parms{};

	Parms.NewRamVerticalIndex = NewRamVerticalIndex;
	Parms.RamForce = RamForce;
	Parms.RotationOfRam = RotationOfRam;
	Parms.ForceNormal = ForceNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.RammedByAnimal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_PlayerSharkCharacter*    RammingAnimal                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RamForce                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::RammedByAnimal(class AME_PlayerSharkCharacter* RammingAnimal, float RamForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "RammedByAnimal");

	Params::AME_VehiclePawn_RammedByAnimal_Params Parms{};

	Parms.RammingAnimal = RammingAnimal;
	Parms.RamForce = RamForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.OnVehicleEmptied
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_VehiclePawn::OnVehicleEmptied()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnVehicleEmptied");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_VehiclePawn.OnSink
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 SinkInstigator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnSink(class AController* SinkInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnSink");

	Params::AME_VehiclePawn_OnSink_Params Parms{};

	Parms.SinkInstigator = SinkInstigator;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_VehiclePawn.OnPhysicsVolumeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APhysicsVolume*              NewVolume                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnPhysicsVolumeChanged");

	Params::AME_VehiclePawn_OnPhysicsVolumeChanged_Params Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnMeshComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         SelfActor                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherPrimitive                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnMeshComponentHit(class UPrimitiveComponent* SelfActor, class AActor* OtherActor, class UPrimitiveComponent* OtherPrimitive, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnMeshComponentHit");

	Params::AME_VehiclePawn_OnMeshComponentHit_Params Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.OtherPrimitive = OtherPrimitive;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnKilledBySlamAttack
// (Final, Native, Public)
// Parameters:
// class AME_PlayerSharkCharacter*    PlayerShark                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnKilledBySlamAttack(class AME_PlayerSharkCharacter* PlayerShark)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnKilledBySlamAttack");

	Params::AME_VehiclePawn_OnKilledBySlamAttack_Params Parms{};

	Parms.PlayerShark = PlayerShark;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnGameplayEffectRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FActiveGameplayEffect       RemovedGameplayEffect                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnGameplayEffectRemoved(struct FActiveGameplayEffect& RemovedGameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnGameplayEffectRemoved");

	Params::AME_VehiclePawn_OnGameplayEffectRemoved_Params Parms{};

	Parms.RemovedGameplayEffect = RemovedGameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnGameplayEffectApplied
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*     Source                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec         SpecApplied                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle ActiveHandle                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnGameplayEffectApplied(class UAbilitySystemComponent* Source, struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnGameplayEffectApplied");

	Params::AME_VehiclePawn_OnGameplayEffectApplied_Params Parms{};

	Parms.Source = Source;
	Parms.SpecApplied = SpecApplied;
	Parms.ActiveHandle = ActiveHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnDamageParticleEffectFinished
// (Final, Native, Private)
// Parameters:
// class UParticleSystemComponent*    PSystem                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnDamageParticleEffectFinished(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnDamageParticleEffectFinished");

	Params::AME_VehiclePawn_OnDamageParticleEffectFinished_Params Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.OnBreakApart
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 BreakInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::OnBreakApart(class AController* BreakInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "OnBreakApart");

	Params::AME_VehiclePawn_OnBreakApart_Params Parms{};

	Parms.BreakInstigator = BreakInstigator;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_VehiclePawn.K2_InitEntity
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_VehiclePawn::K2_InitEntity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "K2_InitEntity");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_VehiclePawn.IsBossVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::IsBossVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "IsBossVehicle");

	Params::AME_VehiclePawn_IsBossVehicle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.IsAbilitySystemComponentSetUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::IsAbilitySystemComponentSetUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "IsAbilitySystemComponentSetUp");

	Params::AME_VehiclePawn_IsAbilitySystemComponentSetUp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.HasPilot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::HasPilot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "HasPilot");

	Params::AME_VehiclePawn_HasPilot_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.HasAnyWeapons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::HasAnyWeapons()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "HasAnyWeapons");

	Params::AME_VehiclePawn_HasAnyWeapons_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetRotationOfLocationAroundBoat
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     PointLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_VehiclePawn::GetRotationOfLocationAroundBoat(struct FVector& PointLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetRotationOfLocationAroundBoat");

	Params::AME_VehiclePawn_GetRotationOfLocationAroundBoat_Params Parms{};

	Parms.PointLocation = PointLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetPassengerMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              PassengerIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AME_VehiclePawn::GetPassengerMesh(int32 PassengerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetPassengerMesh");

	Params::AME_VehiclePawn_GetPassengerMesh_Params Parms{};

	Parms.PassengerIndex = PassengerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetMercunaObstacle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_MercunaObstacleComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_MercunaObstacleComponent* AME_VehiclePawn::GetMercunaObstacle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetMercunaObstacle");

	Params::AME_VehiclePawn_GetMercunaObstacle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetMercunaNavigation
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_MercunaNavigationComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_MercunaNavigationComponent* AME_VehiclePawn::GetMercunaNavigation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetMercunaNavigation");

	Params::AME_VehiclePawn_GetMercunaNavigation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetHunterRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EHunterRank             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EHunterRank AME_VehiclePawn::GetHunterRank()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetHunterRank");

	Params::AME_VehiclePawn_GetHunterRank_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetAIPatrolPlotter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATwAIPatrolPlotter*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATwAIPatrolPlotter* AME_VehiclePawn::GetAIPatrolPlotter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetAIPatrolPlotter");

	Params::AME_VehiclePawn_GetAIPatrolPlotter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_AbilitySystemComponent*  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AbilitySystemComponent* AME_VehiclePawn::GetAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "GetAbilitySystemComponent");

	Params::AME_VehiclePawn_GetAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.FinishBreakApart
// (Final, Native, Public)
// Parameters:

void AME_VehiclePawn::FinishBreakApart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "FinishBreakApart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.EnableBossPhaseTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::EnableBossPhaseTimer(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "EnableBossPhaseTimer");

	Params::AME_VehiclePawn_EnableBossPhaseTimer_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.EjectPassenger
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PassengerIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 EjectInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_HumanCharacter*          EjectedPassenger                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EjectImpulse                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldRagdoll                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bJumpOff                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSpawnController                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEjectingAllPassengers                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::EjectPassenger(int32 PassengerIndex, class AController* EjectInstigator, class AME_HumanCharacter** EjectedPassenger, const struct FVector& EjectImpulse, bool bShouldRagdoll, bool bJumpOff, bool bSpawnController, bool bEjectingAllPassengers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "EjectPassenger");

	Params::AME_VehiclePawn_EjectPassenger_Params Parms{};

	Parms.PassengerIndex = PassengerIndex;
	Parms.EjectInstigator = EjectInstigator;
	Parms.EjectImpulse = EjectImpulse;
	Parms.bShouldRagdoll = bShouldRagdoll;
	Parms.bJumpOff = bJumpOff;
	Parms.bSpawnController = bSpawnController;
	Parms.bEjectingAllPassengers = bEjectingAllPassengers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (EjectedPassenger != nullptr)
		*EjectedPassenger = Parms.EjectedPassenger;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.EjectAllPassengers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 EjectInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::EjectAllPassengers(class AController* EjectInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "EjectAllPassengers");

	Params::AME_VehiclePawn_EjectAllPassengers_Params Parms{};

	Parms.EjectInstigator = EjectInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.BreakApart
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 BreakInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::BreakApart(class AController* BreakInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "BreakApart");

	Params::AME_VehiclePawn_BreakApart_Params Parms{};

	Parms.BreakInstigator = BreakInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_VehiclePawn.BossPhaseChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                              NewPhaseNumber                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PassengerRespawnDelay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_VehiclePawn::BossPhaseChanged(int32 NewPhaseNumber, float PassengerRespawnDelay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "BossPhaseChanged");

	Params::AME_VehiclePawn_BossPhaseChanged_Params Parms{};

	Parms.NewPhaseNumber = NewPhaseNumber;
	Parms.PassengerRespawnDelay = PassengerRespawnDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_VehiclePawn.BoardPassenger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_HumanCharacter*          NewPassenger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_VehiclePawn::BoardPassenger(class AME_HumanCharacter* NewPassenger)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_VehiclePawn", "BoardPassenger");

	Params::AME_VehiclePawn_BoardPassenger_Params Parms{};

	Parms.NewPassenger = NewPassenger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_BoatPawn
// (Actor, Pawn)

class UClass* AME_BoatPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BoatPawn");

	return Clss;
}


// ME_BoatPawn Maneater.Default__ME_BoatPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BoatPawn* AME_BoatPawn::GetDefaultObj()
{
	static class AME_BoatPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BoatPawn*>(AME_BoatPawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BoatPawn.OnBossCinematicStarted
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_BoatPawn::OnBossCinematicStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BoatPawn", "OnBossCinematicStarted");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.ME_BoatPawnNoNav
// (Actor, Pawn)

class UClass* AME_BoatPawnNoNav::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BoatPawnNoNav");

	return Clss;
}


// ME_BoatPawnNoNav Maneater.Default__ME_BoatPawnNoNav
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BoatPawnNoNav* AME_BoatPawnNoNav::GetDefaultObj()
{
	static class AME_BoatPawnNoNav* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BoatPawnNoNav*>(AME_BoatPawnNoNav::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BodyTypeInformation
// (None)

class UClass* UME_BodyTypeInformation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BodyTypeInformation");

	return Clss;
}


// ME_BodyTypeInformation Maneater.Default__ME_BodyTypeInformation
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BodyTypeInformation* UME_BodyTypeInformation::GetDefaultObj()
{
	static class UME_BodyTypeInformation* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BodyTypeInformation*>(UME_BodyTypeInformation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WorldLandmarkActor
// (Actor)

class UClass* AME_WorldLandmarkActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldLandmarkActor");

	return Clss;
}


// ME_WorldLandmarkActor Maneater.Default__ME_WorldLandmarkActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WorldLandmarkActor* AME_WorldLandmarkActor::GetDefaultObj()
{
	static class AME_WorldLandmarkActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WorldLandmarkActor*>(AME_WorldLandmarkActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WorldLandmarkActor.SetDiscoveryState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELandmarkDiscoveryState NewDiscoveryState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_WorldLandmarkActor::SetDiscoveryState(enum class ELandmarkDiscoveryState NewDiscoveryState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldLandmarkActor", "SetDiscoveryState");

	Params::AME_WorldLandmarkActor_SetDiscoveryState_Params Parms{};

	Parms.NewDiscoveryState = NewDiscoveryState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WorldLandmarkActor.ReceivePostInitializeComponents
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_WorldLandmarkActor::ReceivePostInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldLandmarkActor", "ReceivePostInitializeComponents");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_WorldLandmarkActor.OnDiscoveryStateChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// enum class ELandmarkDiscoveryState NewState                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_WorldLandmarkActor::OnDiscoveryStateChanged(enum class ELandmarkDiscoveryState& NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldLandmarkActor", "OnDiscoveryStateChanged");

	Params::AME_WorldLandmarkActor_OnDiscoveryStateChanged_Params Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_BossBattleInfo
// (Actor)

class UClass* AME_BossBattleInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BossBattleInfo");

	return Clss;
}


// ME_BossBattleInfo Maneater.Default__ME_BossBattleInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BossBattleInfo* AME_BossBattleInfo::GetDefaultObj()
{
	static class AME_BossBattleInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BossBattleInfo*>(AME_BossBattleInfo::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BossBattleInfo.SetBattleState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EBossBattleState        NewBattleState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BossBattleInfo::SetBattleState(enum class EBossBattleState NewBattleState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossBattleInfo", "SetBattleState");

	Params::AME_BossBattleInfo_SetBattleState_Params Parms{};

	Parms.NewBattleState = NewBattleState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BossBattleInfo.OnIntroCinematicEnd
// (Final, Native, Private)
// Parameters:

void AME_BossBattleInfo::OnIntroCinematicEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossBattleInfo", "OnIntroCinematicEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BossBattleInfo.OnBountyChanged
// (Final, Native, Public)
// Parameters:
// uint8                              NewBountyLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      BountyChangeInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BossBattleInfo::OnBountyChanged(uint8 NewBountyLevel, class AActor* BountyChangeInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossBattleInfo", "OnBountyChanged");

	Params::AME_BossBattleInfo_OnBountyChanged_Params Parms{};

	Parms.NewBountyLevel = NewBountyLevel;
	Parms.BountyChangeInstigator = BountyChangeInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BossBattleInfo.BossBattleEventInternal
// (Final, Native, Public)
// Parameters:
// class AME_AIController*            Boss                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBossBattleEvent        EventType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BossBattleInfo::BossBattleEventInternal(class AME_AIController* Boss, enum class EBossBattleEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossBattleInfo", "BossBattleEventInternal");

	Params::AME_BossBattleInfo_BossBattleEventInternal_Params Parms{};

	Parms.Boss = Boss;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_BossInterface
// (None)

class UClass* IME_BossInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BossInterface");

	return Clss;
}


// ME_BossInterface Maneater.Default__ME_BossInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_BossInterface* IME_BossInterface::GetDefaultObj()
{
	static class IME_BossInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_BossInterface*>(IME_BossInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BossInterface.GetBossName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IME_BossInterface::GetBossName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossInterface", "GetBossName");

	Params::IME_BossInterface_GetBossName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BossInterface.GetBossHealthPct
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_BossInterface::GetBossHealthPct()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossInterface", "GetBossHealthPct");

	Params::IME_BossInterface_GetBossHealthPct_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BossInterface.GetBossBattleInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftClassPtr<class AME_BossBattleInfo>ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class AME_BossBattleInfo> IME_BossInterface::GetBossBattleInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BossInterface", "GetBossBattleInfo");

	Params::IME_BossInterface_GetBossBattleInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_BountySpawner
// (Actor)

class UClass* AME_BountySpawner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BountySpawner");

	return Clss;
}


// ME_BountySpawner Maneater.Default__ME_BountySpawner
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BountySpawner* AME_BountySpawner::GetDefaultObj()
{
	static class AME_BountySpawner* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BountySpawner*>(AME_BountySpawner::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BossHunterSpawner
// (Actor)

class UClass* AME_BossHunterSpawner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BossHunterSpawner");

	return Clss;
}


// ME_BossHunterSpawner Maneater.Default__ME_BossHunterSpawner
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BossHunterSpawner* AME_BossHunterSpawner::GetDefaultObj()
{
	static class AME_BossHunterSpawner* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BossHunterSpawner*>(AME_BossHunterSpawner::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BountyManager
// (Actor)

class UClass* AME_BountyManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BountyManager");

	return Clss;
}


// ME_BountyManager Maneater.Default__ME_BountyManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BountyManager* AME_BountyManager::GetDefaultObj()
{
	static class AME_BountyManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BountyManager*>(AME_BountyManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BountyManager.SetBountyState
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EBountyState            NewBountyState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BountyManager::SetBountyState(enum class EBountyState NewBountyState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "SetBountyState");

	Params::AME_BountyManager_SetBountyState_Params Parms{};

	Parms.NewBountyState = NewBountyState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BountyManager.OnBossIntroFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_BountyManager::OnBossIntroFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "OnBossIntroFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BountyManager.IsBountyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_BountyManager::IsBountyActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "IsBountyActive");

	Params::AME_BountyManager_IsBountyActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.IsBossActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_BountyManager::IsBossActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "IsBossActive");

	Params::AME_BountyManager_IsBossActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetTierMaxPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_BountyManager::GetTierMaxPoints(int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetTierMaxPoints");

	Params::AME_BountyManager_GetTierMaxPoints_Params Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetPendingBossVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_VehiclePawn*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_VehiclePawn* AME_BountyManager::GetPendingBossVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetPendingBossVehicle");

	Params::AME_BountyManager_GetPendingBossVehicle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetNumActiveDivers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_BountyManager::GetNumActiveDivers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetNumActiveDivers");

	Params::AME_BountyManager_GetNumActiveDivers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetMaxNumActiveDivers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_BountyManager::GetMaxNumActiveDivers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetMaxNumActiveDivers");

	Params::AME_BountyManager_GetMaxNumActiveDivers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetMaxInfamyTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_BountyManager::GetMaxInfamyTier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetMaxInfamyTier");

	Params::AME_BountyManager_GetMaxInfamyTier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetLastKillLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_BountyManager::GetLastKillLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetLastKillLocation");

	Params::AME_BountyManager_GetLastKillLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetHunterControllers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AME_AIController*>    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AME_AIController*> AME_BountyManager::GetHunterControllers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetHunterControllers");

	Params::AME_BountyManager_GetHunterControllers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetClosestBoatLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     SourceLocation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Out_DistanceSqr                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_BountyManager::GetClosestBoatLocation(struct FVector& SourceLocation, float* Out_DistanceSqr)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetClosestBoatLocation");

	Params::AME_BountyManager_GetClosestBoatLocation_Params Parms{};

	Parms.SourceLocation = SourceLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Out_DistanceSqr != nullptr)
		*Out_DistanceSqr = Parms.Out_DistanceSqr;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetBountyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EBountyState            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EBountyState AME_BountyManager::GetBountyState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetBountyState");

	Params::AME_BountyManager_GetBountyState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetBountyDataForTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_BountyTier*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_BountyTier* AME_BountyManager::GetBountyDataForTier(int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetBountyDataForTier");

	Params::AME_BountyManager_GetBountyDataForTier_Params Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetBountyCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_BountyManager::GetBountyCenter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetBountyCenter");

	Params::AME_BountyManager_GetBountyCenter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetBossVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_VehiclePawn*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_VehiclePawn* AME_BountyManager::GetBossVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetBossVehicle");

	Params::AME_BountyManager_GetBossVehicle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_BountyManager.GetActiveBossName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        BossFirstName                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                        BossLastName                                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void AME_BountyManager::GetActiveBossName(class FText* BossFirstName, class FText* BossLastName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "GetActiveBossName");

	Params::AME_BountyManager_GetActiveBossName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (BossFirstName != nullptr)
		*BossFirstName = Parms.BossFirstName;

	if (BossLastName != nullptr)
		*BossLastName = Parms.BossLastName;

}


// Function Maneater.ME_BountyManager.Enable
// (Native, Public, BlueprintCallable)
// Parameters:

void AME_BountyManager::Enable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "Enable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BountyManager.DialogueCallback
// (Final, Native, Public)
// Parameters:
// enum class EAkCallbackType         CallbackType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*             CallbackInfo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BountyManager::DialogueCallback(enum class EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "DialogueCallback");

	Params::AME_BountyManager_DialogueCallback_Params Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BountyManager.CleanUpAndDisable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bWaitForSave                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_BountyManager::CleanUpAndDisable(bool bWaitForSave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BountyManager", "CleanUpAndDisable");

	Params::AME_BountyManager_CleanUpAndDisable_Params Parms{};

	Parms.bWaitForSave = bWaitForSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_BountyTier
// (None)

class UClass* UME_BountyTier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BountyTier");

	return Clss;
}


// ME_BountyTier Maneater.Default__ME_BountyTier
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BountyTier* UME_BountyTier::GetDefaultObj()
{
	static class UME_BountyTier* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BountyTier*>(UME_BountyTier::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.HunterSupportEntry
// (None)

class UClass* UHunterSupportEntry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HunterSupportEntry");

	return Clss;
}


// HunterSupportEntry Maneater.Default__HunterSupportEntry
// (Public, ClassDefaultObject, ArchetypeObject)

class UHunterSupportEntry* UHunterSupportEntry::GetDefaultObj()
{
	static class UHunterSupportEntry* Default = nullptr;

	if (!Default)
		Default = static_cast<UHunterSupportEntry*>(UHunterSupportEntry::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BTDecorator_HasValidActivity
// (None)

class UClass* UME_BTDecorator_HasValidActivity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BTDecorator_HasValidActivity");

	return Clss;
}


// ME_BTDecorator_HasValidActivity Maneater.Default__ME_BTDecorator_HasValidActivity
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BTDecorator_HasValidActivity* UME_BTDecorator_HasValidActivity::GetDefaultObj()
{
	static class UME_BTDecorator_HasValidActivity* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BTDecorator_HasValidActivity*>(UME_BTDecorator_HasValidActivity::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BTTask_PerformAmbientActivity
// (None)

class UClass* UME_BTTask_PerformAmbientActivity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BTTask_PerformAmbientActivity");

	return Clss;
}


// ME_BTTask_PerformAmbientActivity Maneater.Default__ME_BTTask_PerformAmbientActivity
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BTTask_PerformAmbientActivity* UME_BTTask_PerformAmbientActivity::GetDefaultObj()
{
	static class UME_BTTask_PerformAmbientActivity* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BTTask_PerformAmbientActivity*>(UME_BTTask_PerformAmbientActivity::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_BuoyancyForceComponent
// (None)

class UClass* UME_BuoyancyForceComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BuoyancyForceComponent");

	return Clss;
}


// ME_BuoyancyForceComponent Maneater.Default__ME_BuoyancyForceComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_BuoyancyForceComponent* UME_BuoyancyForceComponent::GetDefaultObj()
{
	static class UME_BuoyancyForceComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_BuoyancyForceComponent*>(UME_BuoyancyForceComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_BuoyancyForceComponent.SetBasePrimitiveComp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         PrimComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_BuoyancyForceComponent::SetBasePrimitiveComp(class UPrimitiveComponent* PrimComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BuoyancyForceComponent", "SetBasePrimitiveComp");

	Params::UME_BuoyancyForceComponent_SetBasePrimitiveComp_Params Parms{};

	Parms.PrimComp = PrimComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_BuoyancyForceComponent.GetBasePrimitiveComp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UME_BuoyancyForceComponent::GetBasePrimitiveComp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_BuoyancyForceComponent", "GetBasePrimitiveComp");

	Params::UME_BuoyancyForceComponent_GetBasePrimitiveComp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_BuoyantDecoration
// (Actor)

class UClass* AME_BuoyantDecoration::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_BuoyantDecoration");

	return Clss;
}


// ME_BuoyantDecoration Maneater.Default__ME_BuoyantDecoration
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_BuoyantDecoration* AME_BuoyantDecoration::GetDefaultObj()
{
	static class AME_BuoyantDecoration* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_BuoyantDecoration*>(AME_BuoyantDecoration::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationBoatStun
// (None)

class UClass* UME_CalculationBoatStun::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationBoatStun");

	return Clss;
}


// ME_CalculationBoatStun Maneater.Default__ME_CalculationBoatStun
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationBoatStun* UME_CalculationBoatStun::GetDefaultObj()
{
	static class UME_CalculationBoatStun* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationBoatStun*>(UME_CalculationBoatStun::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationGenericDamage
// (None)

class UClass* UME_CalculationGenericDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationGenericDamage");

	return Clss;
}


// ME_CalculationGenericDamage Maneater.Default__ME_CalculationGenericDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationGenericDamage* UME_CalculationGenericDamage::GetDefaultObj()
{
	static class UME_CalculationGenericDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationGenericDamage*>(UME_CalculationGenericDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationElectricDamage
// (None)

class UClass* UME_CalculationElectricDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationElectricDamage");

	return Clss;
}


// ME_CalculationElectricDamage Maneater.Default__ME_CalculationElectricDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationElectricDamage* UME_CalculationElectricDamage::GetDefaultObj()
{
	static class UME_CalculationElectricDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationElectricDamage*>(UME_CalculationElectricDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationExplosiveDamage
// (None)

class UClass* UME_CalculationExplosiveDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationExplosiveDamage");

	return Clss;
}


// ME_CalculationExplosiveDamage Maneater.Default__ME_CalculationExplosiveDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationExplosiveDamage* UME_CalculationExplosiveDamage::GetDefaultObj()
{
	static class UME_CalculationExplosiveDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationExplosiveDamage*>(UME_CalculationExplosiveDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationHealthCondition
// (None)

class UClass* UME_CalculationHealthCondition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationHealthCondition");

	return Clss;
}


// ME_CalculationHealthCondition Maneater.Default__ME_CalculationHealthCondition
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationHealthCondition* UME_CalculationHealthCondition::GetDefaultObj()
{
	static class UME_CalculationHealthCondition* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationHealthCondition*>(UME_CalculationHealthCondition::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationSlamDamage
// (None)

class UClass* UME_CalculationSlamDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationSlamDamage");

	return Clss;
}


// ME_CalculationSlamDamage Maneater.Default__ME_CalculationSlamDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationSlamDamage* UME_CalculationSlamDamage::GetDefaultObj()
{
	static class UME_CalculationSlamDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationSlamDamage*>(UME_CalculationSlamDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationStrikeDamage
// (None)

class UClass* UME_CalculationStrikeDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationStrikeDamage");

	return Clss;
}


// ME_CalculationStrikeDamage Maneater.Default__ME_CalculationStrikeDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationStrikeDamage* UME_CalculationStrikeDamage::GetDefaultObj()
{
	static class UME_CalculationStrikeDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationStrikeDamage*>(UME_CalculationStrikeDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationTailwhipDamage
// (None)

class UClass* UME_CalculationTailwhipDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationTailwhipDamage");

	return Clss;
}


// ME_CalculationTailwhipDamage Maneater.Default__ME_CalculationTailwhipDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationTailwhipDamage* UME_CalculationTailwhipDamage::GetDefaultObj()
{
	static class UME_CalculationTailwhipDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationTailwhipDamage*>(UME_CalculationTailwhipDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationThrashDamage
// (None)

class UClass* UME_CalculationThrashDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationThrashDamage");

	return Clss;
}


// ME_CalculationThrashDamage Maneater.Default__ME_CalculationThrashDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationThrashDamage* UME_CalculationThrashDamage::GetDefaultObj()
{
	static class UME_CalculationThrashDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationThrashDamage*>(UME_CalculationThrashDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CalculationThrashStruggle
// (None)

class UClass* UME_CalculationThrashStruggle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CalculationThrashStruggle");

	return Clss;
}


// ME_CalculationThrashStruggle Maneater.Default__ME_CalculationThrashStruggle
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CalculationThrashStruggle* UME_CalculationThrashStruggle::GetDefaultObj()
{
	static class UME_CalculationThrashStruggle* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CalculationThrashStruggle*>(UME_CalculationThrashStruggle::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CameraAnimInst
// (None)

class UClass* UME_CameraAnimInst::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CameraAnimInst");

	return Clss;
}


// ME_CameraAnimInst Maneater.Default__ME_CameraAnimInst
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CameraAnimInst* UME_CameraAnimInst::GetDefaultObj()
{
	static class UME_CameraAnimInst* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CameraAnimInst*>(UME_CameraAnimInst::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CameraComponent
// (SceneComponent)

class UClass* UME_CameraComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CameraComponent");

	return Clss;
}


// ME_CameraComponent Maneater.Default__ME_CameraComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CameraComponent* UME_CameraComponent::GetDefaultObj()
{
	static class UME_CameraComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CameraComponent*>(UME_CameraComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CameraSpringArmComponent
// (SceneComponent)

class UClass* UME_CameraSpringArmComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CameraSpringArmComponent");

	return Clss;
}


// ME_CameraSpringArmComponent Maneater.Default__ME_CameraSpringArmComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CameraSpringArmComponent* UME_CameraSpringArmComponent::GetDefaultObj()
{
	static class UME_CameraSpringArmComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CameraSpringArmComponent*>(UME_CameraSpringArmComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CharacterAbilityHelper
// (None)

class UClass* UME_CharacterAbilityHelper::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterAbilityHelper");

	return Clss;
}


// ME_CharacterAbilityHelper Maneater.Default__ME_CharacterAbilityHelper
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterAbilityHelper* UME_CharacterAbilityHelper::GetDefaultObj()
{
	static class UME_CharacterAbilityHelper* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterAbilityHelper*>(UME_CharacterAbilityHelper::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CharacterAbilityHelper.TryActivateAbilityForTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                GameplayTag                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bActionModeDependent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CharacterAbilityHelper::TryActivateAbilityForTag(const struct FGameplayTag& GameplayTag, bool bActionModeDependent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "TryActivateAbilityForTag");

	Params::UME_CharacterAbilityHelper_TryActivateAbilityForTag_Params Parms{};

	Parms.GameplayTag = GameplayTag;
	Parms.bActionModeDependent = bActionModeDependent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterAbilityHelper.TryActivateAbilityForHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle  Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CharacterAbilityHelper::TryActivateAbilityForHandle(const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "TryActivateAbilityForHandle");

	Params::UME_CharacterAbilityHelper_TryActivateAbilityForHandle_Params Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterAbilityHelper.IsStumbled
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CharacterAbilityHelper::IsStumbled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "IsStumbled");

	Params::UME_CharacterAbilityHelper_IsStumbled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterAbilityHelper.GetAbilityIndexFromEnum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EME_CharacterAbility    AbilitySlot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_CharacterAbilityHelper::GetAbilityIndexFromEnum(enum class EME_CharacterAbility AbilitySlot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "GetAbilityIndexFromEnum");

	Params::UME_CharacterAbilityHelper_GetAbilityIndexFromEnum_Params Parms{};

	Parms.AbilitySlot = AbilitySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterAbilityHelper.GetAbilityHandleFromEnum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EME_CharacterAbility    AbilitySlot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle  ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UME_CharacterAbilityHelper::GetAbilityHandleFromEnum(enum class EME_CharacterAbility AbilitySlot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "GetAbilityHandleFromEnum");

	Params::UME_CharacterAbilityHelper_GetAbilityHandleFromEnum_Params Parms{};

	Parms.AbilitySlot = AbilitySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterAbilityHelper.CancelAbilityForHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle  Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CharacterAbilityHelper::CancelAbilityForHandle(const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "CancelAbilityForHandle");

	Params::UME_CharacterAbilityHelper_CancelAbilityForHandle_Params Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterAbilityHelper.CancelAbilityForEnum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EME_CharacterAbility    CharacterAbilityEnum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CharacterAbilityHelper::CancelAbilityForEnum(enum class EME_CharacterAbility CharacterAbilityEnum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "CancelAbilityForEnum");

	Params::UME_CharacterAbilityHelper_CancelAbilityForEnum_Params Parms{};

	Parms.CharacterAbilityEnum = CharacterAbilityEnum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterAbilityHelper.CanActivateAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CharacterAbilityHelper::CanActivateAbilities()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterAbilityHelper", "CanActivateAbilities");

	Params::UME_CharacterAbilityHelper_CanActivateAbilities_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_CharacterAttributeSet
// (None)

class UClass* UME_CharacterAttributeSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterAttributeSet");

	return Clss;
}


// ME_CharacterAttributeSet Maneater.Default__ME_CharacterAttributeSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterAttributeSet* UME_CharacterAttributeSet::GetDefaultObj()
{
	static class UME_CharacterAttributeSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterAttributeSet*>(UME_CharacterAttributeSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CharacterCollisionComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UME_CharacterCollisionComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterCollisionComponent");

	return Clss;
}


// ME_CharacterCollisionComponent Maneater.Default__ME_CharacterCollisionComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterCollisionComponent* UME_CharacterCollisionComponent::GetDefaultObj()
{
	static class UME_CharacterCollisionComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterCollisionComponent*>(UME_CharacterCollisionComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CharacterFunctionLibrary
// (None)

class UClass* UME_CharacterFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterFunctionLibrary");

	return Clss;
}


// ME_CharacterFunctionLibrary Maneater.Default__ME_CharacterFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterFunctionLibrary* UME_CharacterFunctionLibrary::GetDefaultObj()
{
	static class UME_CharacterFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterFunctionLibrary*>(UME_CharacterFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CharacterFunctionLibrary.SetHealthToPercentage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Percent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CharacterFunctionLibrary::SetHealthToPercentage(class AME_Character* TwChar, float Percent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "SetHealthToPercentage");

	Params::UME_CharacterFunctionLibrary_SetHealthToPercentage_Params Parms{};

	Parms.TwChar = TwChar;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetWalkMoveSpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetWalkMoveSpeed(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetWalkMoveSpeed");

	Params::UME_CharacterFunctionLibrary_GetWalkMoveSpeed_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetSwimMoveSpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetSwimMoveSpeed(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetSwimMoveSpeed");

	Params::UME_CharacterFunctionLibrary_GetSwimMoveSpeed_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetStaminaRegen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetStaminaRegen(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetStaminaRegen");

	Params::UME_CharacterFunctionLibrary_GetStaminaRegen_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetStaminaMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetStaminaMax(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetStaminaMax");

	Params::UME_CharacterFunctionLibrary_GetStaminaMax_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetStamina
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetStamina(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetStamina");

	Params::UME_CharacterFunctionLibrary_GetStamina_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetSizeRatio
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AME_Character*               Character1                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_Character*               Character2                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetSizeRatio(class AME_Character* Character1, class AME_Character* Character2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetSizeRatio");

	Params::UME_CharacterFunctionLibrary_GetSizeRatio_Params Parms{};

	Parms.Character1 = Character1;
	Parms.Character2 = Character2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetSizeDifferential
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AME_Character*               Character1                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_Character*               Character2                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SizeDiffThresholdUp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SizeDifferentialDown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESizeDiff               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESizeDiff UME_CharacterFunctionLibrary::GetSizeDifferential(class AME_Character* Character1, class AME_Character* Character2, float SizeDiffThresholdUp, float SizeDifferentialDown)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetSizeDifferential");

	Params::UME_CharacterFunctionLibrary_GetSizeDifferential_Params Parms{};

	Parms.Character1 = Character1;
	Parms.Character2 = Character2;
	Parms.SizeDiffThresholdUp = SizeDiffThresholdUp;
	Parms.SizeDifferentialDown = SizeDifferentialDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetSizeDelta
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetSizeDelta(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetSizeDelta");

	Params::UME_CharacterFunctionLibrary_GetSizeDelta_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetSize
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetSize(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetSize");

	Params::UME_CharacterFunctionLibrary_GetSize_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetMaxAcceleration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetMaxAcceleration(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetMaxAcceleration");

	Params::UME_CharacterFunctionLibrary_GetMaxAcceleration_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetHealthPercentage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetHealthPercentage(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetHealthPercentage");

	Params::UME_CharacterFunctionLibrary_GetHealthPercentage_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetHealthMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetHealthMax(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetHealthMax");

	Params::UME_CharacterFunctionLibrary_GetHealthMax_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetHealth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_CharacterFunctionLibrary::GetHealth(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetHealth");

	Params::UME_CharacterFunctionLibrary_GetHealth_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetCharacterActionMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECharacterActionMode UME_CharacterFunctionLibrary::GetCharacterActionMode(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetCharacterActionMode");

	Params::UME_CharacterFunctionLibrary_GetCharacterActionMode_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CharacterFunctionLibrary.GetActorDamagableAttributeSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_AttributeSet*            ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AttributeSet* UME_CharacterFunctionLibrary::GetActorDamagableAttributeSet(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CharacterFunctionLibrary", "GetActorDamagableAttributeSet");

	Params::UME_CharacterFunctionLibrary_GetActorDamagableAttributeSet_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_CharacterVoiceData
// (None)

class UClass* UME_CharacterVoiceData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CharacterVoiceData");

	return Clss;
}


// ME_CharacterVoiceData Maneater.Default__ME_CharacterVoiceData
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CharacterVoiceData* UME_CharacterVoiceData::GetDefaultObj()
{
	static class UME_CharacterVoiceData* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CharacterVoiceData*>(UME_CharacterVoiceData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CheatManager
// (None)

class UClass* UME_CheatManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CheatManager");

	return Clss;
}


// ME_CheatManager Maneater.Default__ME_CheatManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CheatManager* UME_CheatManager::GetDefaultObj()
{
	static class UME_CheatManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CheatManager*>(UME_CheatManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CheatManager.ToggleCameraAttached
// (Final, Exec, Native, Protected)
// Parameters:

void UME_CheatManager::ToggleCameraAttached()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "ToggleCameraAttached");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Debug_DumpAI
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Debug_DumpAI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Debug_DumpAI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Debug_DrawProgressBar
// (Final, Exec, Native, Static, Public)
// Parameters:
// class UWorld*                      World                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ProgressReferenceActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ProgressPercent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Debug_DrawProgressBar(class UWorld* World, class AActor* ProgressReferenceActor, float ProgressPercent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Debug_DrawProgressBar");

	Params::UME_CheatManager_Debug_DrawProgressBar_Params Parms{};

	Parms.World = World;
	Parms.ProgressReferenceActor = ProgressReferenceActor;
	Parms.ProgressPercent = ProgressPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ValidateEntitlementOwnership
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ValidateEntitlementOwnership()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ValidateEntitlementOwnership");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_UnlockAchievement
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                        AchievementName                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_UnlockAchievement(class FName& AchievementName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_UnlockAchievement");

	Params::UME_CheatManager_Cheat_UnlockAchievement_Params Parms{};

	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_TutorialSkipAhead
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_TutorialSkipAhead(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_TutorialSkipAhead");

	Params::UME_CheatManager_Cheat_TutorialSkipAhead_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_TutorialNextStep
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_TutorialNextStep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_TutorialNextStep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_TutorialAutoComplete
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_TutorialAutoComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_TutorialAutoComplete");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ToggleTODPause
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ToggleTODPause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ToggleTODPause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ToggleKnifing
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ToggleKnifing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ToggleKnifing");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ToggleAI
// (Final, Exec, Native, Public)
// Parameters:
// enum class EThreeStateSwitch       bEnableAI                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_ToggleAI(enum class EThreeStateSwitch bEnableAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ToggleAI");

	Params::UME_CheatManager_Cheat_ToggleAI_Params Parms{};

	Parms.bEnableAI = bEnableAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_Suicide
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_Suicide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_Suicide");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_StoryAdvanceTo
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_StoryAdvanceTo(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_StoryAdvanceTo");

	Params::UME_CheatManager_Cheat_StoryAdvanceTo_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SpawnAI
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                      AIName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SpawnOffset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SpawnAI(const class FString& AIName, float SpawnOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SpawnAI");

	Params::UME_CheatManager_Cheat_SpawnAI_Params Parms{};

	Parms.AIName = AIName;
	Parms.SpawnOffset = SpawnOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SlamDamageEnabled
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bTurnOn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SlamDamageEnabled(bool bTurnOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SlamDamageEnabled");

	Params::UME_CheatManager_Cheat_SlamDamageEnabled_Params Parms{};

	Parms.bTurnOn = bTurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ShowStoryCompleteWidget
// (Final, Exec, Native, Protected)
// Parameters:

void UME_CheatManager::Cheat_ShowStoryCompleteWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ShowStoryCompleteWidget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetWalkMoveSpeed
// (Final, Exec, Native, Protected)
// Parameters:
// float                              NewWalkSpeed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetWalkMoveSpeed(float NewWalkSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetWalkMoveSpeed");

	Params::UME_CheatManager_Cheat_SetWalkMoveSpeed_Params Parms{};

	Parms.NewWalkSpeed = NewWalkSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetTOD
// (Final, Exec, Native, Public)
// Parameters:
// float                              HourOfDay                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetTOD(float HourOfDay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetTOD");

	Params::UME_CheatManager_Cheat_SetTOD_Params Parms{};

	Parms.HourOfDay = HourOfDay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetSwimMoveSpeed
// (Final, Exec, Native, Protected)
// Parameters:
// float                              NewSwimSpeed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetSwimMoveSpeed(float NewSwimSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetSwimMoveSpeed");

	Params::UME_CheatManager_Cheat_SetSwimMoveSpeed_Params Parms{};

	Parms.NewSwimSpeed = NewSwimSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetSharkMesh
// (Final, Exec, Native, Public)
// Parameters:
// int32                              SharkMesh                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetSharkMesh(int32 SharkMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetSharkMesh");

	Params::UME_CheatManager_Cheat_SetSharkMesh_Params Parms{};

	Parms.SharkMesh = SharkMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetMaxAcceleration
// (Final, Exec, Native, Protected)
// Parameters:
// float                              NewMaxAcceleration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetMaxAcceleration(float NewMaxAcceleration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetMaxAcceleration");

	Params::UME_CheatManager_Cheat_SetMaxAcceleration_Params Parms{};

	Parms.NewMaxAcceleration = NewMaxAcceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetLevel");

	Params::UME_CheatManager_Cheat_SetLevel_Params Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetKnifingZOffset
// (Final, Exec, Native, Public)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetKnifingZOffset(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetKnifingZOffset");

	Params::UME_CheatManager_Cheat_SetKnifingZOffset_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetEvolutionCharge
// (Final, Exec, Native, Public)
// Parameters:
// float                              ChargeAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetEvolutionCharge(float ChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetEvolutionCharge");

	Params::UME_CheatManager_Cheat_SetEvolutionCharge_Params Parms{};

	Parms.ChargeAmount = ChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetCameraZOffset
// (Final, Exec, Native, Public)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetCameraZOffset(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetCameraZOffset");

	Params::UME_CheatManager_Cheat_SetCameraZOffset_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetCameraProbeSize
// (Final, Exec, Native, Public)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetCameraProbeSize(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetCameraProbeSize");

	Params::UME_CheatManager_Cheat_SetCameraProbeSize_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetCameraComplex
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bCollideComplex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetCameraComplex(bool bCollideComplex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetCameraComplex");

	Params::UME_CheatManager_Cheat_SetCameraComplex_Params Parms{};

	Parms.bCollideComplex = bCollideComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetCameraArmLength
// (Final, Exec, Native, Public)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetCameraArmLength(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetCameraArmLength");

	Params::UME_CheatManager_Cheat_SetCameraArmLength_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_SetBossPhase
// (Final, Exec, Native, Public)
// Parameters:
// int32                              NewPhaseNum                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_SetBossPhase(int32 NewPhaseNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_SetBossPhase");

	Params::UME_CheatManager_Cheat_SetBossPhase_Params Parms{};

	Parms.NewPhaseNum = NewPhaseNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ScareAI
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ScareAI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ScareAI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ResetSpeedCheats
// (Final, Exec, Native, Protected)
// Parameters:

void UME_CheatManager::Cheat_ResetSpeedCheats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ResetSpeedCheats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ResetObjective
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_ResetObjective(class FName ObjName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ResetObjective");

	Params::UME_CheatManager_Cheat_ResetObjective_Params Parms{};

	Parms.ObjName = ObjName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_RemoveUnequippedEvolutions
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_RemoveUnequippedEvolutions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_RemoveUnequippedEvolutions");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_RecheckAllAchievements
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_RecheckAllAchievements()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_RecheckAllAchievements");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ProgressObjective
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Increment                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_ProgressObjective(class FName ObjName, int32 Increment)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ProgressObjective");

	Params::UME_CheatManager_Cheat_ProgressObjective_Params Parms{};

	Parms.ObjName = ObjName;
	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_PlayStoryCinematic
// (Final, Exec, Native, Protected)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_PlayStoryCinematic(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_PlayStoryCinematic");

	Params::UME_CheatManager_Cheat_PlayStoryCinematic_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_PauseAndSetTOD
// (Final, Exec, Native, Public)
// Parameters:
// float                              HourOfDay                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_PauseAndSetTOD(float HourOfDay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_PauseAndSetTOD");

	Params::UME_CheatManager_Cheat_PauseAndSetTOD_Params Parms{};

	Parms.HourOfDay = HourOfDay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_OverrideBoatTurnSound
// (Final, Exec, Native, Public)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_OverrideBoatTurnSound(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_OverrideBoatTurnSound");

	Params::UME_CheatManager_Cheat_OverrideBoatTurnSound_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_OnePunch
// (Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_OnePunch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_OnePunch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ObjectivesCompleteTickedObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ObjectivesCompleteTickedObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ObjectivesCompleteTickedObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ObjectivesCompleteTerrorizeObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ObjectivesCompleteTerrorizeObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ObjectivesCompleteTerrorizeObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ObjectivesCompletePopControlObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ObjectivesCompletePopControlObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ObjectivesCompletePopControlObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ObjectivesCompleteLandmarkObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ObjectivesCompleteLandmarkObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ObjectivesCompleteLandmarkObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_NextBossPhase
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_NextBossPhase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_NextBossPhase");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_LogSpawnEntityStates
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_LogSpawnEntityStates()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_LogSpawnEntityStates");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_LogObjectives
// (Final, Exec, Native, Public)
// Parameters:
// enum class EObjectiveType          Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EWorldRegion            Region                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_LogObjectives(enum class EObjectiveType Type, enum class EWorldRegion Region)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_LogObjectives");

	Params::UME_CheatManager_Cheat_LogObjectives_Params Parms{};

	Parms.Type = Type;
	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_LogAllEvolutionRewardRows
// (Final, Exec, Native, Public, Const)
// Parameters:

void UME_CheatManager::Cheat_LogAllEvolutionRewardRows()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_LogAllEvolutionRewardRows");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_LogAIManagementStates
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_LogAIManagementStates()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_LogAIManagementStates");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillSchools
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillSchools()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillSchools");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillHumans
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillHumans()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillHumans");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillDivers
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillDivers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillDivers");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillBoats
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillBoats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillBoats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillAnimals
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillAnimals()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillAnimals");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_KillAll
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_KillAll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_KillAll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_HideFromAI
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_HideFromAI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_HideFromAI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_HandleLoadError
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_HandleLoadError()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_HandleLoadError");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_Grow
// (Final, Exec, Native, Public)
// Parameters:
// int32                              GrowthChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_Grow(int32 GrowthChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_Grow");

	Params::UME_CheatManager_Cheat_Grow_Params Parms{};

	Parms.GrowthChange = GrowthChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_GrottosUnlock
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_GrottosUnlock()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_GrottosUnlock");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_GottaGoFast
// (Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_GottaGoFast()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_GottaGoFast");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_GiveNutrients
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Nutrients                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ENutrientType           NutrientType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_GiveNutrients(int32 Nutrients, enum class ENutrientType NutrientType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_GiveNutrients");

	Params::UME_CheatManager_Cheat_GiveNutrients_Params Parms{};

	Parms.Nutrients = Nutrients;
	Parms.NutrientType = NutrientType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_GiveEvolutions
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Rarity                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_GiveEvolutions(int32 Rarity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_GiveEvolutions");

	Params::UME_CheatManager_Cheat_GiveEvolutions_Params Parms{};

	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ForceSaveGame
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ForceSaveGame()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ForceSaveGame");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ForceReleasePrey
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ForceReleasePrey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ForceReleasePrey");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_FindAllObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_FindAllObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_FindAllObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_FastTravel
// (Final, Exec, Native, Public)
// Parameters:
// int32                              RegionIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CheatManager::Cheat_FastTravel(int32 RegionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_FastTravel");

	Params::UME_CheatManager_Cheat_FastTravel_Params Parms{};

	Parms.RegionIndex = RegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CheatManager.Cheat_EnableTargetLasers
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bTurnOn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_EnableTargetLasers(bool bTurnOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_EnableTargetLasers");

	Params::UME_CheatManager_Cheat_EnableTargetLasers_Params Parms{};

	Parms.bTurnOn = bTurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_EnableAIDebuggingStuff
// (Final, Exec, Native, Static, Protected)
// Parameters:

void UME_CheatManager::Cheat_EnableAIDebuggingStuff()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_EnableAIDebuggingStuff");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_Eject
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_Eject()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_Eject");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_Dismember
// (Final, Exec, Native, Public)
// Parameters:
// int32                              GrabPointIdx                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_Dismember(int32 GrabPointIdx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_Dismember");

	Params::UME_CheatManager_Cheat_Dismember_Params Parms{};

	Parms.GrabPointIdx = GrabPointIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_DiscoverObjectives
// (Final, Exec, Native, Public)
// Parameters:
// enum class EObjectiveType          Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EWorldRegion            Region                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_DiscoverObjectives(enum class EObjectiveType Type, enum class EWorldRegion Region)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_DiscoverObjectives");

	Params::UME_CheatManager_Cheat_DiscoverObjectives_Params Parms{};

	Parms.Type = Type;
	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_DiscoverAllObjectives
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_DiscoverAllObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_DiscoverAllObjectives");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_DisableTutorial
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_DisableTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_DisableTutorial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_DemiGod
// (Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_DemiGod()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_DemiGod");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_DebugGTWaves
// (Final, Exec, Native, Public)
// Parameters:
// int32                              GridCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_DebugGTWaves(int32 GridCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_DebugGTWaves");

	Params::UME_CheatManager_Cheat_DebugGTWaves_Params Parms{};

	Parms.GridCount = GridCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_CompleteRegionObjectives
// (Final, Exec, Native, Public)
// Parameters:
// class FString                      RegionName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_CompleteRegionObjectives(const class FString& RegionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_CompleteRegionObjectives");

	Params::UME_CheatManager_Cheat_CompleteRegionObjectives_Params Parms{};

	Parms.RegionName = RegionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_CompleteObjective
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_CompleteObjective(class FName ObjName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_CompleteObjective");

	Params::UME_CheatManager_Cheat_CompleteObjective_Params Parms{};

	Parms.ObjName = ObjName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_CompleteNextAvailableObjectives
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Num                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_CompleteNextAvailableObjectives(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_CompleteNextAvailableObjectives");

	Params::UME_CheatManager_Cheat_CompleteNextAvailableObjectives_Params Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ClearAchievementsInSaveGame
// (Final, Exec, Native, Public, Const)
// Parameters:

void UME_CheatManager::Cheat_ClearAchievementsInSaveGame()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ClearAchievementsInSaveGame");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BreakBoats
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_BreakBoats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BreakBoats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountyTriggerBounty
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_BountyTriggerBounty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountyTriggerBounty");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountyTriggerBoss
// (Final, Exec, Native, Public)
// Parameters:
// int32                              BossIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_BountyTriggerBoss(int32 BossIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountyTriggerBoss");

	Params::UME_CheatManager_Cheat_BountyTriggerBoss_Params Parms{};

	Parms.BossIndex = BossIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountySetInfamyLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                              InfamyLevel                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_BountySetInfamyLevel(int32 InfamyLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountySetInfamyLevel");

	Params::UME_CheatManager_Cheat_BountySetInfamyLevel_Params Parms{};

	Parms.InfamyLevel = InfamyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountyEndBounty
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_BountyEndBounty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountyEndBounty");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountyEnableBountySystem
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_BountyEnableBountySystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountyEnableBountySystem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_BountyDisableBountySystem
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_BountyDisableBountySystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_BountyDisableBountySystem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ApplyTag
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_ApplyTag()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ApplyTag");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_ApplyNutrientMultiplier
// (Final, Exec, Native, Protected)
// Parameters:
// float                              Multiplier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_ApplyNutrientMultiplier(float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_ApplyNutrientMultiplier");

	Params::UME_CheatManager_Cheat_ApplyNutrientMultiplier_Params Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AlertAI
// (Final, Exec, Native, Public)
// Parameters:
// float                              AlertRadius                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AlertAI(float AlertRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AlertAI");

	Params::UME_CheatManager_Cheat_AlertAI_Params Parms{};

	Parms.AlertRadius = AlertRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AIVision
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bTurnOn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AIVision(bool bTurnOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AIVision");

	Params::UME_CheatManager_Cheat_AIVision_Params Parms{};

	Parms.bTurnOn = bTurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AITargeting
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bTurnOn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AITargeting(bool bTurnOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AITargeting");

	Params::UME_CheatManager_Cheat_AITargeting_Params Parms{};

	Parms.bTurnOn = bTurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AdvanceStoryEvent
// (Final, Exec, Native, Protected)
// Parameters:
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AdvanceStoryEvent(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AdvanceStoryEvent");

	Params::UME_CheatManager_Cheat_AdvanceStoryEvent_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AdjustWalkMoveSpeed
// (Final, Exec, Native, Protected)
// Parameters:
// float                              WalkMultiplier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AdjustWalkMoveSpeed(float WalkMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AdjustWalkMoveSpeed");

	Params::UME_CheatManager_Cheat_AdjustWalkMoveSpeed_Params Parms{};

	Parms.WalkMultiplier = WalkMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AdjustSwimMoveSpeed
// (Final, Exec, Native, Protected)
// Parameters:
// float                              SwimMultiplier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AdjustSwimMoveSpeed(float SwimMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AdjustSwimMoveSpeed");

	Params::UME_CheatManager_Cheat_AdjustSwimMoveSpeed_Params Parms{};

	Parms.SwimMultiplier = SwimMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AdjustMaxAcceleration
// (Final, Exec, Native, Protected)
// Parameters:
// float                              MaxAccelerationMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::Cheat_AdjustMaxAcceleration(float MaxAccelerationMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AdjustMaxAcceleration");

	Params::UME_CheatManager_Cheat_AdjustMaxAcceleration_Params Parms{};

	Parms.MaxAccelerationMultiplier = MaxAccelerationMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.Cheat_AbandonVehicle
// (Final, Exec, Native, Public)
// Parameters:

void UME_CheatManager::Cheat_AbandonVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "Cheat_AbandonVehicle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CheatManager.AudioTrigger
// (Final, Exec, Native, Public)
// Parameters:
// class FString                      Event                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ForceMode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_CheatManager::AudioTrigger(const class FString& Event, int32 ForceMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CheatManager", "AudioTrigger");

	Params::UME_CheatManager_AudioTrigger_Params Parms{};

	Parms.Event = Event;
	Parms.ForceMode = ForceMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_ChopperAIController
// (Actor)

class UClass* AME_ChopperAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ChopperAIController");

	return Clss;
}


// ME_ChopperAIController Maneater.Default__ME_ChopperAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ChopperAIController* AME_ChopperAIController::GetDefaultObj()
{
	static class AME_ChopperAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ChopperAIController*>(AME_ChopperAIController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ChopperPawn
// (Actor, Pawn)

class UClass* AME_ChopperPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ChopperPawn");

	return Clss;
}


// ME_ChopperPawn Maneater.Default__ME_ChopperPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ChopperPawn* AME_ChopperPawn::GetDefaultObj()
{
	static class AME_ChopperPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ChopperPawn*>(AME_ChopperPawn::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CollectableActor
// (Actor)

class UClass* AME_CollectableActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CollectableActor");

	return Clss;
}


// ME_CollectableActor Maneater.Default__ME_CollectableActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_CollectableActor* AME_CollectableActor::GetDefaultObj()
{
	static class AME_CollectableActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_CollectableActor*>(AME_CollectableActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CombatManager
// (None)

class UClass* UME_CombatManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CombatManager");

	return Clss;
}


// ME_CombatManager Maneater.Default__ME_CombatManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CombatManager* UME_CombatManager::GetDefaultObj()
{
	static class UME_CombatManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CombatManager*>(UME_CombatManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CombatManager.IsInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_CombatManager::IsInCombat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CombatManager", "IsInCombat");

	Params::UME_CombatManager_IsInCombat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MEControlSchemes
// (None)

class UClass* UMEControlSchemes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEControlSchemes");

	return Clss;
}


// MEControlSchemes Maneater.Default__MEControlSchemes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEControlSchemes* UMEControlSchemes::GetDefaultObj()
{
	static class UMEControlSchemes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEControlSchemes*>(UMEControlSchemes::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEControlSchemes.GetControlSchemes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FText> UMEControlSchemes::GetControlSchemes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "GetControlSchemes");

	Params::UMEControlSchemes_GetControlSchemes_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MEControlSchemes.GetControlSchemeDefault
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMEControlSchemes*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMEControlSchemes* UMEControlSchemes::GetControlSchemeDefault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "GetControlSchemeDefault");

	Params::UMEControlSchemes_GetControlSchemeDefault_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MEControlSchemes.GetControlSchemeAtIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMEControlScheme            ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

struct FMEControlScheme UMEControlSchemes::GetControlSchemeAtIndex(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "GetControlSchemeAtIndex");

	Params::UMEControlSchemes_GetControlSchemeAtIndex_Params Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MEControlSchemes.GetAxisForScheme
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMEControlScheme            Scheme                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FAxisBindingSaveData>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FAxisBindingSaveData> UMEControlSchemes::GetAxisForScheme(struct FMEControlScheme& Scheme)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "GetAxisForScheme");

	Params::UMEControlSchemes_GetAxisForScheme_Params Parms{};

	Parms.Scheme = Scheme;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MEControlSchemes.GetActionsForScheme
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMEControlScheme            Scheme                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActionBindingSaveData>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FActionBindingSaveData> UMEControlSchemes::GetActionsForScheme(struct FMEControlScheme& Scheme)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "GetActionsForScheme");

	Params::UMEControlSchemes_GetActionsForScheme_Params Parms{};

	Parms.Scheme = Scheme;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MEControlSchemes.ApplyControlScheme
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEControlSchemes::ApplyControlScheme(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEControlSchemes", "ApplyControlScheme");

	Params::UMEControlSchemes_ApplyControlScheme_Params Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_CreatureSchoolAIController
// (Actor)

class UClass* AME_CreatureSchoolAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CreatureSchoolAIController");

	return Clss;
}


// ME_CreatureSchoolAIController Maneater.Default__ME_CreatureSchoolAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_CreatureSchoolAIController* AME_CreatureSchoolAIController::GetDefaultObj()
{
	static class AME_CreatureSchoolAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_CreatureSchoolAIController*>(AME_CreatureSchoolAIController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CreatureSchoolMeshComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent, SkeletalMeshComponent)

class UClass* UME_CreatureSchoolMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CreatureSchoolMeshComponent");

	return Clss;
}


// ME_CreatureSchoolMeshComponent Maneater.Default__ME_CreatureSchoolMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CreatureSchoolMeshComponent* UME_CreatureSchoolMeshComponent::GetDefaultObj()
{
	static class UME_CreatureSchoolMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CreatureSchoolMeshComponent*>(UME_CreatureSchoolMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CreatureSchoolMoveComponent
// (None)

class UClass* UME_CreatureSchoolMoveComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CreatureSchoolMoveComponent");

	return Clss;
}


// ME_CreatureSchoolMoveComponent Maneater.Default__ME_CreatureSchoolMoveComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_CreatureSchoolMoveComponent* UME_CreatureSchoolMoveComponent::GetDefaultObj()
{
	static class UME_CreatureSchoolMoveComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_CreatureSchoolMoveComponent*>(UME_CreatureSchoolMoveComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_CreatureSchoolPawn
// (Actor, Pawn)

class UClass* AME_CreatureSchoolPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_CreatureSchoolPawn");

	return Clss;
}


// ME_CreatureSchoolPawn Maneater.Default__ME_CreatureSchoolPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_CreatureSchoolPawn* AME_CreatureSchoolPawn::GetDefaultObj()
{
	static class AME_CreatureSchoolPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_CreatureSchoolPawn*>(AME_CreatureSchoolPawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_CreatureSchoolPawn.SetAIPatrolPlotter
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATwAIPatrolPlotter*          InPatrolPlotter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_CreatureSchoolPawn::SetAIPatrolPlotter(class ATwAIPatrolPlotter* InPatrolPlotter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CreatureSchoolPawn", "SetAIPatrolPlotter");

	Params::AME_CreatureSchoolPawn_SetAIPatrolPlotter_Params Parms{};

	Parms.InPatrolPlotter = InPatrolPlotter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CreatureSchoolPawn.OnGameplayEffectRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FActiveGameplayEffect       RemovedGameplayEffect                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AME_CreatureSchoolPawn::OnGameplayEffectRemoved(struct FActiveGameplayEffect& RemovedGameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CreatureSchoolPawn", "OnGameplayEffectRemoved");

	Params::AME_CreatureSchoolPawn_OnGameplayEffectRemoved_Params Parms{};

	Parms.RemovedGameplayEffect = RemovedGameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_CreatureSchoolPawn.IsAbilitySystemComponentSetUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_CreatureSchoolPawn::IsAbilitySystemComponentSetUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CreatureSchoolPawn", "IsAbilitySystemComponentSetUp");

	Params::AME_CreatureSchoolPawn_IsAbilitySystemComponentSetUp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CreatureSchoolPawn.GetAIPatrolPlotter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATwAIPatrolPlotter*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATwAIPatrolPlotter* AME_CreatureSchoolPawn::GetAIPatrolPlotter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CreatureSchoolPawn", "GetAIPatrolPlotter");

	Params::AME_CreatureSchoolPawn_GetAIPatrolPlotter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_CreatureSchoolPawn.GetAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_AbilitySystemComponent*  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AbilitySystemComponent* AME_CreatureSchoolPawn::GetAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_CreatureSchoolPawn", "GetAbilitySystemComponent");

	Params::AME_CreatureSchoolPawn_GetAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_DamageType
// (None)

class UClass* UME_DamageType::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DamageType");

	return Clss;
}


// ME_DamageType Maneater.Default__ME_DamageType
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DamageType* UME_DamageType::GetDefaultObj()
{
	static class UME_DamageType* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DamageType*>(UME_DamageType::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_DebugCameraController
// (Actor, PlayerController)

class UClass* AME_DebugCameraController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DebugCameraController");

	return Clss;
}


// ME_DebugCameraController Maneater.Default__ME_DebugCameraController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_DebugCameraController* AME_DebugCameraController::GetDefaultObj()
{
	static class AME_DebugCameraController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_DebugCameraController*>(AME_DebugCameraController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_DestructibleActor
// (Actor)

class UClass* AME_DestructibleActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DestructibleActor");

	return Clss;
}


// ME_DestructibleActor Maneater.Default__ME_DestructibleActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_DestructibleActor* AME_DestructibleActor::GetDefaultObj()
{
	static class AME_DestructibleActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_DestructibleActor*>(AME_DestructibleActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_DestructibleActor.UpdateOctree
// (Final, Native, Protected)
// Parameters:
// bool                               bAffectsNavigation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_DestructibleActor::UpdateOctree(bool bAffectsNavigation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "UpdateOctree");

	Params::AME_DestructibleActor_UpdateOctree_Params Parms{};

	Parms.bAffectsNavigation = bAffectsNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DestructibleActor.PostRenderForBP
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_DestructibleActor::PostRenderForBP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "PostRenderForBP");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_DestructibleActor.PlayerDamagedBreakable
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DamageAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_DestructibleActor::PlayerDamagedBreakable(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "PlayerDamagedBreakable");

	Params::AME_DestructibleActor_PlayerDamagedBreakable_Params Parms{};

	Parms.DamageAmount = DamageAmount;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_DestructibleActor.OnComponentFractured
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                     HitPoint                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitDirection                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_DestructibleActor::OnComponentFractured(struct FVector& HitPoint, struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "OnComponentFractured");

	Params::AME_DestructibleActor_OnComponentFractured_Params Parms{};

	Parms.HitPoint = HitPoint;
	Parms.HitDirection = HitDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DestructibleActor.IsDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_DestructibleActor::IsDestroyed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "IsDestroyed");

	Params::AME_DestructibleActor_IsDestroyed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DestructibleActor.GetCurrentHealth_Implementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_DestructibleActor::GetCurrentHealth_Implementation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "GetCurrentHealth_Implementation");

	Params::AME_DestructibleActor_GetCurrentHealth_Implementation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DestructibleActor.CanDamageBreakable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_DestructibleActor::CanDamageBreakable(class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DestructibleActor", "CanDamageBreakable");

	Params::AME_DestructibleActor_CanDamageBreakable_Params Parms{};

	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_DestructibleComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent)

class UClass* UME_DestructibleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DestructibleComponent");

	return Clss;
}


// ME_DestructibleComponent Maneater.Default__ME_DestructibleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DestructibleComponent* UME_DestructibleComponent::GetDefaultObj()
{
	static class UME_DestructibleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DestructibleComponent*>(UME_DestructibleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_DialogueFunctionLibrary
// (None)

class UClass* UME_DialogueFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DialogueFunctionLibrary");

	return Clss;
}


// ME_DialogueFunctionLibrary Maneater.Default__ME_DialogueFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DialogueFunctionLibrary* UME_DialogueFunctionLibrary::GetDefaultObj()
{
	static class UME_DialogueFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DialogueFunctionLibrary*>(UME_DialogueFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_DialogueFunctionLibrary.TwPlaySubtitledAkEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      EventName                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                  SearchTable                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_DialogueFunctionLibrary::TwPlaySubtitledAkEvent(class FString* EventName, class AActor* Actor, class UDataTable* SearchTable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueFunctionLibrary", "TwPlaySubtitledAkEvent");

	Params::UME_DialogueFunctionLibrary_TwPlaySubtitledAkEvent_Params Parms{};

	Parms.Actor = Actor;
	Parms.SearchTable = SearchTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (EventName != nullptr)
		*EventName = std::move(Parms.EventName);

	return Parms.ReturnValue;

}


// Function Maneater.ME_DialogueFunctionLibrary.TwPlayDialogueAkEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                  SearchTable                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*               AkEvent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_DialogueFunctionLibrary::TwPlayDialogueAkEvent(class UDataTable* SearchTable, class UAkAudioEvent* AkEvent, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueFunctionLibrary", "TwPlayDialogueAkEvent");

	Params::UME_DialogueFunctionLibrary_TwPlayDialogueAkEvent_Params Parms{};

	Parms.SearchTable = SearchTable;
	Parms.AkEvent = AkEvent;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DialogueFunctionLibrary.PlayDialogueFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         DialogueToPlay                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                      WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_DialogueFunctionLibrary::PlayDialogueFile(struct FDataTableRowHandle& DialogueToPlay, class AActor* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueFunctionLibrary", "PlayDialogueFile");

	Params::UME_DialogueFunctionLibrary_PlayDialogueFile_Params Parms{};

	Parms.DialogueToPlay = DialogueToPlay;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DialogueFunctionLibrary.PlayDialogueAkEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         DialogueToPlay                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAkAudioEvent*               AkEvent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_DialogueFunctionLibrary::PlayDialogueAkEvent(struct FDataTableRowHandle& DialogueToPlay, class UAkAudioEvent* AkEvent, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueFunctionLibrary", "PlayDialogueAkEvent");

	Params::UME_DialogueFunctionLibrary_PlayDialogueAkEvent_Params Parms{};

	Parms.DialogueToPlay = DialogueToPlay;
	Parms.AkEvent = AkEvent;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_DialogueSystem
// (None)

class UClass* UME_DialogueSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DialogueSystem");

	return Clss;
}


// ME_DialogueSystem Maneater.Default__ME_DialogueSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DialogueSystem* UME_DialogueSystem::GetDefaultObj()
{
	static class UME_DialogueSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DialogueSystem*>(UME_DialogueSystem::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_DialogueSystem.ShowSubtitle
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        DialogueText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeSeconds                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_DialogueSystem::ShowSubtitle(class FText& DialogueText, float Duration, float TimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "ShowSubtitle");

	Params::UME_DialogueSystem_ShowSubtitle_Params Parms{};

	Parms.DialogueText = DialogueText;
	Parms.Duration = Duration;
	Parms.TimeSeconds = TimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DialogueSystem.SequencerDialogueCallback
// (Final, Native, Public)
// Parameters:
// enum class EAkCallbackType         CallbackType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*             CallbackInfo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::SequencerDialogueCallback(enum class EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "SequencerDialogueCallback");

	Params::UME_DialogueSystem_SequencerDialogueCallback_Params Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DialogueSystem.PostDynamicDialogue
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// class FName                        DialogueEventName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Speaker                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ArgumentValueNames                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::PostDynamicDialogue(class FName* DialogueEventName, class AActor* Speaker, TArray<class FString>* ArgumentValueNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "PostDynamicDialogue");

	Params::UME_DialogueSystem_PostDynamicDialogue_Params Parms{};

	Parms.Speaker = Speaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DialogueEventName != nullptr)
		*DialogueEventName = Parms.DialogueEventName;

	if (ArgumentValueNames != nullptr)
		*ArgumentValueNames = std::move(Parms.ArgumentValueNames);

}


// Function Maneater.ME_DialogueSystem.PlayExternalDialogueFile
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        EventName                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Filename                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowSubtitle                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        DialogueText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UME_DialogueSystem::PlayExternalDialogueFile(class FName* EventName, class FString* Filename, class AActor* WorldContext, bool ShowSubtitle, class FText& DialogueText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "PlayExternalDialogueFile");

	Params::UME_DialogueSystem_PlayExternalDialogueFile_Params Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ShowSubtitle = ShowSubtitle;
	Parms.DialogueText = DialogueText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (EventName != nullptr)
		*EventName = Parms.EventName;

	if (Filename != nullptr)
		*Filename = std::move(Parms.Filename);

}


// Function Maneater.ME_DialogueSystem.InitDialogueSystem
// (Final, Native, Public)
// Parameters:
// class AME_GameMode*                OwningGameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::InitDialogueSystem(class AME_GameMode* OwningGameMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "InitDialogueSystem");

	Params::UME_DialogueSystem_InitDialogueSystem_Params Parms{};

	Parms.OwningGameMode = OwningGameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DialogueSystem.GetOnDialogueSystemCallbackDelegate
// (Final, Native, Public)
// Parameters:
// FMulticastInlineDelegateProperty_  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NativeAccessSpecifierPublic)

FMulticastInlineDelegateProperty_ UME_DialogueSystem::GetOnDialogueSystemCallbackDelegate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "GetOnDialogueSystemCallbackDelegate");

	Params::UME_DialogueSystem_GetOnDialogueSystemCallbackDelegate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_DialogueSystem.EndStateCooldown
// (Final, Native, Public)
// Parameters:
// class FName                        StateName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::EndStateCooldown(class FName StateName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "EndStateCooldown");

	Params::UME_DialogueSystem_EndStateCooldown_Params Parms{};

	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DialogueSystem.DynamicDialogueCallback
// (Final, Native, Public)
// Parameters:
// enum class EAkCallbackType         CallbackType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*             CallbackInfo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::DynamicDialogueCallback(enum class EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "DynamicDialogueCallback");

	Params::UME_DialogueSystem_DynamicDialogueCallback_Params Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DialogueSystem.DialogueCallback
// (Final, Native, Public)
// Parameters:
// enum class EAkCallbackType         CallbackType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*             CallbackInfo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::DialogueCallback(enum class EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "DialogueCallback");

	Params::UME_DialogueSystem_DialogueCallback_Params Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_DialogueSystem.AddAudioDialogueMapping
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                              AkPlayingId                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        DialogueText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              TimeSeconds                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DialogueSystem::AddAudioDialogueMapping(int32 AkPlayingId, class FText& DialogueText, float TimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DialogueSystem", "AddAudioDialogueMapping");

	Params::UME_DialogueSystem_AddAudioDialogueMapping_Params Parms{};

	Parms.AkPlayingId = AkPlayingId;
	Parms.DialogueText = DialogueText;
	Parms.TimeSeconds = TimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_SignificanceHandlerInterface
// (None)

class UClass* IME_SignificanceHandlerInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SignificanceHandlerInterface");

	return Clss;
}


// ME_SignificanceHandlerInterface Maneater.Default__ME_SignificanceHandlerInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_SignificanceHandlerInterface* IME_SignificanceHandlerInterface::GetDefaultObj()
{
	static class IME_SignificanceHandlerInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_SignificanceHandlerInterface*>(IME_SignificanceHandlerInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SignificanceHandlerInterface.HandleSignificanceChange
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bIsSignificant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_SignificanceHandlerInterface::HandleSignificanceChange(bool bIsSignificant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SignificanceHandlerInterface", "HandleSignificanceChange");

	Params::IME_SignificanceHandlerInterface_HandleSignificanceChange_Params Parms{};

	Parms.bIsSignificant = bIsSignificant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_DistanceSignificanceComponent
// (None)

class UClass* UME_DistanceSignificanceComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DistanceSignificanceComponent");

	return Clss;
}


// ME_DistanceSignificanceComponent Maneater.Default__ME_DistanceSignificanceComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DistanceSignificanceComponent* UME_DistanceSignificanceComponent::GetDefaultObj()
{
	static class UME_DistanceSignificanceComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DistanceSignificanceComponent*>(UME_DistanceSignificanceComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_DistanceSignificanceComponent.HandleSignificanceChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bIsSignificant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_DistanceSignificanceComponent::HandleSignificanceChange(bool bIsSignificant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_DistanceSignificanceComponent", "HandleSignificanceChange");

	Params::UME_DistanceSignificanceComponent_HandleSignificanceChange_Params Parms{};

	Parms.bIsSignificant = bIsSignificant;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_DiverAttachmentAnimSet
// (None)

class UClass* UME_DiverAttachmentAnimSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_DiverAttachmentAnimSet");

	return Clss;
}


// ME_DiverAttachmentAnimSet Maneater.Default__ME_DiverAttachmentAnimSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_DiverAttachmentAnimSet* UME_DiverAttachmentAnimSet::GetDefaultObj()
{
	static class UME_DiverAttachmentAnimSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_DiverAttachmentAnimSet*>(UME_DiverAttachmentAnimSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_EnvQueryContext_PlayerSharkActor
// (None)

class UClass* UME_EnvQueryContext_PlayerSharkActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_EnvQueryContext_PlayerSharkActor");

	return Clss;
}


// ME_EnvQueryContext_PlayerSharkActor Maneater.Default__ME_EnvQueryContext_PlayerSharkActor
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_EnvQueryContext_PlayerSharkActor* UME_EnvQueryContext_PlayerSharkActor::GetDefaultObj()
{
	static class UME_EnvQueryContext_PlayerSharkActor* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_EnvQueryContext_PlayerSharkActor*>(UME_EnvQueryContext_PlayerSharkActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_EnvQueryGenerator_ActivityPoints
// (None)

class UClass* UME_EnvQueryGenerator_ActivityPoints::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_EnvQueryGenerator_ActivityPoints");

	return Clss;
}


// ME_EnvQueryGenerator_ActivityPoints Maneater.Default__ME_EnvQueryGenerator_ActivityPoints
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_EnvQueryGenerator_ActivityPoints* UME_EnvQueryGenerator_ActivityPoints::GetDefaultObj()
{
	static class UME_EnvQueryGenerator_ActivityPoints* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_EnvQueryGenerator_ActivityPoints*>(UME_EnvQueryGenerator_ActivityPoints::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ExplodingBarrelBase
// (Actor)

class UClass* AME_ExplodingBarrelBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ExplodingBarrelBase");

	return Clss;
}


// ME_ExplodingBarrelBase Maneater.Default__ME_ExplodingBarrelBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ExplodingBarrelBase* AME_ExplodingBarrelBase::GetDefaultObj()
{
	static class AME_ExplodingBarrelBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ExplodingBarrelBase*>(AME_ExplodingBarrelBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ExplodingBarrelBase.Explode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_ExplodingBarrelBase::Explode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ExplodingBarrelBase", "Explode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_ExplosionActor
// (Actor)

class UClass* AME_ExplosionActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ExplosionActor");

	return Clss;
}


// ME_ExplosionActor Maneater.Default__ME_ExplosionActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ExplosionActor* AME_ExplosionActor::GetDefaultObj()
{
	static class AME_ExplosionActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ExplosionActor*>(AME_ExplosionActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ExplosionActor.GetExplosionRadius
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_ExplosionActor::GetExplosionRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ExplosionActor", "GetExplosionRadius");

	Params::AME_ExplosionActor_GetExplosionRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_FogOverrideVolume
// (Actor)

class UClass* AME_FogOverrideVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_FogOverrideVolume");

	return Clss;
}


// ME_FogOverrideVolume Maneater.Default__ME_FogOverrideVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_FogOverrideVolume* AME_FogOverrideVolume::GetDefaultObj()
{
	static class AME_FogOverrideVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_FogOverrideVolume*>(AME_FogOverrideVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_FogOverrideVolume.ActorOverlapped
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_FogOverrideVolume::ActorOverlapped(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_FogOverrideVolume", "ActorOverlapped");

	Params::AME_FogOverrideVolume_ActorOverlapped_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_FogOverrideVolume.ActorEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_FogOverrideVolume::ActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_FogOverrideVolume", "ActorEndOverlap");

	Params::AME_FogOverrideVolume_ActorEndOverlap_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEGameEngine
// (None)

class UClass* UMEGameEngine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEGameEngine");

	return Clss;
}


// MEGameEngine Maneater.Default__MEGameEngine
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEGameEngine* UMEGameEngine::GetDefaultObj()
{
	static class UMEGameEngine* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEGameEngine*>(UMEGameEngine::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameInstance
// (None)

class UClass* UME_GameInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameInstance");

	return Clss;
}


// ME_GameInstance Maneater.Default__ME_GameInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameInstance* UME_GameInstance::GetDefaultObj()
{
	static class UME_GameInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameInstance*>(UME_GameInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameInstance.UpdateFoliageShadowMaterialParametersCallback
// (Final, Native, Public)
// Parameters:

void UME_GameInstance::UpdateFoliageShadowMaterialParametersCallback()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "UpdateFoliageShadowMaterialParametersCallback");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.TriggerNarratorEventEx
// (Final, Native, Protected)
// Parameters:

void UME_GameInstance::TriggerNarratorEventEx()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "TriggerNarratorEventEx");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.TriggerNarratorEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameInstance::TriggerNarratorEvent(class FName Name, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "TriggerNarratorEvent");

	Params::UME_GameInstance_TriggerNarratorEvent_Params Parms{};

	Parms.Name = Name;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameInstance.StreamContentAtLocationForCinematic
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameInstance::StreamContentAtLocationForCinematic(const struct FVector& Location, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "StreamContentAtLocationForCinematic");

	Params::UME_GameInstance_StreamContentAtLocationForCinematic_Params Parms{};

	Parms.Location = Location;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.SetSelectedSaveSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LocalUserIdx                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameInstance::SetSelectedSaveSlot(int32 LocalUserIdx, int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "SetSelectedSaveSlot");

	Params::UME_GameInstance_SetSelectedSaveSlot_Params Parms{};

	Parms.LocalUserIdx = LocalUserIdx;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.GetSelectedSaveSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LocalUserIdx                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameInstance::GetSelectedSaveSlot(int32 LocalUserIdx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "GetSelectedSaveSlot");

	Params::UME_GameInstance_GetSelectedSaveSlot_Params Parms{};

	Parms.LocalUserIdx = LocalUserIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameInstance.GetCurrentNarratorCueTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UME_GameInstance::GetCurrentNarratorCueTable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "GetCurrentNarratorCueTable");

	Params::UME_GameInstance_GetCurrentNarratorCueTable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameInstance.FlushPendingSaveObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_GameInstance::FlushPendingSaveObjects()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "FlushPendingSaveObjects");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.DisableLevelStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bDisable                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameInstance::DisableLevelStreaming(bool bDisable, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "DisableLevelStreaming");

	Params::UME_GameInstance_DisableLevelStreaming_Params Parms{};

	Parms.bDisable = bDisable;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.Cheat_LogSaveGameObjectRecordsForSlot
// (Final, Exec, Native, Private, Const)
// Parameters:
// int32                              SlotIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameInstance::Cheat_LogSaveGameObjectRecordsForSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "Cheat_LogSaveGameObjectRecordsForSlot");

	Params::UME_GameInstance_Cheat_LogSaveGameObjectRecordsForSlot_Params Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.Cheat_LogSaveGameObjectRecords
// (Final, Exec, Native, Private, Const)
// Parameters:

void UME_GameInstance::Cheat_LogSaveGameObjectRecords()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "Cheat_LogSaveGameObjectRecords");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameInstance.Cheat_LogNarratorTableDiff
// (Final, Exec, Native, Private, Const)
// Parameters:

void UME_GameInstance::Cheat_LogNarratorTableDiff()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameInstance", "Cheat_LogNarratorTableDiff");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_GameMode
// (Actor)

class UClass* AME_GameMode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameMode");

	return Clss;
}


// ME_GameMode Maneater.Default__ME_GameMode
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_GameMode* AME_GameMode::GetDefaultObj()
{
	static class AME_GameMode* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_GameMode*>(AME_GameMode::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameMode.SuppressNextAudioPause
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SuppressNextAudioPause(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SuppressNextAudioPause");

	Params::AME_GameMode_SuppressNextAudioPause_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.StartStoryCinematicSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CinematicsDataTableRowName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::StartStoryCinematicSequence(class FName CinematicsDataTableRowName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "StartStoryCinematicSequence");

	Params::AME_GameMode_StartStoryCinematicSequence_Params Parms{};

	Parms.CinematicsDataTableRowName = CinematicsDataTableRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.StartCinematic
// (Final, Native, Public)
// Parameters:

void AME_GameMode::StartCinematic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "StartCinematic");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.ShowLoadingScreen
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DistanceStreamLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        RequiredLevelName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::ShowLoadingScreen(const struct FVector& DistanceStreamLocation, class FName RequiredLevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "ShowLoadingScreen");

	Params::AME_GameMode_ShowLoadingScreen_Params Parms{};

	Parms.DistanceStreamLocation = DistanceStreamLocation;
	Parms.RequiredLevelName = RequiredLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.ShouldWaterBePoisonedForStoryIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              StoryIndex                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_GameMode::ShouldWaterBePoisonedForStoryIndex(int32 StoryIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "ShouldWaterBePoisonedForStoryIndex");

	Params::AME_GameMode_ShouldWaterBePoisonedForStoryIndex_Params Parms{};

	Parms.StoryIndex = StoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.SetWaterPoisoned
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bPoisoned                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SetWaterPoisoned(bool bPoisoned)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SetWaterPoisoned");

	Params::AME_GameMode_SetWaterPoisoned_Params Parms{};

	Parms.bPoisoned = bPoisoned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.SetNoCameraFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               SetTo                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SetNoCameraFadeIn(bool SetTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SetNoCameraFadeIn");

	Params::AME_GameMode_SetNoCameraFadeIn_Params Parms{};

	Parms.SetTo = SetTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.SetLeaveOnBlackScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               SetTo                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SetLeaveOnBlackScreen(bool SetTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SetLeaveOnBlackScreen");

	Params::AME_GameMode_SetLeaveOnBlackScreen_Params Parms{};

	Parms.SetTo = SetTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.SetAutoReEnableControls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               UseAutoReEnable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SetAutoReEnableControls(bool UseAutoReEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SetAutoReEnableControls");

	Params::AME_GameMode_SetAutoReEnableControls_Params Parms{};

	Parms.UseAutoReEnable = UseAutoReEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.SetAutoFadeIn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                               UseAutoFadeIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                CameraStartingColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendDelay                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::SetAutoFadeIn(bool UseAutoFadeIn, const struct FLinearColor& CameraStartingColor, float BlendTime, float BlendDelay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "SetAutoFadeIn");

	Params::AME_GameMode_SetAutoFadeIn_Params Parms{};

	Parms.UseAutoFadeIn = UseAutoFadeIn;
	Parms.CameraStartingColor = CameraStartingColor;
	Parms.BlendTime = BlendTime;
	Parms.BlendDelay = BlendDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.RespawnPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::RespawnPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "RespawnPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.RequestTravelToLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AME_PlayerSharkCharacter*    PlayerSharkCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipLoadScreen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSetCameraRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::RequestTravelToLocation(const struct FVector& Location, const struct FRotator& Rotation, class AME_PlayerSharkCharacter* PlayerSharkCharacter, bool bSkipLoadScreen, bool bSetCameraRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "RequestTravelToLocation");

	Params::AME_GameMode_RequestTravelToLocation_Params Parms{};

	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.PlayerSharkCharacter = PlayerSharkCharacter;
	Parms.bSkipLoadScreen = bSkipLoadScreen;
	Parms.bSetCameraRotation = bSetCameraRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.RemoveLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::RemoveLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "RemoveLoadingScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.PlayCinematicPauseAllEvent
// (Final, Native, Public)
// Parameters:

void AME_GameMode::PlayCinematicPauseAllEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "PlayCinematicPauseAllEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.PauseSunPosition
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bPause                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::PauseSunPosition(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "PauseSunPosition");

	Params::AME_GameMode_PauseSunPosition_Params Parms{};

	Parms.bPause = bPause;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_GameMode.OnHuntCommanderEjected
// (Final, Native, Public)
// Parameters:
// class AController*                 EjectInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_HumanCharacter*          Pilot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::OnHuntCommanderEjected(class AController* EjectInstigator, class AME_HumanCharacter* Pilot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "OnHuntCommanderEjected");

	Params::AME_GameMode_OnHuntCommanderEjected_Params Parms{};

	Parms.EjectInstigator = EjectInstigator;
	Parms.Pilot = Pilot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.OnCinematicCameraCut
// (Final, Native, Public)
// Parameters:
// class UCameraComponent*            CameraComponent                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::OnCinematicCameraCut(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "OnCinematicCameraCut");

	Params::AME_GameMode_OnCinematicCameraCut_Params Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.OnActorSpawned
// (Final, Native, Private)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GameMode::OnActorSpawned(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "OnActorSpawned");

	Params::AME_GameMode_OnActorSpawned_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.LoadCinematic
// (Final, Native, Public)
// Parameters:

void AME_GameMode::LoadCinematic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "LoadCinematic");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.IsWaterPoisoned
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_GameMode::IsWaterPoisoned()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "IsWaterPoisoned");

	Params::AME_GameMode_IsWaterPoisoned_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.HandleStoryCompletePopupDismissed
// (Final, Native, Public)
// Parameters:

void AME_GameMode::HandleStoryCompletePopupDismissed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "HandleStoryCompletePopupDismissed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.HandleEndOfGameScoreScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::HandleEndOfGameScoreScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "HandleEndOfGameScoreScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.GetTutorialManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_TutorialManager*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_TutorialManager* AME_GameMode::GetTutorialManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetTutorialManager");

	Params::AME_GameMode_GetTutorialManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetSonarManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_SonarManager*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_SonarManager* AME_GameMode::GetSonarManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetSonarManager");

	Params::AME_GameMode_GetSonarManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetRegionStates
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FWorldRegionState>   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FWorldRegionState> AME_GameMode::GetRegionStates()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetRegionStates");

	Params::AME_GameMode_GetRegionStates_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetRegionState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              RegionIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldRegionState           State                                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_GameMode::GetRegionState(int32 RegionIndex, struct FWorldRegionState* State)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetRegionState");

	Params::AME_GameMode_GetRegionState_Params Parms{};

	Parms.RegionIndex = RegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (State != nullptr)
		*State = std::move(Parms.State);

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetRegionPopulation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              RegionIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_GameMode::GetRegionPopulation(int32 RegionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetRegionPopulation");

	Params::AME_GameMode_GetRegionPopulation_Params Parms{};

	Parms.RegionIndex = RegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetPlayerObjectiveManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_PlayerObjectiveManager*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_PlayerObjectiveManager* AME_GameMode::GetPlayerObjectiveManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetPlayerObjectiveManager");

	Params::AME_GameMode_GetPlayerObjectiveManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetDLCManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMED_DLCManager*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMED_DLCManager* AME_GameMode::GetDLCManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetDLCManager");

	Params::AME_GameMode_GetDLCManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetDialogueSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_DialogueSystem*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_DialogueSystem* AME_GameMode::GetDialogueSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetDialogueSystem");

	Params::AME_GameMode_GetDialogueSystem_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetBountyManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_BountyManager*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_BountyManager* AME_GameMode::GetBountyManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetBountyManager");

	Params::AME_GameMode_GetBountyManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetAssetLoader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_AssetLoader*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AssetLoader* AME_GameMode::GetAssetLoader()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetAssetLoader");

	Params::AME_GameMode_GetAssetLoader_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.GetAIDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_AIDirector*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AIDirector* AME_GameMode::GetAIDirector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "GetAIDirector");

	Params::AME_GameMode_GetAIDirector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameMode.EnableCinematicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::EnableCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "EnableCinematicMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.DisableCinematicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::DisableCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "DisableCinematicMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.CleanupCinematic
// (Final, Native, Public)
// Parameters:

void AME_GameMode::CleanupCinematic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "CleanupCinematic");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.CinematicLoaded
// (Final, Native, Public)
// Parameters:

void AME_GameMode::CinematicLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "CinematicLoaded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.CinematicFinishedStartPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_GameMode::CinematicFinishedStartPlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "CinematicFinishedStartPlaying");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameMode.CinematicFinished
// (Final, Native, Public)
// Parameters:

void AME_GameMode::CinematicFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameMode", "CinematicFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_GameplayAbility
// (None)

class UClass* UME_GameplayAbility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility");

	return Clss;
}


// ME_GameplayAbility Maneater.Default__ME_GameplayAbility
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility* UME_GameplayAbility::GetDefaultObj()
{
	static class UME_GameplayAbility* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility*>(UME_GameplayAbility::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_Montage
// (None)

class UClass* UME_GameplayAbility_Montage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_Montage");

	return Clss;
}


// ME_GameplayAbility_Montage Maneater.Default__ME_GameplayAbility_Montage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_Montage* UME_GameplayAbility_Montage::GetDefaultObj()
{
	static class UME_GameplayAbility_Montage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_Montage*>(UME_GameplayAbility_Montage::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameplayAbility_Montage.MontageStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_Montage::MontageStarted(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_Montage", "MontageStarted");

	Params::UME_GameplayAbility_Montage_MontageStarted_Params Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_GameplayAbility_Montage.MontageEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInterrupted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_Montage::MontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_Montage", "MontageEnded");

	Params::UME_GameplayAbility_Montage_MontageEnded_Params Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_GameplayAbility_DirectionalMontage
// (None)

class UClass* UME_GameplayAbility_DirectionalMontage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_DirectionalMontage");

	return Clss;
}


// ME_GameplayAbility_DirectionalMontage Maneater.Default__ME_GameplayAbility_DirectionalMontage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_DirectionalMontage* UME_GameplayAbility_DirectionalMontage::GetDefaultObj()
{
	static class UME_GameplayAbility_DirectionalMontage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_DirectionalMontage*>(UME_GameplayAbility_DirectionalMontage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_KillSequence
// (None)

class UClass* UME_GameplayAbility_KillSequence::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_KillSequence");

	return Clss;
}


// ME_GameplayAbility_KillSequence Maneater.Default__ME_GameplayAbility_KillSequence
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_KillSequence* UME_GameplayAbility_KillSequence::GetDefaultObj()
{
	static class UME_GameplayAbility_KillSequence* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_KillSequence*>(UME_GameplayAbility_KillSequence::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbilitySharkMontage
// (None)

class UClass* UME_GameplayAbilitySharkMontage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbilitySharkMontage");

	return Clss;
}


// ME_GameplayAbilitySharkMontage Maneater.Default__ME_GameplayAbilitySharkMontage
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbilitySharkMontage* UME_GameplayAbilitySharkMontage::GetDefaultObj()
{
	static class UME_GameplayAbilitySharkMontage* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbilitySharkMontage*>(UME_GameplayAbilitySharkMontage::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_LandLunge
// (None)

class UClass* UME_GameplayAbility_LandLunge::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_LandLunge");

	return Clss;
}


// ME_GameplayAbility_LandLunge Maneater.Default__ME_GameplayAbility_LandLunge
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_LandLunge* UME_GameplayAbility_LandLunge::GetDefaultObj()
{
	static class UME_GameplayAbility_LandLunge* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_LandLunge*>(UME_GameplayAbility_LandLunge::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_Loop
// (None)

class UClass* UME_GameplayAbility_Loop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_Loop");

	return Clss;
}


// ME_GameplayAbility_Loop Maneater.Default__ME_GameplayAbility_Loop
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_Loop* UME_GameplayAbility_Loop::GetDefaultObj()
{
	static class UME_GameplayAbility_Loop* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_Loop*>(UME_GameplayAbility_Loop::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_MontageSequence
// (None)

class UClass* UME_GameplayAbility_MontageSequence::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_MontageSequence");

	return Clss;
}


// ME_GameplayAbility_MontageSequence Maneater.Default__ME_GameplayAbility_MontageSequence
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_MontageSequence* UME_GameplayAbility_MontageSequence::GetDefaultObj()
{
	static class UME_GameplayAbility_MontageSequence* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_MontageSequence*>(UME_GameplayAbility_MontageSequence::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameplayAbility_MontageSequence.MontageStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_MontageSequence::MontageStarted(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_MontageSequence", "MontageStarted");

	Params::UME_GameplayAbility_MontageSequence_MontageStarted_Params Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_GameplayAbility_MontageSequence.MontageEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInterrupted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_MontageSequence::MontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_MontageSequence", "MontageEnded");

	Params::UME_GameplayAbility_MontageSequence_MontageEnded_Params Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_GameplayAbility_MontageSequence.GetMontageInstanceByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMontageInstance*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontageInstance* UME_GameplayAbility_MontageSequence::GetMontageInstanceByIndex(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_MontageSequence", "GetMontageInstanceByIndex");

	Params::UME_GameplayAbility_MontageSequence_GetMontageInstanceByIndex_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayAbility_MontageSequence.GetCurrentMontageInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontageInstance*            Out_MontageInstance                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameplayAbility_MontageSequence::GetCurrentMontageInstance(class UMontageInstance** Out_MontageInstance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_MontageSequence", "GetCurrentMontageInstance");

	Params::UME_GameplayAbility_MontageSequence_GetCurrentMontageInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Out_MontageInstance != nullptr)
		*Out_MontageInstance = Parms.Out_MontageInstance;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayAbility_MontageSequence.GetCurrentMontageIndex
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameplayAbility_MontageSequence::GetCurrentMontageIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_MontageSequence", "GetCurrentMontageIndex");

	Params::UME_GameplayAbility_MontageSequence_GetCurrentMontageIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_GameplayAbility_Projectiles
// (None)

class UClass* UME_GameplayAbility_Projectiles::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_Projectiles");

	return Clss;
}


// ME_GameplayAbility_Projectiles Maneater.Default__ME_GameplayAbility_Projectiles
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_Projectiles* UME_GameplayAbility_Projectiles::GetDefaultObj()
{
	static class UME_GameplayAbility_Projectiles* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_Projectiles*>(UME_GameplayAbility_Projectiles::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_SharkAirLunge
// (None)

class UClass* UME_GameplayAbility_SharkAirLunge::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_SharkAirLunge");

	return Clss;
}


// ME_GameplayAbility_SharkAirLunge Maneater.Default__ME_GameplayAbility_SharkAirLunge
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_SharkAirLunge* UME_GameplayAbility_SharkAirLunge::GetDefaultObj()
{
	static class UME_GameplayAbility_SharkAirLunge* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_SharkAirLunge*>(UME_GameplayAbility_SharkAirLunge::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_SharkEvade
// (None)

class UClass* UME_GameplayAbility_SharkEvade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_SharkEvade");

	return Clss;
}


// ME_GameplayAbility_SharkEvade Maneater.Default__ME_GameplayAbility_SharkEvade
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_SharkEvade* UME_GameplayAbility_SharkEvade::GetDefaultObj()
{
	static class UME_GameplayAbility_SharkEvade* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_SharkEvade*>(UME_GameplayAbility_SharkEvade::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_SlowWorld
// (None)

class UClass* UME_GameplayAbility_SlowWorld::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_SlowWorld");

	return Clss;
}


// ME_GameplayAbility_SlowWorld Maneater.Default__ME_GameplayAbility_SlowWorld
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_SlowWorld* UME_GameplayAbility_SlowWorld::GetDefaultObj()
{
	static class UME_GameplayAbility_SlowWorld* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_SlowWorld*>(UME_GameplayAbility_SlowWorld::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_Sonar
// (None)

class UClass* UME_GameplayAbility_Sonar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_Sonar");

	return Clss;
}


// ME_GameplayAbility_Sonar Maneater.Default__ME_GameplayAbility_Sonar
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_Sonar* UME_GameplayAbility_Sonar::GetDefaultObj()
{
	static class UME_GameplayAbility_Sonar* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_Sonar*>(UME_GameplayAbility_Sonar::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_ThrashEscape
// (None)

class UClass* UME_GameplayAbility_ThrashEscape::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_ThrashEscape");

	return Clss;
}


// ME_GameplayAbility_ThrashEscape Maneater.Default__ME_GameplayAbility_ThrashEscape
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_ThrashEscape* UME_GameplayAbility_ThrashEscape::GetDefaultObj()
{
	static class UME_GameplayAbility_ThrashEscape* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_ThrashEscape*>(UME_GameplayAbility_ThrashEscape::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbility_WildlifeDirectionalLunge
// (None)

class UClass* UME_GameplayAbility_WildlifeDirectionalLunge::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_WildlifeDirectionalLunge");

	return Clss;
}


// ME_GameplayAbility_WildlifeDirectionalLunge Maneater.Default__ME_GameplayAbility_WildlifeDirectionalLunge
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_WildlifeDirectionalLunge* UME_GameplayAbility_WildlifeDirectionalLunge::GetDefaultObj()
{
	static class UME_GameplayAbility_WildlifeDirectionalLunge* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_WildlifeDirectionalLunge*>(UME_GameplayAbility_WildlifeDirectionalLunge::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameplayAbility_WildlifeDirectionalLunge.MontageStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_WildlifeDirectionalLunge::MontageStarted(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_WildlifeDirectionalLunge", "MontageStarted");

	Params::UME_GameplayAbility_WildlifeDirectionalLunge_MontageStarted_Params Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_GameplayAbility_WildlifeDirectionalLunge.MontageEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                Montage                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInterrupted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_WildlifeDirectionalLunge::MontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_WildlifeDirectionalLunge", "MontageEnded");

	Params::UME_GameplayAbility_WildlifeDirectionalLunge_MontageEnded_Params Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_GameplayAbility_WildlifeLunge
// (None)

class UClass* UME_GameplayAbility_WildlifeLunge::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbility_WildlifeLunge");

	return Clss;
}


// ME_GameplayAbility_WildlifeLunge Maneater.Default__ME_GameplayAbility_WildlifeLunge
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayAbility_WildlifeLunge* UME_GameplayAbility_WildlifeLunge::GetDefaultObj()
{
	static class UME_GameplayAbility_WildlifeLunge* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayAbility_WildlifeLunge*>(UME_GameplayAbility_WildlifeLunge::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameplayAbility_WildlifeLunge.CheckOwnerPosition
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityActorInfo   ActorInfo                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              DropFocusRange                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayAbility_WildlifeLunge::CheckOwnerPosition(struct FGameplayAbilityActorInfo& ActorInfo, float DropFocusRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayAbility_WildlifeLunge", "CheckOwnerPosition");

	Params::UME_GameplayAbility_WildlifeLunge_CheckOwnerPosition_Params Parms{};

	Parms.ActorInfo = ActorInfo;
	Parms.DropFocusRange = DropFocusRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_GameplayAbilityMontageInterface
// (None)

class UClass* IME_GameplayAbilityMontageInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbilityMontageInterface");

	return Clss;
}


// ME_GameplayAbilityMontageInterface Maneater.Default__ME_GameplayAbilityMontageInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_GameplayAbilityMontageInterface* IME_GameplayAbilityMontageInterface::GetDefaultObj()
{
	static class IME_GameplayAbilityMontageInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_GameplayAbilityMontageInterface*>(IME_GameplayAbilityMontageInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayAbilityTargetActor_Radius
// (Actor)

class UClass* AME_GameplayAbilityTargetActor_Radius::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayAbilityTargetActor_Radius");

	return Clss;
}


// ME_GameplayAbilityTargetActor_Radius Maneater.Default__ME_GameplayAbilityTargetActor_Radius
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_GameplayAbilityTargetActor_Radius* AME_GameplayAbilityTargetActor_Radius::GetDefaultObj()
{
	static class AME_GameplayAbilityTargetActor_Radius* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_GameplayAbilityTargetActor_Radius*>(AME_GameplayAbilityTargetActor_Radius::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplaySettings
// (None)

class UClass* UME_GameplaySettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplaySettings");

	return Clss;
}


// ME_GameplaySettings Maneater.Default__ME_GameplaySettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplaySettings* UME_GameplaySettings::GetDefaultObj()
{
	static class UME_GameplaySettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplaySettings*>(UME_GameplaySettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameplayStatics
// (None)

class UClass* UME_GameplayStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameplayStatics");

	return Clss;
}


// ME_GameplayStatics Maneater.Default__ME_GameplayStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameplayStatics* UME_GameplayStatics::GetDefaultObj()
{
	static class UME_GameplayStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameplayStatics*>(UME_GameplayStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameplayStatics.ToggleWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableRendering                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::ToggleWorldRendering(class UObject* Context, bool bEnableRendering)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ToggleWorldRendering");

	Params::UME_GameplayStatics_ToggleWorldRendering_Params Parms{};

	Parms.Context = Context;
	Parms.bEnableRendering = bEnableRendering;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.TestPreyAttachment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      PreyActor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::TestPreyAttachment(class AME_AnimalCharacter* GrabbingAnimal, class AActor* PreyActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "TestPreyAttachment");

	Params::UME_GameplayStatics_TestPreyAttachment_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;
	Parms.PreyActor = PreyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.SpawnAIAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      SpawnClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SpawnLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    SpawnRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bPersistent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESpawnActorCollisionHandlingMethodPawnCollision                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_AIController*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AIController* UME_GameplayStatics::SpawnAIAtLocation(class AActor* WorldContextActor, class UClass* SpawnClass, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, bool bPersistent, enum class ESpawnActorCollisionHandlingMethod PawnCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SpawnAIAtLocation");

	Params::UME_GameplayStatics_SpawnAIAtLocation_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;
	Parms.SpawnClass = SpawnClass;
	Parms.SpawnLocation = SpawnLocation;
	Parms.SpawnRotation = SpawnRotation;
	Parms.bPersistent = bPersistent;
	Parms.PawnCollision = PawnCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.SpawnAIAtActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      SpawnClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseActorRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESpawnActorCollisionHandlingMethodPawnCollision                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_AIController*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AIController* UME_GameplayStatics::SpawnAIAtActor(class AActor* WorldContextActor, class UClass* SpawnClass, class AActor* Actor, bool bUseActorRotation, bool bPersistent, enum class ESpawnActorCollisionHandlingMethod PawnCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SpawnAIAtActor");

	Params::UME_GameplayStatics_SpawnAIAtActor_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;
	Parms.SpawnClass = SpawnClass;
	Parms.Actor = Actor;
	Parms.bUseActorRotation = bUseActorRotation;
	Parms.bPersistent = bPersistent;
	Parms.PawnCollision = PawnCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.ShowTutorialPopup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        TutorialLabel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::ShowTutorialPopup(class FName TutorialLabel, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ShowTutorialPopup");

	Params::UME_GameplayStatics_ShowTutorialPopup_Params Parms{};

	Parms.TutorialLabel = TutorialLabel;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.SetTimeOfDaySpeedScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                              NewScale                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ContextActor                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetTimeOfDaySpeedScale(float NewScale, class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetTimeOfDaySpeedScale");

	Params::UME_GameplayStatics_SetTimeOfDaySpeedScale_Params Parms{};

	Parms.NewScale = NewScale;
	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.SetTimeOfDay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                              TimeOfDay                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ContextActor                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetTimeOfDay(float TimeOfDay, class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetTimeOfDay");

	Params::UME_GameplayStatics_SetTimeOfDay_Params Parms{};

	Parms.TimeOfDay = TimeOfDay;
	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.SetLevelStreamingVolumesEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ALevelStreamingVolume*>Volumes                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetLevelStreamingVolumesEnabled(TArray<class ALevelStreamingVolume*>& Volumes)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetLevelStreamingVolumesEnabled");

	Params::UME_GameplayStatics_SetLevelStreamingVolumesEnabled_Params Parms{};

	Parms.Volumes = Volumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.SetLevelStreamingVolumesDisabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ALevelStreamingVolume*>Volumes                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUnloadLevels                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetLevelStreamingVolumesDisabled(TArray<class ALevelStreamingVolume*>& Volumes, bool bUnloadLevels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetLevelStreamingVolumesDisabled");

	Params::UME_GameplayStatics_SetLevelStreamingVolumesDisabled_Params Parms{};

	Parms.Volumes = Volumes;
	Parms.bUnloadLevels = bUnloadLevels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.SetKeyForAxis
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        ActionName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                        Binding                                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AxisScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bGamepad                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Rebuild                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetKeyForAxis(class FName ActionName, const struct FKey& Binding, float AxisScale, bool bGamepad, class UObject* Context, bool Rebuild)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetKeyForAxis");

	Params::UME_GameplayStatics_SetKeyForAxis_Params Parms{};

	Parms.ActionName = ActionName;
	Parms.Binding = Binding;
	Parms.AxisScale = AxisScale;
	Parms.bGamepad = bGamepad;
	Parms.Context = Context;
	Parms.Rebuild = Rebuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.SetKeyForAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        ActionName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                        Binding                                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              BindIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Rebuild                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::SetKeyForAction(class FName ActionName, const struct FKey& Binding, int32 BindIndex, class UObject* Context, bool Rebuild)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "SetKeyForAction");

	Params::UME_GameplayStatics_SetKeyForAction_Params Parms{};

	Parms.ActionName = ActionName;
	Parms.Binding = Binding;
	Parms.BindIndex = BindIndex;
	Parms.Context = Context;
	Parms.Rebuild = Rebuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.ResolveAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      Asset                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UME_GameplayStatics::ResolveAsset(TSoftObjectPtr<class UObject>& Asset, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ResolveAsset");

	Params::UME_GameplayStatics_ResolveAsset_Params Parms{};

	Parms.Asset = Asset;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.ReadPixelsFromRenderTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*      RT                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FColor>              OutPixelBuffer                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::ReadPixelsFromRenderTarget(class UTextureRenderTarget2D* RT, TArray<struct FColor>* OutPixelBuffer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ReadPixelsFromRenderTarget");

	Params::UME_GameplayStatics_ReadPixelsFromRenderTarget_Params Parms{};

	Parms.RT = RT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPixelBuffer != nullptr)
		*OutPixelBuffer = std::move(Parms.OutPixelBuffer);

}


// Function Maneater.ME_GameplayStatics.ProjectPointToSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Context                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ProjectionPoint                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::ProjectPointToSurface(class UObject* Context, struct FVector* ProjectionPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ProjectPointToSurface");

	Params::UME_GameplayStatics_ProjectPointToSurface_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ProjectionPoint != nullptr)
		*ProjectionPoint = std::move(Parms.ProjectionPoint);

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.ProcessImpactResponse
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*           InstigatorPM                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             Instigator                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         Receiver                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAttachToReceiver                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPoint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPhysicalSurface        ReceivingSurfaceOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ForceWorldRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactResponseInstance     ReturnValue                                                      (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FImpactResponseInstance UME_GameplayStatics::ProcessImpactResponse(class UPhysicalMaterial* InstigatorPM, class USceneComponent* Instigator, class UPrimitiveComponent* Receiver, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bAttachToReceiver, class FName AttachPoint, enum class EPhysicalSurface ReceivingSurfaceOverride, bool ForceWorldRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ProcessImpactResponse");

	Params::UME_GameplayStatics_ProcessImpactResponse_Params Parms{};

	Parms.InstigatorPM = InstigatorPM;
	Parms.Instigator = Instigator;
	Parms.Receiver = Receiver;
	Parms.HitLocation = HitLocation;
	Parms.HitNormal = HitNormal;
	Parms.bAttachToReceiver = bAttachToReceiver;
	Parms.AttachPoint = AttachPoint;
	Parms.ReceivingSurfaceOverride = ReceivingSurfaceOverride;
	Parms.ForceWorldRotation = ForceWorldRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.KeyIsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        InKey                                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::KeyIsValid(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "KeyIsValid");

	Params::UME_GameplayStatics_KeyIsValid_Params Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsWaypointed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsWaypointed(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsWaypointed");

	Params::UME_GameplayStatics_IsWaypointed_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsWatchingCinematic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsWatchingCinematic(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsWatchingCinematic");

	Params::UME_GameplayStatics_IsWatchingCinematic_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayingPrologue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayingPrologue(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayingPrologue");

	Params::UME_GameplayStatics_IsPlayingPrologue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayerOnLand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayerOnLand(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayerOnLand");

	Params::UME_GameplayStatics_IsPlayerOnLand_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayerLookingAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TestLocation                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TestAngle                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayerLookingAtLocation(class UObject* WorldContextObject, const struct FVector& TestLocation, float TestAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayerLookingAtLocation");

	Params::UME_GameplayStatics_IsPlayerLookingAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TestLocation = TestLocation;
	Parms.TestAngle = TestAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayerInRangeOfLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TestLocation                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RangeVal                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayerInRangeOfLocation(class UObject* WorldContextObject, const struct FVector& TestLocation, float RangeVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayerInRangeOfLocation");

	Params::UME_GameplayStatics_IsPlayerInRangeOfLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TestLocation = TestLocation;
	Parms.RangeVal = RangeVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayerInGrotto
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayerInGrotto(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayerInGrotto");

	Params::UME_GameplayStatics_IsPlayerInGrotto_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlayerCameraUnderwater
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlayerCameraUnderwater(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlayerCameraUnderwater");

	Params::UME_GameplayStatics_IsPlayerCameraUnderwater_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlatformWinGDK
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlatformWinGDK()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlatformWinGDK");

	Params::UME_GameplayStatics_IsPlatformWinGDK_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsPlatformWindows
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsPlatformWindows()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsPlatformWindows");

	Params::UME_GameplayStatics_IsPlatformWindows_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsInWorldMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsInWorldMap(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsInWorldMap");

	Params::UME_GameplayStatics_IsInWorldMap_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IsInBaseMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameplayStatics::IsInBaseMap(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IsInBaseMap");

	Params::UME_GameplayStatics_IsInBaseMap_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.IntPointToFVector2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntPoint>           Input                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>           Output                                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::IntPointToFVector2D(const TArray<struct FIntPoint>& Input, TArray<struct FVector2D>* Output)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "IntPointToFVector2D");

	Params::UME_GameplayStatics_IntPointToFVector2D_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Output != nullptr)
		*Output = std::move(Parms.Output);

}


// Function Maneater.ME_GameplayStatics.GetWorldUnitScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetWorldUnitScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldUnitScale");

	Params::UME_GameplayStatics_GetWorldUnitScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_WorldSettings*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_WorldSettings* UME_GameplayStatics::GetWorldSettings(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldSettings");

	Params::UME_GameplayStatics_GetWorldSettings_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWorldRegionStates
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWorldRegionState>   RegionStates                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetWorldRegionStates(class UObject* WorldContextObject, TArray<struct FWorldRegionState>* RegionStates)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldRegionStates");

	Params::UME_GameplayStatics_GetWorldRegionStates_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (RegionStates != nullptr)
		*RegionStates = std::move(Parms.RegionStates);

}


// Function Maneater.ME_GameplayStatics.GetWorldRegionStateFromObjective
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerObjective*         Obj                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldRegionState           RegionState                                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetWorldRegionStateFromObjective(class UObject* WorldContextObject, class UME_PlayerObjective* Obj, struct FWorldRegionState* RegionState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldRegionStateFromObjective");

	Params::UME_GameplayStatics_GetWorldRegionStateFromObjective_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (RegionState != nullptr)
		*RegionState = std::move(Parms.RegionState);

}


// Function Maneater.ME_GameplayStatics.GetWorldRegionState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InRegionIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldRegionState           RegionState                                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetWorldRegionState(class UObject* WorldContextObject, int32 InRegionIndex, struct FWorldRegionState* RegionState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldRegionState");

	Params::UME_GameplayStatics_GetWorldRegionState_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InRegionIndex = InRegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (RegionState != nullptr)
		*RegionState = std::move(Parms.RegionState);

}


// Function Maneater.ME_GameplayStatics.GetWorldRegionData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_WorldRegionData*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_WorldRegionData* UME_GameplayStatics::GetWorldRegionData(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldRegionData");

	Params::UME_GameplayStatics_GetWorldRegionData_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWorldLocationAtUVCoord
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      Bounds                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   UVCoord                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_GameplayStatics::GetWorldLocationAtUVCoord(class AActor* Bounds, const struct FVector2D& UVCoord)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldLocationAtUVCoord");

	Params::UME_GameplayStatics_GetWorldLocationAtUVCoord_Params Parms{};

	Parms.Bounds = Bounds;
	Parms.UVCoord = UVCoord;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWorldBoundsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContext                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_GameplayStatics::GetWorldBoundsActor(class AActor* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWorldBoundsActor");

	Params::UME_GameplayStatics_GetWorldBoundsActor_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWaterDepthAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InLocation                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      WorldContextActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetWaterDepthAtLocation(struct FVector& InLocation, class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWaterDepthAtLocation");

	Params::UME_GameplayStatics_GetWaterDepthAtLocation_Params Parms{};

	Parms.InLocation = InLocation;
	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetWaterDepth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetWaterDepth(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetWaterDepth");

	Params::UME_GameplayStatics_GetWaterDepth_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetUVsAtWorldLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      Bounds                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    Texture                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UME_GameplayStatics::GetUVsAtWorldLocation(class AActor* Bounds, const struct FVector& Location, class UTexture* Texture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetUVsAtWorldLocation");

	Params::UME_GameplayStatics_GetUVsAtWorldLocation_Params Parms{};

	Parms.Bounds = Bounds;
	Parms.Location = Location;
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetTutorialManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_TutorialManager*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_TutorialManager* UME_GameplayStatics::GetTutorialManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetTutorialManager");

	Params::UME_GameplayStatics_GetTutorialManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetTimeofDaySpeedScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ContextActor                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetTimeofDaySpeedScale(class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetTimeofDaySpeedScale");

	Params::UME_GameplayStatics_GetTimeofDaySpeedScale_Params Parms{};

	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetTimeofDayNoContext
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ContextActor                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetTimeofDayNoContext(class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetTimeofDayNoContext");

	Params::UME_GameplayStatics_GetTimeofDayNoContext_Params Parms{};

	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetTimeofDay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ContextActor                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetTimeofDay(class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetTimeofDay");

	Params::UME_GameplayStatics_GetTimeofDay_Params Parms{};

	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetSpawnPool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SpawnPool*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SpawnPool* UME_GameplayStatics::GetSpawnPool(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetSpawnPool");

	Params::UME_GameplayStatics_GetSpawnPool_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetSpawnManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_SpawnManager*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_SpawnManager* UME_GameplayStatics::GetSpawnManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetSpawnManager");

	Params::UME_GameplayStatics_GetSpawnManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetSonarManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_SonarManager*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_SonarManager* UME_GameplayStatics::GetSonarManager(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetSonarManager");

	Params::UME_GameplayStatics_GetSonarManager_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetSilhouetteColor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      SilhouetteActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EOutlineColor           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EOutlineColor UME_GameplayStatics::GetSilhouetteColor(class AActor* SilhouetteActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetSilhouetteColor");

	Params::UME_GameplayStatics_GetSilhouetteColor_Params Parms{};

	Parms.SilhouetteActor = SilhouetteActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetRegionName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EWorldRegion            Region                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIgnoreLocalization                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_GameplayStatics::GetRegionName(enum class EWorldRegion Region, bool bIgnoreLocalization)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetRegionName");

	Params::UME_GameplayStatics_GetRegionName_Params Parms{};

	Parms.Region = Region;
	Parms.bIgnoreLocalization = bIgnoreLocalization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetRegionIndexforVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_WorldRegionVolume*       RegionVolume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameplayStatics::GetRegionIndexforVolume(class AME_WorldRegionVolume* RegionVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetRegionIndexforVolume");

	Params::UME_GameplayStatics_GetRegionIndexforVolume_Params Parms{};

	Parms.RegionVolume = RegionVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetRegionFromName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        RegionName                                                       (Parm, NativeAccessSpecifierPublic)
// enum class EWorldRegion            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWorldRegion UME_GameplayStatics::GetRegionFromName(class FText RegionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetRegionFromName");

	Params::UME_GameplayStatics_GetRegionFromName_Params Parms{};

	Parms.RegionName = RegionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetPMFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             InComponent                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UME_GameplayStatics::GetPMFromComponent(class USceneComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetPMFromComponent");

	Params::UME_GameplayStatics_GetPMFromComponent_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetPlayerSharkState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_PlayerSharkState*        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_PlayerSharkState* UME_GameplayStatics::GetPlayerSharkState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetPlayerSharkState");

	Params::UME_GameplayStatics_GetPlayerSharkState_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetPlayerSharkPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_PlayerSharkCharacter*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_PlayerSharkCharacter* UME_GameplayStatics::GetPlayerSharkPawn(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetPlayerSharkPawn");

	Params::UME_GameplayStatics_GetPlayerSharkPawn_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetPlayerBounty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAsDollars                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetPlayerBounty(class UObject* WorldContextObject, bool bAsDollars)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetPlayerBounty");

	Params::UME_GameplayStatics_GetPlayerBounty_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bAsDollars = bAsDollars;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetPersistentLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* UME_GameplayStatics::GetPersistentLevel(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetPersistentLevel");

	Params::UME_GameplayStatics_GetPersistentLevel_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetOceanPhysicsVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_OceanPhysicsVolume*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_OceanPhysicsVolume* UME_GameplayStatics::GetOceanPhysicsVolume(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetOceanPhysicsVolume");

	Params::UME_GameplayStatics_GetOceanPhysicsVolume_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetOceanManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Context                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_OceanManager*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_OceanManager* UME_GameplayStatics::GetOceanManager(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetOceanManager");

	Params::UME_GameplayStatics_GetOceanManager_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetObjectiveSpawnManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_ObjectiveSpawnManager*   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_ObjectiveSpawnManager* UME_GameplayStatics::GetObjectiveSpawnManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetObjectiveSpawnManager");

	Params::UME_GameplayStatics_GetObjectiveSpawnManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetObjectiveManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_PlayerObjectiveManager*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_PlayerObjectiveManager* UME_GameplayStatics::GetObjectiveManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetObjectiveManager");

	Params::UME_GameplayStatics_GetObjectiveManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetManeaterGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_GameMode*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_GameMode* UME_GameplayStatics::GetManeaterGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetManeaterGameMode");

	Params::UME_GameplayStatics_GetManeaterGameMode_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetLocalViewPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ContextActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_GameplayStatics::GetLocalViewPosition(class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetLocalViewPosition");

	Params::UME_GameplayStatics_GetLocalViewPosition_Params Parms{};

	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetLocalizedGrowthName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EPlayerGrowthStage      GrowthStage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_GameplayStatics::GetLocalizedGrowthName(enum class EPlayerGrowthStage GrowthStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetLocalizedGrowthName");

	Params::UME_GameplayStatics_GetLocalizedGrowthName_Params Parms{};

	Parms.GrowthStage = GrowthStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetLastRenderTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*         InComponent                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetLastRenderTime(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetLastRenderTime");

	Params::UME_GameplayStatics_GetLastRenderTime_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetLandscapeResolution
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscape*                  Landscape                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UME_GameplayStatics::GetLandscapeResolution(class ALandscape* Landscape)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetLandscapeResolution");

	Params::UME_GameplayStatics_GetLandscapeResolution_Params Parms{};

	Parms.Landscape = Landscape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetLandscape
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandscape*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALandscape* UME_GameplayStatics::GetLandscape(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetLandscape");

	Params::UME_GameplayStatics_GetLandscape_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetKeysForAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ActionName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AxisScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                Bindings                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetKeysForAction(class FName ActionName, float AxisScale, TArray<struct FKey>* Bindings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetKeysForAction");

	Params::UME_GameplayStatics_GetKeysForAction_Params Parms{};

	Parms.ActionName = ActionName;
	Parms.AxisScale = AxisScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Bindings != nullptr)
		*Bindings = std::move(Parms.Bindings);

}


// Function Maneater.ME_GameplayStatics.GetKeyFriendlyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        InKey                                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_GameplayStatics::GetKeyFriendlyName(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetKeyFriendlyName");

	Params::UME_GameplayStatics_GetKeyFriendlyName_Params Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetDLCManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMED_DLCManager*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMED_DLCManager* UME_GameplayStatics::GetDLCManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetDLCManager");

	Params::UME_GameplayStatics_GetDLCManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetDialogueSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_DialogueSystem*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_DialogueSystem* UME_GameplayStatics::GetDialogueSystem(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetDialogueSystem");

	Params::UME_GameplayStatics_GetDialogueSystem_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     InObject                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UME_GameplayStatics::GetDefaultObject(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetDefaultObject");

	Params::UME_GameplayStatics_GetDefaultObject_Params Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetCurrentMapName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Context                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_GameplayStatics::GetCurrentMapName(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetCurrentMapName");

	Params::UME_GameplayStatics_GetCurrentMapName_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetCurrentBossFight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_BossBattleInfo*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_BossBattleInfo* UME_GameplayStatics::GetCurrentBossFight(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetCurrentBossFight");

	Params::UME_GameplayStatics_GetCurrentBossFight_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      InClass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UME_GameplayStatics::GetClassDefaultObject(class UClass* InClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetClassDefaultObject");

	Params::UME_GameplayStatics_GetClassDefaultObject_Params Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetCameraWaterDepth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameplayStatics::GetCameraWaterDepth(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetCameraWaterDepth");

	Params::UME_GameplayStatics_GetCameraWaterDepth_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetBountyManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_BountyManager*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_BountyManager* UME_GameplayStatics::GetBountyManager(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetBountyManager");

	Params::UME_GameplayStatics_GetBountyManager_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetAssetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      Asset                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludePath                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_GameplayStatics::GetAssetName(TSoftObjectPtr<class UObject>& Asset, bool bIncludePath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAssetName");

	Params::UME_GameplayStatics_GetAssetName_Params Parms{};

	Parms.Asset = Asset;
	Parms.bIncludePath = bIncludePath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetAssetMapName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      Asset                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_GameplayStatics::GetAssetMapName(TSoftObjectPtr<class UObject>& Asset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAssetMapName");

	Params::UME_GameplayStatics_GetAssetMapName_Params Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetAssetLoader
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_AssetLoader*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AssetLoader* UME_GameplayStatics::GetAssetLoader(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAssetLoader");

	Params::UME_GameplayStatics_GetAssetLoader_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetAllThrashablePawns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APawn*>               ThrashableList                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllThrashablePawns(class AActor* WorldContextActor, TArray<class APawn*>* ThrashableList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllThrashablePawns");

	Params::UME_GameplayStatics_GetAllThrashablePawns_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ThrashableList != nullptr)
		*ThrashableList = std::move(Parms.ThrashableList);

}


// Function Maneater.ME_GameplayStatics.GetAllThrashableActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ThrashableList                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllThrashableActors(class UObject* WorldContext, TArray<class AActor*>* ThrashableList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllThrashableActors");

	Params::UME_GameplayStatics_GetAllThrashableActors_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ThrashableList != nullptr)
		*ThrashableList = std::move(Parms.ThrashableList);

}


// Function Maneater.ME_GameplayStatics.GetAllPingableActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              PingableList                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllPingableActors(class UObject* WorldContext, TArray<class AActor*>* PingableList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllPingableActors");

	Params::UME_GameplayStatics_GetAllPingableActors_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PingableList != nullptr)
		*PingableList = std::move(Parms.PingableList);

}


// Function Maneater.ME_GameplayStatics.GetAllLivingHumans
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AME_HumanCharacter*>  HumanList                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllLivingHumans(class AActor* WorldContextObject, TArray<class AME_HumanCharacter*>* HumanList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllLivingHumans");

	Params::UME_GameplayStatics_GetAllLivingHumans_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HumanList != nullptr)
		*HumanList = std::move(Parms.HumanList);

}


// Function Maneater.ME_GameplayStatics.GetAllLivingCharacters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AME_Character*>       CharacterList                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllLivingCharacters(class AActor* WorldContextActor, TArray<class AME_Character*>* CharacterList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllLivingCharacters");

	Params::UME_GameplayStatics_GetAllLivingCharacters_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CharacterList != nullptr)
		*CharacterList = std::move(Parms.CharacterList);

}


// Function Maneater.ME_GameplayStatics.GetAllLivingAnimals
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AME_AnimalCharacter*> AnimalList                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllLivingAnimals(class AActor* WorldContextActor, TArray<class AME_AnimalCharacter*>* AnimalList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllLivingAnimals");

	Params::UME_GameplayStatics_GetAllLivingAnimals_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (AnimalList != nullptr)
		*AnimalList = std::move(Parms.AnimalList);

}


// Function Maneater.ME_GameplayStatics.GetAllChildrenOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>         InParent                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                IgnoredClasses                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UObject>>ChildList                                                        (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllChildrenOfClass(TSubclassOf<class UObject> InParent, const TArray<class FName>& IgnoredClasses, TArray<TSoftClassPtr<class UObject>>* ChildList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllChildrenOfClass");

	Params::UME_GameplayStatics_GetAllChildrenOfClass_Params Parms{};

	Parms.InParent = InParent;
	Parms.IgnoredClasses = IgnoredClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ChildList != nullptr)
		*ChildList = std::move(Parms.ChildList);

}


// Function Maneater.ME_GameplayStatics.GetAllAxisInputs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FInputAxisKeyMapping>AxisInputs                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllAxisInputs(TArray<struct FInputAxisKeyMapping>* AxisInputs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllAxisInputs");

	Params::UME_GameplayStatics_GetAllAxisInputs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (AxisInputs != nullptr)
		*AxisInputs = std::move(Parms.AxisInputs);

}


// Function Maneater.ME_GameplayStatics.GetAllAIControllers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AME_AIController*>    ControllerList                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSortByDistance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllAIControllers(class AActor* WorldContextActor, TArray<class AME_AIController*>* ControllerList, bool bSortByDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllAIControllers");

	Params::UME_GameplayStatics_GetAllAIControllers_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;
	Parms.bSortByDistance = bSortByDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ControllerList != nullptr)
		*ControllerList = std::move(Parms.ControllerList);

}


// Function Maneater.ME_GameplayStatics.GetAllActionInputs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FInputActionKeyMapping>ActionInputs                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetAllActionInputs(TArray<struct FInputActionKeyMapping>* ActionInputs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAllActionInputs");

	Params::UME_GameplayStatics_GetAllActionInputs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ActionInputs != nullptr)
		*ActionInputs = std::move(Parms.ActionInputs);

}


// Function Maneater.ME_GameplayStatics.GetAIDirector
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContext                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_AIDirector*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AIDirector* UME_GameplayStatics::GetAIDirector(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetAIDirector");

	Params::UME_GameplayStatics_GetAIDirector_Params Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.GetActionsForKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                        InKey                                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputAxisKeyMapping>OutAxisMappings                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>OutActionMappings                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::GetActionsForKey(const struct FKey& InKey, TArray<struct FInputAxisKeyMapping>* OutAxisMappings, TArray<struct FInputActionKeyMapping>* OutActionMappings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "GetActionsForKey");

	Params::UME_GameplayStatics_GetActionsForKey_Params Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutAxisMappings != nullptr)
		*OutAxisMappings = std::move(Parms.OutAxisMappings);

	if (OutActionMappings != nullptr)
		*OutActionMappings = std::move(Parms.OutActionMappings);

}


// Function Maneater.ME_GameplayStatics.FVector2DToIntPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector2D>           Input                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntPoint>           Output                                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::FVector2DToIntPoint(const TArray<struct FVector2D>& Input, TArray<struct FIntPoint>* Output)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "FVector2DToIntPoint");

	Params::UME_GameplayStatics_FVector2DToIntPoint_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Output != nullptr)
		*Output = std::move(Parms.Output);

}


// Function Maneater.ME_GameplayStatics.FormatGameplayText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        TextToFormat                                                     (Parm, NativeAccessSpecifierPublic)
// TArray<struct FRichTextActionMapping>ActionBinds                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_GameplayStatics::FormatGameplayText(class FText TextToFormat, const TArray<struct FRichTextActionMapping>& ActionBinds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "FormatGameplayText");

	Params::UME_GameplayStatics_FormatGameplayText_Params Parms{};

	Parms.TextToFormat = TextToFormat;
	Parms.ActionBinds = ActionBinds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.ForceDespawnAllProxBombs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::ForceDespawnAllProxBombs(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ForceDespawnAllProxBombs");

	Params::UME_GameplayStatics_ForceDespawnAllProxBombs_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.ForceDespawnAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::ForceDespawnAI(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "ForceDespawnAI");

	Params::UME_GameplayStatics_ForceDespawnAI_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.FindSlopeRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     FloorNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    CurrentRotation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UME_GameplayStatics::FindSlopeRotation(const struct FVector& FloorNormal, const struct FRotator& CurrentRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "FindSlopeRotation");

	Params::UME_GameplayStatics_FindSlopeRotation_Params Parms{};

	Parms.FloorNormal = FloorNormal;
	Parms.CurrentRotation = CurrentRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.FFloatIntervalToFVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFloatIntervalBP            Input                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UME_GameplayStatics::FFloatIntervalToFVector2D(const struct FFloatIntervalBP& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "FFloatIntervalToFVector2D");

	Params::UME_GameplayStatics_FFloatIntervalToFVector2D_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.DrawArrowOnActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Direction                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                      Color                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ArrowLength                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::DrawArrowOnActor(class AActor* Actor, struct FRotator& Direction, const struct FColor& Color, float ArrowLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "DrawArrowOnActor");

	Params::UME_GameplayStatics_DrawArrowOnActor_Params Parms{};

	Parms.Actor = Actor;
	Parms.Direction = Direction;
	Parms.Color = Color;
	Parms.ArrowLength = ArrowLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameplayStatics.CreateRenderTarget2DNoHDR
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UME_GameplayStatics::CreateRenderTarget2DNoHDR(class UObject* WorldContextObject, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "CreateRenderTarget2DNoHDR");

	Params::UME_GameplayStatics_CreateRenderTarget2DNoHDR_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameplayStatics.AttachCinematicEvolutionMeshes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASkeletalMeshActor*          SkeletalMeshActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameplayStatics::AttachCinematicEvolutionMeshes(class ASkeletalMeshActor* SkeletalMeshActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameplayStatics", "AttachCinematicEvolutionMeshes");

	Params::UME_GameplayStatics_AttachCinematicEvolutionMeshes_Params Parms{};

	Parms.SkeletalMeshActor = SkeletalMeshActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEGameSingleton
// (None)

class UClass* UMEGameSingleton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEGameSingleton");

	return Clss;
}


// MEGameSingleton Maneater.Default__MEGameSingleton
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEGameSingleton* UMEGameSingleton::GetDefaultObj()
{
	static class UMEGameSingleton* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEGameSingleton*>(UMEGameSingleton::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GameUserSettings
// (None)

class UClass* UME_GameUserSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GameUserSettings");

	return Clss;
}


// ME_GameUserSettings Maneater.Default__ME_GameUserSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GameUserSettings* UME_GameUserSettings::GetDefaultObj()
{
	static class UME_GameUserSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GameUserSettings*>(UME_GameUserSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GameUserSettings.SetVSyncType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                      OwnerWorld                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetVSyncType(class UWorld* OwnerWorld, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetVSyncType");

	Params::UME_GameUserSettings_SetVSyncType_Params Parms{};

	Parms.OwnerWorld = OwnerWorld;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetShowFrameRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewShowFrameRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetShowFrameRate(bool bNewShowFrameRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetShowFrameRate");

	Params::UME_GameUserSettings_SetShowFrameRate_Params Parms{};

	Parms.bNewShowFrameRate = bNewShowFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetShadowsOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                      OwnerWorld                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetShadowsOn(class UWorld* OwnerWorld, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetShadowsOn");

	Params::UME_GameUserSettings_SetShadowsOn_Params Parms{};

	Parms.OwnerWorld = OwnerWorld;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetOceanQualityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              QualityLevel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetOceanQualityLevel(int32 QualityLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetOceanQualityLevel");

	Params::UME_GameUserSettings_SetOceanQualityLevel_Params Parms{};

	Parms.QualityLevel = QualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetLastActiveUserId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      UserId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetLastActiveUserId(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetLastActiveUserId");

	Params::UME_GameUserSettings_SetLastActiveUserId_Params Parms{};

	Parms.UserId = UserId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetGlobalQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetGlobalQuality(int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetGlobalQuality");

	Params::UME_GameUserSettings_SetGlobalQuality_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetDefaultFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InFOV                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetDefaultFOV(float InFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetDefaultFOV");

	Params::UME_GameUserSettings_SetDefaultFOV_Params Parms{};

	Parms.InFOV = InFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                      OwnerWorld                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetBrightness(class UWorld* OwnerWorld, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetBrightness");

	Params::UME_GameUserSettings_SetBrightness_Params Parms{};

	Parms.OwnerWorld = OwnerWorld;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.SetAntiAliasingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                      OwnerWorld                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_GameUserSettings::SetAntiAliasingType(class UWorld* OwnerWorld, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "SetAntiAliasingType");

	Params::UME_GameUserSettings_SetAntiAliasingType_Params Parms{};

	Parms.OwnerWorld = OwnerWorld;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_GameUserSettings.GetVSyncType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameUserSettings::GetVSyncType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetVSyncType");

	Params::UME_GameUserSettings_GetVSyncType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetShowFrameRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameUserSettings::GetShowFrameRate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetShowFrameRate");

	Params::UME_GameUserSettings_GetShowFrameRate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetShadowsOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_GameUserSettings::GetShadowsOn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetShadowsOn");

	Params::UME_GameUserSettings_GetShadowsOn_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetOceanQualityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameUserSettings::GetOceanQualityLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetOceanQualityLevel");

	Params::UME_GameUserSettings_GetOceanQualityLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetManeaterUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UME_GameUserSettings*        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_GameUserSettings* UME_GameUserSettings::GetManeaterUserSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetManeaterUserSettings");

	Params::UME_GameUserSettings_GetManeaterUserSettings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetLastActiveUserId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_GameUserSettings::GetLastActiveUserId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetLastActiveUserId");

	Params::UME_GameUserSettings_GetLastActiveUserId_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetGlobalQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameUserSettings::GetGlobalQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetGlobalQuality");

	Params::UME_GameUserSettings_GetGlobalQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetDefaultFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_GameUserSettings::GetDefaultFOV()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetDefaultFOV");

	Params::UME_GameUserSettings_GetDefaultFOV_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameUserSettings::GetBrightness()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetBrightness");

	Params::UME_GameUserSettings_GetBrightness_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_GameUserSettings.GetAntiAliasingType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_GameUserSettings::GetAntiAliasingType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GameUserSettings", "GetAntiAliasingType");

	Params::UME_GameUserSettings_GetAntiAliasingType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_GateLever
// (Actor)

class UClass* AME_GateLever::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GateLever");

	return Clss;
}


// ME_GateLever Maneater.Default__ME_GateLever
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_GateLever* AME_GateLever::GetDefaultObj()
{
	static class AME_GateLever* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_GateLever*>(AME_GateLever::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GoreChunk
// (Actor)

class UClass* AME_GoreChunk::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GoreChunk");

	return Clss;
}


// ME_GoreChunk Maneater.Default__ME_GoreChunk
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_GoreChunk* AME_GoreChunk::GetDefaultObj()
{
	static class AME_GoreChunk* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_GoreChunk*>(AME_GoreChunk::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_GoreChunk.HandleWaterSurfaceTransition
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               bIsAboveWater                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_GoreChunk::HandleWaterSurfaceTransition(bool bIsAboveWater)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_GoreChunk", "HandleWaterSurfaceTransition");

	Params::AME_GoreChunk_HandleWaterSurfaceTransition_Params Parms{};

	Parms.bIsAboveWater = bIsAboveWater;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_GraphicsSettings
// (None)

class UClass* UME_GraphicsSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GraphicsSettings");

	return Clss;
}


// ME_GraphicsSettings Maneater.Default__ME_GraphicsSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GraphicsSettings* UME_GraphicsSettings::GetDefaultObj()
{
	static class UME_GraphicsSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GraphicsSettings*>(UME_GraphicsSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_GraphicsSettingsContentLink
// (None)

class UClass* UME_GraphicsSettingsContentLink::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_GraphicsSettingsContentLink");

	return Clss;
}


// ME_GraphicsSettingsContentLink Maneater.Default__ME_GraphicsSettingsContentLink
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_GraphicsSettingsContentLink* UME_GraphicsSettingsContentLink::GetDefaultObj()
{
	static class UME_GraphicsSettingsContentLink* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_GraphicsSettingsContentLink*>(UME_GraphicsSettingsContentLink::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_Grotto
// (Actor)

class UClass* AME_Grotto::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_Grotto");

	return Clss;
}


// ME_Grotto Maneater.Default__ME_Grotto
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_Grotto* AME_Grotto::GetDefaultObj()
{
	static class AME_Grotto* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_Grotto*>(AME_Grotto::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_Grotto.StreamingLevelLoaded
// (Final, Native, Public)
// Parameters:

void AME_Grotto::StreamingLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Grotto", "StreamingLevelLoaded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Grotto.SetInactive
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Grotto::SetInactive(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Grotto", "SetInactive");

	Params::AME_Grotto_SetInactive_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Grotto.OnGrottSpaceExited
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_Grotto::OnGrottSpaceExited()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Grotto", "OnGrottSpaceExited");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_Grotto.OnGrottSpaceEntered
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_Grotto::OnGrottSpaceEntered()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Grotto", "OnGrottSpaceEntered");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_Grotto.Activate
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Grotto::Activate(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Grotto", "Activate");

	Params::AME_Grotto_Activate_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_HitComponent
// (None)

class UClass* UME_HitComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HitComponent");

	return Clss;
}


// ME_HitComponent Maneater.Default__ME_HitComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_HitComponent* UME_HitComponent::GetDefaultObj()
{
	static class UME_HitComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_HitComponent*>(UME_HitComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HitComponentAOE
// (None)

class UClass* UME_HitComponentAOE::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HitComponentAOE");

	return Clss;
}


// ME_HitComponentAOE Maneater.Default__ME_HitComponentAOE
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_HitComponentAOE* UME_HitComponentAOE::GetDefaultObj()
{
	static class UME_HitComponentAOE* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_HitComponentAOE*>(UME_HitComponentAOE::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HumanAIController
// (Actor)

class UClass* AME_HumanAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanAIController");

	return Clss;
}


// ME_HumanAIController Maneater.Default__ME_HumanAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanAIController* AME_HumanAIController::GetDefaultObj()
{
	static class AME_HumanAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanAIController*>(AME_HumanAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_HumanAIController.GetStateAsDialogueString
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      State                                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanAIController::GetStateAsDialogueString(class FString* State)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanAIController", "GetStateAsDialogueString");

	Params::AME_HumanAIController_GetStateAsDialogueString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (State != nullptr)
		*State = std::move(Parms.State);

}


// Class Maneater.ME_HumanCharacter
// (Actor, Pawn)

class UClass* AME_HumanCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanCharacter");

	return Clss;
}


// ME_HumanCharacter Maneater.Default__ME_HumanCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanCharacter* AME_HumanCharacter::GetDefaultObj()
{
	static class AME_HumanCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanCharacter*>(AME_HumanCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_HumanCharacter.TryUpdateChatter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanCharacter::TryUpdateChatter(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "TryUpdateChatter");

	Params::AME_HumanCharacter_TryUpdateChatter_Params Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.SetThreatLevel
// (Final, Native, Public)
// Parameters:
// enum class EAIThreatAlertState     NewAlertState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InstigatingActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanCharacter::SetThreatLevel(enum class EAIThreatAlertState NewAlertState, class AActor* InstigatingActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "SetThreatLevel");

	Params::AME_HumanCharacter_SetThreatLevel_Params Parms{};

	Parms.NewAlertState = NewAlertState;
	Parms.InstigatingActor = InstigatingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.SetIsPassenger
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewPassengerStatus                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_VehiclePawn*             NewVehicle                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bChangeCollision                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SeatIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanCharacter::SetIsPassenger(bool bNewPassengerStatus, class AME_VehiclePawn* NewVehicle, bool bChangeCollision, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "SetIsPassenger");

	Params::AME_HumanCharacter_SetIsPassenger_Params Parms{};

	Parms.bNewPassengerStatus = bNewPassengerStatus;
	Parms.NewVehicle = NewVehicle;
	Parms.bChangeCollision = bChangeCollision;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.PostRandomDialogueEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_HumanCharacter::PostRandomDialogueEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "PostRandomDialogueEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.GetupPawn_UseSnapshot
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::GetupPawn_UseSnapshot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "GetupPawn_UseSnapshot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.GetupPawn_TriggerAnimation
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::GetupPawn_TriggerAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "GetupPawn_TriggerAnimation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.GetupPawn_SetupActor
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::GetupPawn_SetupActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "GetupPawn_SetupActor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.GetupPawn_MoveActor
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::GetupPawn_MoveActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "GetupPawn_MoveActor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.GetStateAsDialogueString
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      State                                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanCharacter::GetStateAsDialogueString(class FString* State)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "GetStateAsDialogueString");

	Params::AME_HumanCharacter_GetStateAsDialogueString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (State != nullptr)
		*State = std::move(Parms.State);

}


// Function Maneater.ME_HumanCharacter.EjectIfPassenger
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                 EjectInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldRagdoll                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EjectImpulse                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_HumanCharacter::EjectIfPassenger(class AController* EjectInstigator, bool bShouldRagdoll, struct FVector& EjectImpulse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "EjectIfPassenger");

	Params::AME_HumanCharacter_EjectIfPassenger_Params Parms{};

	Parms.EjectInstigator = EjectInstigator;
	Parms.bShouldRagdoll = bShouldRagdoll;
	Parms.EjectImpulse = EjectImpulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_HumanCharacter.ChatterUpdateEvent_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              TotalLimbs                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              DestroyedLimbs                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsGrabbed                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               WasBumped                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWasForced                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_HumanCharacter::ChatterUpdateEvent_BP(int32 TotalLimbs, int32 DestroyedLimbs, bool IsGrabbed, bool WasBumped, bool bWasForced)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "ChatterUpdateEvent_BP");

	Params::AME_HumanCharacter_ChatterUpdateEvent_BP_Params Parms{};

	Parms.TotalLimbs = TotalLimbs;
	Parms.DestroyedLimbs = DestroyedLimbs;
	Parms.IsGrabbed = IsGrabbed;
	Parms.WasBumped = WasBumped;
	Parms.bWasForced = bWasForced;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_HumanCharacter.BleedOutTimer
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::BleedOutTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "BleedOutTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.AbandonVehicleFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_HumanCharacter::AbandonVehicleFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "AbandonVehicleFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.AbandonVehicle
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::AbandonVehicle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "AbandonVehicle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanCharacter.AbandonIfPassenger
// (Final, Native, Public)
// Parameters:

void AME_HumanCharacter::AbandonIfPassenger()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanCharacter", "AbandonIfPassenger");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_HumanBeachgoer
// (Actor, Pawn)

class UClass* AME_HumanBeachgoer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanBeachgoer");

	return Clss;
}


// ME_HumanBeachgoer Maneater.Default__ME_HumanBeachgoer
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanBeachgoer* AME_HumanBeachgoer::GetDefaultObj()
{
	static class AME_HumanBeachgoer* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanBeachgoer*>(AME_HumanBeachgoer::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HumanBeachgoerAIController
// (Actor)

class UClass* AME_HumanBeachgoerAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanBeachgoerAIController");

	return Clss;
}


// ME_HumanBeachgoerAIController Maneater.Default__ME_HumanBeachgoerAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanBeachgoerAIController* AME_HumanBeachgoerAIController::GetDefaultObj()
{
	static class AME_HumanBeachgoerAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanBeachgoerAIController*>(AME_HumanBeachgoerAIController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_HumanBeachgoerAIController.SetFleeingPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_HumanBeachgoerAIController::SetFleeingPath()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanBeachgoerAIController", "SetFleeingPath");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_HumanBeachgoerAIController.FleeingAfterDelay
// (Final, Native, Public)
// Parameters:

void AME_HumanBeachgoerAIController::FleeingAfterDelay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_HumanBeachgoerAIController", "FleeingAfterDelay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_HumanMovementComponent
// (None)

class UClass* UME_HumanMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanMovementComponent");

	return Clss;
}


// ME_HumanMovementComponent Maneater.Default__ME_HumanMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_HumanMovementComponent* UME_HumanMovementComponent::GetDefaultObj()
{
	static class UME_HumanMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_HumanMovementComponent*>(UME_HumanMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HumanPassenger
// (Actor, Pawn)

class UClass* AME_HumanPassenger::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanPassenger");

	return Clss;
}


// ME_HumanPassenger Maneater.Default__ME_HumanPassenger
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanPassenger* AME_HumanPassenger::GetDefaultObj()
{
	static class AME_HumanPassenger* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanPassenger*>(AME_HumanPassenger::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HumanPassengerController
// (Actor)

class UClass* AME_HumanPassengerController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HumanPassengerController");

	return Clss;
}


// ME_HumanPassengerController Maneater.Default__ME_HumanPassengerController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_HumanPassengerController* AME_HumanPassengerController::GetDefaultObj()
{
	static class AME_HumanPassengerController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_HumanPassengerController*>(AME_HumanPassengerController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_InputComponent
// (None)

class UClass* UME_InputComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_InputComponent");

	return Clss;
}


// ME_InputComponent Maneater.Default__ME_InputComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_InputComponent* UME_InputComponent::GetDefaultObj()
{
	static class UME_InputComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_InputComponent*>(UME_InputComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_InterpolatedSplineActor
// (Actor)

class UClass* AME_InterpolatedSplineActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_InterpolatedSplineActor");

	return Clss;
}


// ME_InterpolatedSplineActor Maneater.Default__ME_InterpolatedSplineActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_InterpolatedSplineActor* AME_InterpolatedSplineActor::GetDefaultObj()
{
	static class AME_InterpolatedSplineActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_InterpolatedSplineActor*>(AME_InterpolatedSplineActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SharkCharacter
// (Actor, Pawn)

class UClass* AME_SharkCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SharkCharacter");

	return Clss;
}


// ME_SharkCharacter Maneater.Default__ME_SharkCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SharkCharacter* AME_SharkCharacter::GetDefaultObj()
{
	static class AME_SharkCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SharkCharacter*>(AME_SharkCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SharkCharacter.GetDorsalFinLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_SharkCharacter::GetDorsalFinLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SharkCharacter", "GetDorsalFinLocation");

	Params::AME_SharkCharacter_GetDorsalFinLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_PlayerSharkCharacter
// (Actor, Pawn)

class UClass* AME_PlayerSharkCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerSharkCharacter");

	return Clss;
}


// ME_PlayerSharkCharacter Maneater.Default__ME_PlayerSharkCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerSharkCharacter* AME_PlayerSharkCharacter::GetDefaultObj()
{
	static class AME_PlayerSharkCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerSharkCharacter*>(AME_PlayerSharkCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerSharkCharacter.ZeroOutStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::ZeroOutStats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ZeroOutStats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.UpdateGrowthAssets
// (Final, Native, Public, HasOutParams)
// Parameters:
// enum class EPlayerGrowthStage      OldGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::UpdateGrowthAssets(enum class EPlayerGrowthStage& OldGrowthStage, enum class EPlayerGrowthStage& NewGrowthStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "UpdateGrowthAssets");

	Params::AME_PlayerSharkCharacter_UpdateGrowthAssets_Params Parms{};

	Parms.OldGrowthStage = OldGrowthStage;
	Parms.NewGrowthStage = NewGrowthStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.TryUseLungeAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::TryUseLungeAbility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "TryUseLungeAbility");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.TryCancelBite
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::TryCancelBite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "TryCancelBite");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.TailWhipTimeDilationStarted_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ECharacterActionMode    ActionMode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::TailWhipTimeDilationStarted_BP(enum class ECharacterActionMode ActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "TailWhipTimeDilationStarted_BP");

	Params::AME_PlayerSharkCharacter_TailWhipTimeDilationStarted_BP_Params Parms{};

	Parms.ActionMode = ActionMode;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkCharacter.TailWhipTimeDilationEnded_BP
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_PlayerSharkCharacter::TailWhipTimeDilationEnded_BP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "TailWhipTimeDilationEnded_BP");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_PlayerSharkCharacter.StopBiting
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bFromInput                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::StopBiting(bool bFromInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "StopBiting");

	Params::AME_PlayerSharkCharacter_StopBiting_Params Parms{};

	Parms.bFromInput = bFromInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.StopAnimationsOnLandfall
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::StopAnimationsOnLandfall()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "StopAnimationsOnLandfall");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.StartBiting
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bFromInput                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::StartBiting(bool bFromInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "StartBiting");

	Params::AME_PlayerSharkCharacter_StartBiting_Params Parms{};

	Parms.bFromInput = bFromInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.SetWantsToLeaveKnifing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bWantsToLeave                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::SetWantsToLeaveKnifing(bool bWantsToLeave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "SetWantsToLeaveKnifing");

	Params::AME_PlayerSharkCharacter_SetWantsToLeaveKnifing_Params Parms{};

	Parms.bWantsToLeave = bWantsToLeave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.SetTagged
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bNewIsTagged                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::SetTagged(bool bNewIsTagged)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "SetTagged");

	Params::AME_PlayerSharkCharacter_SetTagged_Params Parms{};

	Parms.bNewIsTagged = bNewIsTagged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.SetCameraRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::SetCameraRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "SetCameraRotation");

	Params::AME_PlayerSharkCharacter_SetCameraRotation_Params Parms{};

	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.SetActorAndCameraRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class ETeleportType           Teleport                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkCharacter::SetActorAndCameraRotation(const struct FRotator& NewRotation, enum class ETeleportType Teleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "SetActorAndCameraRotation");

	Params::AME_PlayerSharkCharacter_SetActorAndCameraRotation_Params Parms{};

	Parms.NewRotation = NewRotation;
	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.RefreshAttachedMeshes
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::RefreshAttachedMeshes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "RefreshAttachedMeshes");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.PlayWaterReEntryAnimation
// (Final, Native, Public, HasDefaults)
// Parameters:
// float                              EntryAngleDot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VelocityAngleDot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    FlatEntryRotator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               PerfectEntry                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsCruisingWaterLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::PlayWaterReEntryAnimation(float EntryAngleDot, float VelocityAngleDot, const struct FRotator& FlatEntryRotator, bool PerfectEntry, bool IsCruisingWaterLine)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "PlayWaterReEntryAnimation");

	Params::AME_PlayerSharkCharacter_PlayWaterReEntryAnimation_Params Parms{};

	Parms.EntryAngleDot = EntryAngleDot;
	Parms.VelocityAngleDot = VelocityAngleDot;
	Parms.FlatEntryRotator = FlatEntryRotator;
	Parms.PerfectEntry = PerfectEntry;
	Parms.IsCruisingWaterLine = IsCruisingWaterLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.PlayWaterBreachFX
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::PlayWaterBreachFX()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "PlayWaterBreachFX");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.PlayAudioEvent
// (Final, Native, Public)
// Parameters:
// class UAkAudioEvent*               AudioEvent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::PlayAudioEvent(class UAkAudioEvent* AudioEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "PlayAudioEvent");

	Params::AME_PlayerSharkCharacter_PlayAudioEvent_Params Parms{};

	Parms.AudioEvent = AudioEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.OnTimeDilationStarted
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::OnTimeDilationStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnTimeDilationStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.OnTimeDilationEnded
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::OnTimeDilationEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnTimeDilationEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.OnEvolutionAbilityCharged
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::OnEvolutionAbilityCharged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnEvolutionAbilityCharged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.OnCinematicModeChangedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bCinematicMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::OnCinematicModeChangedEvent(bool bCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnCinematicModeChangedEvent");

	Params::AME_PlayerSharkCharacter_OnCinematicModeChangedEvent_Params Parms{};

	Parms.bCinematicMode = bCinematicMode;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkCharacter.OnCinematicModeChanged
// (Final, Native, Public)
// Parameters:
// bool                               bCinematicMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::OnCinematicModeChanged(bool bCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnCinematicModeChanged");

	Params::AME_PlayerSharkCharacter_OnCinematicModeChanged_Params Parms{};

	Parms.bCinematicMode = bCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.OnAttackAbilityMeleeHit_BP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UGameplayAbility*            AttackAbility                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::OnAttackAbilityMeleeHit_BP(class UGameplayAbility* AttackAbility, struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "OnAttackAbilityMeleeHit_BP");

	Params::AME_PlayerSharkCharacter_OnAttackAbilityMeleeHit_BP_Params Parms{};

	Parms.AttackAbility = AttackAbility;
	Parms.HitResult = HitResult;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkCharacter.NotifyDirectorOfAttack
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::NotifyDirectorOfAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "NotifyDirectorOfAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.LerpSharkMaterialParam
// (Final, Native, Public)
// Parameters:
// class FString                      ParamName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ParamValue                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FLerpTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::LerpSharkMaterialParam(const class FString& ParamName, float ParamValue, float FLerpTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "LerpSharkMaterialParam");

	Params::AME_PlayerSharkCharacter_LerpSharkMaterialParam_Params Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.FLerpTime = FLerpTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.KnifingStateChanged_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               NewKnifingState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    ChangeContext                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::KnifingStateChanged_BP(bool NewKnifingState, enum class ECharacterActionMode ChangeContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "KnifingStateChanged_BP");

	Params::AME_PlayerSharkCharacter_KnifingStateChanged_BP_Params Parms{};

	Parms.NewKnifingState = NewKnifingState;
	Parms.ChangeContext = ChangeContext;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkCharacter.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkCharacter::IsSprinting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "IsSprinting");

	Params::AME_PlayerSharkCharacter_IsSprinting_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.IsMotherShark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkCharacter::IsMotherShark()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "IsMotherShark");

	Params::AME_PlayerSharkCharacter_IsMotherShark_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.IsInputDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkCharacter::IsInputDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "IsInputDisabled");

	Params::AME_PlayerSharkCharacter_IsInputDisabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.IsCapableOfFastTravel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      DestGrotto                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EFastTravelReturn       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EFastTravelReturn AME_PlayerSharkCharacter::IsCapableOfFastTravel(class AActor* DestGrotto)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "IsCapableOfFastTravel");

	Params::AME_PlayerSharkCharacter_IsCapableOfFastTravel_Params Parms{};

	Parms.DestGrotto = DestGrotto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.HandleCameraFadeInFinished
// (Final, Native, Protected)
// Parameters:

void AME_PlayerSharkCharacter::HandleCameraFadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "HandleCameraFadeInFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GrowthStageUpdated
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EPlayerGrowthStage      OldGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReinitPose                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::GrowthStageUpdated(enum class EPlayerGrowthStage& OldGrowthStage, enum class EPlayerGrowthStage& NewGrowthStage, bool bReinitPose)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GrowthStageUpdated");

	Params::AME_PlayerSharkCharacter_GrowthStageUpdated_Params Parms{};

	Parms.OldGrowthStage = OldGrowthStage;
	Parms.NewGrowthStage = NewGrowthStage;
	Parms.bReinitPose = bReinitPose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GrowthStageChanged
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::GrowthStageChanged(enum class EPlayerGrowthStage& NewGrowthStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GrowthStageChanged");

	Params::AME_PlayerSharkCharacter_GrowthStageChanged_Params Parms{};

	Parms.NewGrowthStage = NewGrowthStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GrowthLevelChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                              NewGrowthLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bChangeFromTheoretical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::GrowthLevelChanged(int32 NewGrowthLevel, bool bChangeFromTheoretical)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GrowthLevelChanged");

	Params::AME_PlayerSharkCharacter_GrowthLevelChanged_Params Parms{};

	Parms.NewGrowthLevel = NewGrowthLevel;
	Parms.bChangeFromTheoretical = bChangeFromTheoretical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GibLastVictim
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::GibLastVictim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GibLastVictim");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GetPlayerTargetingSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerTargetingSystem*   ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PlayerTargetingSystem* AME_PlayerSharkCharacter::GetPlayerTargetingSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetPlayerTargetingSystem");

	Params::AME_PlayerSharkCharacter_GetPlayerTargetingSystem_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetPlayerSharkMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UME_PlayerSharkMovementComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PlayerSharkMovementComponent* AME_PlayerSharkCharacter::GetPlayerSharkMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetPlayerSharkMovement");

	Params::AME_PlayerSharkCharacter_GetPlayerSharkMovement_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerSharkCharacter::GetPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetPlayerLevel");

	Params::AME_PlayerSharkCharacter_GetPlayerLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetGrowthStageScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerSharkCharacter::GetGrowthStageScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetGrowthStageScale");

	Params::AME_PlayerSharkCharacter_GetGrowthStageScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetGrowthStage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EPlayerGrowthStage      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPlayerGrowthStage AME_PlayerSharkCharacter::GetGrowthStage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetGrowthStage");

	Params::AME_PlayerSharkCharacter_GetGrowthStage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetCurrentLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AME_PlayerSharkCharacter::GetCurrentLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetCurrentLockOnTarget");

	Params::AME_PlayerSharkCharacter_GetCurrentLockOnTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetCurrentFocusedTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AME_PlayerSharkCharacter::GetCurrentFocusedTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetCurrentFocusedTarget");

	Params::AME_PlayerSharkCharacter_GetCurrentFocusedTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetCastAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UME_AnimInstance_PlayerShark*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_AnimInstance_PlayerShark* AME_PlayerSharkCharacter::GetCastAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetCastAnimInstance");

	Params::AME_PlayerSharkCharacter_GetCastAnimInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GetAttachedEvolutionMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEvolutionSlot          EvolutionSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MeshIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AME_PlayerSharkCharacter::GetAttachedEvolutionMesh(enum class EEvolutionSlot EvolutionSlot, int32 MeshIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GetAttachedEvolutionMesh");

	Params::AME_PlayerSharkCharacter_GetAttachedEvolutionMesh_Params Parms{};

	Parms.EvolutionSlot = EvolutionSlot;
	Parms.MeshIndex = MeshIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.GenericWaterlineSplash
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*             Particles                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::GenericWaterlineSplash(class UParticleSystem* Particles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GenericWaterlineSplash");

	Params::AME_PlayerSharkCharacter_GenericWaterlineSplash_Params Parms{};

	Parms.Particles = Particles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.GenericAttachedParticleTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*             Particles                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ELimbBoneName           LimbName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::GenericAttachedParticleTrail(class UParticleSystem* Particles, enum class ELimbBoneName LimbName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "GenericAttachedParticleTrail");

	Params::AME_PlayerSharkCharacter_GenericAttachedParticleTrail_Params Parms{};

	Parms.Particles = Particles;
	Parms.LimbName = LimbName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.ForceKnifingEntryAngle
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_PlayerSharkCharacter::ForceKnifingEntryAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ForceKnifingEntryAngle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_PlayerSharkCharacter.ExitKnifingUnderwater
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::ExitKnifingUnderwater()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ExitKnifingUnderwater");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.EvolutionAbilityActivatedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EEvolutionSetType       SetType                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::EvolutionAbilityActivatedEvent(enum class EEvolutionSetType SetType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "EvolutionAbilityActivatedEvent");

	Params::AME_PlayerSharkCharacter_EvolutionAbilityActivatedEvent_Params Parms{};

	Parms.SetType = SetType;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkCharacter.EnterKnifingFromUnderwater
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::EnterKnifingFromUnderwater()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "EnterKnifingFromUnderwater");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.EnterKnifingFromBreach
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::EnterKnifingFromBreach()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "EnterKnifingFromBreach");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.EndWhipshotSlomo
// (Final, Native, Public)
// Parameters:
// int32                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PageCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::EndWhipshotSlomo(int32 Idx, int32 PageCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "EndWhipshotSlomo");

	Params::AME_PlayerSharkCharacter_EndWhipshotSlomo_Params Parms{};

	Parms.Idx = Idx;
	Parms.PageCount = PageCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.ChunkLastVictim
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::ChunkLastVictim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ChunkLastVictim");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.BroadcastRegionChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkCharacter::BroadcastRegionChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "BroadcastRegionChanged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.AttemptFastTravel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Dest                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkCharacter::AttemptFastTravel(class AActor* Dest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "AttemptFastTravel");

	Params::AME_PlayerSharkCharacter_AttemptFastTravel_Params Parms{};

	Parms.Dest = Dest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkCharacter.ApplyEvolutionMaterial
// (Final, Native, Public)
// Parameters:

void AME_PlayerSharkCharacter::ApplyEvolutionMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ApplyEvolutionMaterial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkCharacter.ActivateMutagenScale
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleSystem*             ParticleToPlay                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketToAttach                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::ActivateMutagenScale(class UParticleSystem* ParticleToPlay, class FName* SocketToAttach)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ActivateMutagenScale");

	Params::AME_PlayerSharkCharacter_ActivateMutagenScale_Params Parms{};

	Parms.ParticleToPlay = ParticleToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SocketToAttach != nullptr)
		*SocketToAttach = Parms.SocketToAttach;

}


// Function Maneater.ME_PlayerSharkCharacter.ActionModeUpdated_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ECharacterActionMode    NewActionMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkCharacter::ActionModeUpdated_BP(enum class ECharacterActionMode NewActionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkCharacter", "ActionModeUpdated_BP");

	Params::AME_PlayerSharkCharacter_ActionModeUpdated_BP_Params Parms{};

	Parms.NewActionMode = NewActionMode;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_InventoryActor
// (Actor, Pawn)

class UClass* AME_InventoryActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_InventoryActor");

	return Clss;
}


// ME_InventoryActor Maneater.Default__ME_InventoryActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_InventoryActor* AME_InventoryActor::GetDefaultObj()
{
	static class AME_InventoryActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_InventoryActor*>(AME_InventoryActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_InventoryActor.SetSharkEvolutionVisuals
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<enum class EEvolutionSlot, class UME_PlayerEvolution*>EquippedEvolutionMap                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void AME_InventoryActor::SetSharkEvolutionVisuals(TMap<enum class EEvolutionSlot, class UME_PlayerEvolution*>* EquippedEvolutionMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_InventoryActor", "SetSharkEvolutionVisuals");

	Params::AME_InventoryActor_SetSharkEvolutionVisuals_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (EquippedEvolutionMap != nullptr)
		*EquippedEvolutionMap = Parms.EquippedEvolutionMap;

}


// Function Maneater.ME_InventoryActor.SetPlayerSharkCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_PlayerSharkCharacter*    Character                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_InventoryActor::SetPlayerSharkCharacter(class AME_PlayerSharkCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_InventoryActor", "SetPlayerSharkCharacter");

	Params::AME_InventoryActor_SetPlayerSharkCharacter_Params Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_InWorldWidgetCreator
// (Actor)

class UClass* AME_InWorldWidgetCreator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_InWorldWidgetCreator");

	return Clss;
}


// ME_InWorldWidgetCreator Maneater.Default__ME_InWorldWidgetCreator
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_InWorldWidgetCreator* AME_InWorldWidgetCreator::GetDefaultObj()
{
	static class AME_InWorldWidgetCreator* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_InWorldWidgetCreator*>(AME_InWorldWidgetCreator::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_InWorldWidgetCreator.SetActiveIndexFromObjective
// (Event, Public, BlueprintEvent)
// Parameters:
// class UME_PlayerObjective*         PlayerObjective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_InWorldWidgetCreator::SetActiveIndexFromObjective(class UME_PlayerObjective* PlayerObjective)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_InWorldWidgetCreator", "SetActiveIndexFromObjective");

	Params::AME_InWorldWidgetCreator_SetActiveIndexFromObjective_Params Parms{};

	Parms.PlayerObjective = PlayerObjective;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_InWorldWidgetCreator.OnViewControllerVisibilityChanged
// (Final, Native, Public)
// Parameters:
// enum class ESlateVisibility        ControllerVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_InWorldWidgetCreator::OnViewControllerVisibilityChanged(enum class ESlateVisibility ControllerVisibility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_InWorldWidgetCreator", "OnViewControllerVisibilityChanged");

	Params::AME_InWorldWidgetCreator_OnViewControllerVisibilityChanged_Params Parms{};

	Parms.ControllerVisibility = ControllerVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_InWorldWidgetCreator.OnGamePauseStateChanged
// (Final, Native, Public)
// Parameters:
// bool                               bPaused                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_InWorldWidgetCreator::OnGamePauseStateChanged(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_InWorldWidgetCreator", "OnGamePauseStateChanged");

	Params::AME_InWorldWidgetCreator_OnGamePauseStateChanged_Params Parms{};

	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_LandmarkObjective
// (Actor)

class UClass* AME_LandmarkObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_LandmarkObjective");

	return Clss;
}


// ME_LandmarkObjective Maneater.Default__ME_LandmarkObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_LandmarkObjective* AME_LandmarkObjective::GetDefaultObj()
{
	static class AME_LandmarkObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_LandmarkObjective*>(AME_LandmarkObjective::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_LandmarkObjective.OnDiscoveredSet
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bNewDiscoveredSetting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_LandmarkObjective::OnDiscoveredSet(bool bNewDiscoveredSetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_LandmarkObjective", "OnDiscoveredSet");

	Params::AME_LandmarkObjective_OnDiscoveredSet_Params Parms{};

	Parms.bNewDiscoveredSetting = bNewDiscoveredSetting;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_LandmarkObjective.GetAssociatedSign
// (Event, Public, BlueprintEvent)
// Parameters:
// class AME_DestructibleActor*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_DestructibleActor* AME_LandmarkObjective::GetAssociatedSign()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_LandmarkObjective", "GetAssociatedSign");

	Params::AME_LandmarkObjective_GetAssociatedSign_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Class Maneater.ME_MapWidgetInterface
// (None)

class UClass* IME_MapWidgetInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MapWidgetInterface");

	return Clss;
}


// ME_MapWidgetInterface Maneater.Default__ME_MapWidgetInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_MapWidgetInterface* IME_MapWidgetInterface::GetDefaultObj()
{
	static class IME_MapWidgetInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_MapWidgetInterface*>(IME_MapWidgetInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_MapWidgetInterface.ShouldClampToEdgeOfMap
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_MapWidgetInterface::ShouldClampToEdgeOfMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "ShouldClampToEdgeOfMap");

	Params::IME_MapWidgetInterface_ShouldClampToEdgeOfMap_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.OnWidgetMouseDown
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                 Widget                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPointerEvent               MouseEvent                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IME_MapWidgetInterface::OnWidgetMouseDown(class UUserWidget* Widget, struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "OnWidgetMouseDown");

	Params::IME_MapWidgetInterface_OnWidgetMouseDown_Params Parms{};

	Parms.Widget = Widget;
	Parms.MouseEvent = MouseEvent;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetVisibility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility IME_MapWidgetInterface::GetMapWidgetVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetVisibility");

	Params::IME_MapWidgetInterface_GetMapWidgetVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetSize
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D IME_MapWidgetInterface::GetMapWidgetSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetSize");

	Params::IME_MapWidgetInterface_GetMapWidgetSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetPriority
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IME_MapWidgetInterface::GetMapWidgetPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetPriority");

	Params::IME_MapWidgetInterface_GetMapWidgetPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetMaterial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* IME_MapWidgetInterface::GetMapWidgetMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetMaterial");

	Params::IME_MapWidgetInterface_GetMapWidgetMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetIcon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* IME_MapWidgetInterface::GetMapWidgetIcon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetIcon");

	Params::IME_MapWidgetInterface_GetMapWidgetIcon_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapWidgetEnabled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_MapWidgetInterface::GetMapWidgetEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapWidgetEnabled");

	Params::IME_MapWidgetInterface_GetMapWidgetEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapDisplayName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IME_MapWidgetInterface::GetMapDisplayName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapDisplayName");

	Params::IME_MapWidgetInterface_GetMapDisplayName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MapWidgetInterface.GetMapDescriptionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IME_MapWidgetInterface::GetMapDescriptionText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MapWidgetInterface", "GetMapDescriptionText");

	Params::IME_MapWidgetInterface_GetMapDescriptionText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_MercunaNavigableInterface
// (None)

class UClass* IME_MercunaNavigableInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MercunaNavigableInterface");

	return Clss;
}


// ME_MercunaNavigableInterface Maneater.Default__ME_MercunaNavigableInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_MercunaNavigableInterface* IME_MercunaNavigableInterface::GetDefaultObj()
{
	static class IME_MercunaNavigableInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_MercunaNavigableInterface*>(IME_MercunaNavigableInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_MercunaNavigationComponent
// (None)

class UClass* UME_MercunaNavigationComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MercunaNavigationComponent");

	return Clss;
}


// ME_MercunaNavigationComponent Maneater.Default__ME_MercunaNavigationComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_MercunaNavigationComponent* UME_MercunaNavigationComponent::GetDefaultObj()
{
	static class UME_MercunaNavigationComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_MercunaNavigationComponent*>(UME_MercunaNavigationComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_MercunaNavOctree
// (Actor)

class UClass* AME_MercunaNavOctree::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MercunaNavOctree");

	return Clss;
}


// ME_MercunaNavOctree Maneater.Default__ME_MercunaNavOctree
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_MercunaNavOctree* AME_MercunaNavOctree::GetDefaultObj()
{
	static class AME_MercunaNavOctree* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_MercunaNavOctree*>(AME_MercunaNavOctree::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_MercunaNavOctree.IsBoatOctree
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_MercunaNavOctree::IsBoatOctree()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MercunaNavOctree", "IsBoatOctree");

	Params::AME_MercunaNavOctree_IsBoatOctree_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_MercunaNavVolume
// (Actor)

class UClass* AME_MercunaNavVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MercunaNavVolume");

	return Clss;
}


// ME_MercunaNavVolume Maneater.Default__ME_MercunaNavVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_MercunaNavVolume* AME_MercunaNavVolume::GetDefaultObj()
{
	static class AME_MercunaNavVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_MercunaNavVolume*>(AME_MercunaNavVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_MercunaNavVolume.IsBoatVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_MercunaNavVolume::IsBoatVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MercunaNavVolume", "IsBoatVolume");

	Params::AME_MercunaNavVolume_IsBoatVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_MercunaNavVolume.IsAirVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_MercunaNavVolume::IsAirVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_MercunaNavVolume", "IsAirVolume");

	Params::AME_MercunaNavVolume_IsAirVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_MercunaObstacleComponent
// (SceneComponent)

class UClass* UME_MercunaObstacleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_MercunaObstacleComponent");

	return Clss;
}


// ME_MercunaObstacleComponent Maneater.Default__ME_MercunaObstacleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_MercunaObstacleComponent* UME_MercunaObstacleComponent::GetDefaultObj()
{
	static class UME_MercunaObstacleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_MercunaObstacleComponent*>(UME_MercunaObstacleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MontageInstance
// (None)

class UClass* UMontageInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MontageInstance");

	return Clss;
}


// MontageInstance Maneater.Default__MontageInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMontageInstance* UMontageInstance::GetDefaultObj()
{
	static class UMontageInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMontageInstance*>(UMontageInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.WildlifeMontageInstance
// (None)

class UClass* UWildlifeMontageInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WildlifeMontageInstance");

	return Clss;
}


// WildlifeMontageInstance Maneater.Default__WildlifeMontageInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UWildlifeMontageInstance* UWildlifeMontageInstance::GetDefaultObj()
{
	static class UWildlifeMontageInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UWildlifeMontageInstance*>(UWildlifeMontageInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.DirectionalMontageInstance
// (None)

class UClass* UDirectionalMontageInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DirectionalMontageInstance");

	return Clss;
}


// DirectionalMontageInstance Maneater.Default__DirectionalMontageInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UDirectionalMontageInstance* UDirectionalMontageInstance::GetDefaultObj()
{
	static class UDirectionalMontageInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UDirectionalMontageInstance*>(UDirectionalMontageInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_NavigationSystem
// (None)

class UClass* UME_NavigationSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_NavigationSystem");

	return Clss;
}


// ME_NavigationSystem Maneater.Default__ME_NavigationSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_NavigationSystem* UME_NavigationSystem::GetDefaultObj()
{
	static class UME_NavigationSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_NavigationSystem*>(UME_NavigationSystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_NutrientCache
// (Actor)

class UClass* AME_NutrientCache::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_NutrientCache");

	return Clss;
}


// ME_NutrientCache Maneater.Default__ME_NutrientCache
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_NutrientCache* AME_NutrientCache::GetDefaultObj()
{
	static class AME_NutrientCache* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_NutrientCache*>(AME_NutrientCache::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_NutrientCache_Skeletal
// (Actor)

class UClass* AME_NutrientCache_Skeletal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_NutrientCache_Skeletal");

	return Clss;
}


// ME_NutrientCache_Skeletal Maneater.Default__ME_NutrientCache_Skeletal
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_NutrientCache_Skeletal* AME_NutrientCache_Skeletal::GetDefaultObj()
{
	static class AME_NutrientCache_Skeletal* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_NutrientCache_Skeletal*>(AME_NutrientCache_Skeletal::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_NutrientCache_Static
// (Actor)

class UClass* AME_NutrientCache_Static::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_NutrientCache_Static");

	return Clss;
}


// ME_NutrientCache_Static Maneater.Default__ME_NutrientCache_Static
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_NutrientCache_Static* AME_NutrientCache_Static::GetDefaultObj()
{
	static class AME_NutrientCache_Static* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_NutrientCache_Static*>(AME_NutrientCache_Static::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveConditionBase
// (None)

class UClass* UME_ObjectiveConditionBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveConditionBase");

	return Clss;
}


// ME_ObjectiveConditionBase Maneater.Default__ME_ObjectiveConditionBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveConditionBase* UME_ObjectiveConditionBase::GetDefaultObj()
{
	static class UME_ObjectiveConditionBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveConditionBase*>(UME_ObjectiveConditionBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ObjectiveConditionBase.ConditionIsValid
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_ObjectiveConditionBase::ConditionIsValid(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ObjectiveConditionBase", "ConditionIsValid");

	Params::UME_ObjectiveConditionBase_ConditionIsValid_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_ObjectiveCondition_GamePercentComplete
// (None)

class UClass* UME_ObjectiveCondition_GamePercentComplete::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_GamePercentComplete");

	return Clss;
}


// ME_ObjectiveCondition_GamePercentComplete Maneater.Default__ME_ObjectiveCondition_GamePercentComplete
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_GamePercentComplete* UME_ObjectiveCondition_GamePercentComplete::GetDefaultObj()
{
	static class UME_ObjectiveCondition_GamePercentComplete* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_GamePercentComplete*>(UME_ObjectiveCondition_GamePercentComplete::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_InfamyRank
// (None)

class UClass* UME_ObjectiveCondition_InfamyRank::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_InfamyRank");

	return Clss;
}


// ME_ObjectiveCondition_InfamyRank Maneater.Default__ME_ObjectiveCondition_InfamyRank
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_InfamyRank* UME_ObjectiveCondition_InfamyRank::GetDefaultObj()
{
	static class UME_ObjectiveCondition_InfamyRank* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_InfamyRank*>(UME_ObjectiveCondition_InfamyRank::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_ObjectiveComplete
// (None)

class UClass* UME_ObjectiveCondition_ObjectiveComplete::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_ObjectiveComplete");

	return Clss;
}


// ME_ObjectiveCondition_ObjectiveComplete Maneater.Default__ME_ObjectiveCondition_ObjectiveComplete
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_ObjectiveComplete* UME_ObjectiveCondition_ObjectiveComplete::GetDefaultObj()
{
	static class UME_ObjectiveCondition_ObjectiveComplete* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_ObjectiveComplete*>(UME_ObjectiveCondition_ObjectiveComplete::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_PlayerLevel
// (None)

class UClass* UME_ObjectiveCondition_PlayerLevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_PlayerLevel");

	return Clss;
}


// ME_ObjectiveCondition_PlayerLevel Maneater.Default__ME_ObjectiveCondition_PlayerLevel
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_PlayerLevel* UME_ObjectiveCondition_PlayerLevel::GetDefaultObj()
{
	static class UME_ObjectiveCondition_PlayerLevel* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_PlayerLevel*>(UME_ObjectiveCondition_PlayerLevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_RegionPercentComplete
// (None)

class UClass* UME_ObjectiveCondition_RegionPercentComplete::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_RegionPercentComplete");

	return Clss;
}


// ME_ObjectiveCondition_RegionPercentComplete Maneater.Default__ME_ObjectiveCondition_RegionPercentComplete
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_RegionPercentComplete* UME_ObjectiveCondition_RegionPercentComplete::GetDefaultObj()
{
	static class UME_ObjectiveCondition_RegionPercentComplete* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_RegionPercentComplete*>(UME_ObjectiveCondition_RegionPercentComplete::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_SharkGrowthStageReached
// (None)

class UClass* UME_ObjectiveCondition_SharkGrowthStageReached::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_SharkGrowthStageReached");

	return Clss;
}


// ME_ObjectiveCondition_SharkGrowthStageReached Maneater.Default__ME_ObjectiveCondition_SharkGrowthStageReached
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_SharkGrowthStageReached* UME_ObjectiveCondition_SharkGrowthStageReached::GetDefaultObj()
{
	static class UME_ObjectiveCondition_SharkGrowthStageReached* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_SharkGrowthStageReached*>(UME_ObjectiveCondition_SharkGrowthStageReached::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_TutorialComplete
// (None)

class UClass* UME_ObjectiveCondition_TutorialComplete::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_TutorialComplete");

	return Clss;
}


// ME_ObjectiveCondition_TutorialComplete Maneater.Default__ME_ObjectiveCondition_TutorialComplete
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_TutorialComplete* UME_ObjectiveCondition_TutorialComplete::GetDefaultObj()
{
	static class UME_ObjectiveCondition_TutorialComplete* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_TutorialComplete*>(UME_ObjectiveCondition_TutorialComplete::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveCondition_ManuallyAdvanceOnly
// (None)

class UClass* UME_ObjectiveCondition_ManuallyAdvanceOnly::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveCondition_ManuallyAdvanceOnly");

	return Clss;
}


// ME_ObjectiveCondition_ManuallyAdvanceOnly Maneater.Default__ME_ObjectiveCondition_ManuallyAdvanceOnly
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectiveCondition_ManuallyAdvanceOnly* UME_ObjectiveCondition_ManuallyAdvanceOnly::GetDefaultObj()
{
	static class UME_ObjectiveCondition_ManuallyAdvanceOnly* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectiveCondition_ManuallyAdvanceOnly*>(UME_ObjectiveCondition_ManuallyAdvanceOnly::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ObjectiveSpawnActor
// (Actor)

class UClass* AME_ObjectiveSpawnActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveSpawnActor");

	return Clss;
}


// ME_ObjectiveSpawnActor Maneater.Default__ME_ObjectiveSpawnActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ObjectiveSpawnActor* AME_ObjectiveSpawnActor::GetDefaultObj()
{
	static class AME_ObjectiveSpawnActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ObjectiveSpawnActor*>(AME_ObjectiveSpawnActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanBloodDecal
// (Actor)

class UClass* AME_OceanBloodDecal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanBloodDecal");

	return Clss;
}


// ME_OceanBloodDecal Maneater.Default__ME_OceanBloodDecal
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_OceanBloodDecal* AME_OceanBloodDecal::GetDefaultObj()
{
	static class AME_OceanBloodDecal* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_OceanBloodDecal*>(AME_OceanBloodDecal::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanCameraMesh
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_OceanCameraMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanCameraMesh");

	return Clss;
}


// ME_OceanCameraMesh Maneater.Default__ME_OceanCameraMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_OceanCameraMesh* UME_OceanCameraMesh::GetDefaultObj()
{
	static class UME_OceanCameraMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_OceanCameraMesh*>(UME_OceanCameraMesh::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanManager
// (Actor)

class UClass* AME_OceanManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanManager");

	return Clss;
}


// ME_OceanManager Maneater.Default__ME_OceanManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_OceanManager* AME_OceanManager::GetDefaultObj()
{
	static class AME_OceanManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_OceanManager*>(AME_OceanManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_OceanManager.IsUnderwater
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InLocation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_OceanManager::IsUnderwater(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanManager", "IsUnderwater");

	Params::AME_OceanManager_IsUnderwater_Params Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_OceanManager.GetWaveModulationAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Location                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_OceanManager::GetWaveModulationAtLocation(struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanManager", "GetWaveModulationAtLocation");

	Params::AME_OceanManager_GetWaveModulationAtLocation_Params Parms{};

	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_OceanManager.GetFluidHeightRT
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* AME_OceanManager::GetFluidHeightRT(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanManager", "GetFluidHeightRT");

	Params::AME_OceanManager_GetFluidHeightRT_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_OceanManager.CauseFluidDisturbance
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DisturbanceOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DisturbanceRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DisturbanceIntensity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EFluidEffectType        EffectType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_OceanManager::CauseFluidDisturbance(const struct FVector& DisturbanceOrigin, float DisturbanceRadius, float DisturbanceIntensity, enum class EFluidEffectType EffectType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanManager", "CauseFluidDisturbance");

	Params::AME_OceanManager_CauseFluidDisturbance_Params Parms{};

	Parms.DisturbanceOrigin = DisturbanceOrigin;
	Parms.DisturbanceRadius = DisturbanceRadius;
	Parms.DisturbanceIntensity = DisturbanceIntensity;
	Parms.EffectType = EffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_OceanPhysicsVolume
// (Actor)

class UClass* AME_OceanPhysicsVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanPhysicsVolume");

	return Clss;
}


// ME_OceanPhysicsVolume Maneater.Default__ME_OceanPhysicsVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_OceanPhysicsVolume* AME_OceanPhysicsVolume::GetDefaultObj()
{
	static class AME_OceanPhysicsVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_OceanPhysicsVolume*>(AME_OceanPhysicsVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanPostProcessComponent
// (SceneComponent)

class UClass* UME_OceanPostProcessComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanPostProcessComponent");

	return Clss;
}


// ME_OceanPostProcessComponent Maneater.Default__ME_OceanPostProcessComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_OceanPostProcessComponent* UME_OceanPostProcessComponent::GetDefaultObj()
{
	static class UME_OceanPostProcessComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_OceanPostProcessComponent*>(UME_OceanPostProcessComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanSurfaceEmitter
// (Actor)

class UClass* AME_OceanSurfaceEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanSurfaceEmitter");

	return Clss;
}


// ME_OceanSurfaceEmitter Maneater.Default__ME_OceanSurfaceEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_OceanSurfaceEmitter* AME_OceanSurfaceEmitter::GetDefaultObj()
{
	static class AME_OceanSurfaceEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_OceanSurfaceEmitter*>(AME_OceanSurfaceEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OceanSurfaceParticleSystemComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UME_OceanSurfaceParticleSystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanSurfaceParticleSystemComponent");

	return Clss;
}


// ME_OceanSurfaceParticleSystemComponent Maneater.Default__ME_OceanSurfaceParticleSystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_OceanSurfaceParticleSystemComponent* UME_OceanSurfaceParticleSystemComponent::GetDefaultObj()
{
	static class UME_OceanSurfaceParticleSystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_OceanSurfaceParticleSystemComponent*>(UME_OceanSurfaceParticleSystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.SetWakeLowSize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              NewSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_OceanSurfaceParticleSystemComponent::SetWakeLowSize(float NewSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "SetWakeLowSize");

	Params::UME_OceanSurfaceParticleSystemComponent_SetWakeLowSize_Params Parms{};

	Parms.NewSize = NewSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.SetWakeLowColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewColor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_OceanSurfaceParticleSystemComponent::SetWakeLowColor(const struct FVector& NewColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "SetWakeLowColor");

	Params::UME_OceanSurfaceParticleSystemComponent_SetWakeLowColor_Params Parms{};

	Parms.NewColor = NewColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.SetWakeLowAlpha
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              NewAlpha                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_OceanSurfaceParticleSystemComponent::SetWakeLowAlpha(float NewAlpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "SetWakeLowAlpha");

	Params::UME_OceanSurfaceParticleSystemComponent_SetWakeLowAlpha_Params Parms{};

	Parms.NewAlpha = NewAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.GetWakeLowSize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_OceanSurfaceParticleSystemComponent::GetWakeLowSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "GetWakeLowSize");

	Params::UME_OceanSurfaceParticleSystemComponent_GetWakeLowSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.GetWakeLowColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_OceanSurfaceParticleSystemComponent::GetWakeLowColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "GetWakeLowColor");

	Params::UME_OceanSurfaceParticleSystemComponent_GetWakeLowColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_OceanSurfaceParticleSystemComponent.GetWakeLowAlpha
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_OceanSurfaceParticleSystemComponent::GetWakeLowAlpha()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_OceanSurfaceParticleSystemComponent", "GetWakeLowAlpha");

	Params::UME_OceanSurfaceParticleSystemComponent_GetWakeLowAlpha_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_OceanTileComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_OceanTileComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OceanTileComponent");

	return Clss;
}


// ME_OceanTileComponent Maneater.Default__ME_OceanTileComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_OceanTileComponent* UME_OceanTileComponent::GetDefaultObj()
{
	static class UME_OceanTileComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_OceanTileComponent*>(UME_OceanTileComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_OverlapDamageProjectile
// (Actor)

class UClass* AME_OverlapDamageProjectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_OverlapDamageProjectile");

	return Clss;
}


// ME_OverlapDamageProjectile Maneater.Default__ME_OverlapDamageProjectile
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_OverlapDamageProjectile* AME_OverlapDamageProjectile::GetDefaultObj()
{
	static class AME_OverlapDamageProjectile* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_OverlapDamageProjectile*>(AME_OverlapDamageProjectile::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleManeaterBase
// (None)

class UClass* UME_ParticleModuleManeaterBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleManeaterBase");

	return Clss;
}


// ME_ParticleModuleManeaterBase Maneater.Default__ME_ParticleModuleManeaterBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleManeaterBase* UME_ParticleModuleManeaterBase::GetDefaultObj()
{
	static class UME_ParticleModuleManeaterBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleManeaterBase*>(UME_ParticleModuleManeaterBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleDetachFromOwner
// (None)

class UClass* UME_ParticleModuleDetachFromOwner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleDetachFromOwner");

	return Clss;
}


// ME_ParticleModuleDetachFromOwner Maneater.Default__ME_ParticleModuleDetachFromOwner
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleDetachFromOwner* UME_ParticleModuleDetachFromOwner::GetDefaultObj()
{
	static class UME_ParticleModuleDetachFromOwner* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleDetachFromOwner*>(UME_ParticleModuleDetachFromOwner::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleDynamiclyEnabled
// (None)

class UClass* UME_ParticleModuleDynamiclyEnabled::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleDynamiclyEnabled");

	return Clss;
}


// ME_ParticleModuleDynamiclyEnabled Maneater.Default__ME_ParticleModuleDynamiclyEnabled
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleDynamiclyEnabled* UME_ParticleModuleDynamiclyEnabled::GetDefaultObj()
{
	static class UME_ParticleModuleDynamiclyEnabled* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleDynamiclyEnabled*>(UME_ParticleModuleDynamiclyEnabled::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleDynamicTranslucencySort
// (None)

class UClass* UME_ParticleModuleDynamicTranslucencySort::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleDynamicTranslucencySort");

	return Clss;
}


// ME_ParticleModuleDynamicTranslucencySort Maneater.Default__ME_ParticleModuleDynamicTranslucencySort
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleDynamicTranslucencySort* UME_ParticleModuleDynamicTranslucencySort::GetDefaultObj()
{
	static class UME_ParticleModuleDynamicTranslucencySort* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleDynamicTranslucencySort*>(UME_ParticleModuleDynamicTranslucencySort::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleFishball
// (None)

class UClass* UME_ParticleModuleFishball::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleFishball");

	return Clss;
}


// ME_ParticleModuleFishball Maneater.Default__ME_ParticleModuleFishball
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleFishball* UME_ParticleModuleFishball::GetDefaultObj()
{
	static class UME_ParticleModuleFishball* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleFishball*>(UME_ParticleModuleFishball::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleFluidEffect
// (None)

class UClass* UME_ParticleModuleFluidEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleFluidEffect");

	return Clss;
}


// ME_ParticleModuleFluidEffect Maneater.Default__ME_ParticleModuleFluidEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleFluidEffect* UME_ParticleModuleFluidEffect::GetDefaultObj()
{
	static class UME_ParticleModuleFluidEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleFluidEffect*>(UME_ParticleModuleFluidEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ParticleModuleSortValue
// (None)

class UClass* UME_ParticleModuleSortValue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ParticleModuleSortValue");

	return Clss;
}


// ME_ParticleModuleSortValue Maneater.Default__ME_ParticleModuleSortValue
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ParticleModuleSortValue* UME_ParticleModuleSortValue::GetDefaultObj()
{
	static class UME_ParticleModuleSortValue* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ParticleModuleSortValue*>(UME_ParticleModuleSortValue::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WeaponComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_WeaponComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WeaponComponent");

	return Clss;
}


// ME_WeaponComponent Maneater.Default__ME_WeaponComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WeaponComponent* UME_WeaponComponent::GetDefaultObj()
{
	static class UME_WeaponComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WeaponComponent*>(UME_WeaponComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WeaponComponent.StartAttackCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              CooldownDuration                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_WeaponComponent::StartAttackCooldown(float CooldownDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "StartAttackCooldown");

	Params::UME_WeaponComponent_StartAttackCooldown_Params Parms{};

	Parms.CooldownDuration = CooldownDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.SetShowLaserPointer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bShowPointer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bResetTargeting                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CustomLockOnStartTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_WeaponComponent::SetShowLaserPointer(bool bShowPointer, bool bResetTargeting, float CustomLockOnStartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "SetShowLaserPointer");

	Params::UME_WeaponComponent_SetShowLaserPointer_Params Parms{};

	Parms.bShowPointer = bShowPointer;
	Parms.bResetTargeting = bResetTargeting;
	Parms.CustomLockOnStartTime = CustomLockOnStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.ResetLaserTargeting
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_WeaponComponent::ResetLaserTargeting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "ResetLaserTargeting");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.PerformFire
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     AimDirection                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bViaAnimNotify                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_WeaponComponent::PerformFire(const struct FVector& AimDirection, bool bViaAnimNotify)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "PerformFire");

	Params::UME_WeaponComponent_PerformFire_Params Parms{};

	Parms.AimDirection = AimDirection;
	Parms.bViaAnimNotify = bViaAnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.OnMeleeAttackCooldownTimerFinished
// (Final, Native, Private)
// Parameters:

void UME_WeaponComponent::OnMeleeAttackCooldownTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "OnMeleeAttackCooldownTimerFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.IsCooldownActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_WeaponComponent::IsCooldownActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "IsCooldownActive");

	Params::UME_WeaponComponent_IsCooldownActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.HasLaserLock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_WeaponComponent::HasLaserLock()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "HasLaserLock");

	Params::UME_WeaponComponent_HasLaserLock_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.HasLaser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_WeaponComponent::HasLaser()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "HasLaser");

	Params::UME_WeaponComponent_HasLaser_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.GetWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*      Owner                                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_WeaponComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_WeaponComponent* UME_WeaponComponent::GetWeapon(class USkeletalMeshComponent* Owner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "GetWeapon");

	Params::UME_WeaponComponent_GetWeapon_Params Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.GetTargetedActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AME_Character*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_Character* UME_WeaponComponent::GetTargetedActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "GetTargetedActor");

	Params::UME_WeaponComponent_GetTargetedActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.GetLaserAimDir
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_WeaponComponent::GetLaserAimDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "GetLaserAimDir");

	Params::UME_WeaponComponent_GetLaserAimDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_WeaponComponent.Fire
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     AimDirection                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bViaAnimNotify                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_WeaponComponent::Fire(const struct FVector& AimDirection, bool bViaAnimNotify)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "Fire");

	Params::UME_WeaponComponent_Fire_Params Parms{};

	Parms.AimDirection = AimDirection;
	Parms.bViaAnimNotify = bViaAnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WeaponComponent.Drop
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_WeaponComponent::Drop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WeaponComponent", "Drop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PassengerAttachment
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UME_PassengerAttachment::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PassengerAttachment");

	return Clss;
}


// ME_PassengerAttachment Maneater.Default__ME_PassengerAttachment
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PassengerAttachment* UME_PassengerAttachment::GetDefaultObj()
{
	static class UME_PassengerAttachment* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PassengerAttachment*>(UME_PassengerAttachment::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PathFollowingComponent
// (None)

class UClass* UME_PathFollowingComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PathFollowingComponent");

	return Clss;
}


// ME_PathFollowingComponent Maneater.Default__ME_PathFollowingComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PathFollowingComponent* UME_PathFollowingComponent::GetDefaultObj()
{
	static class UME_PathFollowingComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PathFollowingComponent*>(UME_PathFollowingComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PathRequestQueue
// (None)

class UClass* UME_PathRequestQueue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PathRequestQueue");

	return Clss;
}


// ME_PathRequestQueue Maneater.Default__ME_PathRequestQueue
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PathRequestQueue* UME_PathRequestQueue::GetDefaultObj()
{
	static class UME_PathRequestQueue* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PathRequestQueue*>(UME_PathRequestQueue::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PathRequestQueue.DecayQueue
// (Final, Native, Private)
// Parameters:

void UME_PathRequestQueue::DecayQueue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PathRequestQueue", "DecayQueue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PathWisp
// (Actor)

class UClass* AME_PathWisp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PathWisp");

	return Clss;
}


// ME_PathWisp Maneater.Default__ME_PathWisp
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PathWisp* AME_PathWisp::GetDefaultObj()
{
	static class AME_PathWisp* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PathWisp*>(AME_PathWisp::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PawnSpawnInterface
// (None)

class UClass* IME_PawnSpawnInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PawnSpawnInterface");

	return Clss;
}


// ME_PawnSpawnInterface Maneater.Default__ME_PawnSpawnInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_PawnSpawnInterface* IME_PawnSpawnInterface::GetDefaultObj()
{
	static class IME_PawnSpawnInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_PawnSpawnInterface*>(IME_PawnSpawnInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PhysicalImpactResponse
// (None)

class UClass* UME_PhysicalImpactResponse::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PhysicalImpactResponse");

	return Clss;
}


// ME_PhysicalImpactResponse Maneater.Default__ME_PhysicalImpactResponse
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PhysicalImpactResponse* UME_PhysicalImpactResponse::GetDefaultObj()
{
	static class UME_PhysicalImpactResponse* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PhysicalImpactResponse*>(UME_PhysicalImpactResponse::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PhysicalImpactResponse.GetManeaterGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_GameMode*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_GameMode* UME_PhysicalImpactResponse::GetManeaterGameMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PhysicalImpactResponse", "GetManeaterGameMode");

	Params::UME_PhysicalImpactResponse_GetManeaterGameMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PhysicalImpactResponse.GetImpactEffects
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EPhysicalSurface        ImpactingSurface                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUnderwater                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScrape                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactEffect               ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FImpactEffect UME_PhysicalImpactResponse::GetImpactEffects(enum class EPhysicalSurface ImpactingSurface, bool bUnderwater, bool bScrape)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PhysicalImpactResponse", "GetImpactEffects");

	Params::UME_PhysicalImpactResponse_GetImpactEffects_Params Parms{};

	Parms.ImpactingSurface = ImpactingSurface;
	Parms.bUnderwater = bUnderwater;
	Parms.bScrape = bScrape;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Class Maneater.ME_PhysicalMaterial
// (None)

class UClass* UME_PhysicalMaterial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PhysicalMaterial");

	return Clss;
}


// ME_PhysicalMaterial Maneater.Default__ME_PhysicalMaterial
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PhysicalMaterial* UME_PhysicalMaterial::GetDefaultObj()
{
	static class UME_PhysicalMaterial* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PhysicalMaterial*>(UME_PhysicalMaterial::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerCameraManager
// (Actor)

class UClass* AME_PlayerCameraManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerCameraManager");

	return Clss;
}


// ME_PlayerCameraManager Maneater.Default__ME_PlayerCameraManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerCameraManager* AME_PlayerCameraManager::GetDefaultObj()
{
	static class AME_PlayerCameraManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerCameraManager*>(AME_PlayerCameraManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerEvolution
// (None)

class UClass* UME_PlayerEvolution::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerEvolution");

	return Clss;
}


// ME_PlayerEvolution Maneater.Default__ME_PlayerEvolution
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerEvolution* UME_PlayerEvolution::GetDefaultObj()
{
	static class UME_PlayerEvolution* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerEvolution*>(UME_PlayerEvolution::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerEvolution.GetDisplayStatsForEvolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              EffectiveLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEvolutionRarity        ERarity                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEvolutionDisplayStat>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FEvolutionDisplayStat> UME_PlayerEvolution::GetDisplayStatsForEvolution(float EffectiveLevel, class UME_PlayerEvolution* Evolution, enum class EEvolutionRarity ERarity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerEvolution", "GetDisplayStatsForEvolution");

	Params::UME_PlayerEvolution_GetDisplayStatsForEvolution_Params Parms{};

	Parms.EffectiveLevel = EffectiveLevel;
	Parms.Evolution = Evolution;
	Parms.ERarity = ERarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_PlayerObjective
// (None)

class UClass* UME_PlayerObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjective");

	return Clss;
}


// ME_PlayerObjective Maneater.Default__ME_PlayerObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjective* UME_PlayerObjective::GetDefaultObj()
{
	static class UME_PlayerObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjective*>(UME_PlayerObjective::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerObjective.SetObjectiveState
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EObjectiveState         NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTriggeredFromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerObjective::SetObjectiveState(enum class EObjectiveState NewState, bool bTriggeredFromLoad, class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "SetObjectiveState");

	Params::UME_PlayerObjective_SetObjectiveState_Params Parms{};

	Parms.NewState = NewState;
	Parms.bTriggeredFromLoad = bTriggeredFromLoad;
	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.OnGateActivated
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ActivatedGate                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerObjective::OnGateActivated(class AActor* ActivatedGate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "OnGateActivated");

	Params::UME_PlayerObjective_OnGateActivated_Params Parms{};

	Parms.ActivatedGate = ActivatedGate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.IsStoryObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_PlayerObjective::IsStoryObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "IsStoryObjective");

	Params::UME_PlayerObjective_IsStoryObjective_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.IsComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_PlayerObjective::IsComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "IsComplete");

	Params::UME_PlayerObjective_IsComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.IsAssociatedWithActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_PlayerObjective::IsAssociatedWithActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "IsAssociatedWithActor");

	Params::UME_PlayerObjective_IsAssociatedWithActor_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.InitObjectiveFromSave
// (Native, Public)
// Parameters:

void UME_PlayerObjective::InitObjectiveFromSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "InitObjectiveFromSave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.GetTotalProgressPoints
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_PlayerObjective::GetTotalProgressPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetTotalProgressPoints");

	Params::UME_PlayerObjective_GetTotalProgressPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetSubtitleText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_PlayerObjective::GetSubtitleText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetSubtitleText");

	Params::UME_PlayerObjective_GetSubtitleText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetShortObjectiveDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_PlayerObjective::GetShortObjectiveDescription()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetShortObjectiveDescription");

	Params::UME_PlayerObjective_GetShortObjectiveDescription_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetProgressText
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_PlayerObjective::GetProgressText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetProgressText");

	Params::UME_PlayerObjective_GetProgressText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetProductFilterType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EObjectiveProductFilterTypeReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EObjectiveProductFilterType UME_PlayerObjective::GetProductFilterType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetProductFilterType");

	Params::UME_PlayerObjective_GetProductFilterType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetObjectiveType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EObjectiveType          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EObjectiveType UME_PlayerObjective::GetObjectiveType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetObjectiveType");

	Params::UME_PlayerObjective_GetObjectiveType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetObjectiveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EObjectiveState         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EObjectiveState UME_PlayerObjective::GetObjectiveState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetObjectiveState");

	Params::UME_PlayerObjective_GetObjectiveState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetObjectiveRewardsHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDataTableRowHandle         ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle UME_PlayerObjective::GetObjectiveRewardsHandle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetObjectiveRewardsHandle");

	Params::UME_PlayerObjective_GetObjectiveRewardsHandle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetObjectiveImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UME_PlayerObjective::GetObjectiveImage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetObjectiveImage");

	Params::UME_PlayerObjective_GetObjectiveImage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetObjectiveDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UME_PlayerObjective::GetObjectiveDescription()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetObjectiveDescription");

	Params::UME_PlayerObjective_GetObjectiveDescription_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetMapLocators
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<struct FVector>             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FVector> UME_PlayerObjective::GetMapLocators()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetMapLocators");

	Params::UME_PlayerObjective_GetMapLocators_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetCurrentProgressPoints
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_PlayerObjective::GetCurrentProgressPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetCurrentProgressPoints");

	Params::UME_PlayerObjective_GetCurrentProgressPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetCompletionPercentage
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_PlayerObjective::GetCompletionPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetCompletionPercentage");

	Params::UME_PlayerObjective_GetCompletionPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.GetAssignedRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWorldRegion            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWorldRegion UME_PlayerObjective::GetAssignedRegion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "GetAssignedRegion");

	Params::UME_PlayerObjective_GetAssignedRegion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjective.Cheat_ResetObjective
// (Native, Public)
// Parameters:

void UME_PlayerObjective::Cheat_ResetObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "Cheat_ResetObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.Cheat_ProgressObjective
// (Native, Public)
// Parameters:
// int32                              Increment                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerObjective::Cheat_ProgressObjective(int32 Increment)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "Cheat_ProgressObjective");

	Params::UME_PlayerObjective_Cheat_ProgressObjective_Params Parms{};

	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.Cheat_LogObjective
// (Native, Public)
// Parameters:

void UME_PlayerObjective::Cheat_LogObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "Cheat_LogObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjective.Cheat_CompleteObjective
// (Native, Public)
// Parameters:

void UME_PlayerObjective::Cheat_CompleteObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjective", "Cheat_CompleteObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_ObjectCollectObjective
// (None)

class UClass* UME_ObjectCollectObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectCollectObjective");

	return Clss;
}


// ME_ObjectCollectObjective Maneater.Default__ME_ObjectCollectObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ObjectCollectObjective* UME_ObjectCollectObjective::GetDefaultObj()
{
	static class UME_ObjectCollectObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ObjectCollectObjective*>(UME_ObjectCollectObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveLandmark
// (None)

class UClass* UME_PlayerObjectiveLandmark::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveLandmark");

	return Clss;
}


// ME_PlayerObjectiveLandmark Maneater.Default__ME_PlayerObjectiveLandmark
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveLandmark* UME_PlayerObjectiveLandmark::GetDefaultObj()
{
	static class UME_PlayerObjectiveLandmark* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveLandmark*>(UME_PlayerObjectiveLandmark::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveNutrientCache
// (None)

class UClass* UME_PlayerObjectiveNutrientCache::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveNutrientCache");

	return Clss;
}


// ME_PlayerObjectiveNutrientCache Maneater.Default__ME_PlayerObjectiveNutrientCache
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveNutrientCache* UME_PlayerObjectiveNutrientCache::GetDefaultObj()
{
	static class UME_PlayerObjectiveNutrientCache* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveNutrientCache*>(UME_PlayerObjectiveNutrientCache::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveCollectable
// (None)

class UClass* UME_PlayerObjectiveCollectable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveCollectable");

	return Clss;
}


// ME_PlayerObjectiveCollectable Maneater.Default__ME_PlayerObjectiveCollectable
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveCollectable* UME_PlayerObjectiveCollectable::GetDefaultObj()
{
	static class UME_PlayerObjectiveCollectable* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveCollectable*>(UME_PlayerObjectiveCollectable::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveGrates
// (None)

class UClass* UME_PlayerObjectiveGrates::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveGrates");

	return Clss;
}


// ME_PlayerObjectiveGrates Maneater.Default__ME_PlayerObjectiveGrates
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveGrates* UME_PlayerObjectiveGrates::GetDefaultObj()
{
	static class UME_PlayerObjectiveGrates* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveGrates*>(UME_PlayerObjectiveGrates::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveGates
// (None)

class UClass* UME_PlayerObjectiveGates::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveGates");

	return Clss;
}


// ME_PlayerObjectiveGates Maneater.Default__ME_PlayerObjectiveGates
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveGates* UME_PlayerObjectiveGates::GetDefaultObj()
{
	static class UME_PlayerObjectiveGates* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveGates*>(UME_PlayerObjectiveGates::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveCustom
// (None)

class UClass* UME_PlayerObjectiveCustom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveCustom");

	return Clss;
}


// ME_PlayerObjectiveCustom Maneater.Default__ME_PlayerObjectiveCustom
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveCustom* UME_PlayerObjectiveCustom::GetDefaultObj()
{
	static class UME_PlayerObjectiveCustom* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveCustom*>(UME_PlayerObjectiveCustom::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveGrotto
// (None)

class UClass* UME_PlayerObjectiveGrotto::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveGrotto");

	return Clss;
}


// ME_PlayerObjectiveGrotto Maneater.Default__ME_PlayerObjectiveGrotto
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveGrotto* UME_PlayerObjectiveGrotto::GetDefaultObj()
{
	static class UME_PlayerObjectiveGrotto* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveGrotto*>(UME_PlayerObjectiveGrotto::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerObjectiveGrotto.GetAssociatedGrotto
// (Final, Native, Public)
// Parameters:
// TSoftObjectPtr<class AActor>       ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class AActor> UME_PlayerObjectiveGrotto::GetAssociatedGrotto()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveGrotto", "GetAssociatedGrotto");

	Params::UME_PlayerObjectiveGrotto_GetAssociatedGrotto_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_PlayerObjectiveCutscene
// (None)

class UClass* UME_PlayerObjectiveCutscene::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveCutscene");

	return Clss;
}


// ME_PlayerObjectiveCutscene Maneater.Default__ME_PlayerObjectiveCutscene
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveCutscene* UME_PlayerObjectiveCutscene::GetDefaultObj()
{
	static class UME_PlayerObjectiveCutscene* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveCutscene*>(UME_PlayerObjectiveCutscene::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveBoss
// (None)

class UClass* UME_PlayerObjectiveBoss::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveBoss");

	return Clss;
}


// ME_PlayerObjectiveBoss Maneater.Default__ME_PlayerObjectiveBoss
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveBoss* UME_PlayerObjectiveBoss::GetDefaultObj()
{
	static class UME_PlayerObjectiveBoss* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveBoss*>(UME_PlayerObjectiveBoss::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveDestroyThrashable
// (None)

class UClass* UME_PlayerObjectiveDestroyThrashable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveDestroyThrashable");

	return Clss;
}


// ME_PlayerObjectiveDestroyThrashable Maneater.Default__ME_PlayerObjectiveDestroyThrashable
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveDestroyThrashable* UME_PlayerObjectiveDestroyThrashable::GetDefaultObj()
{
	static class UME_PlayerObjectiveDestroyThrashable* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveDestroyThrashable*>(UME_PlayerObjectiveDestroyThrashable::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_StoryEvent
// (None)

class UClass* UME_StoryEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_StoryEvent");

	return Clss;
}


// ME_StoryEvent Maneater.Default__ME_StoryEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_StoryEvent* UME_StoryEvent::GetDefaultObj()
{
	static class UME_StoryEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_StoryEvent*>(UME_StoryEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_RegionObjectiveCollection
// (None)

class UClass* UME_RegionObjectiveCollection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_RegionObjectiveCollection");

	return Clss;
}


// ME_RegionObjectiveCollection Maneater.Default__ME_RegionObjectiveCollection
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_RegionObjectiveCollection* UME_RegionObjectiveCollection::GetDefaultObj()
{
	static class UME_RegionObjectiveCollection* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_RegionObjectiveCollection*>(UME_RegionObjectiveCollection::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveManager
// (Actor)

class UClass* AME_PlayerObjectiveManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveManager");

	return Clss;
}


// ME_PlayerObjectiveManager Maneater.Default__ME_PlayerObjectiveManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerObjectiveManager* AME_PlayerObjectiveManager::GetDefaultObj()
{
	static class AME_PlayerObjectiveManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerObjectiveManager*>(AME_PlayerObjectiveManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerObjectiveManager.TutorialFinished
// (Final, Native, Public)
// Parameters:

void AME_PlayerObjectiveManager::TutorialFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "TutorialFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.StartTimeTrial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Rings                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::StartTimeTrial(class AActor* WorldContextActor, float StartTime, int32 Rings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "StartTimeTrial");

	Params::AME_PlayerObjectiveManager_StartTimeTrial_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;
	Parms.StartTime = StartTime;
	Parms.Rings = Rings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.SetObjectState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      FoundActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EObjectiveProgressState EState                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::SetObjectState(class AActor* FoundActor, enum class EObjectiveProgressState EState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "SetObjectState");

	Params::AME_PlayerObjectiveManager_SetObjectState_Params Parms{};

	Parms.FoundActor = FoundActor;
	Parms.EState = EState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.SetCustomObjectiveState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EObjectiveState         NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      AssociatedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::SetCustomObjectiveState(enum class EObjectiveState NewState, class AActor* AssociatedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "SetCustomObjectiveState");

	Params::AME_PlayerObjectiveManager_SetCustomObjectiveState_Params Parms{};

	Parms.NewState = NewState;
	Parms.AssociatedActor = AssociatedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnRingPassed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeIncrease                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnRingPassed(class AActor* WorldContextActor, float TimeIncrease)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnRingPassed");

	Params::AME_PlayerObjectiveManager_OnRingPassed_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;
	Parms.TimeIncrease = TimeIncrease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnRegionChanged
// (Final, Native, Protected)
// Parameters:
// enum class EWorldRegion            Region                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  RegionIcon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnRegionChanged(enum class EWorldRegion Region, class UTexture2D* RegionIcon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnRegionChanged");

	Params::AME_PlayerObjectiveManager_OnRegionChanged_Params Parms{};

	Parms.Region = Region;
	Parms.RegionIcon = RegionIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnPlayerLevelChanged
// (Final, Native, Public)
// Parameters:
// int32                              NewGrowthLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bChangeFromTheoretical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnPlayerLevelChanged(int32 NewGrowthLevel, bool bChangeFromTheoretical)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnPlayerLevelChanged");

	Params::AME_PlayerObjectiveManager_OnPlayerLevelChanged_Params Parms{};

	Parms.NewGrowthLevel = NewGrowthLevel;
	Parms.bChangeFromTheoretical = bChangeFromTheoretical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnInfamyRankUp
// (Final, Native, Public)
// Parameters:
// int32                              Rank                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnInfamyRankUp(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnInfamyRankUp");

	Params::AME_PlayerObjectiveManager_OnInfamyRankUp_Params Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnGrowthStageChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// enum class EPlayerGrowthStage      OldGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReinitPose                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnGrowthStageChanged(enum class EPlayerGrowthStage& OldGrowthStage, enum class EPlayerGrowthStage& NewGrowthStage, bool bReinitPose)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnGrowthStageChanged");

	Params::AME_PlayerObjectiveManager_OnGrowthStageChanged_Params Parms{};

	Parms.OldGrowthStage = OldGrowthStage;
	Parms.NewGrowthStage = NewGrowthStage;
	Parms.bReinitPose = bReinitPose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnGrottoEntered
// (Final, Native, Public)
// Parameters:
// class AME_Grotto*                  ME_Grotto                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnGrottoEntered(class AME_Grotto* ME_Grotto)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnGrottoEntered");

	Params::AME_PlayerObjectiveManager_OnGrottoEntered_Params Parms{};

	Parms.ME_Grotto = ME_Grotto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnGateActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ActivatedGate                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnGateActivated(class AActor* ActivatedGate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnGateActivated");

	Params::AME_PlayerObjectiveManager_OnGateActivated_Params Parms{};

	Parms.ActivatedGate = ActivatedGate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnDLCEntitlementStatusInitialized
// (Final, Native, Public)
// Parameters:
// enum class EDLCType                DLCType                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InitialStatus                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnDLCEntitlementStatusInitialized(enum class EDLCType DLCType, bool InitialStatus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnDLCEntitlementStatusInitialized");

	Params::AME_PlayerObjectiveManager_OnDLCEntitlementStatusInitialized_Params Parms{};

	Parms.DLCType = DLCType;
	Parms.InitialStatus = InitialStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnDLCEntitlementStatusChanged
// (Final, Native, Public)
// Parameters:
// enum class EDLCType                DLCType                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               NewStatus                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::OnDLCEntitlementStatusChanged(enum class EDLCType DLCType, bool NewStatus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnDLCEntitlementStatusChanged");

	Params::AME_PlayerObjectiveManager_OnDLCEntitlementStatusChanged_Params Parms{};

	Parms.DLCType = DLCType;
	Parms.NewStatus = NewStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.OnBountyPlacedOnHold
// (Final, Native, Public)
// Parameters:

void AME_PlayerObjectiveManager::OnBountyPlacedOnHold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "OnBountyPlacedOnHold");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.ObjectUnloaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      UnloadedActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::ObjectUnloaded(class AActor* UnloadedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "ObjectUnloaded");

	Params::AME_PlayerObjectiveManager_ObjectUnloaded_Params Parms{};

	Parms.UnloadedActor = UnloadedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.ObjectLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      LoadedActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::ObjectLoaded(class AActor* LoadedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "ObjectLoaded");

	Params::AME_PlayerObjectiveManager_ObjectLoaded_Params Parms{};

	Parms.LoadedActor = LoadedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.LandmarkObjectBitten
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      LandmarkActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::LandmarkObjectBitten(class AActor* LandmarkActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "LandmarkObjectBitten");

	Params::AME_PlayerObjectiveManager_LandmarkObjectBitten_Params Parms{};

	Parms.LandmarkActor = LandmarkActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.IsBaseStoryFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerObjectiveManager::IsBaseStoryFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "IsBaseStoryFinished");

	Params::AME_PlayerObjectiveManager_IsBaseStoryFinished_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetStoryConditionStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FConditionStatus>    ConditionResults                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::GetStoryConditionStatus(TArray<struct FConditionStatus>* ConditionResults)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetStoryConditionStatus");

	Params::AME_PlayerObjectiveManager_GetStoryConditionStatus_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ConditionResults != nullptr)
		*ConditionResults = std::move(Parms.ConditionResults);

}


// Function Maneater.ME_PlayerObjectiveManager.GetRegionPercentComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EWorldRegion            Region                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerObjectiveManager::GetRegionPercentComplete(enum class EWorldRegion Region)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetRegionPercentComplete");

	Params::AME_PlayerObjectiveManager_GetRegionPercentComplete_Params Parms{};

	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetObjectState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      FoundActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EObjectiveProgressState ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EObjectiveProgressState AME_PlayerObjectiveManager::GetObjectState(class AActor* FoundActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetObjectState");

	Params::AME_PlayerObjectiveManager_GetObjectState_Params Parms{};

	Parms.FoundActor = FoundActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetObjectiveFromActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      SearchingActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EObjectiveType          FilterType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerObjective*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PlayerObjective* AME_PlayerObjectiveManager::GetObjectiveFromActor(class AActor* SearchingActor, enum class EObjectiveType FilterType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetObjectiveFromActor");

	Params::AME_PlayerObjectiveManager_GetObjectiveFromActor_Params Parms{};

	Parms.SearchingActor = SearchingActor;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetObjectiveById
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                       ComparisonId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerObjective*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PlayerObjective* AME_PlayerObjectiveManager::GetObjectiveById(const struct FGuid& ComparisonId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetObjectiveById");

	Params::AME_PlayerObjectiveManager_GetObjectiveById_Params Parms{};

	Parms.ComparisonId = ComparisonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetLastBossKilled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EBossFightSequence      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EBossFightSequence AME_PlayerObjectiveManager::GetLastBossKilled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetLastBossKilled");

	Params::AME_PlayerObjectiveManager_GetLastBossKilled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetGamePercentComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerObjectiveManager::GetGamePercentComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetGamePercentComplete");

	Params::AME_PlayerObjectiveManager_GetGamePercentComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetGameCompletionPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerObjectiveManager::GetGameCompletionPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetGameCompletionPercentage");

	Params::AME_PlayerObjectiveManager_GetGameCompletionPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetEpisodeProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              StoryIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerObjectiveManager::GetEpisodeProgress(int32 StoryIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetEpisodeProgress");

	Params::AME_PlayerObjectiveManager_GetEpisodeProgress_Params Parms{};

	Parms.StoryIndex = StoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.GetCurrentStoryIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerObjectiveManager::GetCurrentStoryIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "GetCurrentStoryIndex");

	Params::AME_PlayerObjectiveManager_GetCurrentStoryIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerObjectiveManager.DelayedBossFightAvailableBroadcast
// (Final, Native, Private)
// Parameters:
// class UME_PlayerObjectiveBoss*     BossObjective                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::DelayedBossFightAvailableBroadcast(class UME_PlayerObjectiveBoss* BossObjective)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "DelayedBossFightAvailableBroadcast");

	Params::AME_PlayerObjectiveManager_DelayedBossFightAvailableBroadcast_Params Parms{};

	Parms.BossObjective = BossObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.CheckNextStoryEvent
// (Final, Native, Public)
// Parameters:
// bool                               bForceAdvanceStoryCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::CheckNextStoryEvent(bool bForceAdvanceStoryCheck)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "CheckNextStoryEvent");

	Params::AME_PlayerObjectiveManager_CheckNextStoryEvent_Params Parms{};

	Parms.bForceAdvanceStoryCheck = bForceAdvanceStoryCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.Cheat_ResetObjective
// (Final, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::Cheat_ResetObjective(class FName ObjName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "Cheat_ResetObjective");

	Params::AME_PlayerObjectiveManager_Cheat_ResetObjective_Params Parms{};

	Parms.ObjName = ObjName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.Cheat_ProgressObjective
// (Final, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Increment                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::Cheat_ProgressObjective(class FName ObjName, int32 Increment)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "Cheat_ProgressObjective");

	Params::AME_PlayerObjectiveManager_Cheat_ProgressObjective_Params Parms{};

	Parms.ObjName = ObjName;
	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.Cheat_CompleteObjective
// (Final, Native, Public)
// Parameters:
// class FName                        ObjName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerObjectiveManager::Cheat_CompleteObjective(class FName ObjName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "Cheat_CompleteObjective");

	Params::AME_PlayerObjectiveManager_Cheat_CompleteObjective_Params Parms{};

	Parms.ObjName = ObjName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerObjectiveManager.AdvanceToNextStoryEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerObjectiveManager::AdvanceToNextStoryEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerObjectiveManager", "AdvanceToNextStoryEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PlayerSharkController
// (Actor, PlayerController)

class UClass* AME_PlayerSharkController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerSharkController");

	return Clss;
}


// ME_PlayerSharkController Maneater.Default__ME_PlayerSharkController
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerSharkController* AME_PlayerSharkController::GetDefaultObj()
{
	static class AME_PlayerSharkController* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerSharkController*>(AME_PlayerSharkController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerSharkController.SetHUDVisibilityChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bVisible                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkController::SetHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "SetHUDVisibilityChanged");

	Params::AME_PlayerSharkController_SetHUDVisibilityChanged_Params Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkController.ReceivePostInitializeComponents
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_PlayerSharkController::ReceivePostInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "ReceivePostInitializeComponents");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_PlayerSharkController.OnRevealMap
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     MapLocation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Intensity                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkController::OnRevealMap(struct FVector& MapLocation, float Radius, float Intensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "OnRevealMap");

	Params::AME_PlayerSharkController_OnRevealMap_Params Parms{};

	Parms.MapLocation = MapLocation;
	Parms.Radius = Radius;
	Parms.Intensity = Intensity;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkController.OnPossessedPawn
// (Event, Public, BlueprintEvent)
// Parameters:
// class AME_PlayerSharkCharacter*    PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkController::OnPossessedPawn(class AME_PlayerSharkCharacter* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "OnPossessedPawn");

	Params::AME_PlayerSharkController_OnPossessedPawn_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkController.OnPlayerDied
// (Event, Public, BlueprintEvent)
// Parameters:
// class AME_PlayerSharkCharacter*    PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkController::OnPlayerDied(class AME_PlayerSharkCharacter* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "OnPlayerDied");

	Params::AME_PlayerSharkController_OnPlayerDied_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkController.IsCinematicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkController::IsCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "IsCinematicMode");

	Params::AME_PlayerSharkController_IsCinematicMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkController.GetKeysForAction
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ActionName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>Bindings                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkController::GetKeysForAction(class FName ActionName, TArray<struct FInputActionKeyMapping>* Bindings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkController", "GetKeysForAction");

	Params::AME_PlayerSharkController_GetKeysForAction_Params Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Bindings != nullptr)
		*Bindings = std::move(Parms.Bindings);

}


// Class Maneater.ME_PlayerSharkMovementComponent
// (None)

class UClass* UME_PlayerSharkMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerSharkMovementComponent");

	return Clss;
}


// ME_PlayerSharkMovementComponent Maneater.Default__ME_PlayerSharkMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerSharkMovementComponent* UME_PlayerSharkMovementComponent::GetDefaultObj()
{
	static class UME_PlayerSharkMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerSharkMovementComponent*>(UME_PlayerSharkMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerSharkMovementComponent.SetCrusingWaterLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewCrusingWaterline                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    ChangeContext                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerSharkMovementComponent::SetCrusingWaterLine(bool bNewCrusingWaterline, enum class ECharacterActionMode ChangeContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkMovementComponent", "SetCrusingWaterLine");

	Params::UME_PlayerSharkMovementComponent_SetCrusingWaterLine_Params Parms{};

	Parms.bNewCrusingWaterline = bNewCrusingWaterline;
	Parms.ChangeContext = ChangeContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PlayerSharkState
// (Actor)

class UClass* AME_PlayerSharkState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerSharkState");

	return Clss;
}


// ME_PlayerSharkState Maneater.Default__ME_PlayerSharkState
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerSharkState* AME_PlayerSharkState::GetDefaultObj()
{
	static class AME_PlayerSharkState* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerSharkState*>(AME_PlayerSharkState::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerSharkState.SetWaypoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      TargetActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TargetLocation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AME_WaypointMarker*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_WaypointMarker* AME_PlayerSharkState::SetWaypoint(class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetWaypoint");

	Params::AME_PlayerSharkState_SetWaypoint_Params Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = TargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.SetTeleporterDestination
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetTeleporterDestination(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetTeleporterDestination");

	Params::AME_PlayerSharkState_SetTeleporterDestination_Params Parms{};

	Parms.Location = Location;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EPersistentStatType     StatToModify                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetStat(enum class EPersistentStatType StatToModify, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetStat");

	Params::AME_PlayerSharkState_SetStat_Params Parms{};

	Parms.StatToModify = StatToModify;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetSlottedEvolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEvolutionSlot          EvolutionSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerEvolution*         Evolution                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::SetSlottedEvolution(enum class EEvolutionSlot EvolutionSlot, class UME_PlayerEvolution* Evolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetSlottedEvolution");

	Params::AME_PlayerSharkState_SetSlottedEvolution_Params Parms{};

	Parms.EvolutionSlot = EvolutionSlot;
	Parms.Evolution = Evolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.SetRespawnLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewRespawnLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRespawnRotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSaveGame                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetRespawnLocation(struct FVector& NewRespawnLocation, const struct FRotator& NewRespawnRotation, bool bSaveGame)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetRespawnLocation");

	Params::AME_PlayerSharkState_SetRespawnLocation_Params Parms{};

	Parms.NewRespawnLocation = NewRespawnLocation;
	Parms.NewRespawnRotation = NewRespawnRotation;
	Parms.bSaveGame = bSaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetNewEvolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsNewEvolution                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetNewEvolution(class UME_PlayerEvolution* Evolution, bool bIsNewEvolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetNewEvolution");

	Params::AME_PlayerSharkState_SetNewEvolution_Params Parms{};

	Parms.Evolution = Evolution;
	Parms.bIsNewEvolution = bIsNewEvolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetInventoryEvolutionEquipped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEvolutionSlot          AssignedSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetInventoryEvolutionEquipped(class UME_PlayerEvolution* Evolution, enum class EEvolutionSlot AssignedSlot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetInventoryEvolutionEquipped");

	Params::AME_PlayerSharkState_SetInventoryEvolutionEquipped_Params Parms{};

	Parms.Evolution = Evolution;
	Parms.AssignedSlot = AssignedSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetHasNewEvolutionAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bAvailable                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetHasNewEvolutionAvailable(bool bAvailable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetHasNewEvolutionAvailable");

	Params::AME_PlayerSharkState_SetHasNewEvolutionAvailable_Params Parms{};

	Parms.bAvailable = bAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetGrowthStage
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReinitPose                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetGrowthStage(enum class EPlayerGrowthStage NewGrowthStage, bool bReinitPose)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetGrowthStage");

	Params::AME_PlayerSharkState_SetGrowthStage_Params Parms{};

	Parms.NewGrowthStage = NewGrowthStage;
	Parms.bReinitPose = bReinitPose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.SetGrowthLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewGrowthLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ForceGrowth                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCauseGameSave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bChangeFromTheoretical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::SetGrowthLevel(int32 NewGrowthLevel, bool ForceGrowth, bool bCauseGameSave, bool bChangeFromTheoretical)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "SetGrowthLevel");

	Params::AME_PlayerSharkState_SetGrowthLevel_Params Parms{};

	Parms.NewGrowthLevel = NewGrowthLevel;
	Parms.ForceGrowth = ForceGrowth;
	Parms.bCauseGameSave = bCauseGameSave;
	Parms.bChangeFromTheoretical = bChangeFromTheoretical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.RemoveWaypoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkState::RemoveWaypoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "RemoveWaypoint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.RemoveInventoryEvolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerEvolution*         ToBeRemovedEvolution                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::RemoveInventoryEvolution(class UME_PlayerEvolution* ToBeRemovedEvolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "RemoveInventoryEvolution");

	Params::AME_PlayerSharkState_RemoveInventoryEvolution_Params Parms{};

	Parms.ToBeRemovedEvolution = ToBeRemovedEvolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.ReceiveBountyChange
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              NewBountyDollars                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      BountyChangeInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::ReceiveBountyChange(float NewBountyDollars, class AActor* BountyChangeInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "ReceiveBountyChange");

	Params::AME_PlayerSharkState_ReceiveBountyChange_Params Parms{};

	Parms.NewBountyDollars = NewBountyDollars;
	Parms.BountyChangeInstigator = BountyChangeInstigator;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkState.PurchaseInventoryEvolutionUpgrade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::PurchaseInventoryEvolutionUpgrade(class UME_PlayerEvolution* Evolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "PurchaseInventoryEvolutionUpgrade");

	Params::AME_PlayerSharkState_PurchaseInventoryEvolutionUpgrade_Params Parms{};

	Parms.Evolution = Evolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.OnWorldRegionChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AME_WorldRegionVolume*       NewRegion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::OnWorldRegionChanged(class AME_WorldRegionVolume* NewRegion)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "OnWorldRegionChanged");

	Params::AME_PlayerSharkState_OnWorldRegionChanged_Params Parms{};

	Parms.NewRegion = NewRegion;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkState.OnPlayerBountyChanged
// (Final, Native, Public)
// Parameters:
// float                              NewBountyDollars                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      BountyChangeInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::OnPlayerBountyChanged(float NewBountyDollars, class AActor* BountyChangeInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "OnPlayerBountyChanged");

	Params::AME_PlayerSharkState_OnPlayerBountyChanged_Params Parms{};

	Parms.NewBountyDollars = NewBountyDollars;
	Parms.BountyChangeInstigator = BountyChangeInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.OnNutrientsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                              NutrientDelta                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ENutrientType           NutrientType                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::OnNutrientsChanged(int32 NutrientDelta, enum class ENutrientType& NutrientType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "OnNutrientsChanged");

	Params::AME_PlayerSharkState_OnNutrientsChanged_Params Parms{};

	Parms.NutrientDelta = NutrientDelta;
	Parms.NutrientType = NutrientType;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkState.OnIncreasedGrowthStage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// enum class EPlayerGrowthStage      NewGrowthStage                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::OnIncreasedGrowthStage(enum class EPlayerGrowthStage& NewGrowthStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "OnIncreasedGrowthStage");

	Params::AME_PlayerSharkState_OnIncreasedGrowthStage_Params Parms{};

	Parms.NewGrowthStage = NewGrowthStage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkState.OnGainedGrowthLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              NewGrowthLevel                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::OnGainedGrowthLevel(int32 NewGrowthLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "OnGainedGrowthLevel");

	Params::AME_PlayerSharkState_OnGainedGrowthLevel_Params Parms{};

	Parms.NewGrowthLevel = NewGrowthLevel;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_PlayerSharkState.ModifyStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EPersistentStatType     StatToModify                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ValueChange                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerSharkState::ModifyStat(enum class EPersistentStatType StatToModify, int32 ValueChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "ModifyStat");

	Params::AME_PlayerSharkState_ModifyStat_Params Parms{};

	Parms.StatToModify = StatToModify;
	Parms.ValueChange = ValueChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.ModifyGrowthStage
// (Final, Native, Public)
// Parameters:
// int32                              GrowthChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::ModifyGrowthStage(int32 GrowthChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "ModifyGrowthStage");

	Params::AME_PlayerSharkState_ModifyGrowthStage_Params Parms{};

	Parms.GrowthChange = GrowthChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.ModifyGrowthLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              GrowthLevelChange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::ModifyGrowthLevel(int32 GrowthLevelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "ModifyGrowthLevel");

	Params::AME_PlayerSharkState_ModifyGrowthLevel_Params Parms{};

	Parms.GrowthLevelChange = GrowthLevelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.LevelUpRequiresGrowth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewGrowthLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::LevelUpRequiresGrowth(int32 NewGrowthLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "LevelUpRequiresGrowth");

	Params::AME_PlayerSharkState_LevelUpRequiresGrowth_Params Parms{};

	Parms.NewGrowthLevel = NewGrowthLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.IsInstigatingAnyAlerts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::IsInstigatingAnyAlerts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "IsInstigatingAnyAlerts");

	Params::AME_PlayerSharkState_IsInstigatingAnyAlerts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.IsGrowthStageAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::IsGrowthStageAvailable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "IsGrowthStageAvailable");

	Params::AME_PlayerSharkState_IsGrowthStageAvailable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.IsEvolutionEquip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_PlayerEvolution*         Evolution                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::IsEvolutionEquip(class UME_PlayerEvolution* Evolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "IsEvolutionEquip");

	Params::AME_PlayerSharkState_IsEvolutionEquip_Params Parms{};

	Parms.Evolution = Evolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetSlottedEvolution
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEvolutionSlot          EvolutionSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerEvolution*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_PlayerEvolution* AME_PlayerSharkState::GetSlottedEvolution(enum class EEvolutionSlot EvolutionSlot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetSlottedEvolution");

	Params::AME_PlayerSharkState_GetSlottedEvolution_Params Parms{};

	Parms.EvolutionSlot = EvolutionSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetRespawnTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AME_PlayerSharkState::GetRespawnTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetRespawnTransform");

	Params::AME_PlayerSharkState_GetRespawnTransform_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetRespawnLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AME_PlayerSharkState::GetRespawnLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetRespawnLocation");

	Params::AME_PlayerSharkState_GetRespawnLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetNumberOfSetItemsEquippedByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEvolutionSetType       EType                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerSharkState::GetNumberOfSetItemsEquippedByType(enum class EEvolutionSetType EType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetNumberOfSetItemsEquippedByType");

	Params::AME_PlayerSharkState_GetNumberOfSetItemsEquippedByType_Params Parms{};

	Parms.EType = EType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetMinGrowthLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerSharkState::GetMinGrowthLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetMinGrowthLevel");

	Params::AME_PlayerSharkState_GetMinGrowthLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetMaxGrowthLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AME_PlayerSharkState::GetMaxGrowthLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetMaxGrowthLevel");

	Params::AME_PlayerSharkState_GetMaxGrowthLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetInventoryEvolutions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UME_PlayerEvolution*> Evolutions                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEvolutionSlot          SlotTypeFilter                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::GetInventoryEvolutions(TArray<class UME_PlayerEvolution*>* Evolutions, enum class EEvolutionSlot SlotTypeFilter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetInventoryEvolutions");

	Params::AME_PlayerSharkState_GetInventoryEvolutions_Params Parms{};

	Parms.SlotTypeFilter = SlotTypeFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Evolutions != nullptr)
		*Evolutions = std::move(Parms.Evolutions);

}


// Function Maneater.ME_PlayerSharkState.GetInventoryEvolutionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEvolutionData              OutEvolutionData                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::GetInventoryEvolutionData(class UME_PlayerEvolution* Evolution, struct FEvolutionData* OutEvolutionData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetInventoryEvolutionData");

	Params::AME_PlayerSharkState_GetInventoryEvolutionData_Params Parms{};

	Parms.Evolution = Evolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutEvolutionData != nullptr)
		*OutEvolutionData = std::move(Parms.OutEvolutionData);

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetHasNewEvolutionAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::GetHasNewEvolutionAvailable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetHasNewEvolutionAvailable");

	Params::AME_PlayerSharkState_GetHasNewEvolutionAvailable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetGrowthPct
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bRelativeToNextStage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AME_PlayerSharkState::GetGrowthPct(bool bRelativeToNextStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetGrowthPct");

	Params::AME_PlayerSharkState_GetGrowthPct_Params Parms{};

	Parms.bRelativeToNextStage = bRelativeToNextStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetEvolutionSetName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEvolutionSetType       EType                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AME_PlayerSharkState::GetEvolutionSetName(enum class EEvolutionSetType EType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetEvolutionSetName");

	Params::AME_PlayerSharkState_GetEvolutionSetName_Params Parms{};

	Parms.EType = EType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetEvolutionsBelongingToSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEvolutionSetType       EType                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UME_PlayerEvolution*> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UME_PlayerEvolution*> AME_PlayerSharkState::GetEvolutionsBelongingToSet(enum class EEvolutionSetType EType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetEvolutionsBelongingToSet");

	Params::AME_PlayerSharkState_GetEvolutionsBelongingToSet_Params Parms{};

	Parms.EType = EType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.GetDisplayStatsForEvolutionSetBonus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEvolutionSetType       EType                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumEquip                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEvolutionDisplayStat>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FEvolutionDisplayStat> AME_PlayerSharkState::GetDisplayStatsForEvolutionSetBonus(enum class EEvolutionSetType EType, int32 NumEquip)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "GetDisplayStatsForEvolutionSetBonus");

	Params::AME_PlayerSharkState_GetDisplayStatsForEvolutionSetBonus_Params Parms{};

	Parms.EType = EType;
	Parms.NumEquip = NumEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.DeductNutrientCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEvolutionUpgradeCost       UpgradeCost                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::DeductNutrientCost(struct FEvolutionUpgradeCost& UpgradeCost)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "DeductNutrientCost");

	Params::AME_PlayerSharkState_DeductNutrientCost_Params Parms{};

	Parms.UpgradeCost = UpgradeCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.ClearTeleporterDestination
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkState::ClearTeleporterDestination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "ClearTeleporterDestination");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.CheckAndGrantPlayerEntitlements
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_PlayerSharkState::CheckAndGrantPlayerEntitlements()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "CheckAndGrantPlayerEntitlements");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerSharkState.CanPurchaseEvolutionUpgrade
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEvolutionUpgradePrice      UpgradePrice                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::CanPurchaseEvolutionUpgrade(struct FEvolutionUpgradePrice& UpgradePrice)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "CanPurchaseEvolutionUpgrade");

	Params::AME_PlayerSharkState_CanPurchaseEvolutionUpgrade_Params Parms{};

	Parms.UpgradePrice = UpgradePrice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.CanAffordEvolutionCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEvolutionUpgradeCost       UpgradeCost                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::CanAffordEvolutionCost(struct FEvolutionUpgradeCost& UpgradeCost)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "CanAffordEvolutionCost");

	Params::AME_PlayerSharkState_CanAffordEvolutionCost_Params Parms{};

	Parms.UpgradeCost = UpgradeCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.AddInventoryEvolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UME_PlayerEvolution*         NewEvolution                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEvolutionRarity        Rarity                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_PlayerSharkState::AddInventoryEvolution(class UME_PlayerEvolution* NewEvolution, enum class EEvolutionRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "AddInventoryEvolution");

	Params::AME_PlayerSharkState_AddInventoryEvolution_Params Parms{};

	Parms.NewEvolution = NewEvolution;
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerSharkState.AcceptGrowthStageAtGrotto
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EPlayerGrowthStage      PlayerGrowthStage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_PlayerSharkState::AcceptGrowthStageAtGrotto(enum class EPlayerGrowthStage PlayerGrowthStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerSharkState", "AcceptGrowthStageAtGrotto");

	Params::AME_PlayerSharkState_AcceptGrowthStageAtGrotto_Params Parms{};

	Parms.PlayerGrowthStage = PlayerGrowthStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PlayerTargetingSystem
// (None)

class UClass* UME_PlayerTargetingSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerTargetingSystem");

	return Clss;
}


// ME_PlayerTargetingSystem Maneater.Default__ME_PlayerTargetingSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerTargetingSystem* UME_PlayerTargetingSystem::GetDefaultObj()
{
	static class UME_PlayerTargetingSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerTargetingSystem*>(UME_PlayerTargetingSystem::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerTargetingSystem.SetShowSilhouette
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      PingTarget                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EOutlineColor           ForcedOutlineColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerTargetingSystem::SetShowSilhouette(class AActor* PingTarget, bool bShow, enum class EOutlineColor ForcedOutlineColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "SetShowSilhouette");

	Params::UME_PlayerTargetingSystem_SetShowSilhouette_Params Parms{};

	Parms.PingTarget = PingTarget;
	Parms.bShow = bShow;
	Parms.ForcedOutlineColor = ForcedOutlineColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerTargetingSystem.RemovePotentialTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerTargetingSystem::RemovePotentialTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "RemovePotentialTarget");

	Params::UME_PlayerTargetingSystem_RemovePotentialTarget_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_PlayerTargetingSystem.GetSoftLockOnTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_PlayerTargetingSystem::GetSoftLockOnTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetSoftLockOnTargetLocation");

	Params::UME_PlayerTargetingSystem_GetSoftLockOnTargetLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetLockOnTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_PlayerTargetingSystem::GetLockOnTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetLockOnTargetLocation");

	Params::UME_PlayerTargetingSystem_GetLockOnTargetLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetFocusedTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UME_PlayerTargetingSystem::GetFocusedTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetFocusedTargetLocation");

	Params::UME_PlayerTargetingSystem_GetFocusedTargetLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetCurrentWhipShotTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_PlayerTargetingSystem::GetCurrentWhipShotTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetCurrentWhipShotTarget");

	Params::UME_PlayerTargetingSystem_GetCurrentWhipShotTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetCurrentSoftLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_PlayerTargetingSystem::GetCurrentSoftLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetCurrentSoftLockOnTarget");

	Params::UME_PlayerTargetingSystem_GetCurrentSoftLockOnTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetCurrentLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_PlayerTargetingSystem::GetCurrentLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetCurrentLockOnTarget");

	Params::UME_PlayerTargetingSystem_GetCurrentLockOnTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetCurrentFocusedTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_PlayerTargetingSystem::GetCurrentFocusedTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetCurrentFocusedTarget");

	Params::UME_PlayerTargetingSystem_GetCurrentFocusedTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.GetCurrentFocusedObjectiveTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_PlayerTargetingSystem::GetCurrentFocusedObjectiveTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "GetCurrentFocusedObjectiveTarget");

	Params::UME_PlayerTargetingSystem_GetCurrentFocusedObjectiveTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_PlayerTargetingSystem.AddPotentialTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOnlyWhipshotTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsObjectiveTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_PlayerTargetingSystem::AddPotentialTarget(class AActor* Actor, bool bOnlyWhipshotTarget, bool bIsObjectiveTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerTargetingSystem", "AddPotentialTarget");

	Params::UME_PlayerTargetingSystem_AddPotentialTarget_Params Parms{};

	Parms.Actor = Actor;
	Parms.bOnlyWhipshotTarget = bOnlyWhipshotTarget;
	Parms.bIsObjectiveTarget = bIsObjectiveTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_PlayerUIAvatarActor
// (Actor)

class UClass* AME_PlayerUIAvatarActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerUIAvatarActor");

	return Clss;
}


// ME_PlayerUIAvatarActor Maneater.Default__ME_PlayerUIAvatarActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_PlayerUIAvatarActor* AME_PlayerUIAvatarActor::GetDefaultObj()
{
	static class AME_PlayerUIAvatarActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_PlayerUIAvatarActor*>(AME_PlayerUIAvatarActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_PlayerUIAvatarActor.ReceivePostInitializeComponents
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_PlayerUIAvatarActor::ReceivePostInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_PlayerUIAvatarActor", "ReceivePostInitializeComponents");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.ME_PlayerUIAvatarMeshComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent, SkeletalMeshComponent)

class UClass* UME_PlayerUIAvatarMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerUIAvatarMeshComponent");

	return Clss;
}


// ME_PlayerUIAvatarMeshComponent Maneater.Default__ME_PlayerUIAvatarMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerUIAvatarMeshComponent* UME_PlayerUIAvatarMeshComponent::GetDefaultObj()
{
	static class UME_PlayerUIAvatarMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerUIAvatarMeshComponent*>(UME_PlayerUIAvatarMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_Projectile
// (Actor)

class UClass* AME_Projectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_Projectile");

	return Clss;
}


// ME_Projectile Maneater.Default__ME_Projectile
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_Projectile* AME_Projectile::GetDefaultObj()
{
	static class AME_Projectile* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_Projectile*>(AME_Projectile::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_Projectile.OnPhysicsVolumeChanged
// (Final, Native, Public)
// Parameters:
// class APhysicsVolume*              NewVolume                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Projectile::OnPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Projectile", "OnPhysicsVolumeChanged");

	Params::AME_Projectile_OnPhysicsVolumeChanged_Params Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_Projectile.OnHitActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      HitActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_Projectile::OnHitActor(class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_Projectile", "OnHitActor");

	Params::AME_Projectile_OnHitActor_Params Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);

}


// Class Maneater.ME_ProjectileMovementComponent
// (None)

class UClass* UME_ProjectileMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ProjectileMovementComponent");

	return Clss;
}


// ME_ProjectileMovementComponent Maneater.Default__ME_ProjectileMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ProjectileMovementComponent* UME_ProjectileMovementComponent::GetDefaultObj()
{
	static class UME_ProjectileMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ProjectileMovementComponent*>(UME_ProjectileMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ProximityBomb
// (Actor)

class UClass* AME_ProximityBomb::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ProximityBomb");

	return Clss;
}


// ME_ProximityBomb Maneater.Default__ME_ProximityBomb
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ProximityBomb* AME_ProximityBomb::GetDefaultObj()
{
	static class AME_ProximityBomb* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ProximityBomb*>(AME_ProximityBomb::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SaveObjectBase
// (None)

class UClass* UME_SaveObjectBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SaveObjectBase");

	return Clss;
}


// ME_SaveObjectBase Maneater.Default__ME_SaveObjectBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SaveObjectBase* UME_SaveObjectBase::GetDefaultObj()
{
	static class UME_SaveObjectBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SaveObjectBase*>(UME_SaveObjectBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SaveObjectBase.SetDirty
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_SaveObjectBase::SetDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveObjectBase", "SetDirty");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveObjectBase.SetClean
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_SaveObjectBase::SetClean()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveObjectBase", "SetClean");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveObjectBase.IsDirty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveObjectBase::IsDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveObjectBase", "IsDirty");

	Params::UME_SaveObjectBase_IsDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SaveGameObject
// (None)

class UClass* UME_SaveGameObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SaveGameObject");

	return Clss;
}


// ME_SaveGameObject Maneater.Default__ME_SaveGameObject
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SaveGameObject* UME_SaveGameObject::GetDefaultObj()
{
	static class UME_SaveGameObject* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SaveGameObject*>(UME_SaveGameObject::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SaveGameObject.SetTigerSkinEvolutionRarity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEvolutionRarity        ERarity                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveGameObject::SetTigerSkinEvolutionRarity(enum class EEvolutionRarity ERarity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "SetTigerSkinEvolutionRarity");

	Params::UME_SaveGameObject_SetTigerSkinEvolutionRarity_Params Parms{};

	Parms.ERarity = ERarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveGameObject.SaveObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     ObjectToSave                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                      GameWorld                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveGameObject::SaveObject(class UObject* ObjectToSave, class UWorld* GameWorld)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "SaveObject");

	Params::UME_SaveGameObject_SaveObject_Params Parms{};

	Parms.ObjectToSave = ObjectToSave;
	Parms.GameWorld = GameWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.SaveActorWithTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ActorToSave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveGameObject::SaveActorWithTransform(class AActor* ActorToSave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "SaveActorWithTransform");

	Params::UME_SaveGameObject_SaveActorWithTransform_Params Parms{};

	Parms.ActorToSave = ActorToSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.RemoveSavedObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     ObjectToRemove                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveGameObject::RemoveSavedObject(class UObject* ObjectToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "RemoveSavedObject");

	Params::UME_SaveGameObject_RemoveSavedObject_Params Parms{};

	Parms.ObjectToRemove = ObjectToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.LoadObjectProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     ObjectToLoad                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                      GameWorld                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOnlyClassMustMatch                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveGameObject::LoadObjectProperties(class UObject* ObjectToLoad, class UWorld* GameWorld, bool bOnlyClassMustMatch)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "LoadObjectProperties");

	Params::UME_SaveGameObject_LoadObjectProperties_Params Parms{};

	Parms.ObjectToLoad = ObjectToLoad;
	Parms.GameWorld = GameWorld;
	Parms.bOnlyClassMustMatch = bOnlyClassMustMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.LoadAllObjectsOfClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                      ClassToLoad                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UObject*> UME_SaveGameObject::LoadAllObjectsOfClass(class UClass* ClassToLoad, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "LoadAllObjectsOfClass");

	Params::UME_SaveGameObject_LoadAllObjectsOfClass_Params Parms{};

	Parms.ClassToLoad = ClassToLoad;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.LoadAllActorsWithTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                      ClassToLoad                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AActor*> UME_SaveGameObject::LoadAllActorsWithTransform(class UClass* ClassToLoad, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "LoadAllActorsWithTransform");

	Params::UME_SaveGameObject_LoadAllActorsWithTransform_Params Parms{};

	Parms.ClassToLoad = ClassToLoad;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.LoadActorWithTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ActorName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UME_SaveGameObject::LoadActorWithTransform(const class FString& ActorName, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "LoadActorWithTransform");

	Params::UME_SaveGameObject_LoadActorWithTransform_Params Parms{};

	Parms.ActorName = ActorName;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveGameObject.GetTigerSkinEvolutionRarity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEvolutionRarity        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EEvolutionRarity UME_SaveGameObject::GetTigerSkinEvolutionRarity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveGameObject", "GetTigerSkinEvolutionRarity");

	Params::UME_SaveGameObject_GetTigerSkinEvolutionRarity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SaveProfileObject
// (None)

class UClass* UME_SaveProfileObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SaveProfileObject");

	return Clss;
}


// ME_SaveProfileObject Maneater.Default__ME_SaveProfileObject
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SaveProfileObject* UME_SaveProfileObject::GetDefaultObj()
{
	static class UME_SaveProfileObject* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SaveProfileObject*>(UME_SaveProfileObject::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SaveProfileObject.SetTutorialPopupEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetTutorialPopupEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetTutorialPopupEnabled");

	Params::UME_SaveProfileObject_SetTutorialPopupEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetSubtitlesEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetSubtitlesEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetSubtitlesEnabled");

	Params::UME_SaveProfileObject_SetSubtitlesEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetSfxVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetSfxVolume(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetSfxVolume");

	Params::UME_SaveProfileObject_SetSfxVolume_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetRightStickSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Sensitivity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetRightStickSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetRightStickSensitivity");

	Params::UME_SaveProfileObject_SetRightStickSensitivity_Params Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetRaytracingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Quality                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetRaytracingQuality(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetRaytracingQuality");

	Params::UME_SaveProfileObject_SetRaytracingQuality_Params Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetNarratorVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetNarratorVolume(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetNarratorVolume");

	Params::UME_SaveProfileObject_SetNarratorVolume_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetMusicVolume(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetMusicVolume");

	Params::UME_SaveProfileObject_SetMusicVolume_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Sensitivity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetMouseSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetMouseSensitivity");

	Params::UME_SaveProfileObject_SetMouseSensitivity_Params Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetMasterVolume(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetMasterVolume");

	Params::UME_SaveProfileObject_SetMasterVolume_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetLeftStickSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Sensitivity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetLeftStickSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetLeftStickSensitivity");

	Params::UME_SaveProfileObject_SetLeftStickSensitivity_Params Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetInvertMouseYEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetInvertMouseYEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetInvertMouseYEnabled");

	Params::UME_SaveProfileObject_SetInvertMouseYEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetInvertMouseY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetInvertMouseY(bool Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetInvertMouseY");

	Params::UME_SaveProfileObject_SetInvertMouseY_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetInvertGamepadYEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetInvertGamepadYEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetInvertGamepadYEnabled");

	Params::UME_SaveProfileObject_SetInvertGamepadYEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetInvertGamepadY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetInvertGamepadY(bool Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetInvertGamepadY");

	Params::UME_SaveProfileObject_SetInvertGamepadY_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetDialogVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetDialogVolume(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetDialogVolume");

	Params::UME_SaveProfileObject_SetDialogVolume_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetControlScheme
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetControlScheme(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetControlScheme");

	Params::UME_SaveProfileObject_SetControlScheme_Params Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.SetControllerVibrationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::SetControllerVibrationEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "SetControllerVibrationEnabled");

	Params::UME_SaveProfileObject_SetControllerVibrationEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.IsMouseYInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::IsMouseYInverted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "IsMouseYInverted");

	Params::UME_SaveProfileObject_IsMouseYInverted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.IsInvertMouseYEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::IsInvertMouseYEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "IsInvertMouseYEnabled");

	Params::UME_SaveProfileObject_IsInvertMouseYEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.IsInvertGamepadYEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::IsInvertGamepadYEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "IsInvertGamepadYEnabled");

	Params::UME_SaveProfileObject_IsInvertGamepadYEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.IsGamepadYInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::IsGamepadYInverted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "IsGamepadYInverted");

	Params::UME_SaveProfileObject_IsGamepadYInverted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetTutorialPopupEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::GetTutorialPopupEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetTutorialPopupEnabled");

	Params::UME_SaveProfileObject_GetTutorialPopupEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetSubtitlesEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::GetSubtitlesEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetSubtitlesEnabled");

	Params::UME_SaveProfileObject_GetSubtitlesEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetSfxVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetSfxVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetSfxVolume");

	Params::UME_SaveProfileObject_GetSfxVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetRightStickSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetRightStickSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetRightStickSensitivity");

	Params::UME_SaveProfileObject_GetRightStickSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetRaytracingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_SaveProfileObject::GetRaytracingQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetRaytracingQuality");

	Params::UME_SaveProfileObject_GetRaytracingQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetNarratorVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetNarratorVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetNarratorVolume");

	Params::UME_SaveProfileObject_GetNarratorVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMusicVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMusicVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMusicVolume");

	Params::UME_SaveProfileObject_GetMusicVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMouseSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMouseSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMouseSensitivity");

	Params::UME_SaveProfileObject_GetMouseSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMinStickSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMinStickSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMinStickSensitivity");

	Params::UME_SaveProfileObject_GetMinStickSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMinMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMinMouseSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMinMouseSensitivity");

	Params::UME_SaveProfileObject_GetMinMouseSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMaxStickSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMaxStickSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMaxStickSensitivity");

	Params::UME_SaveProfileObject_GetMaxStickSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMaxMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMaxMouseSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMaxMouseSensitivity");

	Params::UME_SaveProfileObject_GetMaxMouseSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetMasterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetMasterVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetMasterVolume");

	Params::UME_SaveProfileObject_GetMasterVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetLeftStickSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetLeftStickSensitivity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetLeftStickSensitivity");

	Params::UME_SaveProfileObject_GetLeftStickSensitivity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetDialogVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UME_SaveProfileObject::GetDialogVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetDialogVolume");

	Params::UME_SaveProfileObject_GetDialogVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetControlScheme
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_SaveProfileObject::GetControlScheme()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetControlScheme");

	Params::UME_SaveProfileObject_GetControlScheme_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.GetControllerVibrationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveProfileObject::GetControllerVibrationEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "GetControllerVibrationEnabled");

	Params::UME_SaveProfileObject_GetControllerVibrationEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.DEV_SetBoostType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SaveProfileObject::DEV_SetBoostType(uint8 Idx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "DEV_SetBoostType");

	Params::UME_SaveProfileObject_DEV_SetBoostType_Params Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SaveProfileObject.DEV_GetBoostType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UME_SaveProfileObject::DEV_GetBoostType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "DEV_GetBoostType");

	Params::UME_SaveProfileObject_DEV_GetBoostType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveProfileObject.ApplyAudioSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UME_SaveProfileObject::ApplyAudioSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveProfileObject", "ApplyAudioSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_SaveSystemStatics
// (None)

class UClass* UME_SaveSystemStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SaveSystemStatics");

	return Clss;
}


// ME_SaveSystemStatics Maneater.Default__ME_SaveSystemStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SaveSystemStatics* UME_SaveSystemStatics::GetDefaultObj()
{
	static class UME_SaveSystemStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SaveSystemStatics*>(UME_SaveSystemStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SaveSystemStatics.SaveCurrentlyActiveProfileData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveSystemStatics::SaveCurrentlyActiveProfileData(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "SaveCurrentlyActiveProfileData");

	Params::UME_SaveSystemStatics_SaveCurrentlyActiveProfileData_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.SaveCurrentlyActiveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceFlush                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveSystemStatics::SaveCurrentlyActiveGameToSlot(class UObject* WorldContextObject, bool bForceFlush)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "SaveCurrentlyActiveGameToSlot");

	Params::UME_SaveSystemStatics_SaveCurrentlyActiveGameToSlot_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bForceFlush = bForceFlush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.PeekSaveGameSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SaveGameObject*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SaveGameObject* UME_SaveSystemStatics::PeekSaveGameSlot(int32 Slot, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "PeekSaveGameSlot");

	Params::UME_SaveSystemStatics_PeekSaveGameSlot_Params Parms{};

	Parms.Slot = Slot;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.LoadSaveGameSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SaveGameObject*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SaveGameObject* UME_SaveSystemStatics::LoadSaveGameSlot(int32 Slot, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "LoadSaveGameSlot");

	Params::UME_SaveSystemStatics_LoadSaveGameSlot_Params Parms{};

	Parms.Slot = Slot;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.LoadProfileData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObjet                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SaveProfileObject*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SaveProfileObject* UME_SaveSystemStatics::LoadProfileData(class UObject* WorldContextObjet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "LoadProfileData");

	Params::UME_SaveSystemStatics_LoadProfileData_Params Parms{};

	Parms.WorldContextObjet = WorldContextObjet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetSaveName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_SaveSystemStatics::GetSaveName(int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetSaveName");

	Params::UME_SaveSystemStatics_GetSaveName_Params Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetSaveGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SaveGameObject*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SaveGameObject* UME_SaveSystemStatics::GetSaveGameInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetSaveGameInstance");

	Params::UME_SaveSystemStatics_GetSaveGameInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetSavedProfileTimeStamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UME_SaveSystemStatics::GetSavedProfileTimeStamp(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetSavedProfileTimeStamp");

	Params::UME_SaveSystemStatics_GetSavedProfileTimeStamp_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetSavedProfileDir
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UME_SaveSystemStatics::GetSavedProfileDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetSavedProfileDir");

	Params::UME_SaveSystemStatics_GetSavedProfileDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetProfileSaveInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_SaveProfileObject*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UME_SaveProfileObject* UME_SaveSystemStatics::GetProfileSaveInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetProfileSaveInstance");

	Params::UME_SaveSystemStatics_GetProfileSaveInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.GetPreviouslyLoadedSaveSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UME_SaveSystemStatics::GetPreviouslyLoadedSaveSlot(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "GetPreviouslyLoadedSaveSlot");

	Params::UME_SaveSystemStatics_GetPreviouslyLoadedSaveSlot_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.DestroySaveGameInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveSystemStatics::DestroySaveGameInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "DestroySaveGameInstance");

	Params::UME_SaveSystemStatics_DestroySaveGameInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.DeleteSaveGameSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveSystemStatics::DeleteSaveGameSlot(int32 Slot, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "DeleteSaveGameSlot");

	Params::UME_SaveSystemStatics_DeleteSaveGameSlot_Params Parms{};

	Parms.Slot = Slot;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SaveSystemStatics.CurrentPlayerDoesSlotHaveSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SaveSystemStatics::CurrentPlayerDoesSlotHaveSave(int32 Slot, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SaveSystemStatics", "CurrentPlayerDoesSlotHaveSave");

	Params::UME_SaveSystemStatics_CurrentPlayerDoesSlotHaveSave_Params Parms{};

	Parms.Slot = Slot;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SignificanceEmitter
// (Actor)

class UClass* AME_SignificanceEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SignificanceEmitter");

	return Clss;
}


// ME_SignificanceEmitter Maneater.Default__ME_SignificanceEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SignificanceEmitter* AME_SignificanceEmitter::GetDefaultObj()
{
	static class AME_SignificanceEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SignificanceEmitter*>(AME_SignificanceEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SignificanceEntity
// (None)

class UClass* IME_SignificanceEntity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SignificanceEntity");

	return Clss;
}


// ME_SignificanceEntity Maneater.Default__ME_SignificanceEntity
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_SignificanceEntity* IME_SignificanceEntity::GetDefaultObj()
{
	static class IME_SignificanceEntity* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_SignificanceEntity*>(IME_SignificanceEntity::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SignificanceEntity.PostSignificance
// (Native, Public)
// Parameters:
// class UObject*                     SignificanceObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OldSignificance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewSignificance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUnregistered                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_SignificanceEntity::PostSignificance(class UObject* SignificanceObject, float OldSignificance, float NewSignificance, bool bUnregistered)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SignificanceEntity", "PostSignificance");

	Params::IME_SignificanceEntity_PostSignificance_Params Parms{};

	Parms.SignificanceObject = SignificanceObject;
	Parms.OldSignificance = OldSignificance;
	Parms.NewSignificance = NewSignificance;
	Parms.bUnregistered = bUnregistered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SignificanceEntity.CalculateSignificance
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UObject*                     SignificanceObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ViewPoint                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_SignificanceEntity::CalculateSignificance(class UObject* SignificanceObject, struct FTransform& ViewPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SignificanceEntity", "CalculateSignificance");

	Params::IME_SignificanceEntity_CalculateSignificance_Params Parms{};

	Parms.SignificanceObject = SignificanceObject;
	Parms.ViewPoint = ViewPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SignificanceManager
// (None)

class UClass* UME_SignificanceManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SignificanceManager");

	return Clss;
}


// ME_SignificanceManager Maneater.Default__ME_SignificanceManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SignificanceManager* UME_SignificanceManager::GetDefaultObj()
{
	static class UME_SignificanceManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SignificanceManager*>(UME_SignificanceManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SonarDetectableInterface
// (None)

class UClass* IME_SonarDetectableInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SonarDetectableInterface");

	return Clss;
}


// ME_SonarDetectableInterface Maneater.Default__ME_SonarDetectableInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_SonarDetectableInterface* IME_SonarDetectableInterface::GetDefaultObj()
{
	static class IME_SonarDetectableInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_SonarDetectableInterface*>(IME_SonarDetectableInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SonarDetectableInterface.OnPlayerFocused
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void IME_SonarDetectableInterface::OnPlayerFocused()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "OnPlayerFocused");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SonarDetectableInterface.OnPingedByPlayerSonar
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IME_SonarDetectableInterface::OnPingedByPlayerSonar()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "OnPingedByPlayerSonar");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_SonarDetectableInterface.OnFoundBySonar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IME_SonarDetectableInterface::OnFoundBySonar()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "OnFoundBySonar");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SonarDetectableInterface.GetSonarWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetComponent*            ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetComponent* IME_SonarDetectableInterface::GetSonarWidget(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetSonarWidget");

	Params::IME_SonarDetectableInterface_GetSonarWidget_Params Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetMaxDistanceVisible
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_SonarDetectableInterface::GetMaxDistanceVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetMaxDistanceVisible");

	Params::IME_SonarDetectableInterface_GetMaxDistanceVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetFriendlyName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IME_SonarDetectableInterface::GetFriendlyName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetFriendlyName");

	Params::IME_SonarDetectableInterface_GetFriendlyName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetFocusPriority
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IME_SonarDetectableInterface::GetFocusPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetFocusPriority");

	Params::IME_SonarDetectableInterface_GetFocusPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetDisplayLevel
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IME_SonarDetectableInterface::GetDisplayLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetDisplayLevel");

	Params::IME_SonarDetectableInterface_GetDisplayLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetDetectableLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                     AttackerLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IME_SonarDetectableInterface::GetDetectableLocation(struct FVector& AttackerLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetDetectableLocation");

	Params::IME_SonarDetectableInterface_GetDetectableLocation_Params Parms{};

	Parms.AttackerLocation = AttackerLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetDetectableComponentLocationOffset
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IME_SonarDetectableInterface::GetDetectableComponentLocationOffset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetDetectableComponentLocationOffset");

	Params::IME_SonarDetectableInterface_GetDetectableComponentLocationOffset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.GetDetectableComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* IME_SonarDetectableInterface::GetDetectableComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "GetDetectableComponent");

	Params::IME_SonarDetectableInterface_GetDetectableComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.CanBeLockedOnTo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_SonarDetectableInterface::CanBeLockedOnTo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "CanBeLockedOnTo");

	Params::IME_SonarDetectableInterface_CanBeLockedOnTo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SonarDetectableInterface.CanBeFocused
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_SonarDetectableInterface::CanBeFocused()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarDetectableInterface", "CanBeFocused");

	Params::IME_SonarDetectableInterface_CanBeFocused_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SonarManager
// (Actor)

class UClass* AME_SonarManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SonarManager");

	return Clss;
}


// ME_SonarManager Maneater.Default__ME_SonarManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SonarManager* AME_SonarManager::GetDefaultObj()
{
	static class AME_SonarManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SonarManager*>(AME_SonarManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SonarManager.OnCinematicModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                               bCinematicMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_SonarManager::OnCinematicModeChanged(bool bCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SonarManager", "OnCinematicModeChanged");

	Params::AME_SonarManager_OnCinematicModeChanged_Params Parms{};

	Parms.bCinematicMode = bCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_SpawnActorVisualizerComponent
// (None)

class UClass* UME_SpawnActorVisualizerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnActorVisualizerComponent");

	return Clss;
}


// ME_SpawnActorVisualizerComponent Maneater.Default__ME_SpawnActorVisualizerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnActorVisualizerComponent* UME_SpawnActorVisualizerComponent::GetDefaultObj()
{
	static class UME_SpawnActorVisualizerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnActorVisualizerComponent*>(UME_SpawnActorVisualizerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawningObjectiveBase
// (None)

class UClass* UME_SpawningObjectiveBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawningObjectiveBase");

	return Clss;
}


// ME_SpawningObjectiveBase Maneater.Default__ME_SpawningObjectiveBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawningObjectiveBase* UME_SpawningObjectiveBase::GetDefaultObj()
{
	static class UME_SpawningObjectiveBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawningObjectiveBase*>(UME_SpawningObjectiveBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_KillObjective
// (None)

class UClass* UME_KillObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_KillObjective");

	return Clss;
}


// ME_KillObjective Maneater.Default__ME_KillObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_KillObjective* UME_KillObjective::GetDefaultObj()
{
	static class UME_KillObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_KillObjective*>(UME_KillObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HighValueTargetObjective
// (None)

class UClass* UME_HighValueTargetObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HighValueTargetObjective");

	return Clss;
}


// ME_HighValueTargetObjective Maneater.Default__ME_HighValueTargetObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_HighValueTargetObjective* UME_HighValueTargetObjective::GetDefaultObj()
{
	static class UME_HighValueTargetObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_HighValueTargetObjective*>(UME_HighValueTargetObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_AreaSpawnObjective
// (None)

class UClass* UME_AreaSpawnObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_AreaSpawnObjective");

	return Clss;
}


// ME_AreaSpawnObjective Maneater.Default__ME_AreaSpawnObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_AreaSpawnObjective* UME_AreaSpawnObjective::GetDefaultObj()
{
	static class UME_AreaSpawnObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_AreaSpawnObjective*>(UME_AreaSpawnObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_HuntObjective
// (None)

class UClass* UME_HuntObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_HuntObjective");

	return Clss;
}


// ME_HuntObjective Maneater.Default__ME_HuntObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_HuntObjective* UME_HuntObjective::GetDefaultObj()
{
	static class UME_HuntObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_HuntObjective*>(UME_HuntObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectiveTerrorize
// (None)

class UClass* UME_PlayerObjectiveTerrorize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectiveTerrorize");

	return Clss;
}


// ME_PlayerObjectiveTerrorize Maneater.Default__ME_PlayerObjectiveTerrorize
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectiveTerrorize* UME_PlayerObjectiveTerrorize::GetDefaultObj()
{
	static class UME_PlayerObjectiveTerrorize* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectiveTerrorize*>(UME_PlayerObjectiveTerrorize::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_PlayerObjectivePopulationControl
// (None)

class UClass* UME_PlayerObjectivePopulationControl::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_PlayerObjectivePopulationControl");

	return Clss;
}


// ME_PlayerObjectivePopulationControl Maneater.Default__ME_PlayerObjectivePopulationControl
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_PlayerObjectivePopulationControl* UME_PlayerObjectivePopulationControl::GetDefaultObj()
{
	static class UME_PlayerObjectivePopulationControl* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_PlayerObjectivePopulationControl*>(UME_PlayerObjectivePopulationControl::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnManagerBase
// (Actor)

class UClass* AME_SpawnManagerBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnManagerBase");

	return Clss;
}


// ME_SpawnManagerBase Maneater.Default__ME_SpawnManagerBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SpawnManagerBase* AME_SpawnManagerBase::GetDefaultObj()
{
	static class AME_SpawnManagerBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SpawnManagerBase*>(AME_SpawnManagerBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SpawnManagerBase.AISpawned
// (Native, Public, BlueprintCallable)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_SpawnManagerBase::AISpawned(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnManagerBase", "AISpawned");

	Params::AME_SpawnManagerBase_AISpawned_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_ObjectiveSpawnManager
// (Actor)

class UClass* AME_ObjectiveSpawnManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ObjectiveSpawnManager");

	return Clss;
}


// ME_ObjectiveSpawnManager Maneater.Default__ME_ObjectiveSpawnManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_ObjectiveSpawnManager* AME_ObjectiveSpawnManager::GetDefaultObj()
{
	static class AME_ObjectiveSpawnManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_ObjectiveSpawnManager*>(AME_ObjectiveSpawnManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnlistCondition
// (None)

class UClass* UME_SpawnlistCondition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnlistCondition");

	return Clss;
}


// ME_SpawnlistCondition Maneater.Default__ME_SpawnlistCondition
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnlistCondition* UME_SpawnlistCondition::GetDefaultObj()
{
	static class UME_SpawnlistCondition* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnlistCondition*>(UME_SpawnlistCondition::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SpawnlistCondition.ConditionIsValid
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      WorldContextActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UME_SpawnlistCondition::ConditionIsValid(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnlistCondition", "ConditionIsValid");

	Params::UME_SpawnlistCondition_ConditionIsValid_Params Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_SpawnListCondition_ActiveBounty
// (None)

class UClass* UME_SpawnListCondition_ActiveBounty::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_ActiveBounty");

	return Clss;
}


// ME_SpawnListCondition_ActiveBounty Maneater.Default__ME_SpawnListCondition_ActiveBounty
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_ActiveBounty* UME_SpawnListCondition_ActiveBounty::GetDefaultObj()
{
	static class UME_SpawnListCondition_ActiveBounty* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_ActiveBounty*>(UME_SpawnListCondition_ActiveBounty::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_BossIsActive
// (None)

class UClass* UME_SpawnListCondition_BossIsActive::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_BossIsActive");

	return Clss;
}


// ME_SpawnListCondition_BossIsActive Maneater.Default__ME_SpawnListCondition_BossIsActive
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_BossIsActive* UME_SpawnListCondition_BossIsActive::GetDefaultObj()
{
	static class UME_SpawnListCondition_BossIsActive* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_BossIsActive*>(UME_SpawnListCondition_BossIsActive::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_IgnoreForObjective
// (None)

class UClass* UME_SpawnListCondition_IgnoreForObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_IgnoreForObjective");

	return Clss;
}


// ME_SpawnListCondition_IgnoreForObjective Maneater.Default__ME_SpawnListCondition_IgnoreForObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_IgnoreForObjective* UME_SpawnListCondition_IgnoreForObjective::GetDefaultObj()
{
	static class UME_SpawnListCondition_IgnoreForObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_IgnoreForObjective*>(UME_SpawnListCondition_IgnoreForObjective::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_MaxInPlay
// (None)

class UClass* UME_SpawnListCondition_MaxInPlay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_MaxInPlay");

	return Clss;
}


// ME_SpawnListCondition_MaxInPlay Maneater.Default__ME_SpawnListCondition_MaxInPlay
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_MaxInPlay* UME_SpawnListCondition_MaxInPlay::GetDefaultObj()
{
	static class UME_SpawnListCondition_MaxInPlay* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_MaxInPlay*>(UME_SpawnListCondition_MaxInPlay::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_PoisonedWater
// (None)

class UClass* UME_SpawnListCondition_PoisonedWater::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_PoisonedWater");

	return Clss;
}


// ME_SpawnListCondition_PoisonedWater Maneater.Default__ME_SpawnListCondition_PoisonedWater
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_PoisonedWater* UME_SpawnListCondition_PoisonedWater::GetDefaultObj()
{
	static class UME_SpawnListCondition_PoisonedWater* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_PoisonedWater*>(UME_SpawnListCondition_PoisonedWater::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_StorylineProgress
// (None)

class UClass* UME_SpawnListCondition_StorylineProgress::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_StorylineProgress");

	return Clss;
}


// ME_SpawnListCondition_StorylineProgress Maneater.Default__ME_SpawnListCondition_StorylineProgress
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_StorylineProgress* UME_SpawnListCondition_StorylineProgress::GetDefaultObj()
{
	static class UME_SpawnListCondition_StorylineProgress* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_StorylineProgress*>(UME_SpawnListCondition_StorylineProgress::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_TimeOfDay
// (None)

class UClass* UME_SpawnListCondition_TimeOfDay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_TimeOfDay");

	return Clss;
}


// ME_SpawnListCondition_TimeOfDay Maneater.Default__ME_SpawnListCondition_TimeOfDay
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_TimeOfDay* UME_SpawnListCondition_TimeOfDay::GetDefaultObj()
{
	static class UME_SpawnListCondition_TimeOfDay* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_TimeOfDay*>(UME_SpawnListCondition_TimeOfDay::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnListCondition_TutorialComplete
// (None)

class UClass* UME_SpawnListCondition_TutorialComplete::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnListCondition_TutorialComplete");

	return Clss;
}


// ME_SpawnListCondition_TutorialComplete Maneater.Default__ME_SpawnListCondition_TutorialComplete
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnListCondition_TutorialComplete* UME_SpawnListCondition_TutorialComplete::GetDefaultObj()
{
	static class UME_SpawnListCondition_TutorialComplete* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnListCondition_TutorialComplete*>(UME_SpawnListCondition_TutorialComplete::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnManager
// (Actor)

class UClass* AME_SpawnManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnManager");

	return Clss;
}


// ME_SpawnManager Maneater.Default__ME_SpawnManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SpawnManager* AME_SpawnManager::GetDefaultObj()
{
	static class AME_SpawnManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SpawnManager*>(AME_SpawnManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnPool
// (None)

class UClass* UME_SpawnPool::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnPool");

	return Clss;
}


// ME_SpawnPool Maneater.Default__ME_SpawnPool
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnPool* UME_SpawnPool::GetDefaultObj()
{
	static class UME_SpawnPool* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnPool*>(UME_SpawnPool::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SpawnPool.RemoveActorClassFromPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                      ActorClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UME_SpawnPool::RemoveActorClassFromPool(class UClass* ActorClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPool", "RemoveActorClassFromPool");

	Params::UME_SpawnPool_RemoveActorClassFromPool_Params Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_SpawnPoolEntity
// (None)

class UClass* IME_SpawnPoolEntity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnPoolEntity");

	return Clss;
}


// ME_SpawnPoolEntity Maneater.Default__ME_SpawnPoolEntity
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_SpawnPoolEntity* IME_SpawnPoolEntity::GetDefaultObj()
{
	static class IME_SpawnPoolEntity* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_SpawnPoolEntity*>(IME_SpawnPoolEntity::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_SpawnPoolEntity.ResetEntity
// (Native, Public)
// Parameters:

void IME_SpawnPoolEntity::ResetEntity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPoolEntity", "ResetEntity");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SpawnPoolEntity.IsExemptFromPool
// (Native, Public, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_SpawnPoolEntity::IsExemptFromPool()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPoolEntity", "IsExemptFromPool");

	Params::IME_SpawnPoolEntity_IsExemptFromPool_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SpawnPoolEntity.IsDespawning
// (Native, Public, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_SpawnPoolEntity::IsDespawning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPoolEntity", "IsDespawning");

	Params::IME_SpawnPoolEntity_IsDespawning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_SpawnPoolEntity.InitEntity
// (Native, Public, BlueprintCallable)
// Parameters:

void IME_SpawnPoolEntity::InitEntity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPoolEntity", "InitEntity");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_SpawnPoolEntity.EntityDespawned
// (Native, Public)
// Parameters:

void IME_SpawnPoolEntity::EntityDespawned()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_SpawnPoolEntity", "EntityDespawned");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_SpawnData
// (None)

class UClass* UME_SpawnData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnData");

	return Clss;
}


// ME_SpawnData Maneater.Default__ME_SpawnData
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnData* UME_SpawnData::GetDefaultObj()
{
	static class UME_SpawnData* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnData*>(UME_SpawnData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnVolumeCollection
// (None)

class UClass* UME_SpawnVolumeCollection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnVolumeCollection");

	return Clss;
}


// ME_SpawnVolumeCollection Maneater.Default__ME_SpawnVolumeCollection
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnVolumeCollection* UME_SpawnVolumeCollection::GetDefaultObj()
{
	static class UME_SpawnVolumeCollection* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnVolumeCollection*>(UME_SpawnVolumeCollection::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnVolume
// (Actor)

class UClass* AME_SpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnVolume");

	return Clss;
}


// ME_SpawnVolume Maneater.Default__ME_SpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SpawnVolume* AME_SpawnVolume::GetDefaultObj()
{
	static class AME_SpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SpawnVolume*>(AME_SpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnVolumeCollection_Beachgoer
// (None)

class UClass* UME_SpawnVolumeCollection_Beachgoer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnVolumeCollection_Beachgoer");

	return Clss;
}


// ME_SpawnVolumeCollection_Beachgoer Maneater.Default__ME_SpawnVolumeCollection_Beachgoer
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnVolumeCollection_Beachgoer* UME_SpawnVolumeCollection_Beachgoer::GetDefaultObj()
{
	static class UME_SpawnVolumeCollection_Beachgoer* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnVolumeCollection_Beachgoer*>(UME_SpawnVolumeCollection_Beachgoer::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnVolume_Beachgoer
// (Actor)

class UClass* AME_SpawnVolume_Beachgoer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnVolume_Beachgoer");

	return Clss;
}


// ME_SpawnVolume_Beachgoer Maneater.Default__ME_SpawnVolume_Beachgoer
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_SpawnVolume_Beachgoer* AME_SpawnVolume_Beachgoer::GetDefaultObj()
{
	static class AME_SpawnVolume_Beachgoer* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_SpawnVolume_Beachgoer*>(AME_SpawnVolume_Beachgoer::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_SpawnVolumeVisualizerComponent
// (None)

class UClass* UME_SpawnVolumeVisualizerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_SpawnVolumeVisualizerComponent");

	return Clss;
}


// ME_SpawnVolumeVisualizerComponent Maneater.Default__ME_SpawnVolumeVisualizerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_SpawnVolumeVisualizerComponent* UME_SpawnVolumeVisualizerComponent::GetDefaultObj()
{
	static class UME_SpawnVolumeVisualizerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_SpawnVolumeVisualizerComponent*>(UME_SpawnVolumeVisualizerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_TerrainMappedAmbience
// (Actor)

class UClass* AME_TerrainMappedAmbience::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TerrainMappedAmbience");

	return Clss;
}


// ME_TerrainMappedAmbience Maneater.Default__ME_TerrainMappedAmbience
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_TerrainMappedAmbience* AME_TerrainMappedAmbience::GetDefaultObj()
{
	static class AME_TerrainMappedAmbience* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_TerrainMappedAmbience*>(AME_TerrainMappedAmbience::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ThrashableInterface
// (None)

class UClass* IME_ThrashableInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ThrashableInterface");

	return Clss;
}


// ME_ThrashableInterface Maneater.Default__ME_ThrashableInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IME_ThrashableInterface* IME_ThrashableInterface::GetDefaultObj()
{
	static class IME_ThrashableInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IME_ThrashableInterface*>(IME_ThrashableInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_ThrashableInterface.OnWhipShotImpact
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                       WhipInstigator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnWhipShotImpact(class APawn* WhipInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnWhipShotImpact");

	Params::IME_ThrashableInterface_OnWhipShotImpact_Params Parms{};

	Parms.WhipInstigator = WhipInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnWhipShotEnd
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class APawn*                       WhipInstigator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EndVelocity                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               GrabbedActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnWhipShotEnd(class APawn* WhipInstigator, struct FVector& EndVelocity, bool GrabbedActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnWhipShotEnd");

	Params::IME_ThrashableInterface_OnWhipShotEnd_Params Parms{};

	Parms.WhipInstigator = WhipInstigator;
	Parms.EndVelocity = EndVelocity;
	Parms.GrabbedActor = GrabbedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnWhipShotBegin
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class APawn*                       WhipInstigator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WhipVelocity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnWhipShotBegin(class APawn* WhipInstigator, const struct FVector& WhipVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnWhipShotBegin");

	Params::IME_ThrashableInterface_OnWhipShotBegin_Params Parms{};

	Parms.WhipInstigator = WhipInstigator;
	Parms.WhipVelocity = WhipVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnReleasedBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         ReleasingAnimal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIgnoreFlee                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBrokeAway                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnReleasedBy(class AME_AnimalCharacter* ReleasingAnimal, bool bIgnoreFlee, bool bBrokeAway)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnReleasedBy");

	Params::IME_ThrashableInterface_OnReleasedBy_Params Parms{};

	Parms.ReleasingAnimal = ReleasingAnimal;
	Parms.bIgnoreFlee = bIgnoreFlee;
	Parms.bBrokeAway = bBrokeAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnGrabPointDamagedVFX
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FThrashGrabPoint            GrabPoint                                                        (Parm, NativeAccessSpecifierPublic)
// float                              DamageToApply                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DamageNormal                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DamageLocation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnGrabPointDamagedVFX(const struct FThrashGrabPoint& GrabPoint, float DamageToApply, const struct FVector& DamageNormal, const struct FVector& DamageLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnGrabPointDamagedVFX");

	Params::IME_ThrashableInterface_OnGrabPointDamagedVFX_Params Parms{};

	Parms.GrabPoint = GrabPoint;
	Parms.DamageToApply = DamageToApply;
	Parms.DamageNormal = DamageNormal;
	Parms.DamageLocation = DamageLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnGrabPointDamaged
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FThrashGrabPoint            GrabPoint                                                        (Parm, NativeAccessSpecifierPublic)
// float                              DamageToApply                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPhysicalSurface        PhysSurface                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         DamagedComponent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageInstigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InstigatingComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DamageNormal                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DamageLocation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnGrabPointDamaged(const struct FThrashGrabPoint& GrabPoint, float DamageToApply, enum class EPhysicalSurface PhysSurface, class UPrimitiveComponent* DamagedComponent, class AActor* DamageInstigator, class UPrimitiveComponent* InstigatingComponent, const struct FVector& DamageNormal, const struct FVector& DamageLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnGrabPointDamaged");

	Params::IME_ThrashableInterface_OnGrabPointDamaged_Params Parms{};

	Parms.GrabPoint = GrabPoint;
	Parms.DamageToApply = DamageToApply;
	Parms.PhysSurface = PhysSurface;
	Parms.DamagedComponent = DamagedComponent;
	Parms.DamageInstigator = DamageInstigator;
	Parms.InstigatingComponent = InstigatingComponent;
	Parms.DamageNormal = DamageNormal;
	Parms.DamageLocation = DamageLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnGrabPointConsumed
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         ConsumingAnimal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FThrashGrabPoint            ConsumedGrabPoint                                                (Parm, NativeAccessSpecifierPublic)
// class FName                        GoreCapBoneName                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnGrabPointConsumed(class AME_AnimalCharacter* ConsumingAnimal, const struct FThrashGrabPoint& ConsumedGrabPoint, class FName& GoreCapBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnGrabPointConsumed");

	Params::IME_ThrashableInterface_OnGrabPointConsumed_Params Parms{};

	Parms.ConsumingAnimal = ConsumingAnimal;
	Parms.ConsumedGrabPoint = ConsumedGrabPoint;
	Parms.GoreCapBoneName = GoreCapBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnGrabPointChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         GrabbedComponent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              GrabPointIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnGrabPointChanged(class AME_AnimalCharacter* GrabbingAnimal, class UPrimitiveComponent* GrabbedComponent, int32 GrabPointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnGrabPointChanged");

	Params::IME_ThrashableInterface_OnGrabPointChanged_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;
	Parms.GrabbedComponent = GrabbedComponent;
	Parms.GrabPointIndex = GrabPointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnGrabbedBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         GrabbedComponent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              GrabPointIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnGrabbedBy(class AME_AnimalCharacter* GrabbingAnimal, class UPrimitiveComponent* GrabbedComponent, int32 GrabPointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnGrabbedBy");

	Params::IME_ThrashableInterface_OnGrabbedBy_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;
	Parms.GrabbedComponent = GrabbedComponent;
	Parms.GrabPointIndex = GrabPointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.OnConsumedWhole
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         ConsumingAnimal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::OnConsumedWhole(class AME_AnimalCharacter* ConsumingAnimal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "OnConsumedWhole");

	Params::IME_ThrashableInterface_OnConsumedWhole_Params Parms{};

	Parms.ConsumingAnimal = ConsumingAnimal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_ThrashableInterface.MoveActorToMeshPositionOnRelease
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_ThrashableInterface::MoveActorToMeshPositionOnRelease()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "MoveActorToMeshPositionOnRelease");

	Params::IME_ThrashableInterface_MoveActorToMeshPositionOnRelease_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipshotSpinning
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ThrashableInterface::GetWhipshotSpinning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipshotSpinning");

	Params::IME_ThrashableInterface_GetWhipshotSpinning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipshotRotationSpeed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ThrashableInterface::GetWhipshotRotationSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipshotRotationSpeed");

	Params::IME_ThrashableInterface_GetWhipshotRotationSpeed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipshotRolling
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ThrashableInterface::GetWhipshotRolling()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipshotRolling");

	Params::IME_ThrashableInterface_GetWhipshotRolling_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipShotMovementClass
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class UME_WhipshotMovementComponent>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UME_WhipshotMovementComponent> IME_ThrashableInterface::GetWhipShotMovementClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipShotMovementClass");

	Params::IME_ThrashableInterface_GetWhipShotMovementClass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipshotLandClearance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ThrashableInterface::GetWhipshotLandClearance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipshotLandClearance");

	Params::IME_ThrashableInterface_GetWhipshotLandClearance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipShotImpactEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> IME_ThrashableInterface::GetWhipShotImpactEffect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipShotImpactEffect");

	Params::IME_ThrashableInterface_GetWhipShotImpactEffect_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipShotFlightType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EMECustomMovementMode   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EMECustomMovementMode IME_ThrashableInterface::GetWhipShotFlightType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipShotFlightType");

	Params::IME_ThrashableInterface_GetWhipShotFlightType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetWhipShotFlightParticleEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* IME_ThrashableInterface::GetWhipShotFlightParticleEffect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetWhipShotFlightParticleEffect");

	Params::IME_ThrashableInterface_GetWhipShotFlightParticleEffect_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetThrashableMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*              ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* IME_ThrashableInterface::GetThrashableMesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetThrashableMesh");

	Params::IME_ThrashableInterface_GetThrashableMesh_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetSize
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IME_ThrashableInterface::GetSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetSize");

	Params::IME_ThrashableInterface_GetSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.GetGrabPoints
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FThrashGrabPoint>    GrabPoints                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IME_ThrashableInterface::GetGrabPoints(class AME_AnimalCharacter* GrabbingAnimal, TArray<struct FThrashGrabPoint>* GrabPoints)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "GetGrabPoints");

	Params::IME_ThrashableInterface_GetGrabPoints_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (GrabPoints != nullptr)
		*GrabPoints = std::move(Parms.GrabPoints);

}


// Function Maneater.ME_ThrashableInterface.CanBeWhipShot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_ThrashableInterface::CanBeWhipShot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "CanBeWhipShot");

	Params::IME_ThrashableInterface_CanBeWhipShot_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.CanBeGrabbedBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_ThrashableInterface::CanBeGrabbedBy(class AME_AnimalCharacter* GrabbingAnimal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "CanBeGrabbedBy");

	Params::IME_ThrashableInterface_CanBeGrabbedBy_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_ThrashableInterface.CanBeConsumedWholeBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AME_AnimalCharacter*         GrabbingAnimal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IME_ThrashableInterface::CanBeConsumedWholeBy(class AME_AnimalCharacter* GrabbingAnimal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_ThrashableInterface", "CanBeConsumedWholeBy");

	Params::IME_ThrashableInterface_CanBeConsumedWholeBy_Params Parms{};

	Parms.GrabbingAnimal = GrabbingAnimal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_TimeofDayInfo
// (Actor)

class UClass* AME_TimeofDayInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TimeofDayInfo");

	return Clss;
}


// ME_TimeofDayInfo Maneater.Default__ME_TimeofDayInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_TimeofDayInfo* AME_TimeofDayInfo::GetDefaultObj()
{
	static class AME_TimeofDayInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_TimeofDayInfo*>(AME_TimeofDayInfo::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_TimeofDayInfo.SetTimeOfDay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewHourOfDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TimeofDayInfo::SetTimeOfDay(float NewHourOfDay, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeofDayInfo", "SetTimeOfDay");

	Params::AME_TimeofDayInfo_SetTimeOfDay_Params Parms{};

	Parms.NewHourOfDay = NewHourOfDay;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeofDayInfo.SetPauseState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewPause                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TimeofDayInfo::SetPauseState(bool bNewPause)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeofDayInfo", "SetPauseState");

	Params::AME_TimeofDayInfo_SetPauseState_Params Parms{};

	Parms.bNewPause = bNewPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeofDayInfo.GetPauseState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TimeofDayInfo::GetPauseState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeofDayInfo", "GetPauseState");

	Params::AME_TimeofDayInfo_GetPauseState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_TimeOfDayWorldActor
// (Actor)

class UClass* AME_TimeOfDayWorldActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TimeOfDayWorldActor");

	return Clss;
}


// ME_TimeOfDayWorldActor Maneater.Default__ME_TimeOfDayWorldActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_TimeOfDayWorldActor* AME_TimeOfDayWorldActor::GetDefaultObj()
{
	static class AME_TimeOfDayWorldActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_TimeOfDayWorldActor*>(AME_TimeOfDayWorldActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_TimeOfDayWorldActor.UpdateTimeOfDayCubemaps
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              InTimeOfDay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TimeOfDayWorldActor::UpdateTimeOfDayCubemaps(float InTimeOfDay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "UpdateTimeOfDayCubemaps");

	Params::AME_TimeOfDayWorldActor_UpdateTimeOfDayCubemaps_Params Parms{};

	Parms.InTimeOfDay = InTimeOfDay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeOfDayWorldActor.TriggerStartNightTime
// (Event, Protected, BlueprintEvent)
// Parameters:

void AME_TimeOfDayWorldActor::TriggerStartNightTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TriggerStartNightTime");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TimeOfDayWorldActor.TriggerStartDayTime
// (Event, Protected, BlueprintEvent)
// Parameters:

void AME_TimeOfDayWorldActor::TriggerStartDayTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TriggerStartDayTime");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TimeOfDayWorldActor.TriggerForceChangeTime
// (Event, Protected, BlueprintEvent)
// Parameters:

void AME_TimeOfDayWorldActor::TriggerForceChangeTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TriggerForceChangeTime");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TimeOfDayWorldActor.TriggerFogBelowWater
// (Event, Protected, BlueprintEvent)
// Parameters:

void AME_TimeOfDayWorldActor::TriggerFogBelowWater()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TriggerFogBelowWater");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TimeOfDayWorldActor.TriggerFogAboveWater
// (Event, Protected, BlueprintEvent)
// Parameters:

void AME_TimeOfDayWorldActor::TriggerFogAboveWater()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TriggerFogAboveWater");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TimeOfDayWorldActor.TickFogTransition
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_TimeOfDayWorldActor::TickFogTransition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TickFogTransition");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeOfDayWorldActor.TickDayNightTransition
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_TimeOfDayWorldActor::TickDayNightTransition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "TickDayNightTransition");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeOfDayWorldActor.OnNewFogVolumeEntered
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class EFogState               PlayerFogOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TimeOfDayWorldActor::OnNewFogVolumeEntered(enum class EFogState PlayerFogOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "OnNewFogVolumeEntered");

	Params::AME_TimeOfDayWorldActor_OnNewFogVolumeEntered_Params Parms{};

	Parms.PlayerFogOverride = PlayerFogOverride;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Maneater.ME_TimeOfDayWorldActor.IsDaytime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TimeOfDayWorldActor::IsDaytime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "IsDaytime");

	Params::AME_TimeOfDayWorldActor_IsDaytime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TimeOfDayWorldActor.InitTODActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_TimeOfDayWorldActor::InitTODActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "InitTODActor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeOfDayWorldActor.InitTimeOfDaySettings
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_TimeOfDayWorldActor::InitTimeOfDaySettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "InitTimeOfDaySettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TimeOfDayWorldActor.InitFogSettings
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AME_TimeOfDayWorldActor::InitFogSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TimeOfDayWorldActor", "InitFogSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_TorpedoLauncherComponent
// (None)

class UClass* UME_TorpedoLauncherComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TorpedoLauncherComponent");

	return Clss;
}


// ME_TorpedoLauncherComponent Maneater.Default__ME_TorpedoLauncherComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_TorpedoLauncherComponent* UME_TorpedoLauncherComponent::GetDefaultObj()
{
	static class UME_TorpedoLauncherComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_TorpedoLauncherComponent*>(UME_TorpedoLauncherComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_TorpedoMovementComponent
// (None)

class UClass* UME_TorpedoMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TorpedoMovementComponent");

	return Clss;
}


// ME_TorpedoMovementComponent Maneater.Default__ME_TorpedoMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_TorpedoMovementComponent* UME_TorpedoMovementComponent::GetDefaultObj()
{
	static class UME_TorpedoMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_TorpedoMovementComponent*>(UME_TorpedoMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_TorpedoProjectile
// (Actor)

class UClass* AME_TorpedoProjectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TorpedoProjectile");

	return Clss;
}


// ME_TorpedoProjectile Maneater.Default__ME_TorpedoProjectile
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_TorpedoProjectile* AME_TorpedoProjectile::GetDefaultObj()
{
	static class AME_TorpedoProjectile* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_TorpedoProjectile*>(AME_TorpedoProjectile::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_TorpedoProjectile.SetCanBeGrabbed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bCanGrab                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TorpedoProjectile::SetCanBeGrabbed(bool bCanGrab)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TorpedoProjectile", "SetCanBeGrabbed");

	Params::AME_TorpedoProjectile_SetCanBeGrabbed_Params Parms{};

	Parms.bCanGrab = bCanGrab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TorpedoProjectile.OnHomingLost
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_TorpedoProjectile::OnHomingLost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TorpedoProjectile", "OnHomingLost");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.ME_TorpedoProjectile.OnEvaded
// (Event, Public, BlueprintEvent)
// Parameters:

void AME_TorpedoProjectile::OnEvaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TorpedoProjectile", "OnEvaded");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.ME_TransparencyCaptureComponent
// (SceneComponent)

class UClass* UME_TransparencyCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TransparencyCaptureComponent");

	return Clss;
}


// ME_TransparencyCaptureComponent Maneater.Default__ME_TransparencyCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_TransparencyCaptureComponent* UME_TransparencyCaptureComponent::GetDefaultObj()
{
	static class UME_TransparencyCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_TransparencyCaptureComponent*>(UME_TransparencyCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_TutorialManager
// (Actor)

class UClass* AME_TutorialManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_TutorialManager");

	return Clss;
}


// ME_TutorialManager Maneater.Default__ME_TutorialManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_TutorialManager* AME_TutorialManager::GetDefaultObj()
{
	static class AME_TutorialManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_TutorialManager*>(AME_TutorialManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_TutorialManager.TriggerNarratorInitialProgressEvent
// (Final, Native, Private)
// Parameters:

void AME_TutorialManager::TriggerNarratorInitialProgressEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "TriggerNarratorInitialProgressEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.ShouldShowInGamePopupWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETutorialPopupID        PopupId                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::ShouldShowInGamePopupWidget(enum class ETutorialPopupID PopupId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "ShouldShowInGamePopupWidget");

	Params::AME_TutorialManager_ShouldShowInGamePopupWidget_Params Parms{};

	Parms.PopupId = PopupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.RequestInGamePopupWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETutorialPopupID        PopupId                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::RequestInGamePopupWidget(enum class ETutorialPopupID PopupId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "RequestInGamePopupWidget");

	Params::AME_TutorialManager_RequestInGamePopupWidget_Params Parms{};

	Parms.PopupId = PopupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.PushHudTip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::PushHudTip(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "PushHudTip");

	Params::AME_TutorialManager_PushHudTip_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnWhipShotPerformed
// (Final, Native, Public)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::OnWhipShotPerformed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnWhipShotPerformed");

	Params::AME_TutorialManager_OnWhipShotPerformed_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnTailwhipPerformed
// (Final, Native, Public)
// Parameters:

void AME_TutorialManager::OnTailwhipPerformed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnTailwhipPerformed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnPlayerConsumedPrey
// (Final, Native, Public)
// Parameters:
// class AME_AnimalCharacter*         Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Prey                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::OnPlayerConsumedPrey(class AME_AnimalCharacter* Player, class AActor* Prey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnPlayerConsumedPrey");

	Params::AME_TutorialManager_OnPlayerConsumedPrey_Params Parms{};

	Parms.Player = Player;
	Parms.Prey = Prey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnLungePerformed
// (Final, Native, Public)
// Parameters:

void AME_TutorialManager::OnLungePerformed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnLungePerformed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnKnifingStateChanged
// (Final, Native, Public)
// Parameters:
// bool                               NewKnifingState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECharacterActionMode    ChangeContext                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::OnKnifingStateChanged(bool NewKnifingState, enum class ECharacterActionMode ChangeContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnKnifingStateChanged");

	Params::AME_TutorialManager_OnKnifingStateChanged_Params Parms{};

	Parms.NewKnifingState = NewKnifingState;
	Parms.ChangeContext = ChangeContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnKnifingJumpPerformed
// (Final, Native, Public)
// Parameters:

void AME_TutorialManager::OnKnifingJumpPerformed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnKnifingJumpPerformed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnEvolutionEquipped
// (Final, Native, Public)
// Parameters:
// enum class EEvolutionSlot          EvolutionSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UME_PlayerEvolution*         Evolution                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::OnEvolutionEquipped(enum class EEvolutionSlot EvolutionSlot, class UME_PlayerEvolution* Evolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnEvolutionEquipped");

	Params::AME_TutorialManager_OnEvolutionEquipped_Params Parms{};

	Parms.EvolutionSlot = EvolutionSlot;
	Parms.Evolution = Evolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.OnBreachPerformed
// (Final, Native, Public)
// Parameters:

void AME_TutorialManager::OnBreachPerformed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "OnBreachPerformed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.IsTutorialPartTwoComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::IsTutorialPartTwoComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "IsTutorialPartTwoComplete");

	Params::AME_TutorialManager_IsTutorialPartTwoComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.IsTutorialPartOneComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::IsTutorialPartOneComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "IsTutorialPartOneComplete");

	Params::AME_TutorialManager_IsTutorialPartOneComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::IsEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "IsEnabled");

	Params::AME_TutorialManager_IsEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.IncrementObjective
// (Final, Native, Public)
// Parameters:
// bool                               ForceShowDelayedStep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_TutorialManager::IncrementObjective(bool ForceShowDelayedStep)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "IncrementObjective");

	Params::AME_TutorialManager_IncrementObjective_Params Parms{};

	Parms.ForceShowDelayedStep = ForceShowDelayedStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.GetCurrentTutorialIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETutorialEventId        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ETutorialEventId AME_TutorialManager::GetCurrentTutorialIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "GetCurrentTutorialIndex");

	Params::AME_TutorialManager_GetCurrentTutorialIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.DelayedShowInvertedControlsPopup
// (Final, Native, Private)
// Parameters:

void AME_TutorialManager::DelayedShowInvertedControlsPopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "DelayedShowInvertedControlsPopup");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.DelayedIncrementObjective
// (Final, Native, Private)
// Parameters:

void AME_TutorialManager::DelayedIncrementObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "DelayedIncrementObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_TutorialManager.CreateInGamePopupWidget
// (Final, Native, Public)
// Parameters:
// enum class ETutorialPopupID        PopupId                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_TutorialManager::CreateInGamePopupWidget(enum class ETutorialPopupID PopupId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "CreateInGamePopupWidget");

	Params::AME_TutorialManager_CreateInGamePopupWidget_Params Parms{};

	Parms.PopupId = PopupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.ME_TutorialManager.ClearHudTip
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AME_TutorialManager::ClearHudTip()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_TutorialManager", "ClearHudTip");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_UserProfileSettings
// (None)

class UClass* UME_UserProfileSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_UserProfileSettings");

	return Clss;
}


// ME_UserProfileSettings Maneater.Default__ME_UserProfileSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_UserProfileSettings* UME_UserProfileSettings::GetDefaultObj()
{
	static class UME_UserProfileSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_UserProfileSettings*>(UME_UserProfileSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_VehicleDebrisActor
// (Actor)

class UClass* AME_VehicleDebrisActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehicleDebrisActor");

	return Clss;
}


// ME_VehicleDebrisActor Maneater.Default__ME_VehicleDebrisActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_VehicleDebrisActor* AME_VehicleDebrisActor::GetDefaultObj()
{
	static class AME_VehicleDebrisActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_VehicleDebrisActor*>(AME_VehicleDebrisActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_VehicleNavigationComponent
// (None)

class UClass* UME_VehicleNavigationComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_VehicleNavigationComponent");

	return Clss;
}


// ME_VehicleNavigationComponent Maneater.Default__ME_VehicleNavigationComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_VehicleNavigationComponent* UME_VehicleNavigationComponent::GetDefaultObj()
{
	static class UME_VehicleNavigationComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_VehicleNavigationComponent*>(UME_VehicleNavigationComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_ViewportClient
// (None)

class UClass* UME_ViewportClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_ViewportClient");

	return Clss;
}


// ME_ViewportClient Maneater.Default__ME_ViewportClient
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_ViewportClient* UME_ViewportClient::GetDefaultObj()
{
	static class UME_ViewportClient* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_ViewportClient*>(UME_ViewportClient::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WaterVehicleMoveComponent
// (None)

class UClass* UME_WaterVehicleMoveComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WaterVehicleMoveComponent");

	return Clss;
}


// ME_WaterVehicleMoveComponent Maneater.Default__ME_WaterVehicleMoveComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WaterVehicleMoveComponent* UME_WaterVehicleMoveComponent::GetDefaultObj()
{
	static class UME_WaterVehicleMoveComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WaterVehicleMoveComponent*>(UME_WaterVehicleMoveComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WaterVehicleNavComponent
// (None)

class UClass* UME_WaterVehicleNavComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WaterVehicleNavComponent");

	return Clss;
}


// ME_WaterVehicleNavComponent Maneater.Default__ME_WaterVehicleNavComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WaterVehicleNavComponent* UME_WaterVehicleNavComponent::GetDefaultObj()
{
	static class UME_WaterVehicleNavComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WaterVehicleNavComponent*>(UME_WaterVehicleNavComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WaypointMarker
// (Actor)

class UClass* AME_WaypointMarker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WaypointMarker");

	return Clss;
}


// ME_WaypointMarker Maneater.Default__ME_WaypointMarker
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WaypointMarker* AME_WaypointMarker::GetDefaultObj()
{
	static class AME_WaypointMarker* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WaypointMarker*>(AME_WaypointMarker::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WhippableActorBase
// (Actor)

class UClass* AME_WhippableActorBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WhippableActorBase");

	return Clss;
}


// ME_WhippableActorBase Maneater.Default__ME_WhippableActorBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WhippableActorBase* AME_WhippableActorBase::GetDefaultObj()
{
	static class AME_WhippableActorBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WhippableActorBase*>(AME_WhippableActorBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WhipshotMovementComponent
// (None)

class UClass* UME_WhipshotMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WhipshotMovementComponent");

	return Clss;
}


// ME_WhipshotMovementComponent Maneater.Default__ME_WhipshotMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WhipshotMovementComponent* UME_WhipshotMovementComponent::GetDefaultObj()
{
	static class UME_WhipshotMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WhipshotMovementComponent*>(UME_WhipshotMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WhipshotMovementComponent.OnWhipShotVictimImpact
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         SelfActor                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherPrimitive                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UME_WhipshotMovementComponent::OnWhipShotVictimImpact(class UPrimitiveComponent* SelfActor, class AActor* OtherActor, class UPrimitiveComponent* OtherPrimitive, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WhipshotMovementComponent", "OnWhipShotVictimImpact");

	Params::UME_WhipshotMovementComponent_OnWhipShotVictimImpact_Params Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.OtherPrimitive = OtherPrimitive;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.ME_WildlifeCharacter
// (Actor, Pawn)

class UClass* AME_WildlifeCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WildlifeCharacter");

	return Clss;
}


// ME_WildlifeCharacter Maneater.Default__ME_WildlifeCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WildlifeCharacter* AME_WildlifeCharacter::GetDefaultObj()
{
	static class AME_WildlifeCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WildlifeCharacter*>(AME_WildlifeCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WorldMapCaptureComponent
// (SceneComponent)

class UClass* UME_WorldMapCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldMapCaptureComponent");

	return Clss;
}


// ME_WorldMapCaptureComponent Maneater.Default__ME_WorldMapCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WorldMapCaptureComponent* UME_WorldMapCaptureComponent::GetDefaultObj()
{
	static class UME_WorldMapCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WorldMapCaptureComponent*>(UME_WorldMapCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WorldMapWidget
// (None)

class UClass* UME_WorldMapWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldMapWidget");

	return Clss;
}


// ME_WorldMapWidget Maneater.Default__ME_WorldMapWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WorldMapWidget* UME_WorldMapWidget::GetDefaultObj()
{
	static class UME_WorldMapWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WorldMapWidget*>(UME_WorldMapWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WorldMapWidget.LoadSavedRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UME_WorldMapWidget::LoadSavedRenderTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldMapWidget", "LoadSavedRenderTarget");

	Params::UME_WorldMapWidget_LoadSavedRenderTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_WorldRegionData
// (None)

class UClass* UME_WorldRegionData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldRegionData");

	return Clss;
}


// ME_WorldRegionData Maneater.Default__ME_WorldRegionData
// (Public, ClassDefaultObject, ArchetypeObject)

class UME_WorldRegionData* UME_WorldRegionData::GetDefaultObj()
{
	static class UME_WorldRegionData* Default = nullptr;

	if (!Default)
		Default = static_cast<UME_WorldRegionData*>(UME_WorldRegionData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.ME_WorldRegionVolume
// (Actor)

class UClass* AME_WorldRegionVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldRegionVolume");

	return Clss;
}


// ME_WorldRegionVolume Maneater.Default__ME_WorldRegionVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WorldRegionVolume* AME_WorldRegionVolume::GetDefaultObj()
{
	static class AME_WorldRegionVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WorldRegionVolume*>(AME_WorldRegionVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WorldRegionVolume.PointIsWithinRegion
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SphereRadius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AME_WorldRegionVolume::PointIsWithinRegion(const struct FVector& Point, float SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldRegionVolume", "PointIsWithinRegion");

	Params::AME_WorldRegionVolume_PointIsWithinRegion_Params Parms{};

	Parms.Point = Point;
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.ME_WorldSettings
// (Actor)

class UClass* AME_WorldSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ME_WorldSettings");

	return Clss;
}


// ME_WorldSettings Maneater.Default__ME_WorldSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class AME_WorldSettings* AME_WorldSettings::GetDefaultObj()
{
	static class AME_WorldSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<AME_WorldSettings*>(AME_WorldSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.ME_WorldSettings.UpdateWorldCapture
// (Final, Native, Public)
// Parameters:

void AME_WorldSettings::UpdateWorldCapture()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldSettings", "UpdateWorldCapture");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WorldSettings.OnImpactParticleComplete
// (Final, Native, Private)
// Parameters:
// class UParticleSystemComponent*    PSystem                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_WorldSettings::OnImpactParticleComplete(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldSettings", "OnImpactParticleComplete");

	Params::AME_WorldSettings_OnImpactParticleComplete_Params Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.ME_WorldSettings.OnImpactAudioComplete
// (Final, Native, Private)
// Parameters:
// enum class EAkCallbackType         CallbackType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*             CallbackInfo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AME_WorldSettings::OnImpactAudioComplete(enum class EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ME_WorldSettings", "OnImpactAudioComplete");

	Params::AME_WorldSettings_OnImpactAudioComplete_Params Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEAIDataProvider_CombatHeight
// (None)

class UClass* UMEAIDataProvider_CombatHeight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEAIDataProvider_CombatHeight");

	return Clss;
}


// MEAIDataProvider_CombatHeight Maneater.Default__MEAIDataProvider_CombatHeight
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEAIDataProvider_CombatHeight* UMEAIDataProvider_CombatHeight::GetDefaultObj()
{
	static class UMEAIDataProvider_CombatHeight* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEAIDataProvider_CombatHeight*>(UMEAIDataProvider_CombatHeight::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEAIDataProvider_CombatRange
// (None)

class UClass* UMEAIDataProvider_CombatRange::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEAIDataProvider_CombatRange");

	return Clss;
}


// MEAIDataProvider_CombatRange Maneater.Default__MEAIDataProvider_CombatRange
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEAIDataProvider_CombatRange* UMEAIDataProvider_CombatRange::GetDefaultObj()
{
	static class UMEAIDataProvider_CombatRange* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEAIDataProvider_CombatRange*>(UMEAIDataProvider_CombatRange::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEAIDataProvider_EscapeVolExtents
// (None)

class UClass* UMEAIDataProvider_EscapeVolExtents::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEAIDataProvider_EscapeVolExtents");

	return Clss;
}


// MEAIDataProvider_EscapeVolExtents Maneater.Default__MEAIDataProvider_EscapeVolExtents
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEAIDataProvider_EscapeVolExtents* UMEAIDataProvider_EscapeVolExtents::GetDefaultObj()
{
	static class UMEAIDataProvider_EscapeVolExtents* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEAIDataProvider_EscapeVolExtents*>(UMEAIDataProvider_EscapeVolExtents::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEAIDataProvider_LeashDistance
// (None)

class UClass* UMEAIDataProvider_LeashDistance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEAIDataProvider_LeashDistance");

	return Clss;
}


// MEAIDataProvider_LeashDistance Maneater.Default__MEAIDataProvider_LeashDistance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEAIDataProvider_LeashDistance* UMEAIDataProvider_LeashDistance::GetDefaultObj()
{
	static class UMEAIDataProvider_LeashDistance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEAIDataProvider_LeashDistance*>(UMEAIDataProvider_LeashDistance::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_AbilityBase
// (None)

class UClass* UMEBTDecorator_AbilityBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_AbilityBase");

	return Clss;
}


// MEBTDecorator_AbilityBase Maneater.Default__MEBTDecorator_AbilityBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_AbilityBase* UMEBTDecorator_AbilityBase::GetDefaultObj()
{
	static class UMEBTDecorator_AbilityBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_AbilityBase*>(UMEBTDecorator_AbilityBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_BBValueChanged
// (None)

class UClass* UMEBTDecorator_BBValueChanged::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_BBValueChanged");

	return Clss;
}


// MEBTDecorator_BBValueChanged Maneater.Default__MEBTDecorator_BBValueChanged
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_BBValueChanged* UMEBTDecorator_BBValueChanged::GetDefaultObj()
{
	static class UMEBTDecorator_BBValueChanged* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_BBValueChanged*>(UMEBTDecorator_BBValueChanged::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_CanSpawnDiver
// (None)

class UClass* UMEBTDecorator_CanSpawnDiver::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_CanSpawnDiver");

	return Clss;
}


// MEBTDecorator_CanSpawnDiver Maneater.Default__MEBTDecorator_CanSpawnDiver
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_CanSpawnDiver* UMEBTDecorator_CanSpawnDiver::GetDefaultObj()
{
	static class UMEBTDecorator_CanSpawnDiver* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_CanSpawnDiver*>(UMEBTDecorator_CanSpawnDiver::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTDecorator_CanSpawnDiver.OnTrackedAIChange
// (Final, Native, Protected)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTDecorator_CanSpawnDiver::OnTrackedAIChange(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTDecorator_CanSpawnDiver", "OnTrackedAIChange");

	Params::UMEBTDecorator_CanSpawnDiver_OnTrackedAIChange_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTDecorator_CanUseAbility
// (None)

class UClass* UMEBTDecorator_CanUseAbility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_CanUseAbility");

	return Clss;
}


// MEBTDecorator_CanUseAbility Maneater.Default__MEBTDecorator_CanUseAbility
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_CanUseAbility* UMEBTDecorator_CanUseAbility::GetDefaultObj()
{
	static class UMEBTDecorator_CanUseAbility* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_CanUseAbility*>(UMEBTDecorator_CanUseAbility::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_CombatState
// (None)

class UClass* UMEBTDecorator_CombatState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_CombatState");

	return Clss;
}


// MEBTDecorator_CombatState Maneater.Default__MEBTDecorator_CombatState
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_CombatState* UMEBTDecorator_CombatState::GetDefaultObj()
{
	static class UMEBTDecorator_CombatState* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_CombatState*>(UMEBTDecorator_CombatState::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTDecorator_CombatState.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECombatStatus           PrevStatus                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTDecorator_CombatState::OnCombatStateChanged(class AME_AIController* AIC, enum class ECombatStatus PrevStatus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTDecorator_CombatState", "OnCombatStateChanged");

	Params::UMEBTDecorator_CombatState_OnCombatStateChanged_Params Parms{};

	Parms.AIC = AIC;
	Parms.PrevStatus = PrevStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTDecorator_HasGameplayTags
// (None)

class UClass* UMEBTDecorator_HasGameplayTags::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_HasGameplayTags");

	return Clss;
}


// MEBTDecorator_HasGameplayTags Maneater.Default__MEBTDecorator_HasGameplayTags
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_HasGameplayTags* UMEBTDecorator_HasGameplayTags::GetDefaultObj()
{
	static class UMEBTDecorator_HasGameplayTags* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_HasGameplayTags*>(UMEBTDecorator_HasGameplayTags::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_HasGrabbedPrey
// (None)

class UClass* UMEBTDecorator_HasGrabbedPrey::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_HasGrabbedPrey");

	return Clss;
}


// MEBTDecorator_HasGrabbedPrey Maneater.Default__MEBTDecorator_HasGrabbedPrey
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_HasGrabbedPrey* UMEBTDecorator_HasGrabbedPrey::GetDefaultObj()
{
	static class UMEBTDecorator_HasGrabbedPrey* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_HasGrabbedPrey*>(UMEBTDecorator_HasGrabbedPrey::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_IsPawnRelevant
// (None)

class UClass* UMEBTDecorator_IsPawnRelevant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_IsPawnRelevant");

	return Clss;
}


// MEBTDecorator_IsPawnRelevant Maneater.Default__MEBTDecorator_IsPawnRelevant
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_IsPawnRelevant* UMEBTDecorator_IsPawnRelevant::GetDefaultObj()
{
	static class UMEBTDecorator_IsPawnRelevant* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_IsPawnRelevant*>(UMEBTDecorator_IsPawnRelevant::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_LandOrSea
// (None)

class UClass* UMEBTDecorator_LandOrSea::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_LandOrSea");

	return Clss;
}


// MEBTDecorator_LandOrSea Maneater.Default__MEBTDecorator_LandOrSea
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_LandOrSea* UMEBTDecorator_LandOrSea::GetDefaultObj()
{
	static class UMEBTDecorator_LandOrSea* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_LandOrSea*>(UMEBTDecorator_LandOrSea::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_TimeSince
// (None)

class UClass* UMEBTDecorator_TimeSince::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_TimeSince");

	return Clss;
}


// MEBTDecorator_TimeSince Maneater.Default__MEBTDecorator_TimeSince
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_TimeSince* UMEBTDecorator_TimeSince::GetDefaultObj()
{
	static class UMEBTDecorator_TimeSince* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_TimeSince*>(UMEBTDecorator_TimeSince::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTDecorator_TimeSinceLastSpawn
// (None)

class UClass* UMEBTDecorator_TimeSinceLastSpawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_TimeSinceLastSpawn");

	return Clss;
}


// MEBTDecorator_TimeSinceLastSpawn Maneater.Default__MEBTDecorator_TimeSinceLastSpawn
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_TimeSinceLastSpawn* UMEBTDecorator_TimeSinceLastSpawn::GetDefaultObj()
{
	static class UMEBTDecorator_TimeSinceLastSpawn* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_TimeSinceLastSpawn*>(UMEBTDecorator_TimeSinceLastSpawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTDecorator_TimeSinceLastSpawn.OnNewSpawn
// (Final, Native, Protected)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTDecorator_TimeSinceLastSpawn::OnNewSpawn(class AME_AIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTDecorator_TimeSinceLastSpawn", "OnNewSpawn");

	Params::UMEBTDecorator_TimeSinceLastSpawn_OnNewSpawn_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTDecorator_WaterDepth
// (None)

class UClass* UMEBTDecorator_WaterDepth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTDecorator_WaterDepth");

	return Clss;
}


// MEBTDecorator_WaterDepth Maneater.Default__MEBTDecorator_WaterDepth
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTDecorator_WaterDepth* UMEBTDecorator_WaterDepth::GetDefaultObj()
{
	static class UMEBTDecorator_WaterDepth* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTDecorator_WaterDepth*>(UMEBTDecorator_WaterDepth::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_AbilityBase
// (None)

class UClass* UMEBTService_AbilityBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_AbilityBase");

	return Clss;
}


// MEBTService_AbilityBase Maneater.Default__MEBTService_AbilityBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_AbilityBase* UMEBTService_AbilityBase::GetDefaultObj()
{
	static class UMEBTService_AbilityBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_AbilityBase*>(UMEBTService_AbilityBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_AttackTarget
// (None)

class UClass* UMEBTService_AttackTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_AttackTarget");

	return Clss;
}


// MEBTService_AttackTarget Maneater.Default__MEBTService_AttackTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_AttackTarget* UMEBTService_AttackTarget::GetDefaultObj()
{
	static class UMEBTService_AttackTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_AttackTarget*>(UMEBTService_AttackTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_CacheEscapeRoutes
// (None)

class UClass* UMEBTService_CacheEscapeRoutes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_CacheEscapeRoutes");

	return Clss;
}


// MEBTService_CacheEscapeRoutes Maneater.Default__MEBTService_CacheEscapeRoutes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_CacheEscapeRoutes* UMEBTService_CacheEscapeRoutes::GetDefaultObj()
{
	static class UMEBTService_CacheEscapeRoutes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_CacheEscapeRoutes*>(UMEBTService_CacheEscapeRoutes::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_CheckThreatUnderBoat
// (None)

class UClass* UMEBTService_CheckThreatUnderBoat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_CheckThreatUnderBoat");

	return Clss;
}


// MEBTService_CheckThreatUnderBoat Maneater.Default__MEBTService_CheckThreatUnderBoat
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_CheckThreatUnderBoat* UMEBTService_CheckThreatUnderBoat::GetDefaultObj()
{
	static class UMEBTService_CheckThreatUnderBoat* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_CheckThreatUnderBoat*>(UMEBTService_CheckThreatUnderBoat::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_ClaimCombatLocation
// (None)

class UClass* UMEBTService_ClaimCombatLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_ClaimCombatLocation");

	return Clss;
}


// MEBTService_ClaimCombatLocation Maneater.Default__MEBTService_ClaimCombatLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_ClaimCombatLocation* UMEBTService_ClaimCombatLocation::GetDefaultObj()
{
	static class UMEBTService_ClaimCombatLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_ClaimCombatLocation*>(UMEBTService_ClaimCombatLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_LookForBoats
// (None)

class UClass* UMEBTService_LookForBoats::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_LookForBoats");

	return Clss;
}


// MEBTService_LookForBoats Maneater.Default__MEBTService_LookForBoats
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_LookForBoats* UMEBTService_LookForBoats::GetDefaultObj()
{
	static class UMEBTService_LookForBoats* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_LookForBoats*>(UMEBTService_LookForBoats::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_LookForThreats
// (None)

class UClass* UMEBTService_LookForThreats::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_LookForThreats");

	return Clss;
}


// MEBTService_LookForThreats Maneater.Default__MEBTService_LookForThreats
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_LookForThreats* UMEBTService_LookForThreats::GetDefaultObj()
{
	static class UMEBTService_LookForThreats* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_LookForThreats*>(UMEBTService_LookForThreats::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_RepelFromGeometry
// (None)

class UClass* UMEBTService_RepelFromGeometry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_RepelFromGeometry");

	return Clss;
}


// MEBTService_RepelFromGeometry Maneater.Default__MEBTService_RepelFromGeometry
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_RepelFromGeometry* UMEBTService_RepelFromGeometry::GetDefaultObj()
{
	static class UMEBTService_RepelFromGeometry* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_RepelFromGeometry*>(UMEBTService_RepelFromGeometry::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTService_UseAbility
// (None)

class UClass* UMEBTService_UseAbility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTService_UseAbility");

	return Clss;
}


// MEBTService_UseAbility Maneater.Default__MEBTService_UseAbility
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTService_UseAbility* UMEBTService_UseAbility::GetDefaultObj()
{
	static class UMEBTService_UseAbility* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTService_UseAbility*>(UMEBTService_UseAbility::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_AbilityBase
// (None)

class UClass* UMEBTTask_AbilityBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_AbilityBase");

	return Clss;
}


// MEBTTask_AbilityBase Maneater.Default__MEBTTask_AbilityBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_AbilityBase* UMEBTTask_AbilityBase::GetDefaultObj()
{
	static class UMEBTTask_AbilityBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_AbilityBase*>(UMEBTTask_AbilityBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTTask_AbilityBase.OnAbilityFinished
// (Final, Native, Public)
// Parameters:
// struct FGameplayAbilitySpecHandle  AbilityHandle                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBehaviorTreeComponent*      OwnerComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTTask_AbilityBase::OnAbilityFinished(const struct FGameplayAbilitySpecHandle& AbilityHandle, class UBehaviorTreeComponent* OwnerComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTTask_AbilityBase", "OnAbilityFinished");

	Params::UMEBTTask_AbilityBase_OnAbilityFinished_Params Parms{};

	Parms.AbilityHandle = AbilityHandle;
	Parms.OwnerComp = OwnerComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTTask_TargetBase
// (None)

class UClass* UMEBTTask_TargetBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_TargetBase");

	return Clss;
}


// MEBTTask_TargetBase Maneater.Default__MEBTTask_TargetBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_TargetBase* UMEBTTask_TargetBase::GetDefaultObj()
{
	static class UMEBTTask_TargetBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_TargetBase*>(UMEBTTask_TargetBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_AttackTarget
// (None)

class UClass* UMEBTTask_AttackTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_AttackTarget");

	return Clss;
}


// MEBTTask_AttackTarget Maneater.Default__MEBTTask_AttackTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_AttackTarget* UMEBTTask_AttackTarget::GetDefaultObj()
{
	static class UMEBTTask_AttackTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_AttackTarget*>(UMEBTTask_AttackTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_CacheActivityPoints
// (None)

class UClass* UMEBTTask_CacheActivityPoints::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_CacheActivityPoints");

	return Clss;
}


// MEBTTask_CacheActivityPoints Maneater.Default__MEBTTask_CacheActivityPoints
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_CacheActivityPoints* UMEBTTask_CacheActivityPoints::GetDefaultObj()
{
	static class UMEBTTask_CacheActivityPoints* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_CacheActivityPoints*>(UMEBTTask_CacheActivityPoints::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_CacheEscapeRoutes
// (None)

class UClass* UMEBTTask_CacheEscapeRoutes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_CacheEscapeRoutes");

	return Clss;
}


// MEBTTask_CacheEscapeRoutes Maneater.Default__MEBTTask_CacheEscapeRoutes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_CacheEscapeRoutes* UMEBTTask_CacheEscapeRoutes::GetDefaultObj()
{
	static class UMEBTTask_CacheEscapeRoutes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_CacheEscapeRoutes*>(UMEBTTask_CacheEscapeRoutes::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_ChangeAlertState
// (None)

class UClass* UMEBTTask_ChangeAlertState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_ChangeAlertState");

	return Clss;
}


// MEBTTask_ChangeAlertState Maneater.Default__MEBTTask_ChangeAlertState
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_ChangeAlertState* UMEBTTask_ChangeAlertState::GetDefaultObj()
{
	static class UMEBTTask_ChangeAlertState* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_ChangeAlertState*>(UMEBTTask_ChangeAlertState::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_ChangeCombatPriority
// (None)

class UClass* UMEBTTask_ChangeCombatPriority::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_ChangeCombatPriority");

	return Clss;
}


// MEBTTask_ChangeCombatPriority Maneater.Default__MEBTTask_ChangeCombatPriority
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_ChangeCombatPriority* UMEBTTask_ChangeCombatPriority::GetDefaultObj()
{
	static class UMEBTTask_ChangeCombatPriority* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_ChangeCombatPriority*>(UMEBTTask_ChangeCombatPriority::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_ClaimCombatLocation
// (None)

class UClass* UMEBTTask_ClaimCombatLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_ClaimCombatLocation");

	return Clss;
}


// MEBTTask_ClaimCombatLocation Maneater.Default__MEBTTask_ClaimCombatLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_ClaimCombatLocation* UMEBTTask_ClaimCombatLocation::GetDefaultObj()
{
	static class UMEBTTask_ClaimCombatLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_ClaimCombatLocation*>(UMEBTTask_ClaimCombatLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_MoveToBase
// (None)

class UClass* UMEBTTask_MoveToBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_MoveToBase");

	return Clss;
}


// MEBTTask_MoveToBase Maneater.Default__MEBTTask_MoveToBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_MoveToBase* UMEBTTask_MoveToBase::GetDefaultObj()
{
	static class UMEBTTask_MoveToBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_MoveToBase*>(UMEBTTask_MoveToBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_DirectMoveTo
// (None)

class UClass* UMEBTTask_DirectMoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_DirectMoveTo");

	return Clss;
}


// MEBTTask_DirectMoveTo Maneater.Default__MEBTTask_DirectMoveTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_DirectMoveTo* UMEBTTask_DirectMoveTo::GetDefaultObj()
{
	static class UMEBTTask_DirectMoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_DirectMoveTo*>(UMEBTTask_DirectMoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_EjectPassengers
// (None)

class UClass* UMEBTTask_EjectPassengers::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_EjectPassengers");

	return Clss;
}


// MEBTTask_EjectPassengers Maneater.Default__MEBTTask_EjectPassengers
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_EjectPassengers* UMEBTTask_EjectPassengers::GetDefaultObj()
{
	static class UMEBTTask_EjectPassengers* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_EjectPassengers*>(UMEBTTask_EjectPassengers::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_EmitNoise
// (None)

class UClass* UMEBTTask_EmitNoise::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_EmitNoise");

	return Clss;
}


// MEBTTask_EmitNoise Maneater.Default__MEBTTask_EmitNoise
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_EmitNoise* UMEBTTask_EmitNoise::GetDefaultObj()
{
	static class UMEBTTask_EmitNoise* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_EmitNoise*>(UMEBTTask_EmitNoise::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_FireTorpedo
// (None)

class UClass* UMEBTTask_FireTorpedo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_FireTorpedo");

	return Clss;
}


// MEBTTask_FireTorpedo Maneater.Default__MEBTTask_FireTorpedo
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_FireTorpedo* UMEBTTask_FireTorpedo::GetDefaultObj()
{
	static class UMEBTTask_FireTorpedo* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_FireTorpedo*>(UMEBTTask_FireTorpedo::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_GetNextPatrol
// (None)

class UClass* UMEBTTask_GetNextPatrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_GetNextPatrol");

	return Clss;
}


// MEBTTask_GetNextPatrol Maneater.Default__MEBTTask_GetNextPatrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_GetNextPatrol* UMEBTTask_GetNextPatrol::GetDefaultObj()
{
	static class UMEBTTask_GetNextPatrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_GetNextPatrol*>(UMEBTTask_GetNextPatrol::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_MoveTo
// (None)

class UClass* UMEBTTask_MoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_MoveTo");

	return Clss;
}


// MEBTTask_MoveTo Maneater.Default__MEBTTask_MoveTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_MoveTo* UMEBTTask_MoveTo::GetDefaultObj()
{
	static class UMEBTTask_MoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_MoveTo*>(UMEBTTask_MoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTTask_MoveTo.OnRequestIdUpdated
// (Final, Native, Private)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                UpdatedRequestId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTTask_MoveTo::OnRequestIdUpdated(class AME_AIController* AIC, const struct FAIRequestID& UpdatedRequestId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTTask_MoveTo", "OnRequestIdUpdated");

	Params::UMEBTTask_MoveTo_OnRequestIdUpdated_Params Parms{};

	Parms.AIC = AIC;
	Parms.UpdatedRequestId = UpdatedRequestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTTask_PlayCustomAnimations
// (None)

class UClass* UMEBTTask_PlayCustomAnimations::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_PlayCustomAnimations");

	return Clss;
}


// MEBTTask_PlayCustomAnimations Maneater.Default__MEBTTask_PlayCustomAnimations
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_PlayCustomAnimations* UMEBTTask_PlayCustomAnimations::GetDefaultObj()
{
	static class UMEBTTask_PlayCustomAnimations* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_PlayCustomAnimations*>(UMEBTTask_PlayCustomAnimations::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTTask_PlayCustomAnimations.OnMontageComplete
// (Final, Native, Protected)
// Parameters:

void UMEBTTask_PlayCustomAnimations::OnMontageComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTTask_PlayCustomAnimations", "OnMontageComplete");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTTask_PlayCustomPassengerAnimations
// (None)

class UClass* UMEBTTask_PlayCustomPassengerAnimations::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_PlayCustomPassengerAnimations");

	return Clss;
}


// MEBTTask_PlayCustomPassengerAnimations Maneater.Default__MEBTTask_PlayCustomPassengerAnimations
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_PlayCustomPassengerAnimations* UMEBTTask_PlayCustomPassengerAnimations::GetDefaultObj()
{
	static class UMEBTTask_PlayCustomPassengerAnimations* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_PlayCustomPassengerAnimations*>(UMEBTTask_PlayCustomPassengerAnimations::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_PlayDialogueAkEvent
// (None)

class UClass* UMEBTTask_PlayDialogueAkEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_PlayDialogueAkEvent");

	return Clss;
}


// MEBTTask_PlayDialogueAkEvent Maneater.Default__MEBTTask_PlayDialogueAkEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_PlayDialogueAkEvent* UMEBTTask_PlayDialogueAkEvent::GetDefaultObj()
{
	static class UMEBTTask_PlayDialogueAkEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_PlayDialogueAkEvent*>(UMEBTTask_PlayDialogueAkEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_PlayDialogueFile
// (None)

class UClass* UMEBTTask_PlayDialogueFile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_PlayDialogueFile");

	return Clss;
}


// MEBTTask_PlayDialogueFile Maneater.Default__MEBTTask_PlayDialogueFile
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_PlayDialogueFile* UMEBTTask_PlayDialogueFile::GetDefaultObj()
{
	static class UMEBTTask_PlayDialogueFile* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_PlayDialogueFile*>(UMEBTTask_PlayDialogueFile::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_ReleasePrey
// (None)

class UClass* UMEBTTask_ReleasePrey::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_ReleasePrey");

	return Clss;
}


// MEBTTask_ReleasePrey Maneater.Default__MEBTTask_ReleasePrey
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_ReleasePrey* UMEBTTask_ReleasePrey::GetDefaultObj()
{
	static class UMEBTTask_ReleasePrey* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_ReleasePrey*>(UMEBTTask_ReleasePrey::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_RemoveAI
// (None)

class UClass* UMEBTTask_RemoveAI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_RemoveAI");

	return Clss;
}


// MEBTTask_RemoveAI Maneater.Default__MEBTTask_RemoveAI
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_RemoveAI* UMEBTTask_RemoveAI::GetDefaultObj()
{
	static class UMEBTTask_RemoveAI* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_RemoveAI*>(UMEBTTask_RemoveAI::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_SpawnActor
// (None)

class UClass* UMEBTTask_SpawnActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_SpawnActor");

	return Clss;
}


// MEBTTask_SpawnActor Maneater.Default__MEBTTask_SpawnActor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_SpawnActor* UMEBTTask_SpawnActor::GetDefaultObj()
{
	static class UMEBTTask_SpawnActor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_SpawnActor*>(UMEBTTask_SpawnActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_SpawnAI
// (None)

class UClass* UMEBTTask_SpawnAI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_SpawnAI");

	return Clss;
}


// MEBTTask_SpawnAI Maneater.Default__MEBTTask_SpawnAI
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_SpawnAI* UMEBTTask_SpawnAI::GetDefaultObj()
{
	static class UMEBTTask_SpawnAI* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_SpawnAI*>(UMEBTTask_SpawnAI::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTTask_SpawnAI.OnSpawnComplete
// (Final, Native, Private)
// Parameters:
// class AME_BoatAIController*        AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTTask_SpawnAI::OnSpawnComplete(class AME_BoatAIController* AIC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTTask_SpawnAI", "OnSpawnComplete");

	Params::UMEBTTask_SpawnAI_OnSpawnComplete_Params Parms{};

	Parms.AIC = AIC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MEBTTask_StopAllMovement
// (None)

class UClass* UMEBTTask_StopAllMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_StopAllMovement");

	return Clss;
}


// MEBTTask_StopAllMovement Maneater.Default__MEBTTask_StopAllMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_StopAllMovement* UMEBTTask_StopAllMovement::GetDefaultObj()
{
	static class UMEBTTask_StopAllMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_StopAllMovement*>(UMEBTTask_StopAllMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_StopCustomAnimation
// (None)

class UClass* UMEBTTask_StopCustomAnimation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_StopCustomAnimation");

	return Clss;
}


// MEBTTask_StopCustomAnimation Maneater.Default__MEBTTask_StopCustomAnimation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_StopCustomAnimation* UMEBTTask_StopCustomAnimation::GetDefaultObj()
{
	static class UMEBTTask_StopCustomAnimation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_StopCustomAnimation*>(UMEBTTask_StopCustomAnimation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_UseAbility
// (None)

class UClass* UMEBTTask_UseAbility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_UseAbility");

	return Clss;
}


// MEBTTask_UseAbility Maneater.Default__MEBTTask_UseAbility
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_UseAbility* UMEBTTask_UseAbility::GetDefaultObj()
{
	static class UMEBTTask_UseAbility* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_UseAbility*>(UMEBTTask_UseAbility::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEBTTask_VehicleMoveTo
// (None)

class UClass* UMEBTTask_VehicleMoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEBTTask_VehicleMoveTo");

	return Clss;
}


// MEBTTask_VehicleMoveTo Maneater.Default__MEBTTask_VehicleMoveTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEBTTask_VehicleMoveTo* UMEBTTask_VehicleMoveTo::GetDefaultObj()
{
	static class UMEBTTask_VehicleMoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEBTTask_VehicleMoveTo*>(UMEBTTask_VehicleMoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MEBTTask_VehicleMoveTo.OnRequestIdUpdated
// (Final, Native, Private)
// Parameters:
// class AME_AIController*            AIC                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                UpdatedRequestId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMEBTTask_VehicleMoveTo::OnRequestIdUpdated(class AME_AIController* AIC, const struct FAIRequestID& UpdatedRequestId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MEBTTask_VehicleMoveTo", "OnRequestIdUpdated");

	Params::UMEBTTask_VehicleMoveTo_OnRequestIdUpdated_Params Parms{};

	Parms.AIC = AIC;
	Parms.UpdatedRequestId = UpdatedRequestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MED_AirVehicleMoveComponent
// (None)

class UClass* UMED_AirVehicleMoveComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_AirVehicleMoveComponent");

	return Clss;
}


// MED_AirVehicleMoveComponent Maneater.Default__MED_AirVehicleMoveComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_AirVehicleMoveComponent* UMED_AirVehicleMoveComponent::GetDefaultObj()
{
	static class UMED_AirVehicleMoveComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_AirVehicleMoveComponent*>(UMED_AirVehicleMoveComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_AirVehicleMoveComponent.SetMaxSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              UpdatedSpeed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMED_AirVehicleMoveComponent::SetMaxSpeedModifier(float UpdatedSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_AirVehicleMoveComponent", "SetMaxSpeedModifier");

	Params::UMED_AirVehicleMoveComponent_SetMaxSpeedModifier_Params Parms{};

	Parms.UpdatedSpeed = UpdatedSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_AirVehicleMoveComponent.SetGoalLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMED_AirVehicleMoveComponent::SetGoalLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_AirVehicleMoveComponent", "SetGoalLocation");

	Params::UMED_AirVehicleMoveComponent_SetGoalLocation_Params Parms{};

	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MED_AirVehicleNavComponent
// (None)

class UClass* UMED_AirVehicleNavComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_AirVehicleNavComponent");

	return Clss;
}


// MED_AirVehicleNavComponent Maneater.Default__MED_AirVehicleNavComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_AirVehicleNavComponent* UMED_AirVehicleNavComponent::GetDefaultObj()
{
	static class UMED_AirVehicleNavComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_AirVehicleNavComponent*>(UMED_AirVehicleNavComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_AnimInstance_HumanNPC
// (None)

class UClass* UMED_AnimInstance_HumanNPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_AnimInstance_HumanNPC");

	return Clss;
}


// MED_AnimInstance_HumanNPC Maneater.Default__MED_AnimInstance_HumanNPC
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_AnimInstance_HumanNPC* UMED_AnimInstance_HumanNPC::GetDefaultObj()
{
	static class UMED_AnimInstance_HumanNPC* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_AnimInstance_HumanNPC*>(UMED_AnimInstance_HumanNPC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_BountyManager
// (Actor)

class UClass* AMED_BountyManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_BountyManager");

	return Clss;
}


// MED_BountyManager Maneater.Default__MED_BountyManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_BountyManager* AMED_BountyManager::GetDefaultObj()
{
	static class AMED_BountyManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_BountyManager*>(AMED_BountyManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_BountyManager.PlaceOnHold
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_BountyManager::PlaceOnHold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_BountyManager", "PlaceOnHold");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_BountyManager.GetIsBountyOnHold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_BountyManager::GetIsBountyOnHold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_BountyManager", "GetIsBountyOnHold");

	Params::AMED_BountyManager_GetIsBountyOnHold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_BountyManagerTierData
// (None)

class UClass* UMED_BountyManagerTierData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_BountyManagerTierData");

	return Clss;
}


// MED_BountyManagerTierData Maneater.Default__MED_BountyManagerTierData
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_BountyManagerTierData* UMED_BountyManagerTierData::GetDefaultObj()
{
	static class UMED_BountyManagerTierData* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_BountyManagerTierData*>(UMED_BountyManagerTierData::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_CharacterAttributeSet
// (None)

class UClass* UMED_CharacterAttributeSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_CharacterAttributeSet");

	return Clss;
}


// MED_CharacterAttributeSet Maneater.Default__MED_CharacterAttributeSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_CharacterAttributeSet* UMED_CharacterAttributeSet::GetDefaultObj()
{
	static class UMED_CharacterAttributeSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_CharacterAttributeSet*>(UMED_CharacterAttributeSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_CharacterFunctionLibrary
// (None)

class UClass* UMED_CharacterFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_CharacterFunctionLibrary");

	return Clss;
}


// MED_CharacterFunctionLibrary Maneater.Default__MED_CharacterFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_CharacterFunctionLibrary* UMED_CharacterFunctionLibrary::GetDefaultObj()
{
	static class UMED_CharacterFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_CharacterFunctionLibrary*>(UMED_CharacterFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_CharacterFunctionLibrary.GetRunMoveSpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMED_CharacterFunctionLibrary::GetRunMoveSpeed(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_CharacterFunctionLibrary", "GetRunMoveSpeed");

	Params::UMED_CharacterFunctionLibrary_GetRunMoveSpeed_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_CharacterFunctionLibrary.GetFlyMoveSpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AME_Character*               TwChar                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMED_CharacterFunctionLibrary::GetFlyMoveSpeed(class AME_Character* TwChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_CharacterFunctionLibrary", "GetFlyMoveSpeed");

	Params::UMED_CharacterFunctionLibrary_GetFlyMoveSpeed_Params Parms{};

	Parms.TwChar = TwChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_CharacterMovementComponent
// (None)

class UClass* UMED_CharacterMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_CharacterMovementComponent");

	return Clss;
}


// MED_CharacterMovementComponent Maneater.Default__MED_CharacterMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_CharacterMovementComponent* UMED_CharacterMovementComponent::GetDefaultObj()
{
	static class UMED_CharacterMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_CharacterMovementComponent*>(UMED_CharacterMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SaveData_DLC
// (None)

class UClass* UMED_SaveData_DLC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SaveData_DLC");

	return Clss;
}


// MED_SaveData_DLC Maneater.Default__MED_SaveData_DLC
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SaveData_DLC* UMED_SaveData_DLC::GetDefaultObj()
{
	static class UMED_SaveData_DLC* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SaveData_DLC*>(UMED_SaveData_DLC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SaveData_DLC01
// (None)

class UClass* UMED_SaveData_DLC01::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SaveData_DLC01");

	return Clss;
}


// MED_SaveData_DLC01 Maneater.Default__MED_SaveData_DLC01
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SaveData_DLC01* UMED_SaveData_DLC01::GetDefaultObj()
{
	static class UMED_SaveData_DLC01* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SaveData_DLC01*>(UMED_SaveData_DLC01::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_DLCManager
// (Actor)

class UClass* AMED_DLCManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_DLCManager");

	return Clss;
}


// MED_DLCManager Maneater.Default__MED_DLCManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_DLCManager* AMED_DLCManager::GetDefaultObj()
{
	static class AMED_DLCManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_DLCManager*>(AMED_DLCManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_DLCManager.UnlockAchievementForEnteringDLC01Map
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_DLCManager::UnlockAchievementForEnteringDLC01Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "UnlockAchievementForEnteringDLC01Map");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_DLCManager.SetHasEnteredDLC01Map
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bSet                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_DLCManager::SetHasEnteredDLC01Map(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "SetHasEnteredDLC01Map");

	Params::AMED_DLCManager_SetHasEnteredDLC01Map_Params Parms{};

	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_DLCManager.SetHasCompletedDLC01Map
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bSet                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_DLCManager::SetHasCompletedDLC01Map(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "SetHasCompletedDLC01Map");

	Params::AMED_DLCManager_SetHasCompletedDLC01Map_Params Parms{};

	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_DLCManager.OwnsDLC01
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_DLCManager::OwnsDLC01()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "OwnsDLC01");

	Params::AMED_DLCManager_OwnsDLC01_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_DLCManager.LaunchPurchaseOverlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDLCType                DLCType                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_DLCManager::LaunchPurchaseOverlay(enum class EDLCType DLCType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "LaunchPurchaseOverlay");

	Params::AMED_DLCManager_LaunchPurchaseOverlay_Params Parms{};

	Parms.DLCType = DLCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_DLCManager.IsInDLC01Map
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_DLCManager::IsInDLC01Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "IsInDLC01Map");

	Params::AMED_DLCManager_IsInDLC01Map_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_DLCManager.HasEnteredDLC01Map
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_DLCManager::HasEnteredDLC01Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "HasEnteredDLC01Map");

	Params::AMED_DLCManager_HasEnteredDLC01Map_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_DLCManager.HasCompletedDLC01Map
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_DLCManager::HasCompletedDLC01Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_DLCManager", "HasCompletedDLC01Map");

	Params::AMED_DLCManager_HasCompletedDLC01Map_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_FlyingVehiclePawn
// (Actor, Pawn)

class UClass* AMED_FlyingVehiclePawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_FlyingVehiclePawn");

	return Clss;
}


// MED_FlyingVehiclePawn Maneater.Default__MED_FlyingVehiclePawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_FlyingVehiclePawn* AMED_FlyingVehiclePawn::GetDefaultObj()
{
	static class AMED_FlyingVehiclePawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_FlyingVehiclePawn*>(AMED_FlyingVehiclePawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_FlyingVehiclePawn.TriggerFullPassengerEjection
// (Final, Native, Protected)
// Parameters:

void AMED_FlyingVehiclePawn::TriggerFullPassengerEjection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "TriggerFullPassengerEjection");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.SetToCrash
// (Final, Native, Protected)
// Parameters:

void AMED_FlyingVehiclePawn::SetToCrash()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "SetToCrash");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.OnRotorOverlapEnd
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_FlyingVehiclePawn::OnRotorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "OnRotorOverlapEnd");

	Params::AMED_FlyingVehiclePawn_OnRotorOverlapEnd_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.OnRotorOverlapBegin
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMED_FlyingVehiclePawn::OnRotorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "OnRotorOverlapBegin");

	Params::AMED_FlyingVehiclePawn_OnRotorOverlapBegin_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.OnRotorEjectedPassengerImpact
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         HitComp                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMED_FlyingVehiclePawn::OnRotorEjectedPassengerImpact(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "OnRotorEjectedPassengerImpact");

	Params::AMED_FlyingVehiclePawn_OnRotorEjectedPassengerImpact_Params Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.DeactivateSideTargeting
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_FlyingVehiclePawn::DeactivateSideTargeting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "DeactivateSideTargeting");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.DeactivateHoverMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_FlyingVehiclePawn::DeactivateHoverMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "DeactivateHoverMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.DeactivateCircleTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_FlyingVehiclePawn::DeactivateCircleTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "DeactivateCircleTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.ActivateSideTargeting
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_FlyingVehiclePawn::ActivateSideTargeting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "ActivateSideTargeting");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.ActivateHoverMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              HoverStoppingDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HoverHeight                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bActivateSideTargeting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_FlyingVehiclePawn::ActivateHoverMode(float HoverStoppingDistance, float HoverHeight, bool bActivateSideTargeting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "ActivateHoverMode");

	Params::AMED_FlyingVehiclePawn_ActivateHoverMode_Params Parms{};

	Parms.HoverStoppingDistance = HoverStoppingDistance;
	Parms.HoverHeight = HoverHeight;
	Parms.bActivateSideTargeting = bActivateSideTargeting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_FlyingVehiclePawn.ActivateCircleTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_FlyingVehiclePawn::ActivateCircleTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_FlyingVehiclePawn", "ActivateCircleTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MED_HelicopterAIController
// (Actor)

class UClass* AMED_HelicopterAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_HelicopterAIController");

	return Clss;
}


// MED_HelicopterAIController Maneater.Default__MED_HelicopterAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_HelicopterAIController* AMED_HelicopterAIController::GetDefaultObj()
{
	static class AMED_HelicopterAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_HelicopterAIController*>(AMED_HelicopterAIController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_LandHunterAIController
// (Actor)

class UClass* AMED_LandHunterAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_LandHunterAIController");

	return Clss;
}


// MED_LandHunterAIController Maneater.Default__MED_LandHunterAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_LandHunterAIController* AMED_LandHunterAIController::GetDefaultObj()
{
	static class AMED_LandHunterAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_LandHunterAIController*>(AMED_LandHunterAIController::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_NavigationSystem
// (None)

class UClass* UMED_NavigationSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_NavigationSystem");

	return Clss;
}


// MED_NavigationSystem Maneater.Default__MED_NavigationSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_NavigationSystem* UMED_NavigationSystem::GetDefaultObj()
{
	static class UMED_NavigationSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_NavigationSystem*>(UMED_NavigationSystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ObjectiveCondition_BountyOnHold
// (None)

class UClass* UMED_ObjectiveCondition_BountyOnHold::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ObjectiveCondition_BountyOnHold");

	return Clss;
}


// MED_ObjectiveCondition_BountyOnHold Maneater.Default__MED_ObjectiveCondition_BountyOnHold
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ObjectiveCondition_BountyOnHold* UMED_ObjectiveCondition_BountyOnHold::GetDefaultObj()
{
	static class UMED_ObjectiveCondition_BountyOnHold* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ObjectiveCondition_BountyOnHold*>(UMED_ObjectiveCondition_BountyOnHold::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ObjectiveCondition_HasCompletedDLCMap
// (None)

class UClass* UMED_ObjectiveCondition_HasCompletedDLCMap::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ObjectiveCondition_HasCompletedDLCMap");

	return Clss;
}


// MED_ObjectiveCondition_HasCompletedDLCMap Maneater.Default__MED_ObjectiveCondition_HasCompletedDLCMap
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ObjectiveCondition_HasCompletedDLCMap* UMED_ObjectiveCondition_HasCompletedDLCMap::GetDefaultObj()
{
	static class UMED_ObjectiveCondition_HasCompletedDLCMap* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ObjectiveCondition_HasCompletedDLCMap*>(UMED_ObjectiveCondition_HasCompletedDLCMap::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ObjectiveCondition_InfamyRank_DLC01
// (None)

class UClass* UMED_ObjectiveCondition_InfamyRank_DLC01::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ObjectiveCondition_InfamyRank_DLC01");

	return Clss;
}


// MED_ObjectiveCondition_InfamyRank_DLC01 Maneater.Default__MED_ObjectiveCondition_InfamyRank_DLC01
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ObjectiveCondition_InfamyRank_DLC01* UMED_ObjectiveCondition_InfamyRank_DLC01::GetDefaultObj()
{
	static class UMED_ObjectiveCondition_InfamyRank_DLC01* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ObjectiveCondition_InfamyRank_DLC01*>(UMED_ObjectiveCondition_InfamyRank_DLC01::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ObjectiveCondition_OwnsDLC
// (None)

class UClass* UMED_ObjectiveCondition_OwnsDLC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ObjectiveCondition_OwnsDLC");

	return Clss;
}


// MED_ObjectiveCondition_OwnsDLC Maneater.Default__MED_ObjectiveCondition_OwnsDLC
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ObjectiveCondition_OwnsDLC* UMED_ObjectiveCondition_OwnsDLC::GetDefaultObj()
{
	static class UMED_ObjectiveCondition_OwnsDLC* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ObjectiveCondition_OwnsDLC*>(UMED_ObjectiveCondition_OwnsDLC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ParticleModuleDynamicallyHideWithOwner
// (None)

class UClass* UMED_ParticleModuleDynamicallyHideWithOwner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ParticleModuleDynamicallyHideWithOwner");

	return Clss;
}


// MED_ParticleModuleDynamicallyHideWithOwner Maneater.Default__MED_ParticleModuleDynamicallyHideWithOwner
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ParticleModuleDynamicallyHideWithOwner* UMED_ParticleModuleDynamicallyHideWithOwner::GetDefaultObj()
{
	static class UMED_ParticleModuleDynamicallyHideWithOwner* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ParticleModuleDynamicallyHideWithOwner*>(UMED_ParticleModuleDynamicallyHideWithOwner::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark
// (None)

class UClass* UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark");

	return Clss;
}


// MED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark Maneater.Default__MED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark* UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark::GetDefaultObj()
{
	static class UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark*>(UMED_ParticleModuleDynamicTranslucencySort_AttachedToPlayerShark::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_ParticleModuleSeagullball
// (None)

class UClass* UMED_ParticleModuleSeagullball::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_ParticleModuleSeagullball");

	return Clss;
}


// MED_ParticleModuleSeagullball Maneater.Default__MED_ParticleModuleSeagullball
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_ParticleModuleSeagullball* UMED_ParticleModuleSeagullball::GetDefaultObj()
{
	static class UMED_ParticleModuleSeagullball* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_ParticleModuleSeagullball*>(UMED_ParticleModuleSeagullball::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_PlayerObjective_BountyTrigger
// (None)

class UClass* UMED_PlayerObjective_BountyTrigger::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjective_BountyTrigger");

	return Clss;
}


// MED_PlayerObjective_BountyTrigger Maneater.Default__MED_PlayerObjective_BountyTrigger
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjective_BountyTrigger* UMED_PlayerObjective_BountyTrigger::GetDefaultObj()
{
	static class UMED_PlayerObjective_BountyTrigger* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjective_BountyTrigger*>(UMED_PlayerObjective_BountyTrigger::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_PlayerObjective_BountyTrigger.OnPlayerDied
// (Final, Native, Protected)
// Parameters:

void UMED_PlayerObjective_BountyTrigger::OnPlayerDied()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_PlayerObjective_BountyTrigger", "OnPlayerDied");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_PlayerObjective_BountyTrigger.OnBountyEnding
// (Final, Native, Protected)
// Parameters:

void UMED_PlayerObjective_BountyTrigger::OnBountyEnding()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_PlayerObjective_BountyTrigger", "OnBountyEnding");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_PlayerObjective_BountyTrigger.OnBountyBossDefeated
// (Final, Native, Protected)
// Parameters:
// int32                              Rank                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMED_PlayerObjective_BountyTrigger::OnBountyBossDefeated(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_PlayerObjective_BountyTrigger", "OnBountyBossDefeated");

	Params::UMED_PlayerObjective_BountyTrigger_OnBountyBossDefeated_Params Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MED_WaveSpawner
// (Actor)

class UClass* AMED_WaveSpawner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_WaveSpawner");

	return Clss;
}


// MED_WaveSpawner Maneater.Default__MED_WaveSpawner
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_WaveSpawner* AMED_WaveSpawner::GetDefaultObj()
{
	static class AMED_WaveSpawner* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_WaveSpawner*>(AMED_WaveSpawner::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_WaveSpawner.StopWave
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMED_WaveSpawner::StopWave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WaveSpawner", "StopWave");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.MED_WaveSpawner.StartWave
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMED_WaveSpawner::StartWave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WaveSpawner", "StartWave");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.MED_WaveSpawner.SpawnWaveAI
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                      SpawnClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SpawnLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    SpawnRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AME_AIController*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AME_AIController* AMED_WaveSpawner::SpawnWaveAI(class UClass* SpawnClass, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WaveSpawner", "SpawnWaveAI");

	Params::AMED_WaveSpawner_SpawnWaveAI_Params Parms{};

	Parms.SpawnClass = SpawnClass;
	Parms.SpawnLocation = SpawnLocation;
	Parms.SpawnRotation = SpawnRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_WaveSpawner.Spawn
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMED_WaveSpawner::Spawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WaveSpawner", "Spawn");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.MED_WaveSpawner.Cleanup
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMED_WaveSpawner::Cleanup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WaveSpawner", "Cleanup");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.MED_PlayerObjective_DestroyBreakable
// (None)

class UClass* UMED_PlayerObjective_DestroyBreakable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjective_DestroyBreakable");

	return Clss;
}


// MED_PlayerObjective_DestroyBreakable Maneater.Default__MED_PlayerObjective_DestroyBreakable
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjective_DestroyBreakable* UMED_PlayerObjective_DestroyBreakable::GetDefaultObj()
{
	static class UMED_PlayerObjective_DestroyBreakable* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjective_DestroyBreakable*>(UMED_PlayerObjective_DestroyBreakable::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_PlayerObjective_FailureToCommunicate
// (None)

class UClass* UMED_PlayerObjective_FailureToCommunicate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjective_FailureToCommunicate");

	return Clss;
}


// MED_PlayerObjective_FailureToCommunicate Maneater.Default__MED_PlayerObjective_FailureToCommunicate
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjective_FailureToCommunicate* UMED_PlayerObjective_FailureToCommunicate::GetDefaultObj()
{
	static class UMED_PlayerObjective_FailureToCommunicate* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjective_FailureToCommunicate*>(UMED_PlayerObjective_FailureToCommunicate::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_PlayerObjective_GoTo
// (None)

class UClass* UMED_PlayerObjective_GoTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjective_GoTo");

	return Clss;
}


// MED_PlayerObjective_GoTo Maneater.Default__MED_PlayerObjective_GoTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjective_GoTo* UMED_PlayerObjective_GoTo::GetDefaultObj()
{
	static class UMED_PlayerObjective_GoTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjective_GoTo*>(UMED_PlayerObjective_GoTo::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_PlayerObjective_TinFoilHat
// (None)

class UClass* UMED_PlayerObjective_TinFoilHat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjective_TinFoilHat");

	return Clss;
}


// MED_PlayerObjective_TinFoilHat Maneater.Default__MED_PlayerObjective_TinFoilHat
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjective_TinFoilHat* UMED_PlayerObjective_TinFoilHat::GetDefaultObj()
{
	static class UMED_PlayerObjective_TinFoilHat* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjective_TinFoilHat*>(UMED_PlayerObjective_TinFoilHat::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_PlayerObjective_TinFoilHat.GetSubObjectiveByActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      SearchingActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTinFoilHatSubObject        OutSubObjective                                                  (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMED_PlayerObjective_TinFoilHat::GetSubObjectiveByActor(class AActor* SearchingActor, struct FTinFoilHatSubObject* OutSubObjective)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_PlayerObjective_TinFoilHat", "GetSubObjectiveByActor");

	Params::UMED_PlayerObjective_TinFoilHat_GetSubObjectiveByActor_Params Parms{};

	Parms.SearchingActor = SearchingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSubObjective != nullptr)
		*OutSubObjective = std::move(Parms.OutSubObjective);

	return Parms.ReturnValue;

}


// Class Maneater.MED_PlayerObjectiveTimeTrial
// (None)

class UClass* UMED_PlayerObjectiveTimeTrial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_PlayerObjectiveTimeTrial");

	return Clss;
}


// MED_PlayerObjectiveTimeTrial Maneater.Default__MED_PlayerObjectiveTimeTrial
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_PlayerObjectiveTimeTrial* UMED_PlayerObjectiveTimeTrial::GetDefaultObj()
{
	static class UMED_PlayerObjectiveTimeTrial* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_PlayerObjectiveTimeTrial*>(UMED_PlayerObjectiveTimeTrial::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_PlayerObjectiveTimeTrial.GetTimerRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMED_PlayerObjectiveTimeTrial::GetTimerRemaining()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_PlayerObjectiveTimeTrial", "GetTimerRemaining");

	Params::UMED_PlayerObjectiveTimeTrial_GetTimerRemaining_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_SpawnListCondition_ActiveBountyState
// (None)

class UClass* UMED_SpawnListCondition_ActiveBountyState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_ActiveBountyState");

	return Clss;
}


// MED_SpawnListCondition_ActiveBountyState Maneater.Default__MED_SpawnListCondition_ActiveBountyState
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_ActiveBountyState* UMED_SpawnListCondition_ActiveBountyState::GetDefaultObj()
{
	static class UMED_SpawnListCondition_ActiveBountyState* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_ActiveBountyState*>(UMED_SpawnListCondition_ActiveBountyState::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_DLC01_Current_StoryEvent
// (None)

class UClass* UMED_SpawnListCondition_DLC01_Current_StoryEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_DLC01_Current_StoryEvent");

	return Clss;
}


// MED_SpawnListCondition_DLC01_Current_StoryEvent Maneater.Default__MED_SpawnListCondition_DLC01_Current_StoryEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_DLC01_Current_StoryEvent* UMED_SpawnListCondition_DLC01_Current_StoryEvent::GetDefaultObj()
{
	static class UMED_SpawnListCondition_DLC01_Current_StoryEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_DLC01_Current_StoryEvent*>(UMED_SpawnListCondition_DLC01_Current_StoryEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_ForceHostileBoats
// (None)

class UClass* UMED_SpawnListCondition_ForceHostileBoats::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_ForceHostileBoats");

	return Clss;
}


// MED_SpawnListCondition_ForceHostileBoats Maneater.Default__MED_SpawnListCondition_ForceHostileBoats
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_ForceHostileBoats* UMED_SpawnListCondition_ForceHostileBoats::GetDefaultObj()
{
	static class UMED_SpawnListCondition_ForceHostileBoats* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_ForceHostileBoats*>(UMED_SpawnListCondition_ForceHostileBoats::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_HasCompletedDLC01
// (None)

class UClass* UMED_SpawnListCondition_HasCompletedDLC01::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_HasCompletedDLC01");

	return Clss;
}


// MED_SpawnListCondition_HasCompletedDLC01 Maneater.Default__MED_SpawnListCondition_HasCompletedDLC01
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_HasCompletedDLC01* UMED_SpawnListCondition_HasCompletedDLC01::GetDefaultObj()
{
	static class UMED_SpawnListCondition_HasCompletedDLC01* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_HasCompletedDLC01*>(UMED_SpawnListCondition_HasCompletedDLC01::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_ObjectiveTypeInProgress
// (None)

class UClass* UMED_SpawnListCondition_ObjectiveTypeInProgress::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_ObjectiveTypeInProgress");

	return Clss;
}


// MED_SpawnListCondition_ObjectiveTypeInProgress Maneater.Default__MED_SpawnListCondition_ObjectiveTypeInProgress
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_ObjectiveTypeInProgress* UMED_SpawnListCondition_ObjectiveTypeInProgress::GetDefaultObj()
{
	static class UMED_SpawnListCondition_ObjectiveTypeInProgress* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_ObjectiveTypeInProgress*>(UMED_SpawnListCondition_ObjectiveTypeInProgress::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_InProgressTimeTrial
// (None)

class UClass* UMED_SpawnListCondition_InProgressTimeTrial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_InProgressTimeTrial");

	return Clss;
}


// MED_SpawnListCondition_InProgressTimeTrial Maneater.Default__MED_SpawnListCondition_InProgressTimeTrial
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_InProgressTimeTrial* UMED_SpawnListCondition_InProgressTimeTrial::GetDefaultObj()
{
	static class UMED_SpawnListCondition_InProgressTimeTrial* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_InProgressTimeTrial*>(UMED_SpawnListCondition_InProgressTimeTrial::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_InProgressFTC
// (None)

class UClass* UMED_SpawnListCondition_InProgressFTC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_InProgressFTC");

	return Clss;
}


// MED_SpawnListCondition_InProgressFTC Maneater.Default__MED_SpawnListCondition_InProgressFTC
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_InProgressFTC* UMED_SpawnListCondition_InProgressFTC::GetDefaultObj()
{
	static class UMED_SpawnListCondition_InProgressFTC* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_InProgressFTC*>(UMED_SpawnListCondition_InProgressFTC::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_SpawnListCondition_InProgressHunt
// (None)

class UClass* UMED_SpawnListCondition_InProgressHunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_SpawnListCondition_InProgressHunt");

	return Clss;
}


// MED_SpawnListCondition_InProgressHunt Maneater.Default__MED_SpawnListCondition_InProgressHunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_SpawnListCondition_InProgressHunt* UMED_SpawnListCondition_InProgressHunt::GetDefaultObj()
{
	static class UMED_SpawnListCondition_InProgressHunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_SpawnListCondition_InProgressHunt*>(UMED_SpawnListCondition_InProgressHunt::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_StaticPropActor
// (Actor)

class UClass* AMED_StaticPropActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_StaticPropActor");

	return Clss;
}


// MED_StaticPropActor Maneater.Default__MED_StaticPropActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_StaticPropActor* AMED_StaticPropActor::GetDefaultObj()
{
	static class AMED_StaticPropActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_StaticPropActor*>(AMED_StaticPropActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_StaticPropActor.HandleActorHitByPawn
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         SelfActor                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherPrimitive                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMED_StaticPropActor::HandleActorHitByPawn(class UPrimitiveComponent* SelfActor, class AActor* OtherActor, class UPrimitiveComponent* OtherPrimitive, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_StaticPropActor", "HandleActorHitByPawn");

	Params::AMED_StaticPropActor_HandleActorHitByPawn_Params Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.OtherPrimitive = OtherPrimitive;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Maneater.MED_Teleporter
// (Actor)

class UClass* AMED_Teleporter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_Teleporter");

	return Clss;
}


// MED_Teleporter Maneater.Default__MED_Teleporter
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_Teleporter* AMED_Teleporter::GetDefaultObj()
{
	static class AMED_Teleporter* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_Teleporter*>(AMED_Teleporter::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_Teleporter.SetTeleportEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMED_Teleporter::SetTeleportEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "SetTeleportEnabled");

	Params::AMED_Teleporter_SetTeleportEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_Teleporter.OnTeleportSequenceStarted
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMED_Teleporter::OnTeleportSequenceStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "OnTeleportSequenceStarted");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Maneater.MED_Teleporter.IsTeleportEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_Teleporter::IsTeleportEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "IsTeleportEnabled");

	Params::AMED_Teleporter_IsTeleportEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_Teleporter.HandleCinematicFinished
// (Final, Native, Private)
// Parameters:

void AMED_Teleporter::HandleCinematicFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "HandleCinematicFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_Teleporter.GetMissingRequiredProducts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FMED_TeleporterProductRequirement>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FMED_TeleporterProductRequirement> AMED_Teleporter::GetMissingRequiredProducts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "GetMissingRequiredProducts");

	Params::AMED_Teleporter_GetMissingRequiredProducts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_Teleporter.GetDestination
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMED_TeleporterDestination*  ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMED_TeleporterDestination* AMED_Teleporter::GetDestination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "GetDestination");

	Params::AMED_Teleporter_GetDestination_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_Teleporter.CanUseTeleporter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AME_PlayerSharkCharacter*    PlayerShark                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsFromMenu                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EFastTravelReturn       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EFastTravelReturn AMED_Teleporter::CanUseTeleporter(class AME_PlayerSharkCharacter* PlayerShark, bool IsFromMenu)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_Teleporter", "CanUseTeleporter");

	Params::AMED_Teleporter_CanUseTeleporter_Params Parms{};

	Parms.PlayerShark = PlayerShark;
	Parms.IsFromMenu = IsFromMenu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_TeleporterDestination
// (None)

class UClass* UMED_TeleporterDestination::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_TeleporterDestination");

	return Clss;
}


// MED_TeleporterDestination Maneater.Default__MED_TeleporterDestination
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_TeleporterDestination* UMED_TeleporterDestination::GetDefaultObj()
{
	static class UMED_TeleporterDestination* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_TeleporterDestination*>(UMED_TeleporterDestination::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_TeleporterDestination.GetWorldRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMED_TeleporterDestination::GetWorldRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetWorldRotation");

	Params::UMED_TeleporterDestination_GetWorldRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetWorldLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMED_TeleporterDestination::GetWorldLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetWorldLocation");

	Params::UMED_TeleporterDestination_GetWorldLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetRequiredProducts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FMED_TeleporterProductRequirement>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FMED_TeleporterProductRequirement> UMED_TeleporterDestination::GetRequiredProducts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetRequiredProducts");

	Params::UMED_TeleporterDestination_GetRequiredProducts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetPreTravelCinematicSaveId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UMED_TeleporterDestination::GetPreTravelCinematicSaveId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetPreTravelCinematicSaveId");

	Params::UMED_TeleporterDestination_GetPreTravelCinematicSaveId_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetPreTravelCinematicDataTableRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMED_TeleporterDestination::GetPreTravelCinematicDataTableRowName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetPreTravelCinematicDataTableRowName");

	Params::UMED_TeleporterDestination_GetPreTravelCinematicDataTableRowName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetLevelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMED_TeleporterDestination::GetLevelName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetLevelName");

	Params::UMED_TeleporterDestination_GetLevelName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetInWorldWidgetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMED_TeleporterDestination::GetInWorldWidgetText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetInWorldWidgetText");

	Params::UMED_TeleporterDestination_GetInWorldWidgetText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMED_TeleporterDestination::GetDisplayName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetDisplayName");

	Params::UMED_TeleporterDestination_GetDisplayName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_TeleporterDestination.GetDisplayIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UMED_TeleporterDestination::GetDisplayIcon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TeleporterDestination", "GetDisplayIcon");

	Params::UMED_TeleporterDestination_GetDisplayIcon_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_TimeTrialController
// (Actor)

class UClass* AMED_TimeTrialController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_TimeTrialController");

	return Clss;
}


// MED_TimeTrialController Maneater.Default__MED_TimeTrialController
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_TimeTrialController* AMED_TimeTrialController::GetDefaultObj()
{
	static class AMED_TimeTrialController* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_TimeTrialController*>(AMED_TimeTrialController::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_TimeTrialController.ResetObjective
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AMED_TimeTrialController::ResetObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TimeTrialController", "ResetObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_TimeTrialController.ProgressObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMED_TimeTrialController::ProgressObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TimeTrialController", "ProgressObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_TimeTrialController.BeginFadeSequence
// (Event, Public, BlueprintEvent)
// Parameters:

void AMED_TimeTrialController::BeginFadeSequence()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TimeTrialController", "BeginFadeSequence");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Maneater.MED_TimeTrialRingBase
// (Actor)

class UClass* AMED_TimeTrialRingBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_TimeTrialRingBase");

	return Clss;
}


// MED_TimeTrialRingBase Maneater.Default__MED_TimeTrialRingBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_TimeTrialRingBase* AMED_TimeTrialRingBase::GetDefaultObj()
{
	static class AMED_TimeTrialRingBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_TimeTrialRingBase*>(AMED_TimeTrialRingBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MED_TinFoilHatActor
// (Actor, Pawn)

class UClass* AMED_TinFoilHatActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_TinFoilHatActor");

	return Clss;
}


// MED_TinFoilHatActor Maneater.Default__MED_TinFoilHatActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AMED_TinFoilHatActor* AMED_TinFoilHatActor::GetDefaultObj()
{
	static class AMED_TinFoilHatActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AMED_TinFoilHatActor*>(AMED_TinFoilHatActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_TinFoilHatActor.CheckObjectStateCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMED_TinFoilHatActor::CheckObjectStateCompleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_TinFoilHatActor", "CheckObjectStateCompleted");

	Params::AMED_TinFoilHatActor_CheckObjectStateCompleted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MED_WeaponComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UMED_WeaponComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MED_WeaponComponent");

	return Clss;
}


// MED_WeaponComponent Maneater.Default__MED_WeaponComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMED_WeaponComponent* UMED_WeaponComponent::GetDefaultObj()
{
	static class UMED_WeaponComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMED_WeaponComponent*>(UMED_WeaponComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.MED_WeaponComponent.SetAITreeWindowOpen
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               SetTo                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMED_WeaponComponent::SetAITreeWindowOpen(bool SetTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WeaponComponent", "SetAITreeWindowOpen");

	Params::UMED_WeaponComponent_SetAITreeWindowOpen_Params Parms{};

	Parms.SetTo = SetTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.MED_WeaponComponent.GetLastFireTime
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMED_WeaponComponent::GetLastFireTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WeaponComponent", "GetLastFireTime");

	Params::UMED_WeaponComponent_GetLastFireTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_WeaponComponent.GetLaserLockOnStartTime
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMED_WeaponComponent::GetLaserLockOnStartTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WeaponComponent", "GetLaserLockOnStartTime");

	Params::UMED_WeaponComponent_GetLaserLockOnStartTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Maneater.MED_WeaponComponent.GetIsLaserPointerShown
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMED_WeaponComponent::GetIsLaserPointerShown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MED_WeaponComponent", "GetIsLaserPointerShown");

	Params::UMED_WeaponComponent_GetIsLaserPointerShown_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Maneater.MEEnvQueryContext_BoatEscape
// (None)

class UClass* UMEEnvQueryContext_BoatEscape::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_BoatEscape");

	return Clss;
}


// MEEnvQueryContext_BoatEscape Maneater.Default__MEEnvQueryContext_BoatEscape
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_BoatEscape* UMEEnvQueryContext_BoatEscape::GetDefaultObj()
{
	static class UMEEnvQueryContext_BoatEscape* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_BoatEscape*>(UMEEnvQueryContext_BoatEscape::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_BossVehicleActor
// (None)

class UClass* UMEEnvQueryContext_BossVehicleActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_BossVehicleActor");

	return Clss;
}


// MEEnvQueryContext_BossVehicleActor Maneater.Default__MEEnvQueryContext_BossVehicleActor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_BossVehicleActor* UMEEnvQueryContext_BossVehicleActor::GetDefaultObj()
{
	static class UMEEnvQueryContext_BossVehicleActor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_BossVehicleActor*>(UMEEnvQueryContext_BossVehicleActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_ClosestEscape
// (None)

class UClass* UMEEnvQueryContext_ClosestEscape::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_ClosestEscape");

	return Clss;
}


// MEEnvQueryContext_ClosestEscape Maneater.Default__MEEnvQueryContext_ClosestEscape
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_ClosestEscape* UMEEnvQueryContext_ClosestEscape::GetDefaultObj()
{
	static class UMEEnvQueryContext_ClosestEscape* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_ClosestEscape*>(UMEEnvQueryContext_ClosestEscape::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_ClosestLandNavPoint
// (None)

class UClass* UMEEnvQueryContext_ClosestLandNavPoint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_ClosestLandNavPoint");

	return Clss;
}


// MEEnvQueryContext_ClosestLandNavPoint Maneater.Default__MEEnvQueryContext_ClosestLandNavPoint
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_ClosestLandNavPoint* UMEEnvQueryContext_ClosestLandNavPoint::GetDefaultObj()
{
	static class UMEEnvQueryContext_ClosestLandNavPoint* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_ClosestLandNavPoint*>(UMEEnvQueryContext_ClosestLandNavPoint::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_CombatLocation
// (None)

class UClass* UMEEnvQueryContext_CombatLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_CombatLocation");

	return Clss;
}


// MEEnvQueryContext_CombatLocation Maneater.Default__MEEnvQueryContext_CombatLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_CombatLocation* UMEEnvQueryContext_CombatLocation::GetDefaultObj()
{
	static class UMEEnvQueryContext_CombatLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_CombatLocation*>(UMEEnvQueryContext_CombatLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_LastSawThreatLocation
// (None)

class UClass* UMEEnvQueryContext_LastSawThreatLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_LastSawThreatLocation");

	return Clss;
}


// MEEnvQueryContext_LastSawThreatLocation Maneater.Default__MEEnvQueryContext_LastSawThreatLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_LastSawThreatLocation* UMEEnvQueryContext_LastSawThreatLocation::GetDefaultObj()
{
	static class UMEEnvQueryContext_LastSawThreatLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_LastSawThreatLocation*>(UMEEnvQueryContext_LastSawThreatLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_LeashLocation
// (None)

class UClass* UMEEnvQueryContext_LeashLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_LeashLocation");

	return Clss;
}


// MEEnvQueryContext_LeashLocation Maneater.Default__MEEnvQueryContext_LeashLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_LeashLocation* UMEEnvQueryContext_LeashLocation::GetDefaultObj()
{
	static class UMEEnvQueryContext_LeashLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_LeashLocation*>(UMEEnvQueryContext_LeashLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_NextPatrolLoc
// (None)

class UClass* UMEEnvQueryContext_NextPatrolLoc::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_NextPatrolLoc");

	return Clss;
}


// MEEnvQueryContext_NextPatrolLoc Maneater.Default__MEEnvQueryContext_NextPatrolLoc
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_NextPatrolLoc* UMEEnvQueryContext_NextPatrolLoc::GetDefaultObj()
{
	static class UMEEnvQueryContext_NextPatrolLoc* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_NextPatrolLoc*>(UMEEnvQueryContext_NextPatrolLoc::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_PlayerCameraLocation
// (None)

class UClass* UMEEnvQueryContext_PlayerCameraLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_PlayerCameraLocation");

	return Clss;
}


// MEEnvQueryContext_PlayerCameraLocation Maneater.Default__MEEnvQueryContext_PlayerCameraLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_PlayerCameraLocation* UMEEnvQueryContext_PlayerCameraLocation::GetDefaultObj()
{
	static class UMEEnvQueryContext_PlayerCameraLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_PlayerCameraLocation*>(UMEEnvQueryContext_PlayerCameraLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryContext_PlayerCameraRotation
// (None)

class UClass* UMEEnvQueryContext_PlayerCameraRotation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryContext_PlayerCameraRotation");

	return Clss;
}


// MEEnvQueryContext_PlayerCameraRotation Maneater.Default__MEEnvQueryContext_PlayerCameraRotation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryContext_PlayerCameraRotation* UMEEnvQueryContext_PlayerCameraRotation::GetDefaultObj()
{
	static class UMEEnvQueryContext_PlayerCameraRotation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryContext_PlayerCameraRotation*>(UMEEnvQueryContext_PlayerCameraRotation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryGenerator_3DGrid
// (None)

class UClass* UMEEnvQueryGenerator_3DGrid::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryGenerator_3DGrid");

	return Clss;
}


// MEEnvQueryGenerator_3DGrid Maneater.Default__MEEnvQueryGenerator_3DGrid
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryGenerator_3DGrid* UMEEnvQueryGenerator_3DGrid::GetDefaultObj()
{
	static class UMEEnvQueryGenerator_3DGrid* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryGenerator_3DGrid*>(UMEEnvQueryGenerator_3DGrid::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryGenerator_CombatLocations
// (None)

class UClass* UMEEnvQueryGenerator_CombatLocations::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryGenerator_CombatLocations");

	return Clss;
}


// MEEnvQueryGenerator_CombatLocations Maneater.Default__MEEnvQueryGenerator_CombatLocations
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryGenerator_CombatLocations* UMEEnvQueryGenerator_CombatLocations::GetDefaultObj()
{
	static class UMEEnvQueryGenerator_CombatLocations* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryGenerator_CombatLocations*>(UMEEnvQueryGenerator_CombatLocations::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryGenerator_EscapeVolume
// (None)

class UClass* UMEEnvQueryGenerator_EscapeVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryGenerator_EscapeVolume");

	return Clss;
}


// MEEnvQueryGenerator_EscapeVolume Maneater.Default__MEEnvQueryGenerator_EscapeVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryGenerator_EscapeVolume* UMEEnvQueryGenerator_EscapeVolume::GetDefaultObj()
{
	static class UMEEnvQueryGenerator_EscapeVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryGenerator_EscapeVolume*>(UMEEnvQueryGenerator_EscapeVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryItemType_CombatLocation
// (None)

class UClass* UMEEnvQueryItemType_CombatLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryItemType_CombatLocation");

	return Clss;
}


// MEEnvQueryItemType_CombatLocation Maneater.Default__MEEnvQueryItemType_CombatLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryItemType_CombatLocation* UMEEnvQueryItemType_CombatLocation::GetDefaultObj()
{
	static class UMEEnvQueryItemType_CombatLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryItemType_CombatLocation*>(UMEEnvQueryItemType_CombatLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryTest_InsideEscapeVol
// (None)

class UClass* UMEEnvQueryTest_InsideEscapeVol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryTest_InsideEscapeVol");

	return Clss;
}


// MEEnvQueryTest_InsideEscapeVol Maneater.Default__MEEnvQueryTest_InsideEscapeVol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryTest_InsideEscapeVol* UMEEnvQueryTest_InsideEscapeVol::GetDefaultObj()
{
	static class UMEEnvQueryTest_InsideEscapeVol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryTest_InsideEscapeVol*>(UMEEnvQueryTest_InsideEscapeVol::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryTest_IsInsideOcean
// (None)

class UClass* UMEEnvQueryTest_IsInsideOcean::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryTest_IsInsideOcean");

	return Clss;
}


// MEEnvQueryTest_IsInsideOcean Maneater.Default__MEEnvQueryTest_IsInsideOcean
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryTest_IsInsideOcean* UMEEnvQueryTest_IsInsideOcean::GetDefaultObj()
{
	static class UMEEnvQueryTest_IsInsideOcean* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryTest_IsInsideOcean*>(UMEEnvQueryTest_IsInsideOcean::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryTest_ProjectToSeaLevel
// (None)

class UClass* UMEEnvQueryTest_ProjectToSeaLevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryTest_ProjectToSeaLevel");

	return Clss;
}


// MEEnvQueryTest_ProjectToSeaLevel Maneater.Default__MEEnvQueryTest_ProjectToSeaLevel
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryTest_ProjectToSeaLevel* UMEEnvQueryTest_ProjectToSeaLevel::GetDefaultObj()
{
	static class UMEEnvQueryTest_ProjectToSeaLevel* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryTest_ProjectToSeaLevel*>(UMEEnvQueryTest_ProjectToSeaLevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEnvQueryTest_WaterDepth
// (None)

class UClass* UMEEnvQueryTest_WaterDepth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEnvQueryTest_WaterDepth");

	return Clss;
}


// MEEnvQueryTest_WaterDepth Maneater.Default__MEEnvQueryTest_WaterDepth
// (Public, ClassDefaultObject, ArchetypeObject)

class UMEEnvQueryTest_WaterDepth* UMEEnvQueryTest_WaterDepth::GetDefaultObj()
{
	static class UMEEnvQueryTest_WaterDepth* Default = nullptr;

	if (!Default)
		Default = static_cast<UMEEnvQueryTest_WaterDepth*>(UMEEnvQueryTest_WaterDepth::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MEEscapeVolume
// (Actor)

class UClass* AMEEscapeVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MEEscapeVolume");

	return Clss;
}


// MEEscapeVolume Maneater.Default__MEEscapeVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AMEEscapeVolume* AMEEscapeVolume::GetDefaultObj()
{
	static class AMEEscapeVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AMEEscapeVolume*>(AMEEscapeVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MENavArea_Escape
// (None)

class UClass* UMENavArea_Escape::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MENavArea_Escape");

	return Clss;
}


// MENavArea_Escape Maneater.Default__MENavArea_Escape
// (Public, ClassDefaultObject, ArchetypeObject)

class UMENavArea_Escape* UMENavArea_Escape::GetDefaultObj()
{
	static class UMENavArea_Escape* Default = nullptr;

	if (!Default)
		Default = static_cast<UMENavArea_Escape*>(UMENavArea_Escape::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.MerEQSTestingPawn
// (Actor, Pawn)

class UClass* AMerEQSTestingPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MerEQSTestingPawn");

	return Clss;
}


// MerEQSTestingPawn Maneater.Default__MerEQSTestingPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class AMerEQSTestingPawn* AMerEQSTestingPawn::GetDefaultObj()
{
	static class AMerEQSTestingPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<AMerEQSTestingPawn*>(AMerEQSTestingPawn::StaticClass()->DefaultObject);

	return Default;
}


// Class Maneater.OvodusButton
// (None)

class UClass* UOvodusButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OvodusButton");

	return Clss;
}


// OvodusButton Maneater.Default__OvodusButton
// (Public, ClassDefaultObject, ArchetypeObject)

class UOvodusButton* UOvodusButton::GetDefaultObj()
{
	static class UOvodusButton* Default = nullptr;

	if (!Default)
		Default = static_cast<UOvodusButton*>(UOvodusButton::StaticClass()->DefaultObject);

	return Default;
}


// Function Maneater.OvodusButton.UpdateCursorOverlaps
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGeometry                   AllottedGeometry                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOvodusButton::UpdateCursorOverlaps(struct FGeometry& AllottedGeometry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OvodusButton", "UpdateCursorOverlaps");

	Params::UOvodusButton_UpdateCursorOverlaps_Params Parms{};

	Parms.AllottedGeometry = AllottedGeometry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.OvodusButton.SetAdvancedHitTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  InTexture                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOvodusButton::SetAdvancedHitTexture(class UTexture2D* InTexture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OvodusButton", "SetAdvancedHitTexture");

	Params::UOvodusButton_SetAdvancedHitTexture_Params Parms{};

	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Maneater.OvodusButton.SetAdvancedHitAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InAlpha                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOvodusButton::SetAdvancedHitAlpha(int32 InAlpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OvodusButton", "SetAdvancedHitAlpha");

	Params::UOvodusButton_SetAdvancedHitAlpha_Params Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}

}


