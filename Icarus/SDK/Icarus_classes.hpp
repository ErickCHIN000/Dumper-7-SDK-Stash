#pragma once

// Dumped with Dumper-7!


namespace SDK
{
//---------------------------------------------------------------------------------------------------------------------
// CLASSES
//---------------------------------------------------------------------------------------------------------------------

// 0x0 (0x28 - 0x28)
// Class Icarus.AccoladeImpl
class UAccoladeImpl : public UObject
{
public:

	static class UClass* StaticClass();
	static class UAccoladeImpl* GetDefaultObj();

	bool ShouldRunAccoladeOnStartup(class UWorld* WorldContext, const struct FAccoladesRowHandle& Accolade);
	bool RunAccolade(class UWorld* WorldContext, const struct FAccoladesRowHandle& Accolade);
	bool GetAccoladeProgress(class UWorld* WorldContext, const struct FAccoladesRowHandle& Accolade, int32* OutProgress);
	int32 GetAccoladeMaxProgressValue(class UWorld* WorldContext, const struct FAccoladesRowHandle& Accolade);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AccoladesLibrary
class UAccoladesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAccoladesLibrary* GetDefaultObj();

	struct FAccoladesRowHandle StructToRowHandle(const struct FAccoladesEnum& EnumValue);
	class FName StructToName(const struct FAccoladesEnum& EnumValue);
	int32 StructToInt(const struct FAccoladesEnum& EnumValue);
	struct FAccoladesEnum RowHandleToStruct(const struct FAccoladesRowHandle& RowHandle);
	void RemoveRowFromAccoladesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAccoladesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAccoladesEnum& A, const struct FAccoladesEnum& B);
	struct FAccoladesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAccoladesRowHandle MakeLiteralAccolades(const struct FAccoladesRowHandle& RowHandle);
	struct FAccoladesRowHandle MakeAccoladesFromIndex(int32 Index);
	struct FAccoladesEnum MakeAccoladesEnum(const struct FAccoladesEnum& Enum);
	struct FAccoladesRowHandle MakeAccolades(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAccoladesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAccoladesStruct(const struct FAccoladesRowHandle& RowHandle, struct FAccoladeData* Accolades, enum class EValid* Paths);
	bool EqualEqual_FAccoladesRowHandleFAccoladesRowHandle(const struct FAccoladesRowHandle& RowHandleA, const struct FAccoladesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAccoladesEnum& A, const struct FAccoladesEnum& B);
	struct FAccoladesRowHandle CastToAccoladesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAccoladesEnum(const struct FAccoladesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAccoladesTable(class FName Name, const struct FAccoladeData& Data, struct FAccoladesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AccoladesTable
class UAccoladesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAccoladesTable* GetDefaultObj();

};

// 0xC0 (0xF0 - 0x30)
// Class Icarus.AccoladeSubsystem
class UAccoladeSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnAccoladeCompleted;                               // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnAccoladeUpdated;                                 // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1744[0x38];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FAccoladeCompletedState>       CompletedAccolades;                                // 0x88(0x10)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	uint8                                        Pad_1746[0x58];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UAccoladeSubsystem* GetDefaultObj();

	void TryCompleteOneOffAccolade(class AIcarusPlayerCharacter* Player, const struct FAccoladesRowHandle& Accolade);
	void ResetAccolades();
	void PostPlayerTrackerInitialized();
	void OnTrackerUpdated(const struct FPlayerTrackersRowHandle& Tracker, int32 OldValue, int32 NewValue);
	void OnTalentUpdated(class AIcarusPlayerCharacter* Player);
	bool IsTaskListAccolade(struct FAccoladesRowHandle& AccoladeRow);
	bool IsAccoladeCompleted(struct FAccoladesRowHandle& AccoladeRow);
	TArray<struct FAccoladesRowHandle> GetSortedIncompleteAccolades();
	TArray<struct FAccoladeCompletedState> GetCompletedAccoladesWithProspectID(const class FString& ProspectID);
	TArray<struct FAccoladeCompletedState> GetCompletedAccolades();
	TArray<struct FAccoladeTaskState> GetAccoladeTaskStates(class AIcarusPlayerCharacter* Character, struct FAccoladesRowHandle& AccoladeRow);
	bool GetAccoladeProgress(struct FAccoladesRowHandle& AccoladeRow, int32* CurrentValue, int32* MaxValue, struct FDateTime* TimeCompleted);
	bool DeleteAccoladeSave(struct FPlayerCharacterID& PlayerCharacterID);
	void CheckAgainstCompletedAccolades();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AccountFlagsLibrary
class UAccountFlagsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAccountFlagsLibrary* GetDefaultObj();

	struct FAccountFlagsRowHandle StructToRowHandle(const struct FAccountFlagsEnum& EnumValue);
	class FName StructToName(const struct FAccountFlagsEnum& EnumValue);
	int32 StructToInt(const struct FAccountFlagsEnum& EnumValue);
	struct FAccountFlagsEnum RowHandleToStruct(const struct FAccountFlagsRowHandle& RowHandle);
	void RemoveRowFromAccountFlagsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAccountFlagsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAccountFlagsEnum& A, const struct FAccountFlagsEnum& B);
	struct FAccountFlagsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAccountFlagsRowHandle MakeLiteralAccountFlags(const struct FAccountFlagsRowHandle& RowHandle);
	struct FAccountFlagsRowHandle MakeAccountFlagsFromIndex(int32 Index);
	struct FAccountFlagsEnum MakeAccountFlagsEnum(const struct FAccountFlagsEnum& Enum);
	struct FAccountFlagsRowHandle MakeAccountFlags(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAccountFlagsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAccountFlagsStruct(const struct FAccountFlagsRowHandle& RowHandle, struct FAccountFlag* AccountFlags, enum class EValid* Paths);
	bool EqualEqual_FAccountFlagsRowHandleFAccountFlagsRowHandle(const struct FAccountFlagsRowHandle& RowHandleA, const struct FAccountFlagsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAccountFlagsEnum& A, const struct FAccountFlagsEnum& B);
	struct FAccountFlagsRowHandle CastToAccountFlagsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAccountFlagsEnum(const struct FAccountFlagsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAccountFlagsTable(class FName Name, const struct FAccountFlag& Data, struct FAccountFlagsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AccountFlagsTable
class UAccountFlagsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAccountFlagsTable* GetDefaultObj();

};

// 0x10 (0xC0 - 0xB0)
// Class Icarus.TraitBehaviour
class UTraitBehaviour : public UActorComponent
{
public:
	class UTraitBehaviours*                      OwningComponent;                                   // 0xB0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bBehaviourDelegatesBound;                          // 0xB8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_1C32[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTraitBehaviour* GetDefaultObj();

	void OnTraitAnimNotify(struct FAnimNotifyEvent& Notify, class AActor* AnimInstancePawn);
	void OnRep_OwningComponent();
};

// 0x210 (0x2D0 - 0xC0)
// Class Icarus.ActionableBehaviour
class UActionableBehaviour : public UTraitBehaviour
{
public:
	TArray<enum class EActionableEventType>      ActionEventTypes;                                  // 0xC0(0x10)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FActionsRowHandle                     ActionRowHandle;                                   // 0xD0(0x18)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<enum class EActionableEventType, struct FStaminaActionCostsRowHandle> StaminaCosts;                                      // 0xE8(0x50)(NativeAccessSpecifierPublic)
	TArray<struct FActionStaminaCostEventPairing> ReplicatedStaminaCosts;                            // 0x138(0x10)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCooldownElapsed;                                 // 0x148(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FModifierStatesRowHandle              ModifierRowHandle;                                 // 0x158(0x18)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2101[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UCharacterState*                       OwnerActorState;                                   // 0x1C0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                OwnerActor;                                        // 0x1C8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_210E[0xF8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusAnimInstance*                   AnimatingMeshAnimInstance;                         // 0x2C8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UActionableBehaviour* GetDefaultObj();

	void PerformActionFromMenu(class AActor* InvokingActor);
	void PerformAction(class AActor* InvokingActor, enum class EActionableEventType OnActionType, enum class EActionableTrigger ActionTrigger);
	void OnUsedFromMenu(class AActor* InvokingActor);
	void OnRep_ReplicatedStaminaCosts();
	void OnActionNotify(class FName NotifyName);
	void OnActionInsufficientStamina(enum class EActionableTrigger ActionTrigger);
	void OnActionInsufficientDurability(enum class EActionableTrigger ActionTrigger);
	void OnActionHit(class AActor* InvokingActor, class UPrimitiveComponent* OverlappedComponent, struct FHitResult& SweepResult);
	void OnActionAborted(enum class EActionableEventType EventType);
	void OnAction(class AActor* InvokingActor, enum class EActionableEventType OnActionType, enum class EActionableTrigger ActionTrigger);
	void NetMulti_OnActionInsufficientStamina(enum class EActionableTrigger ActionTrigger);
	void Multicast_NotifyCurrentActionAborted(enum class EActionableEventType EventType);
	bool IsActionAborted(enum class EActionableEventType EventType);
	bool HasCooldownElapsed(enum class EActionableEventType ActionType);
	struct FStaminaCost GetStaminaCostForEventType(enum class EActionableEventType EventType);
	TArray<struct FRowHandle> GetGenericData();
	float GetCooldownSpeedMultiplier();
	float GetCooldownDuration();
	class USkeletalMeshComponent* GetAnimatingMesh();
	bool GetActionData(struct FActionData* OutData);
	class UActionableComponent* GetActionableComponent();
	void CheckCurrentActionAborted(class UActorState* ActorStateIn, int32 UID);
	void CancelStaminaActionForEventType(enum class EActionableEventType EventType);
	bool BP_ShouldApplyEndStaminaCost(enum class EActionableEventType EventType);
	void BeginActionCooldown(enum class EActionableEventType ActionableEvent);
	void ActionComplete(enum class EActionableEventType ActionType);
	void AbortAction(enum class EActionableEventType EventType, bool bApplyEndActionStaminaCost);
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.TraitComponent
class UTraitComponent : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_            DynamicDataUpdated;                                // 0xB0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_22F0[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRowHandle                            DataRowHandle;                                     // 0xB4(0x18)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_22F5[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTraitComponent* GetDefaultObj();

	void OnRep_DataRowHandle();
	void OnDataSet();
	void OnAnimNotify(struct FAnimNotifyEvent& Notify, class AActor* AnimInstancePawn);
	TSubclassOf<class UTraitComponent> GetTraitClassFromData(const struct FRowHandle& ItemDataRow);
	class AIcarusItem* GetOwnerIcarusItem();
	class AIcarusActor* GetOwnerIcarusActor();
};

// 0x18 (0xE8 - 0xD0)
// Class Icarus.TraitBehaviours
class UTraitBehaviours : public UTraitComponent
{
public:
	FMulticastSparseDelegateProperty_            OnTraitAnimNotify;                                 // 0xD0(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_246C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UTraitBehaviour*>               OwnedBehaviours;                                   // 0xD8(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UTraitBehaviours* GetDefaultObj();

	void RegisterBehaviour(class UTraitBehaviour* Behaviour);
	class UTraitBehaviour* GetFirstBehaviourOfType(TSubclassOf<class UTraitBehaviour> Class);
	TArray<class UTraitBehaviour*> GetBehaviours();
	void CreateBehaviours();
	class UTraitBehaviour* CreateBehaviour(TSubclassOf<class UTraitBehaviour> BehaviourClass);
};

// 0x70 (0x158 - 0xE8)
// Class Icarus.ActionableComponent
class UActionableComponent : public UTraitBehaviours
{
public:
	FMulticastSparseDelegateProperty_            OnAction;                                          // 0xE8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnUsedFromMenu;                                    // 0xE9(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActionHit;                                       // 0xEA(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAssociatedItemUpdated;                           // 0xEB(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                        Pad_298E[0x54];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        AssociatedItemInventoryId;                         // 0x140(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        AssociatedItemInventorySlot;                       // 0x144(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DynamicState;                                      // 0x148(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        GunCurrentMagSize;                                 // 0x14C(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CurrentAmmoType;                                   // 0x150(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_2997[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UActionableComponent* GetDefaultObj();

	void UseFromMenu(class AActor* InvokingActor);
	void SetNewAssociatedItem(int32 NewAssociatedItemInventoryId, int32 NewAssocaitedItemSlot);
	void SetGunCurrentMagSize(int32 NewGunCurrentMagSize);
	void SetDynamicState(int32 NewDynamicState);
	void SetCurrentAmmoType(int32 NewCurrentAmmoType);
	void SetAssociatedItemInventorySlot(int32 NewAssociatedItemInventorySlot);
	void SetAssociatedItemInventoryId(int32 NewAssociatedItemInventoryId);
	void Server_OwningClientActionableHitNamed(class AActor* InvokingActor, class AActor* OverlappedComponentOwner, class FName OverlappedComponentName, struct FHitResult& SweepResult);
	void Server_OwningClientActionableHit(class AActor* InvokingActor, class UPrimitiveComponent* OverlappedComponent, struct FHitResult& SweepResult);
	void OnRep_CurrentAmmoType();
	void OnHeldTimerExpired(class AActor* InvokingActor, enum class EActionableEventType ActionType, bool bClientPrediction);
	void Multicast_ActionableHitNamed(class AActor* InvokingActor, class AActor* OverlappedComponentOwner, class FName OverlappedComponentName, struct FHitResult& SweepResult);
	void Multicast_ActionableHit(class AActor* InvokingActor, class UPrimitiveComponent* OverlappedComponent, struct FHitResult& SweepResult);
	class UActionableBehaviour* GetBehaviourForActionType(enum class EActionableEventType& EventType);
	bool GetActionData(const struct FActionsRowHandle& ActionRowHandle, struct FActionData* OutData);
	bool GetActionableData(struct FActionableData* OutData);
	void Action(class AActor* InvokingActor, enum class EActionableEventType ActionType, enum class EActionableTrigger ActionTrigger, bool bClientPrediction);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ActionableLibrary
class UActionableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UActionableLibrary* GetDefaultObj();

	struct FActionableRowHandle StructToRowHandle(const struct FActionableEnum& EnumValue);
	class FName StructToName(const struct FActionableEnum& EnumValue);
	int32 StructToInt(const struct FActionableEnum& EnumValue);
	struct FActionableEnum RowHandleToStruct(const struct FActionableRowHandle& RowHandle);
	void RemoveRowFromActionableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FActionableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FActionableEnum& A, const struct FActionableEnum& B);
	struct FActionableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FActionableRowHandle MakeLiteralActionable(const struct FActionableRowHandle& RowHandle);
	struct FActionableRowHandle MakeActionableFromIndex(int32 Index);
	struct FActionableEnum MakeActionableEnum(const struct FActionableEnum& Enum);
	struct FActionableRowHandle MakeActionable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FActionableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetActionableStruct(const struct FActionableRowHandle& RowHandle, struct FActionableData* Actionable, enum class EValid* Paths);
	bool EqualEqual_FActionableRowHandleFActionableRowHandle(const struct FActionableRowHandle& RowHandleA, const struct FActionableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FActionableEnum& A, const struct FActionableEnum& B);
	struct FActionableRowHandle CastToActionableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakActionableEnum(const struct FActionableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToActionableTable(class FName Name, const struct FActionableData& Data, struct FActionableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ActionableTable
class UActionableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UActionableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ActionsLibrary
class UActionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UActionsLibrary* GetDefaultObj();

	struct FActionsRowHandle StructToRowHandle(const struct FActionsEnum& EnumValue);
	class FName StructToName(const struct FActionsEnum& EnumValue);
	int32 StructToInt(const struct FActionsEnum& EnumValue);
	struct FActionsEnum RowHandleToStruct(const struct FActionsRowHandle& RowHandle);
	void RemoveRowFromActionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FActionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FActionsEnum& A, const struct FActionsEnum& B);
	struct FActionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FActionsRowHandle MakeLiteralActions(const struct FActionsRowHandle& RowHandle);
	struct FActionsRowHandle MakeActionsFromIndex(int32 Index);
	struct FActionsEnum MakeActionsEnum(const struct FActionsEnum& Enum);
	struct FActionsRowHandle MakeActions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FActionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetActionsStruct(const struct FActionsRowHandle& RowHandle, struct FActionData* Actions, enum class EValid* Paths);
	bool EqualEqual_FActionsRowHandleFActionsRowHandle(const struct FActionsRowHandle& RowHandleA, const struct FActionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FActionsEnum& A, const struct FActionsEnum& B);
	struct FActionsRowHandle CastToActionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakActionsEnum(const struct FActionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToActionsTable(class FName Name, const struct FActionData& Data, struct FActionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ActionsTable
class UActionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UActionsTable* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.ActorPrefabAsset
class UActorPrefabAsset : public UDataAsset
{
public:

	static class UClass* StaticClass();
	static class UActorPrefabAsset* GetDefaultObj();

	TArray<class AActor*> DeserializePrefab(class UActorPrefabFunctionLibrary* PrefabLibrary, class AActor* PrefabActor);
};

// 0x0 (0x220 - 0x220)
// Class Icarus.ActorPrefab
class AActorPrefab : public AActor
{
public:

	static class UClass* StaticClass();
	static class AActorPrefab* GetDefaultObj();

	class UActorPrefabAsset* GetPrefabAsset();
};

// 0x8 (0x30 - 0x28)
// Class Icarus.ActorPrefabFunctionLibrary
class UActorPrefabFunctionLibrary : public UObject
{
public:
	class UObject*                               WorldContext;                                      // 0x28(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UActorPrefabFunctionLibrary* GetDefaultObj();

	void SetLightUseTemperature(class ULightComponent* Light, bool bUseTemperature);
	void SetLightMaxDrawDistance(class ULightComponent* Light, float MaxDrawDistance);
	bool SerializePrefabWaterfall(class AActor* Waterfall, struct FTransform& Origin, struct FPrefabWaterfall* WaterfallData);
	bool SerializePrefabTransform(class AActor* Actor, struct FTransform& Origin, struct FPrefabTransform* TransformData);
	bool SerializePrefabStaticMesh(class UStaticMeshComponent* MeshComponent, struct FTransform& Origin, struct FPrefabStaticMesh* MeshData);
	bool SerializePrefabMegaTreeAudioVolume(class AActor* Actor, struct FTransform& Origin, struct FPrefabTriggerBox* Data);
	bool SerializePrefabLavaFlowPoint(class AActor* LavaFlowPoint, struct FTransform& Origin, struct FPrefabLavaFlowPoint* LavaFlowPointData);
	bool SerializePrefabLake(class AActor* Lake, struct FTransform& Origin, struct FPrefabLake* LakeData);
	bool SerializePrefabFoliage(class AInstancedFoliageActor* InFoliageActor, struct FTransform& Origin, TArray<struct FPrefabFoliage>* PrefabFoliage);
	bool SerializePrefabCaveLight(class AActor* CaveLight, struct FTransform& Origin, struct FPrefabCaveLight* CaveLightData);
	bool SerializePrefabCaveCreatureSpawns(TArray<class AActor*>& CreatureSpawns, struct FTransform& Origin, TMap<TSubclassOf<class AActor>, struct FVector2D>& PerActorMinMaxSpawnCounts, TMap<TSubclassOf<class AActor>, struct FCaveSpawnConfig>* CaveSpawnConfig);
	bool SerializePrefabActorClass(class AActor* Actor, struct FTransform& Origin, struct FPrefabActorClass* ActorData);
	class AActor* DeserializePrefabWaterfall(struct FPrefabWaterfall& WaterfallData, struct FTransform& Origin);
	struct FTransform DeserializePrefabTransform(struct FPrefabTransform& TransformData, struct FTransform& Origin);
	class AActor* DeserializePrefabStaticMesh(struct FPrefabStaticMesh& MeshData, struct FTransform& Origin);
	class AActor* DeserializePrefabMegaTreeAudioVolume(struct FTransform& Origin, struct FPrefabTriggerBox& Data);
	class AActor* DeserializePrefabLavaFlowPoint(struct FPrefabLavaFlowPoint& LavaFlowPointData, struct FTransform& Origin);
	class AActor* DeserializePrefabLake(struct FPrefabLake& LakeData, struct FTransform& Origin);
	bool DeserializePrefabFoliage(class AActor* PrefabActor, TArray<struct FPrefabFoliage>& PrefabFoliageData);
	class AActor* DeserializePrefabCaveLight(struct FPrefabCaveLight& CaveLightData, struct FTransform& Origin);
	class AActor* DeserializePrefabCaveCreatureSpawns(TMap<TSubclassOf<class AActor>, struct FCaveSpawnConfig>& CaveSpawnConfig, class UActorPrefabAsset* CavePrefab, struct FTransform& Origin);
	class AActor* DeserializePrefabActorClass(struct FPrefabActorClass& ActorData, struct FTransform& Origin);
	class AActor* DeserializeCaveInstance(TArray<struct FPrefabTransform>& Volumes, TArray<struct FPrefabTransform>& Entrances, struct FTransform& Origin);
};

// 0x1B0 (0x260 - 0xB0)
// Class Icarus.ActorState
class UActorState : public UActorComponent
{
public:
	struct FIcarusDamagePacket                   LastDamagePacket;                                  // 0xB0(0xD8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         bKeepRecentDamageEvents;                           // 0x188(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_49A7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        RecentDamageLifetime;                              // 0x18C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIcarusDamagePacket>           RecentDamagePackets;                               // 0x190(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_49AB[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnActorStateReady;                                 // 0x1B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActorDeath;                                      // 0x1C0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAliveStateChanged;                               // 0x1C1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDamaged;                                         // 0x1C2(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnHealthUpdated;                                   // 0x1C3(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShelterUpdated;                                  // 0x1C4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            BiomeUpdated;                                      // 0x1C5(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActorDamaged;                                    // 0x1C6(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_49D8[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnDamageReturned;                                  // 0x1C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        Health;                                            // 0x1D8(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxHealth;                                         // 0x1DC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        Shelter;                                           // 0x1E0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ExternalTemperature;                               // 0x1E4(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ModifiedExternalTemperature;                       // 0x1E8(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ModifiedInternalTemperature;                       // 0x1EC(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBiomesRowHandle                      CurrentBiome;                                      // 0x1F0(0x18)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EAliveState                       CurrentAliveState;                                 // 0x208(0x1)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSkipStatContainerChecks;                          // 0x209(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_4A4C[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusStatContainer*                  OwnerStatContainer;                                // 0x210(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_4A50[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBiomesRowHandle                      BiomeOverride;                                     // 0x224(0x18)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAtmospheresRowHandle                 AtmosphereOverride;                                // 0x23C(0x18)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         BlockBiomeUpdate;                                  // 0x254(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         BlockAtmosphereUpdate;                             // 0x255(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_4A5F[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bHasHealthRegen;                                   // 0x25C(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_4A64[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UActorState* GetDefaultObj();

	void WeatherTimeTick(float Delta);
	void TakeDamage(const struct FIcarusDamagePacket& DamagePacket);
	void StatContainerUpdated();
	void SetShelter(float Amount);
	void SetHealth(int32 Amount);
	void SetBlockBiomeUpdate(bool bLock);
	void SetBiomeOverride(const struct FBiomesRowHandle& Biome);
	void SetBiome(const struct FBiomesRowHandle& Biome);
	void Respawn();
	void RequestClientsideBiomeUpdate();
	void RequestBiomeUpdate();
	void RegenTick(float DeltaTime);
	void RecalculateHealthRegenRate();
	void RecalculateCurrentHealth();
	void OnRep_ModifiedExternalTemp();
	void OnRep_Health();
	void OnRep_CurrentBiome();
	void OnRep_CurrentAliveState();
	void OnCurrentBiomeUpdated(struct FBiomesRowHandle& NewBiome);
	void Multicast_OnDamaged(int32 InDamage, struct FDamageEvent& DamageEvent, class AController* Instigator, class AActor* DamageCauser);
	void Kill();
	bool IsAlive();
	void InternalTick(float DeltaTime);
	float GetTotalRecentDamage(float Duration);
	float GetShelter();
	float GetRecentDamageCausedByController(class AController* DamageInstigator, float Duration);
	float GetRecentDamageCausedByActor(class AActor* DamageCauser, float Duration);
	int32 GetMaxHealth();
	int32 GetHealth();
	int32 GetEnvironmentalTemperature();
	struct FBoxSphereBounds GetBoundsForTemperatureEffect();
	int32 ConsumeNextUID();
	bool CanRegenerateHealth();
	void AddHealth(int32 Amount);
};

// 0x28 (0xD8 - 0xB0)
// Class Icarus.IcarusStateRecorderComponent
class UIcarusStateRecorderComponent : public UActorComponent
{
public:
	bool                                         bBeginRecordingImmediately;                        // 0xB0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRetainOnDestroy;                                  // 0xB1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EStateRecorderOwnerResolvePolicy  OwnerResolvePolicy;                                // 0xB2(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUsesFastActorPathNameMatching;                    // 0xB3(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  ActorClassName;                                    // 0xB4(0x8)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_4BBE[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                ActorPathName;                                     // 0xC0(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsRecordingGameState;                             // 0xD0(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasRecordedValidState;                            // 0xD1(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_4BCD[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusStateRecorderComponent* GetDefaultObj();

	void OnResolvedOwnerEndPlay(class AActor* ResolvedOwner, enum class EEndPlayReason EndPlayReason);
	void EndRecording();
	void BeginRecording();
};

// 0xD0 (0x1A8 - 0xD8)
// Class Icarus.ActorStateRecorderComponent
class UActorStateRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	bool                                         bSaveModifiers;                                    // 0xD8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShouldReloadActorTransform;                       // 0xD9(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_4C25[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        ActorStateRecorderVersion;                         // 0xDC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                            ActorTransform;                                    // 0xE0(0x30)(Edit, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInventorySaveData>            SavedInventories;                                  // 0x110(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FFLODActorComponentSaveData           FLODComponentData;                                 // 0x120(0x1C)(Edit, EditConst, SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                         bIgnoreUIDWhenFindingOwner;                        // 0x13C(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_4C41[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        IcarusActorGUID;                                   // 0x140(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  ObjectFName;                                       // 0x144(0x8)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_4C50[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FModifierStateSaveData>        Modifiers;                                         // 0x150(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FEnergyTraitRecord                    EnergyTraitRecord;                                 // 0x160(0x1)(Edit, EditConst, SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWaterTraitRecord                     WaterTraitRecord;                                  // 0x161(0x1)(Edit, EditConst, SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGeneratorTraitRecord                 GeneratorTraitRecord;                              // 0x162(0x1)(Edit, EditConst, SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_4C84[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FActorIntVariableRecord>       IntVariables;                                      // 0x168(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActorBoolVariableRecord>      BoolVariables;                                     // 0x178(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActorNameVariableRecord>      NameVariables;                                     // 0x188(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLinearColorVariableRecord>    LinearColorVariables;                              // 0x198(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UActorStateRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AfflictionChanceLibrary
class UAfflictionChanceLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAfflictionChanceLibrary* GetDefaultObj();

	struct FAfflictionChanceRowHandle StructToRowHandle(const struct FAfflictionChanceEnum& EnumValue);
	class FName StructToName(const struct FAfflictionChanceEnum& EnumValue);
	int32 StructToInt(const struct FAfflictionChanceEnum& EnumValue);
	struct FAfflictionChanceEnum RowHandleToStruct(const struct FAfflictionChanceRowHandle& RowHandle);
	void RemoveRowFromAfflictionChanceTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAfflictionChanceEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAfflictionChanceEnum& A, const struct FAfflictionChanceEnum& B);
	struct FAfflictionChanceEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAfflictionChanceRowHandle MakeLiteralAfflictionChance(const struct FAfflictionChanceRowHandle& RowHandle);
	struct FAfflictionChanceRowHandle MakeAfflictionChanceFromIndex(int32 Index);
	struct FAfflictionChanceEnum MakeAfflictionChanceEnum(const struct FAfflictionChanceEnum& Enum);
	struct FAfflictionChanceRowHandle MakeAfflictionChance(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAfflictionChanceEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAfflictionChanceStruct(const struct FAfflictionChanceRowHandle& RowHandle, struct FAfflictionChance* AfflictionChance, enum class EValid* Paths);
	bool EqualEqual_FAfflictionChanceRowHandleFAfflictionChanceRowHandle(const struct FAfflictionChanceRowHandle& RowHandleA, const struct FAfflictionChanceRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAfflictionChanceEnum& A, const struct FAfflictionChanceEnum& B);
	struct FAfflictionChanceRowHandle CastToAfflictionChanceRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAfflictionChanceEnum(const struct FAfflictionChanceEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAfflictionChanceTable(class FName Name, const struct FAfflictionChance& Data, struct FAfflictionChanceRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AfflictionChanceTable
class UAfflictionChanceTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAfflictionChanceTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AIAudioDataLibrary
class UAIAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAIAudioDataLibrary* GetDefaultObj();

	struct FAIAudioDataRowHandle StructToRowHandle(const struct FAIAudioDataEnum& EnumValue);
	class FName StructToName(const struct FAIAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FAIAudioDataEnum& EnumValue);
	struct FAIAudioDataEnum RowHandleToStruct(const struct FAIAudioDataRowHandle& RowHandle);
	void RemoveRowFromAIAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAIAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAIAudioDataEnum& A, const struct FAIAudioDataEnum& B);
	struct FAIAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAIAudioDataRowHandle MakeLiteralAIAudioData(const struct FAIAudioDataRowHandle& RowHandle);
	struct FAIAudioDataRowHandle MakeAIAudioDataFromIndex(int32 Index);
	struct FAIAudioDataEnum MakeAIAudioDataEnum(const struct FAIAudioDataEnum& Enum);
	struct FAIAudioDataRowHandle MakeAIAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAIAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAIAudioDataStruct(const struct FAIAudioDataRowHandle& RowHandle, struct FAIAudioData* AIAudioData, enum class EValid* Paths);
	bool EqualEqual_FAIAudioDataRowHandleFAIAudioDataRowHandle(const struct FAIAudioDataRowHandle& RowHandleA, const struct FAIAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAIAudioDataEnum& A, const struct FAIAudioDataEnum& B);
	struct FAIAudioDataRowHandle CastToAIAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAIAudioDataEnum(const struct FAIAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAIAudioDataTable(class FName Name, const struct FAIAudioData& Data, struct FAIAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AIAudioDataTable
class UAIAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAIAudioDataTable* GetDefaultObj();

};

// 0x68 (0x98 - 0x30)
// Class Icarus.AICoordinatorSubsystem
class UAICoordinatorSubsystem : public UWorldSubsystem
{
public:
	TArray<struct FActiveEvent>                  ActiveEvents;                                      // 0x30(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FAIEventsEnum, struct FEventCooldownList> EventsOnCooldown;                                  // 0x40(0x50)(Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                          CheckPendingCooldownsHandle;                       // 0x90(0x8)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UAICoordinatorSubsystem* GetDefaultObj();

	void SetupInitialCooldowns();
	enum class EAIEventRequestResponse RequestAIEvent(const struct FAIEventsEnum& Event, class AActor* InstigatorActor);
	void PutEventOnCooldown(struct FAIEventsRowHandle& Event);
	void OnActiveEventEndPlay(class AActor* Actor, enum class EEndPlayReason EndPlayReason);
	bool IsEventActive(const struct FAIEventsEnum& Event);
	int32 GetActiveEventsOfType(const struct FAIEventsEnum& Event, TArray<class AAIEvent*>* OutEvents);
	void CleanupActiveEvent(class AAIEvent* Event);
	void CheckPendingCooldownTimers();
	bool CanRequestAIEvent(const struct FAIEventsEnum& Event);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AICreatureTypeLibrary
class UAICreatureTypeLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAICreatureTypeLibrary* GetDefaultObj();

	struct FAICreatureTypeRowHandle StructToRowHandle(const struct FAICreatureTypeEnum& EnumValue);
	class FName StructToName(const struct FAICreatureTypeEnum& EnumValue);
	int32 StructToInt(const struct FAICreatureTypeEnum& EnumValue);
	struct FAICreatureTypeEnum RowHandleToStruct(const struct FAICreatureTypeRowHandle& RowHandle);
	void RemoveRowFromAICreatureTypeTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAICreatureTypeEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAICreatureTypeEnum& A, const struct FAICreatureTypeEnum& B);
	struct FAICreatureTypeEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAICreatureTypeRowHandle MakeLiteralAICreatureType(const struct FAICreatureTypeRowHandle& RowHandle);
	struct FAICreatureTypeRowHandle MakeAICreatureTypeFromIndex(int32 Index);
	struct FAICreatureTypeEnum MakeAICreatureTypeEnum(const struct FAICreatureTypeEnum& Enum);
	struct FAICreatureTypeRowHandle MakeAICreatureType(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAICreatureTypeEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAICreatureTypeStruct(const struct FAICreatureTypeRowHandle& RowHandle, struct FAICreatureType* AICreatureType, enum class EValid* Paths);
	bool EqualEqual_FAICreatureTypeRowHandleFAICreatureTypeRowHandle(const struct FAICreatureTypeRowHandle& RowHandleA, const struct FAICreatureTypeRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAICreatureTypeEnum& A, const struct FAICreatureTypeEnum& B);
	struct FAICreatureTypeRowHandle CastToAICreatureTypeRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAICreatureTypeEnum(const struct FAICreatureTypeEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAICreatureTypeTable(class FName Name, const struct FAICreatureType& Data, struct FAICreatureTypeRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AICreatureTypeTable
class UAICreatureTypeTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAICreatureTypeTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AIDescriptorsLibrary
class UAIDescriptorsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAIDescriptorsLibrary* GetDefaultObj();

	struct FAIDescriptorsRowHandle StructToRowHandle(const struct FAIDescriptorsEnum& EnumValue);
	class FName StructToName(const struct FAIDescriptorsEnum& EnumValue);
	int32 StructToInt(const struct FAIDescriptorsEnum& EnumValue);
	struct FAIDescriptorsEnum RowHandleToStruct(const struct FAIDescriptorsRowHandle& RowHandle);
	void RemoveRowFromAIDescriptorsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAIDescriptorsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAIDescriptorsEnum& A, const struct FAIDescriptorsEnum& B);
	struct FAIDescriptorsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAIDescriptorsRowHandle MakeLiteralAIDescriptors(const struct FAIDescriptorsRowHandle& RowHandle);
	struct FAIDescriptorsRowHandle MakeAIDescriptorsFromIndex(int32 Index);
	struct FAIDescriptorsEnum MakeAIDescriptorsEnum(const struct FAIDescriptorsEnum& Enum);
	struct FAIDescriptorsRowHandle MakeAIDescriptors(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAIDescriptorsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAIDescriptorsStruct(const struct FAIDescriptorsRowHandle& RowHandle, struct FAIDescriptor* AIDescriptors, enum class EValid* Paths);
	bool EqualEqual_FAIDescriptorsRowHandleFAIDescriptorsRowHandle(const struct FAIDescriptorsRowHandle& RowHandleA, const struct FAIDescriptorsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAIDescriptorsEnum& A, const struct FAIDescriptorsEnum& B);
	struct FAIDescriptorsRowHandle CastToAIDescriptorsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAIDescriptorsEnum(const struct FAIDescriptorsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAIDescriptorsTable(class FName Name, const struct FAIDescriptor& Data, struct FAIDescriptorsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AIDescriptorsTable
class UAIDescriptorsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAIDescriptorsTable* GetDefaultObj();

};

// 0x28 (0x248 - 0x220)
// Class Icarus.AIEvent
class AAIEvent : public AActor
{
public:
	struct FAIEventsRowHandle                    AssignedEvent;                                     // 0x220(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                InstigatorActor;                                   // 0x238(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TickInterval;                                      // 0x240(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_64F0[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AAIEvent* GetDefaultObj();

	bool WasEventCompletionSuccessful();
	void TickEvent(float DeltaTime);
	void SetupEvent(const struct FAIEventsRowHandle& Event, class AActor* EventInstigator);
	void CompleteEvent(bool bSuccess);
	bool ArePreconditionsValid(class AActor* InInstigatorActor);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AIEventsLibrary
class UAIEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAIEventsLibrary* GetDefaultObj();

	struct FAIEventsRowHandle StructToRowHandle(const struct FAIEventsEnum& EnumValue);
	class FName StructToName(const struct FAIEventsEnum& EnumValue);
	int32 StructToInt(const struct FAIEventsEnum& EnumValue);
	struct FAIEventsEnum RowHandleToStruct(const struct FAIEventsRowHandle& RowHandle);
	void RemoveRowFromAIEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAIEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAIEventsEnum& A, const struct FAIEventsEnum& B);
	struct FAIEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAIEventsRowHandle MakeLiteralAIEvents(const struct FAIEventsRowHandle& RowHandle);
	struct FAIEventsRowHandle MakeAIEventsFromIndex(int32 Index);
	struct FAIEventsEnum MakeAIEventsEnum(const struct FAIEventsEnum& Enum);
	struct FAIEventsRowHandle MakeAIEvents(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAIEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAIEventsStruct(const struct FAIEventsRowHandle& RowHandle, struct FAIEventData* AIEvents, enum class EValid* Paths);
	bool EqualEqual_FAIEventsRowHandleFAIEventsRowHandle(const struct FAIEventsRowHandle& RowHandleA, const struct FAIEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAIEventsEnum& A, const struct FAIEventsEnum& B);
	struct FAIEventsRowHandle CastToAIEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAIEventsEnum(const struct FAIEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAIEventsTable(class FName Name, const struct FAIEventData& Data, struct FAIEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AIEventsTable
class UAIEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAIEventsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AIGrowthLibrary
class UAIGrowthLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAIGrowthLibrary* GetDefaultObj();

	struct FAIGrowthRowHandle StructToRowHandle(const struct FAIGrowthEnum& EnumValue);
	class FName StructToName(const struct FAIGrowthEnum& EnumValue);
	int32 StructToInt(const struct FAIGrowthEnum& EnumValue);
	struct FAIGrowthEnum RowHandleToStruct(const struct FAIGrowthRowHandle& RowHandle);
	void RemoveRowFromAIGrowthTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAIGrowthEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAIGrowthEnum& A, const struct FAIGrowthEnum& B);
	struct FAIGrowthEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAIGrowthRowHandle MakeLiteralAIGrowth(const struct FAIGrowthRowHandle& RowHandle);
	struct FAIGrowthRowHandle MakeAIGrowthFromIndex(int32 Index);
	struct FAIGrowthEnum MakeAIGrowthEnum(const struct FAIGrowthEnum& Enum);
	struct FAIGrowthRowHandle MakeAIGrowth(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAIGrowthEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAIGrowthStruct(const struct FAIGrowthRowHandle& RowHandle, struct FAIGrowth* AIGrowth, enum class EValid* Paths);
	bool EqualEqual_FAIGrowthRowHandleFAIGrowthRowHandle(const struct FAIGrowthRowHandle& RowHandleA, const struct FAIGrowthRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAIGrowthEnum& A, const struct FAIGrowthEnum& B);
	struct FAIGrowthRowHandle CastToAIGrowthRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAIGrowthEnum(const struct FAIGrowthEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAIGrowthTable(class FName Name, const struct FAIGrowth& Data, struct FAIGrowthRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AIGrowthTable
class UAIGrowthTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAIGrowthTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AIRelationshipsLibrary
class UAIRelationshipsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAIRelationshipsLibrary* GetDefaultObj();

	struct FAIRelationshipsRowHandle StructToRowHandle(const struct FAIRelationshipsEnum& EnumValue);
	class FName StructToName(const struct FAIRelationshipsEnum& EnumValue);
	int32 StructToInt(const struct FAIRelationshipsEnum& EnumValue);
	struct FAIRelationshipsEnum RowHandleToStruct(const struct FAIRelationshipsRowHandle& RowHandle);
	void RemoveRowFromAIRelationshipsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAIRelationshipsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAIRelationshipsEnum& A, const struct FAIRelationshipsEnum& B);
	struct FAIRelationshipsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAIRelationshipsRowHandle MakeLiteralAIRelationships(const struct FAIRelationshipsRowHandle& RowHandle);
	struct FAIRelationshipsRowHandle MakeAIRelationshipsFromIndex(int32 Index);
	struct FAIRelationshipsEnum MakeAIRelationshipsEnum(const struct FAIRelationshipsEnum& Enum);
	struct FAIRelationshipsRowHandle MakeAIRelationships(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAIRelationshipsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAIRelationshipsStruct(const struct FAIRelationshipsRowHandle& RowHandle, struct FAIRelationshipData* AIRelationships, enum class EValid* Paths);
	bool EqualEqual_FAIRelationshipsRowHandleFAIRelationshipsRowHandle(const struct FAIRelationshipsRowHandle& RowHandleA, const struct FAIRelationshipsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAIRelationshipsEnum& A, const struct FAIRelationshipsEnum& B);
	struct FAIRelationshipsRowHandle CastToAIRelationshipsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAIRelationshipsEnum(const struct FAIRelationshipsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAIRelationshipsTable(class FName Name, const struct FAIRelationshipData& Data, struct FAIRelationshipsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AIRelationshipsTable
class UAIRelationshipsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAIRelationshipsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AISetupLibrary
class UAISetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAISetupLibrary* GetDefaultObj();

	struct FAISetupRowHandle StructToRowHandle(const struct FAISetupEnum& EnumValue);
	class FName StructToName(const struct FAISetupEnum& EnumValue);
	int32 StructToInt(const struct FAISetupEnum& EnumValue);
	struct FAISetupEnum RowHandleToStruct(const struct FAISetupRowHandle& RowHandle);
	void RemoveRowFromAISetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAISetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAISetupEnum& A, const struct FAISetupEnum& B);
	struct FAISetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAISetupRowHandle MakeLiteralAISetup(const struct FAISetupRowHandle& RowHandle);
	struct FAISetupRowHandle MakeAISetupFromIndex(int32 Index);
	struct FAISetupEnum MakeAISetupEnum(const struct FAISetupEnum& Enum);
	struct FAISetupRowHandle MakeAISetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAISetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAISetupStruct(const struct FAISetupRowHandle& RowHandle, struct FAISetup* AISetup, enum class EValid* Paths);
	bool EqualEqual_FAISetupRowHandleFAISetupRowHandle(const struct FAISetupRowHandle& RowHandleA, const struct FAISetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAISetupEnum& A, const struct FAISetupEnum& B);
	struct FAISetupRowHandle CastToAISetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAISetupEnum(const struct FAISetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAISetupTable(class FName Name, const struct FAISetup& Data, struct FAISetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AISetupTable
class UAISetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAISetupTable* GetDefaultObj();

};

// 0xE8 (0x110 - 0x28)
// Class Icarus.AISpawnBehaviour
class UAISpawnBehaviour : public UObject
{
public:
	struct FAutonomousSpawnData                  SpawnData;                                         // 0x28(0xA8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FAutonomousSpawnsRowHandle            SpawnsRowHandle;                                   // 0xD0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnComplete;                                     // 0xE8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        SpawnedAI;                                         // 0xF8(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AIcarusActor>              CachedActorSpawnClass;                             // 0x108(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UAISpawnBehaviour* GetDefaultObj();

	bool TrySpawnAI(class UObject* WorldContextObject);
	void TryCleanupIrrelevantAI();
	bool SpawnAI(class UObject* WorldContextObject, struct FTransform& SpawnTransform, class AActor** SpawnedAI, int32 Level, enum class ESpawnActorCollisionHandlingMethod CollisionHandlingMethod);
	void OnSpawnedActorDeath(class UActorState* ActorState);
	void InitialiseSpawnBehaviour(struct FAutonomousSpawnsRowHandle& InSpawnData);
	void CleanupAI(class AActor* AI);
	bool CanCleanupAI(class AActor* AI);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AISpawnConfigLibrary
class UAISpawnConfigLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAISpawnConfigLibrary* GetDefaultObj();

	struct FAISpawnConfigRowHandle StructToRowHandle(const struct FAISpawnConfigEnum& EnumValue);
	class FName StructToName(const struct FAISpawnConfigEnum& EnumValue);
	int32 StructToInt(const struct FAISpawnConfigEnum& EnumValue);
	struct FAISpawnConfigEnum RowHandleToStruct(const struct FAISpawnConfigRowHandle& RowHandle);
	void RemoveRowFromAISpawnConfigTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAISpawnConfigEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAISpawnConfigEnum& A, const struct FAISpawnConfigEnum& B);
	struct FAISpawnConfigEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAISpawnConfigRowHandle MakeLiteralAISpawnConfig(const struct FAISpawnConfigRowHandle& RowHandle);
	struct FAISpawnConfigRowHandle MakeAISpawnConfigFromIndex(int32 Index);
	struct FAISpawnConfigEnum MakeAISpawnConfigEnum(const struct FAISpawnConfigEnum& Enum);
	struct FAISpawnConfigRowHandle MakeAISpawnConfig(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAISpawnConfigEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAISpawnConfigStruct(const struct FAISpawnConfigRowHandle& RowHandle, struct FAISpawnConfigData* AISpawnConfig, enum class EValid* Paths);
	bool EqualEqual_FAISpawnConfigRowHandleFAISpawnConfigRowHandle(const struct FAISpawnConfigRowHandle& RowHandleA, const struct FAISpawnConfigRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAISpawnConfigEnum& A, const struct FAISpawnConfigEnum& B);
	struct FAISpawnConfigRowHandle CastToAISpawnConfigRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAISpawnConfigEnum(const struct FAISpawnConfigEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAISpawnConfigTable(class FName Name, const struct FAISpawnConfigData& Data, struct FAISpawnConfigRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AISpawnConfigTable
class UAISpawnConfigTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAISpawnConfigTable* GetDefaultObj();

};

// 0x2B8 (0x4D8 - 0x220)
// Class Icarus.AISpawner
class AAISpawner : public AActor
{
public:
	TArray<struct FTileSpawnData>                WorldSpawnData;                                    // 0x220(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class UEnvQuery*                             Template;                                          // 0x230(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        NumberOfCachedSpawnPoints;                         // 0x238(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6AEF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            GenerationComplete;                                // 0x240(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        SelectedTile;                                      // 0x250(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISpawnConfigRowHandle               SpawnConfig;                                       // 0x254(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6AF0[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UIcarusAISpawnFilter>> SpawnRules;                                        // 0x270(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class UIcarusStatContainer*                  StatContainer;                                     // 0x280(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldData                            WorldData;                                         // 0x288(0x160)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FAISetupRowHandle, float>        LastAISetupSpawnTime;                              // 0x3E8(0x50)(Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_6AF1[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UAISpawnBehaviour*>             ActiveAutonomousSpawners;                          // 0x448(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        ActorsPendingCleanup;                              // 0x458(0x10)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FBiomesRowHandle, bool>          BlockedBiomes;                                     // 0x468(0x50)(Protected, NativeAccessSpecifierProtected)
	class AIcarusEQSTestingPawn*                 TestingPawn;                                       // 0x4B8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_6AF2[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AAISpawner* GetDefaultObj();

	void WorldStatsSet();
	void VisualiseTilePosition();
	void UnlinkSpawnedNPC(class AActor* NPC);
	void SpawnPointGenerationComplete();
	void SetupNPC(class AIcarusNPCGOAPCharacter* SpawnedNPC);
	void SetupAutonomousSpawnersPendingLoad();
	void SetupAutonomousSpawner(struct FAutonomousSpawnsRowHandle& AutonomousSpawnHandle);
	void SetDebugSpawnBlockers(bool bEnabled);
	void RemoveActorPendingCleanup(class AActor* Actor);
	void PrintDebugInformation();
	bool PerformNextTileEQS();
	void OnProspectDataSet();
	void OnNPCKilled(class UActorState* ActorState);
	void OnEQSQueryCompleted(TArray<struct FVector>& EQSResults);
	bool IsSpawnPointValid(struct FVector& InLocation, struct FAISetupEnum& InAISetup);
	bool IsBiomeDynamicSpawnLocationBlocked(struct FVector& Location);
	bool IsBiomeDynamicSpawnBlocked(struct FBiomesRowHandle& Biome);
	void InitialiseBehavioursForSpawnConfig(struct FAISpawnConfigData& SpawnConfig);
	int32 GetTotalNumNPCsUndergoingLatentDeath();
	int32 GetNumLatentDeathsForAISetup(const struct FAISetupRowHandle& AISetup);
	float GetLastAISetupSpawnTime(const struct FAISetupRowHandle& AISetup);
	float GetLastAISetupDeathTime(const struct FAISetupRowHandle& AISetup);
	bool GetDebugSpawnBlockers();
	void GenerateSingleTileSpawnPoints();
	void GenerateCachedSpawnPoints();
	void ClearLatentNPCDeaths();
	void BlockBiomeDynamicSpawns(struct FBiomesRowHandle& Biome, bool bBlock);
	void AddActorPendingCleanup(class AActor* Actor);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AISpawnRulesLibrary
class UAISpawnRulesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAISpawnRulesLibrary* GetDefaultObj();

	struct FAISpawnRulesRowHandle StructToRowHandle(const struct FAISpawnRulesEnum& EnumValue);
	class FName StructToName(const struct FAISpawnRulesEnum& EnumValue);
	int32 StructToInt(const struct FAISpawnRulesEnum& EnumValue);
	struct FAISpawnRulesEnum RowHandleToStruct(const struct FAISpawnRulesRowHandle& RowHandle);
	void RemoveRowFromAISpawnRulesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAISpawnRulesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAISpawnRulesEnum& A, const struct FAISpawnRulesEnum& B);
	struct FAISpawnRulesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAISpawnRulesRowHandle MakeLiteralAISpawnRules(const struct FAISpawnRulesRowHandle& RowHandle);
	struct FAISpawnRulesRowHandle MakeAISpawnRulesFromIndex(int32 Index);
	struct FAISpawnRulesEnum MakeAISpawnRulesEnum(const struct FAISpawnRulesEnum& Enum);
	struct FAISpawnRulesRowHandle MakeAISpawnRules(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAISpawnRulesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAISpawnRulesStruct(const struct FAISpawnRulesRowHandle& RowHandle, struct FAISpawnRuleData* AISpawnRules, enum class EValid* Paths);
	bool EqualEqual_FAISpawnRulesRowHandleFAISpawnRulesRowHandle(const struct FAISpawnRulesRowHandle& RowHandleA, const struct FAISpawnRulesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAISpawnRulesEnum& A, const struct FAISpawnRulesEnum& B);
	struct FAISpawnRulesRowHandle CastToAISpawnRulesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAISpawnRulesEnum(const struct FAISpawnRulesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAISpawnRulesTable(class FName Name, const struct FAISpawnRuleData& Data, struct FAISpawnRulesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AISpawnRulesTable
class UAISpawnRulesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAISpawnRulesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AISpawnZonesLibrary
class UAISpawnZonesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAISpawnZonesLibrary* GetDefaultObj();

	struct FAISpawnZonesRowHandle StructToRowHandle(const struct FAISpawnZonesEnum& EnumValue);
	class FName StructToName(const struct FAISpawnZonesEnum& EnumValue);
	int32 StructToInt(const struct FAISpawnZonesEnum& EnumValue);
	struct FAISpawnZonesEnum RowHandleToStruct(const struct FAISpawnZonesRowHandle& RowHandle);
	void RemoveRowFromAISpawnZonesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAISpawnZonesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAISpawnZonesEnum& A, const struct FAISpawnZonesEnum& B);
	struct FAISpawnZonesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAISpawnZonesRowHandle MakeLiteralAISpawnZones(const struct FAISpawnZonesRowHandle& RowHandle);
	struct FAISpawnZonesRowHandle MakeAISpawnZonesFromIndex(int32 Index);
	struct FAISpawnZonesEnum MakeAISpawnZonesEnum(const struct FAISpawnZonesEnum& Enum);
	struct FAISpawnZonesRowHandle MakeAISpawnZones(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAISpawnZonesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAISpawnZonesStruct(const struct FAISpawnZonesRowHandle& RowHandle, struct FAISpawnZones* AISpawnZones, enum class EValid* Paths);
	bool EqualEqual_FAISpawnZonesRowHandleFAISpawnZonesRowHandle(const struct FAISpawnZonesRowHandle& RowHandleA, const struct FAISpawnZonesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAISpawnZonesEnum& A, const struct FAISpawnZonesEnum& B);
	struct FAISpawnZonesRowHandle CastToAISpawnZonesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAISpawnZonesEnum(const struct FAISpawnZonesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAISpawnZonesTable(class FName Name, const struct FAISpawnZones& Data, struct FAISpawnZonesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AISpawnZonesTable
class UAISpawnZonesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAISpawnZonesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AITargetable
class IAITargetable : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IAITargetable* GetDefaultObj();

	bool ShouldOverrideTargetNeutrality(class AActor* TargetActor, bool* bIsTargetHostile);
	bool IsHidden();
	bool IsCriticalHitDisabled();
	bool IsActorAlive();
	struct FVector GetTargetLocation();
	int32 GetTargetAlertness();
	struct FAIRelationshipsRowHandle GetRelationshipData();
	TArray<struct FCriticalHitLocation> GetCriticalHitBones();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AITargetableFunctionLibrary
class UAITargetableFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UAITargetableFunctionLibrary* GetDefaultObj();

	void IsHostileTowards(class AActor* SelfTargetable, class AActor* OtherActorTargetable, enum class ERelationshipType* OutRelationshipSwitch, enum class ERelationshipType* OutRelationshipType);
	bool IsActorTargetable(class AActor* Actor, bool bOnlyAliveActors);
	enum class EStealthAttackType GetTargetStealth(class AActor* TargetableActor);
};

// 0x58 (0x108 - 0xB0)
// Class Icarus.VocalisationComponent
class UVocalisationComponent : public UActorComponent
{
public:
	class UFMODAudioComponent*                   AudioComponent;                                    // 0xB0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_6C2E[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UVocalisationComponent* GetDefaultObj();

	enum class EVocalisationPlayResult TryPlayVocalisation(const struct FVocalisationsRowHandle& Vocalisation);
	void OnEventStopped();
	void Initialise(class USceneComponent* TargetComponent, class FName TargetSocket);
	float GetVocalisationLength(const struct FVocalisationsRowHandle& Vocalisation);
	float GetCurrentVocalisationLength();
};

// 0x8 (0x110 - 0x108)
// Class Icarus.AIVocalisationComponent
class UAIVocalisationComponent : public UVocalisationComponent
{
public:
	uint8                                        Pad_6C2F[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UAIVocalisationComponent* GetDefaultObj();

	void SetAIState(enum class EAIAudioState State);
	void PlayAIVocalisation(enum class EAIVocalisationType Type);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AllTalentsInTreeAccolade
class UAllTalentsInTreeAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UAllTalentsInTreeAccolade* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AlterationsLibrary
class UAlterationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAlterationsLibrary* GetDefaultObj();

	struct FAlterationsRowHandle StructToRowHandle(const struct FAlterationsEnum& EnumValue);
	class FName StructToName(const struct FAlterationsEnum& EnumValue);
	int32 StructToInt(const struct FAlterationsEnum& EnumValue);
	struct FAlterationsEnum RowHandleToStruct(const struct FAlterationsRowHandle& RowHandle);
	void RemoveRowFromAlterationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAlterationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAlterationsEnum& A, const struct FAlterationsEnum& B);
	struct FAlterationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAlterationsRowHandle MakeLiteralAlterations(const struct FAlterationsRowHandle& RowHandle);
	struct FAlterationsRowHandle MakeAlterationsFromIndex(int32 Index);
	struct FAlterationsEnum MakeAlterationsEnum(const struct FAlterationsEnum& Enum);
	struct FAlterationsRowHandle MakeAlterations(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAlterationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAlterationsStruct(const struct FAlterationsRowHandle& RowHandle, struct FAlteration* Alterations, enum class EValid* Paths);
	bool EqualEqual_FAlterationsRowHandleFAlterationsRowHandle(const struct FAlterationsRowHandle& RowHandleA, const struct FAlterationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAlterationsEnum& A, const struct FAlterationsEnum& B);
	struct FAlterationsRowHandle CastToAlterationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAlterationsEnum(const struct FAlterationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAlterationsTable(class FName Name, const struct FAlteration& Data, struct FAlterationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AlterationsTable
class UAlterationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAlterationsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AmmoTypesLibrary
class UAmmoTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAmmoTypesLibrary* GetDefaultObj();

	struct FAmmoTypesRowHandle StructToRowHandle(const struct FAmmoTypesEnum& EnumValue);
	class FName StructToName(const struct FAmmoTypesEnum& EnumValue);
	int32 StructToInt(const struct FAmmoTypesEnum& EnumValue);
	struct FAmmoTypesEnum RowHandleToStruct(const struct FAmmoTypesRowHandle& RowHandle);
	void RemoveRowFromAmmoTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAmmoTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAmmoTypesEnum& A, const struct FAmmoTypesEnum& B);
	struct FAmmoTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAmmoTypesRowHandle MakeLiteralAmmoTypes(const struct FAmmoTypesRowHandle& RowHandle);
	struct FAmmoTypesRowHandle MakeAmmoTypesFromIndex(int32 Index);
	struct FAmmoTypesEnum MakeAmmoTypesEnum(const struct FAmmoTypesEnum& Enum);
	struct FAmmoTypesRowHandle MakeAmmoTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAmmoTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAmmoTypesStruct(const struct FAmmoTypesRowHandle& RowHandle, struct FAmmoTypeData* AmmoTypes, enum class EValid* Paths);
	bool EqualEqual_FAmmoTypesRowHandleFAmmoTypesRowHandle(const struct FAmmoTypesRowHandle& RowHandleA, const struct FAmmoTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAmmoTypesEnum& A, const struct FAmmoTypesEnum& B);
	struct FAmmoTypesRowHandle CastToAmmoTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAmmoTypesEnum(const struct FAmmoTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAmmoTypesTable(class FName Name, const struct FAmmoTypeData& Data, struct FAmmoTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AmmoTypesTable
class UAmmoTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAmmoTypesTable* GetDefaultObj();

};

// 0x20 (0x58 - 0x38)
// Class Icarus.AnimNotify_IcarusPlaySound
class UAnimNotify_IcarusPlaySound : public UAnimNotify
{
public:
	class UFMODEvent*                            FMODEvent;                                         // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFollow;                                           // 0x40(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6CC5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  AttachSocket;                                      // 0x44(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseListenerRotation;                              // 0x4C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseOcclusion;                                     // 0x4D(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6CC7[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  OcclusionTrace;                                    // 0x50(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UAnimNotify_IcarusPlaySound* GetDefaultObj();

};

// 0x18 (0x50 - 0x38)
// Class Icarus.AnimNotify_PlaySoundPlayer
class UAnimNotify_PlaySoundPlayer : public UAnimNotify
{
public:
	class UFMODEvent*                            FMODEvent;                                         // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseItemAnimData;                                  // 0x40(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6CCE[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  ItemAnimName;                                      // 0x44(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ItemAnimIndex;                                     // 0x4C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UAnimNotify_PlaySoundPlayer* GetDefaultObj();

	class UFMODEvent* GetFMODEvent(class AIcarusPlayerCharacter* PlayerCharacter);
};

// 0x28 (0x58 - 0x30)
// Class Icarus.AnimNotifyState_IcarusPlaySoundContinuous
class UAnimNotifyState_IcarusPlaySoundContinuous : public UAnimNotifyState
{
public:
	class UFMODEvent*                            FMODEvent;                                         // 0x30(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  AttachSocket;                                      // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseListenerRotation;                              // 0x40(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseOcclusion;                                     // 0x41(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6CCF[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  OcclusionTrace;                                    // 0x44(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6CD0[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x50(0x8)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UAnimNotifyState_IcarusPlaySoundContinuous* GetDefaultObj();

};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.ArmourComponent
class UArmourComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UArmourComponent* GetDefaultObj();

	bool GetArmourData(struct FArmourData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ArmourLibrary
class UArmourLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UArmourLibrary* GetDefaultObj();

	struct FArmourRowHandle StructToRowHandle(const struct FArmourEnum& EnumValue);
	class FName StructToName(const struct FArmourEnum& EnumValue);
	int32 StructToInt(const struct FArmourEnum& EnumValue);
	struct FArmourEnum RowHandleToStruct(const struct FArmourRowHandle& RowHandle);
	void RemoveRowFromArmourTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FArmourEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FArmourEnum& A, const struct FArmourEnum& B);
	struct FArmourEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FArmourRowHandle MakeLiteralArmour(const struct FArmourRowHandle& RowHandle);
	struct FArmourRowHandle MakeArmourFromIndex(int32 Index);
	struct FArmourEnum MakeArmourEnum(const struct FArmourEnum& Enum);
	struct FArmourRowHandle MakeArmour(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FArmourEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetArmourStruct(const struct FArmourRowHandle& RowHandle, struct FArmourData* Armour, enum class EValid* Paths);
	bool EqualEqual_FArmourRowHandleFArmourRowHandle(const struct FArmourRowHandle& RowHandleA, const struct FArmourRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FArmourEnum& A, const struct FArmourEnum& B);
	struct FArmourRowHandle CastToArmourRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakArmourEnum(const struct FArmourEnum& Enum, class FName* Name, int32* Index);
	void AddRowToArmourTable(class FName Name, const struct FArmourData& Data, struct FArmourRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ArmourSetBonusLibrary
class UArmourSetBonusLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UArmourSetBonusLibrary* GetDefaultObj();

	struct FArmourSetBonusRowHandle StructToRowHandle(const struct FArmourSetBonusEnum& EnumValue);
	class FName StructToName(const struct FArmourSetBonusEnum& EnumValue);
	int32 StructToInt(const struct FArmourSetBonusEnum& EnumValue);
	struct FArmourSetBonusEnum RowHandleToStruct(const struct FArmourSetBonusRowHandle& RowHandle);
	void RemoveRowFromArmourSetBonusTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FArmourSetBonusEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FArmourSetBonusEnum& A, const struct FArmourSetBonusEnum& B);
	struct FArmourSetBonusEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FArmourSetBonusRowHandle MakeLiteralArmourSetBonus(const struct FArmourSetBonusRowHandle& RowHandle);
	struct FArmourSetBonusRowHandle MakeArmourSetBonusFromIndex(int32 Index);
	struct FArmourSetBonusEnum MakeArmourSetBonusEnum(const struct FArmourSetBonusEnum& Enum);
	struct FArmourSetBonusRowHandle MakeArmourSetBonus(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FArmourSetBonusEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetArmourSetBonusStruct(const struct FArmourSetBonusRowHandle& RowHandle, struct FArmourSetBonus* ArmourSetBonus, enum class EValid* Paths);
	bool EqualEqual_FArmourSetBonusRowHandleFArmourSetBonusRowHandle(const struct FArmourSetBonusRowHandle& RowHandleA, const struct FArmourSetBonusRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FArmourSetBonusEnum& A, const struct FArmourSetBonusEnum& B);
	struct FArmourSetBonusRowHandle CastToArmourSetBonusRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakArmourSetBonusEnum(const struct FArmourSetBonusEnum& Enum, class FName* Name, int32* Index);
	void AddRowToArmourSetBonusTable(class FName Name, const struct FArmourSetBonus& Data, struct FArmourSetBonusRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ArmourSetBonusTable
class UArmourSetBonusTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UArmourSetBonusTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ArmourSetsLibrary
class UArmourSetsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UArmourSetsLibrary* GetDefaultObj();

	struct FArmourSetsRowHandle StructToRowHandle(const struct FArmourSetsEnum& EnumValue);
	class FName StructToName(const struct FArmourSetsEnum& EnumValue);
	int32 StructToInt(const struct FArmourSetsEnum& EnumValue);
	struct FArmourSetsEnum RowHandleToStruct(const struct FArmourSetsRowHandle& RowHandle);
	void RemoveRowFromArmourSetsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FArmourSetsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FArmourSetsEnum& A, const struct FArmourSetsEnum& B);
	struct FArmourSetsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FArmourSetsRowHandle MakeLiteralArmourSets(const struct FArmourSetsRowHandle& RowHandle);
	struct FArmourSetsRowHandle MakeArmourSetsFromIndex(int32 Index);
	struct FArmourSetsEnum MakeArmourSetsEnum(const struct FArmourSetsEnum& Enum);
	struct FArmourSetsRowHandle MakeArmourSets(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FArmourSetsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetArmourSetsStruct(const struct FArmourSetsRowHandle& RowHandle, struct FArmourSet* ArmourSets, enum class EValid* Paths);
	bool EqualEqual_FArmourSetsRowHandleFArmourSetsRowHandle(const struct FArmourSetsRowHandle& RowHandleA, const struct FArmourSetsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FArmourSetsEnum& A, const struct FArmourSetsEnum& B);
	struct FArmourSetsRowHandle CastToArmourSetsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakArmourSetsEnum(const struct FArmourSetsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToArmourSetsTable(class FName Name, const struct FArmourSet& Data, struct FArmourSetsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ArmourSetsTable
class UArmourSetsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UArmourSetsTable* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ArmourTable
class UArmourTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UArmourTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AssetReferencesLibrary
class UAssetReferencesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAssetReferencesLibrary* GetDefaultObj();

	struct FAssetReferencesRowHandle StructToRowHandle(const struct FAssetReferencesEnum& EnumValue);
	class FName StructToName(const struct FAssetReferencesEnum& EnumValue);
	int32 StructToInt(const struct FAssetReferencesEnum& EnumValue);
	struct FAssetReferencesEnum RowHandleToStruct(const struct FAssetReferencesRowHandle& RowHandle);
	void RemoveRowFromAssetReferencesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAssetReferencesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAssetReferencesEnum& A, const struct FAssetReferencesEnum& B);
	struct FAssetReferencesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAssetReferencesRowHandle MakeLiteralAssetReferences(const struct FAssetReferencesRowHandle& RowHandle);
	struct FAssetReferencesRowHandle MakeAssetReferencesFromIndex(int32 Index);
	struct FAssetReferencesEnum MakeAssetReferencesEnum(const struct FAssetReferencesEnum& Enum);
	struct FAssetReferencesRowHandle MakeAssetReferences(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAssetReferencesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAssetReferencesStruct(const struct FAssetReferencesRowHandle& RowHandle, struct FAssetReferenceData* AssetReferences, enum class EValid* Paths);
	bool EqualEqual_FAssetReferencesRowHandleFAssetReferencesRowHandle(const struct FAssetReferencesRowHandle& RowHandleA, const struct FAssetReferencesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAssetReferencesEnum& A, const struct FAssetReferencesEnum& B);
	struct FAssetReferencesRowHandle CastToAssetReferencesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAssetReferencesEnum(const struct FAssetReferencesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAssetReferencesTable(class FName Name, const struct FAssetReferenceData& Data, struct FAssetReferencesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AssetReferencesTable
class UAssetReferencesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAssetReferencesTable* GetDefaultObj();

};

// 0x0 (0x220 - 0x220)
// Class Icarus.AtmosphereController
class AAtmosphereController : public AInfo
{
public:

	static class UClass* StaticClass();
	static class AAtmosphereController* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AtmospheresLibrary
class UAtmospheresLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAtmospheresLibrary* GetDefaultObj();

	struct FAtmospheresRowHandle StructToRowHandle(const struct FAtmospheresEnum& EnumValue);
	class FName StructToName(const struct FAtmospheresEnum& EnumValue);
	int32 StructToInt(const struct FAtmospheresEnum& EnumValue);
	struct FAtmospheresEnum RowHandleToStruct(const struct FAtmospheresRowHandle& RowHandle);
	void RemoveRowFromAtmospheresTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAtmospheresEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAtmospheresEnum& A, const struct FAtmospheresEnum& B);
	struct FAtmospheresEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAtmospheresRowHandle MakeLiteralAtmospheres(const struct FAtmospheresRowHandle& RowHandle);
	struct FAtmospheresRowHandle MakeAtmospheresFromIndex(int32 Index);
	struct FAtmospheresEnum MakeAtmospheresEnum(const struct FAtmospheresEnum& Enum);
	struct FAtmospheresRowHandle MakeAtmospheres(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAtmospheresEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAtmospheresStruct(const struct FAtmospheresRowHandle& RowHandle, struct FIcarusAtmosphere* Atmospheres, enum class EValid* Paths);
	bool EqualEqual_FAtmospheresRowHandleFAtmospheresRowHandle(const struct FAtmospheresRowHandle& RowHandleA, const struct FAtmospheresRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAtmospheresEnum& A, const struct FAtmospheresEnum& B);
	struct FAtmospheresRowHandle CastToAtmospheresRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAtmospheresEnum(const struct FAtmospheresEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAtmospheresTable(class FName Name, const struct FIcarusAtmosphere& Data, struct FAtmospheresRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AtmospheresTable
class UAtmospheresTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAtmospheresTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AttachmentIconsLibrary
class UAttachmentIconsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAttachmentIconsLibrary* GetDefaultObj();

	struct FAttachmentIconsRowHandle StructToRowHandle(const struct FAttachmentIconsEnum& EnumValue);
	class FName StructToName(const struct FAttachmentIconsEnum& EnumValue);
	int32 StructToInt(const struct FAttachmentIconsEnum& EnumValue);
	struct FAttachmentIconsEnum RowHandleToStruct(const struct FAttachmentIconsRowHandle& RowHandle);
	void RemoveRowFromAttachmentIconsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAttachmentIconsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAttachmentIconsEnum& A, const struct FAttachmentIconsEnum& B);
	struct FAttachmentIconsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAttachmentIconsRowHandle MakeLiteralAttachmentIcons(const struct FAttachmentIconsRowHandle& RowHandle);
	struct FAttachmentIconsRowHandle MakeAttachmentIconsFromIndex(int32 Index);
	struct FAttachmentIconsEnum MakeAttachmentIconsEnum(const struct FAttachmentIconsEnum& Enum);
	struct FAttachmentIconsRowHandle MakeAttachmentIcons(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAttachmentIconsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAttachmentIconsStruct(const struct FAttachmentIconsRowHandle& RowHandle, struct FAttachmentIcon* AttachmentIcons, enum class EValid* Paths);
	bool EqualEqual_FAttachmentIconsRowHandleFAttachmentIconsRowHandle(const struct FAttachmentIconsRowHandle& RowHandleA, const struct FAttachmentIconsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAttachmentIconsEnum& A, const struct FAttachmentIconsEnum& B);
	struct FAttachmentIconsRowHandle CastToAttachmentIconsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAttachmentIconsEnum(const struct FAttachmentIconsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAttachmentIconsTable(class FName Name, const struct FAttachmentIcon& Data, struct FAttachmentIconsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AttachmentIconsTable
class UAttachmentIconsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAttachmentIconsTable* GetDefaultObj();

};

// 0xB0 (0x160 - 0xB0)
// Class Icarus.AudioContextComponent
class UAudioContextComponent : public UActorComponent
{
public:
	float                                        MaxUpdateDistance;                                 // 0xB0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        OcclusionShelterContextThreshold;                  // 0xB4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEnteredCave;                                     // 0xB8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnExitedCave;                                      // 0xC8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_6DF4[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	enum class EAudioShelterState                ShelterState;                                      // 0xD9(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_6DF5[0x16];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UAudioOcclusionComponent*              OcclusionComponent;                                // 0xF0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAudioContextSubscriber>       Subscribers;                                       // 0xF8(0x10)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FAudioContextCaveColliderSet> CaveOverlaps;                                      // 0x108(0x50)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_6DF6[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UAudioContextComponent* GetDefaultObj();

	void UnsubscribeAudioComponentFromUpdates(class UFMODAudioComponent* AudioComponent);
	void SubscribeAudioComponentToUpdates(class UFMODAudioComponent* AudioComponent, bool bUsesOcclusionParameter, class FName OcclusionTraceName, bool bUsesWaterImmersionParameter);
	void SetCaveOverlapOnceByLocation(const struct FVector& Location);
	void RemoveCaveOverlap(class AActor* Cave, class UPrimitiveComponent* Collider);
	enum class EAudioShelterState GetShelterState();
	enum class EOcclusionShelterContextFMODParam GetOcclusionShelterContextFMODParam(float OcclusionValue);
	float GetListenerCaveSpaceCorrelation();
	float GetCurrentWaterImmersion();
	float GetCurrentOcclusion(class FName TracePointName);
	enum class ECaveContextFMODParam GetCaveContextFMODParam();
	void AddCaveOverlap(class AActor* Cave, class UPrimitiveComponent* Collider);
};

// 0x8 (0x168 - 0x160)
// Class Icarus.AudioContextCreatureComponent
class UAudioContextCreatureComponent : public UAudioContextComponent
{
public:
	class UCreatureAudioComponent*               CreatureAudio;                                     // 0x160(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UAudioContextCreatureComponent* GetDefaultObj();

};

// 0x10 (0x170 - 0x160)
// Class Icarus.AudioContextPlayerComponent
class UAudioContextPlayerComponent : public UAudioContextComponent
{
public:
	float                                        ShelterStateLowThreshold;                          // 0x160(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ShelterStateHighThreshold;                         // 0x164(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerMovementAudioComponent*         PlayerMovementAudioComponent;                      // 0x168(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UAudioContextPlayerComponent* GetDefaultObj();

	void ServerSetNewShelter(enum class EAudioShelterState NewShelterState);
	void OnShelterUpdated(float NewShelter);
};

// 0x0 (0x470 - 0x470)
// Class Icarus.AudioListenerCollider
class UAudioListenerCollider : public USphereComponent
{
public:

	static class UClass* StaticClass();
	static class UAudioListenerCollider* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AudioOccluderInterface
class IAudioOccluderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IAudioOccluderInterface* GetDefaultObj();

	float GetOcclusionValue();
};

// 0x78 (0x270 - 0x1F8)
// Class Icarus.AudioOcclusionComponent
class UAudioOcclusionComponent : public USceneComponent
{
public:
	bool                                         bDebug;                                            // 0x1F8(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6E0C[0x77];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UAudioOcclusionComponent* GetDefaultObj();

	TArray<struct FAudioOcclusionTracePoint> GetTracePoints(struct FVector& ListenerLocation);
};

// 0x10 (0x280 - 0x270)
// Class Icarus.AudioOcclusionSocketTraceComponent
class UAudioOcclusionSocketTraceComponent : public UAudioOcclusionComponent
{
public:
	TArray<struct FAudioOcclusionSocketTracePoint> TracePointDefinitions;                             // 0x270(0x10)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UAudioOcclusionSocketTraceComponent* GetDefaultObj();

	void SetTracePointTargets(class USceneComponent* TargetComponent);
};

// 0x0 (0x280 - 0x280)
// Class Icarus.AudioOcclusionCharacterComponent
class UAudioOcclusionCharacterComponent : public UAudioOcclusionSocketTraceComponent
{
public:

	static class UClass* StaticClass();
	static class UAudioOcclusionCharacterComponent* GetDefaultObj();

};

// 0x0 (0x270 - 0x270)
// Class Icarus.AudioOcclusionDropshipComponent
class UAudioOcclusionDropshipComponent : public UAudioOcclusionComponent
{
public:

	static class UClass* StaticClass();
	static class UAudioOcclusionDropshipComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.AudioReflectorInterface
class IAudioReflectorInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IAudioReflectorInterface* GetDefaultObj();

	struct FSurfaceAudioReflectionData GetReflectionValue();
};

// 0x0 (0x30 - 0x30)
// Class Icarus.AudioSettingsSubsystem
class UAudioSettingsSubsystem : public UGameInstanceSubsystem
{
public:

	static class UClass* StaticClass();
	static class UAudioSettingsSubsystem* GetDefaultObj();

	void OnSFXVolumeChanged(float Volume);
	void OnMusicVolumeChanged(float Volume);
	void OnMasterVolumeChanged(float Volume);
	void OnDialogueVolumeChanged(float Volume);
	void OnCharacterVoiceVolumeChanged(float Volume);
	void OnAmbientVolumeChanged(float Volume);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AudioShelterInterface
class IAudioShelterInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IAudioShelterInterface* GetDefaultObj();

	float GetAudioShelterValue(class AIcarusPlayerCharacter* Player);
};

// 0x38 (0x580 - 0x548)
// Class Icarus.AudioSplineComponent
class UAudioSplineComponent : public USplineComponent
{
public:
	class UFMODEvent*                            Event;                                             // 0x548(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        UpdateFrequencyInListenerRange;                    // 0x550(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        UpdateFrequencyOutsideListenerRange;               // 0x554(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InterpSpeed;                                       // 0x558(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6E44[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x560(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_6E45[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UAudioSplineComponent* GetDefaultObj();

};

// 0x218 (0x2C8 - 0xB0)
// Class Icarus.AuraManagerComponent
class UAuraManagerComponent : public UActorComponent
{
public:
	TSet<class AActor*>                          AllPlayers;                                        // 0xB0(0x50)(NativeAccessSpecifierPrivate)
	TSet<class AActor*>                          AllNPCs;                                           // 0x100(0x50)(NativeAccessSpecifierPrivate)
	TSet<class AActor*>                          AllDeployables;                                    // 0x150(0x50)(NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FAuraInstances>   AuraInstances;                                     // 0x1A0(0x50)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                     PlayerTagQuery;                                    // 0x1F0(0x48)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                     NPCTagQuery;                                       // 0x238(0x48)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                     DeployableTagQuery;                                // 0x280(0x48)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UAuraManagerComponent* GetDefaultObj();

	void UnregisterModifiableObject(class AActor* Modifiable);
	void TickModifier(class UModifierStateComponent* ModifierComp);
	void RemoveAura(class UModifierStateComponent* ModifierComp);
	void RegisterModifiableObject(class AActor* Modifiable);
	TArray<struct FFindAuraResult> GetAurasAtLocation(const struct FVector& Location);
	void AddAuraCustomRange(class UModifierStateComponent* ModifierComp, int32 Range);
	void AddAura(class UModifierStateComponent* ModifierComp);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.AutonomousSpawnsLibrary
class UAutonomousSpawnsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UAutonomousSpawnsLibrary* GetDefaultObj();

	struct FAutonomousSpawnsRowHandle StructToRowHandle(const struct FAutonomousSpawnsEnum& EnumValue);
	class FName StructToName(const struct FAutonomousSpawnsEnum& EnumValue);
	int32 StructToInt(const struct FAutonomousSpawnsEnum& EnumValue);
	struct FAutonomousSpawnsEnum RowHandleToStruct(const struct FAutonomousSpawnsRowHandle& RowHandle);
	void RemoveRowFromAutonomousSpawnsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FAutonomousSpawnsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FAutonomousSpawnsEnum& A, const struct FAutonomousSpawnsEnum& B);
	struct FAutonomousSpawnsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FAutonomousSpawnsRowHandle MakeLiteralAutonomousSpawns(const struct FAutonomousSpawnsRowHandle& RowHandle);
	struct FAutonomousSpawnsRowHandle MakeAutonomousSpawnsFromIndex(int32 Index);
	struct FAutonomousSpawnsEnum MakeAutonomousSpawnsEnum(const struct FAutonomousSpawnsEnum& Enum);
	struct FAutonomousSpawnsRowHandle MakeAutonomousSpawns(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FAutonomousSpawnsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetAutonomousSpawnsStruct(const struct FAutonomousSpawnsRowHandle& RowHandle, struct FAutonomousSpawnData* AutonomousSpawns, enum class EValid* Paths);
	bool EqualEqual_FAutonomousSpawnsRowHandleFAutonomousSpawnsRowHandle(const struct FAutonomousSpawnsRowHandle& RowHandleA, const struct FAutonomousSpawnsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FAutonomousSpawnsEnum& A, const struct FAutonomousSpawnsEnum& B);
	struct FAutonomousSpawnsRowHandle CastToAutonomousSpawnsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakAutonomousSpawnsEnum(const struct FAutonomousSpawnsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToAutonomousSpawnsTable(class FName Name, const struct FAutonomousSpawnData& Data, struct FAutonomousSpawnsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.AutonomousSpawnsTable
class UAutonomousSpawnsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UAutonomousSpawnsTable* GetDefaultObj();

};

// 0x420 (0x4D0 - 0xB0)
// Class Icarus.BackendProxyComponent
class UBackendProxyComponent : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_            MetaResourcesUpdated;                              // 0xB0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            MetaInventoryUpdated;                              // 0xB1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            MetaInventorySlotUpdated;                          // 0xB2(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            WorkshopPurchaseResult;                            // 0xB3(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            DropshipsUpdated;                                  // 0xB4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            DropshipCreationResult;                            // 0xB5(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            DropshipModificationResult;                        // 0xB6(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            DropshipDeletionResult;                            // 0xB7(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            PreparedLoadoutUpdated;                            // 0xB8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            CharacterLoadoutUpdated;                           // 0xB9(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            LoadoutInventoryUpdated;                           // 0xBA(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            LoadoutInventorySlotUpdated;                       // 0xBB(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            LoadoutPackaged;                                   // 0xBC(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            CreditsUpdated;                                    // 0xBD(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ProspectsUpdated;                                  // 0xBE(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ClaimedProspectResult;                             // 0xBF(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SettleProspectResult;                              // 0xC0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            NotificationsUpdated;                              // 0xC1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            TalentUnlocked;                                    // 0xC2(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            TrackedStatisticsUpdateResult;                     // 0xC3(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            FactionMissionUpdateResult;                        // 0xC4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            BackToHabResult;                                   // 0xC5(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_6EDC[0x52];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            GetCharacterProfileResult;                         // 0x118(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            GetUserProfileResult;                              // 0x119(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            PackageLoadoutResult;                              // 0x11A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            WorkshopResearchResult;                            // 0x11B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            WorkshopReplicationResult;                         // 0x11C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            GetCharacterLoadoutResult;                         // 0x11D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            UpdateCharacterProgressResult;                     // 0x11E(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            UpdateCharacterProspectLocationResult;             // 0x11F(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SyncCharacterTalentsResult;                        // 0x120(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SyncAccountTalentsResult;                          // 0x121(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SyncAccountFlagsResult;                            // 0x122(0x1)(InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ExchangeCurrencyResult;                            // 0x123(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            WorkshopRepairResult;                              // 0x124(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_6EDD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetMetaResourceCallbackProxyGen*      MetaResourcesCallback;                             // 0x128(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetMetaInventoryCallbackProxyGen*     MetaInventoryCallback;                             // 0x130(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetLoadoutInventoryCallbackProxyGen*  LoadoutInventoryCallback;                          // 0x138(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveMetaInventoryItemCallbackProxyGen* ShiftMetaItemCallbackProxy;                        // 0x140(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URemoveMetaItemCallbackProxyGen*       RemoveMetaItemCallbackProxy;                       // 0x148(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetDropshipsCallbackProxyGen*         GetDropshipsCallbackProxy;                         // 0x150(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreateDropshipCallbackProxyGen*       CreateDropshipsCallbackProxy;                      // 0x158(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModifyDropshipCallbackProxyGen*       ModifyDropshipsCallbackProxy;                      // 0x160(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeleteDropshipCallbackProxyGen*       DeleteDropshipsCallbackProxy;                      // 0x168(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USelectDropshipCallbackProxyGen*       SelectDropshipCallbackProxy;                       // 0x170(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URemoveSelectedDropshipCallbackProxyGen* RemoveSelectedDropshipCallbackProxy;               // 0x178(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USelectEnvirosuitCallbackProxyGen*     SelectEnvirosuitCallbackProxy;                     // 0x180(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URemoveEnvirosuitCallbackProxyGen*     RemoveEnvirosuitCallbackProxy;                     // 0x188(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPackageLoadoutCallbackProxyGen*       PackageLoadoutCallbackProxy;                       // 0x190(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnpackageLoadoutCallbackProxyGen*     UnpackageLoadoutCallbackProxy;                     // 0x198(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetCharacterLoadoutCallbackProxyGen*  CharacterLoadoutCallbackProxy;                     // 0x1A0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetPreparedLoadoutCallbackProxyGen*   PreparedLoadoutCallbackProxy;                      // 0x1A8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetCreditsCallbackProxyGen*           GetCreditsCallbackProxy;                           // 0x1B0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetAllProspectsCallbackProxyGen*      GetAllProspectsCallbackProxy;                      // 0x1B8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClaimProspectCallbackProxyGen*        ClaimProspectCallbackProxy;                        // 0x1C0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USettleProspectCallbackProxyGen*       SettleProspectCallbackProxy;                       // 0x1C8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetNotificationsCallbackProxyGen*     GetNotificationsCallbackProxy;                     // 0x1D0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClaimNotificationAttachmentsCallbackProxyGen* ClaimNotificationAttachmentsCallbackProxy;         // 0x1D8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeleteNotificationCallbackProxyGen*   DeleteNotificationCallbackProxy;                   // 0x1E0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadNotificationCallbackProxyGen*     ReadNotificationCallbackProxy;                     // 0x1E8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUpdateCharacterProgressCallbackProxyGen* UpdateCharacterProgressProxy;                      // 0x1F0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUpdateCharacterProspectLocationCallbackProxyGen* UpdateCharacterProspectLocationProxy;              // 0x1F8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUpdateTrackedStatsCallbackProxyGen*   UpdateTrackedStatsCallbackProxy;                   // 0x200(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUpdateFactionMissionProgressCallbackProxyGen* UpdateFactionMissionProgressCallbackProxy;         // 0x208(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USyncCharacterTalentsCallbackProxyGen* SyncCharacterTalentsCallbackProxy;                 // 0x210(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USyncAccountTalentsCallbackProxyGen*   SyncAccountTalentsCallbackProxy;                   // 0x218(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USyncAccountFlagsCallbackProxyGen*     SyncAccountFlagsCallbackProxy;                     // 0x220(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetCharacterProfileCallbackProxyGen*  GetCharacterProfileCallbackProxy;                  // 0x228(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGetUserProfileCallbackProxyGen*       GetUserProfileCallbackProxy;                       // 0x230(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBackToHabCallbackProxyGen*            BackToHabCallbackProxy;                            // 0x238(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnlockWorkshopItemCallbackProxyGen*   UnlockWorkshopItemCallbackProxy;                   // 0x240(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicateWorkshopItemCallbackProxyGen* ReplicateWorkshopItemCallbackProxy;                // 0x248(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URepairWorkshopItemCallbackProxyGen*   RepairWorkshopItemCallbackProxy;                   // 0x250(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExchangeCurrencyCallbackProxyGen*     ExchangeCurrencyCallbackProxy;                     // 0x258(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTalentRefundCallbackProxyGen*         TalentRefundCallbackProxy;                         // 0x260(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<enum class ERateLimitedRequests, int32> RequestTimers;                                     // 0x268(0x50)(NativeAccessSpecifierPublic)
	float                                        CurrentTime;                                       // 0x2B8(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6EDF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FMetaResource>                 MetaResources;                                     // 0x2C0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	int32                                        Credits;                                           // 0x2D0(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6EE0[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FMetaItem>                     MetaInventory;                                     // 0x2D8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FMetaItem>                     LoadoutInventory;                                  // 0x2E8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FDropship>                     Dropships;                                         // 0x2F8(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	int32                                        PreparedDropship;                                  // 0x308(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        PreparedDropshipID;                                // 0x30C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMetaItem                             PreparedEnvirosuit;                                // 0x310(0x40)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FCharacterLoadout                     CharacterLoadout;                                  // 0x350(0x138)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	bool                                         PreparedLoadout;                                   // 0x488(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6EE1[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FProspectInfo>                 Prospects;                                         // 0x490(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FNotification>                 Notifications;                                     // 0x4A0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	struct FPendingInventorySwap                 PendingInventorySwap;                              // 0x4B0(0x20)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBackendProxyComponent* GetDefaultObj();

	void UpdateSelectedDropship();
	void TriggerWorkshopPurchaseResult(bool Success);
	void TriggerTalentUnlocked(const struct FTalentsRowHandle& Talent, int32 Rank, bool Success);
	void TriggerProspectSettleResult(bool Success, struct FProspectInfo& ProspectInfo);
	void TriggerLoadoutPackage();
	void TriggerDropshipModificationResult(bool Success);
	void TriggerDropshipDeletionResult(bool Success);
	void TriggerDropshipCreationResult(bool Success);
	void TriggerClaimProspectResult(bool Success, const struct FProspectInfo& ProspectInfo);
	void RetrieveCharacterLoadout();
	void Response_WorkshopPurchaseWorkshopPack();
	void Response_WorkshopPacks(struct FResGetWorkshopPacks& Response);
	void Response_UpdateTrackedStats(struct FResUpdateTrackedStats& Response);
	void Response_UpdateFactionMissionProgress(struct FResUpdateFactionMissionProgress& Response);
	void Response_UpdateCharacterProspectLocation(struct FResUpdateCharacterProspectLocation& Response);
	void Response_UpdateCharacterProgress(struct FResUpdateCharacterProgress& Response);
	void Response_UnpackageLoadout(struct FResUnpackageLoadout& Response);
	void Response_UnlockWorkshopItem(struct FResUnlockWorkshopItem& Response);
	void Response_TalentRefund(struct FResTalentRefund& Response);
	void Response_SyncCharacterTalents(struct FResSyncCharacterTalents& Response);
	void Response_SyncAccountTalents(struct FResSyncAccountTalents& Response);
	void Response_SyncAccountFlags(struct FResSyncAccountFlags& Response);
	void Response_ShiftInventoryItem(struct FResMoveMetaInventoryItem& Response);
	void Response_SettleProspect(struct FResSettleProspect& Response);
	void Response_ReplicateWorkshopItem(struct FResReplicateWorkshopItem& Response);
	void Response_RepairWorkshopItem(struct FResRepairWorkshopItem& Response);
	void Response_RemovePreparedEnvirosuit(struct FResRemoveEnvirosuit& Response);
	void Response_RemovePreparedDropship(struct FResRemoveSelectedDropship& Response);
	void Response_RemoveMetaItem(struct FResRemoveMetaInventoryItem& Response);
	void Response_ReadNotification(struct FResReadNotification& Response);
	void Response_PrepareEnvirosuit(struct FResSelectEnvirosuit& Response);
	void Response_PrepareDropship(struct FResSelectDropship& Response);
	void Response_PreparedLoadout(struct FResPreparedLoadout& Response);
	void Response_PackageLoadout_WithCharacter(struct FResPackageLoadout& Response);
	void Response_ModifyDropship(struct FResModifyDropship& Response);
	void Response_MetaResources(struct FResGetMetaResources& Response);
	void Response_MetaInventory(struct FResGetMetaInventory& Response);
	void Response_LoadoutInventory(struct FResLoadoutInventory& Response);
	void Response_LeaveProspectByDropship(struct FResBackToHab& Response);
	void Response_GetUserProfile(struct FResGetUserProfile& Response);
	void Response_GetNotifications(struct FResGetNotifications& Response);
	void Response_GetCharacterProfile(struct FResGetCharacterProfile& Response);
	void Response_ExchangeCurrency(struct FResExchangeCurrency& Response);
	void Response_Dropships(struct FResGetDropships& Response);
	void Response_DeleteNotification(struct FResDeleteNotification& Response);
	void Response_DeleteDropship(struct FResDeleteDropship& Response);
	void Response_Credits(struct FResGetCredits& Response);
	void Response_CreateDropship(struct FResCreateDropship& Response);
	void Response_ClaimProspect(struct FResClaimProspect& Response);
	void Response_ClaimNotificationAttachements(struct FResClaimNotificationAttachments& Response);
	void Response_CharacterLoadout(struct FResGetCharacterLoadout& Response);
	void Response_AvailableProspects(struct FResGetAllProspects& Response);
	void Request_WorkshopPurchaseWorkshopPack(int32 Index);
	void Request_WorkshopPacks();
	void Request_UpdateTrackedStats();
	void Request_UpdateFactionMissionProgress(struct FFactionMissionsRowHandle& Mission, int32 Progress);
	void Request_UpdateCharacterProspectLocation(enum class EProspectLocation Location);
	void Request_UpdateCharacterProgress();
	void Request_UnpackageLoadout();
	void Request_UnlockWorkshopItem(struct FTalentsRowHandle& TalentsRowHandle);
	void Request_TalentRefund(struct FTalentsRowHandle& Talent, int32 CharacterSlot);
	void Request_SyncCharacterTalents();
	void Request_SyncAccountTalents();
	void Request_SyncAccountFlags();
	void Request_ShiftInventoryItem(class UInventory* SourceInventory, class UInventory* DestinationInventory, int32 SourceSlot, int32 DestinationSlot, int32 Amount);
	void Request_SettleProspect(const class FString& ProspectID, bool SettleProspect);
	void Request_ReplicateWorkshopItem(struct FTalentsRowHandle& TalentsRowHandle);
	void Request_RepairWorkshopItem(class UInventory* SourceInventory, int32 SourceSlot);
	void Request_RemovePreparedEnvirosuit();
	void Request_RemovePreparedDropship();
	void Request_RemoveMetaItem(class UInventory* SourceInventory, int32 SourceSlot, int32 Amount);
	void Request_ReadNotification(const class FString& NotificationID);
	void Request_PrepareEnvirosuit(class UInventory* Inventory, int32 Slot);
	void Request_PrepareDropship(int32 Index);
	void Request_PreparedLoadout();
	void Request_PackageLoadout_WithCharacter(struct FOnlineProfileCharacter& OnlineProfileCharacter);
	void Request_PackageLoadout();
	void Request_ModifyDropship(int32 Index, struct FDropshipModification& Dropship);
	void Request_MetaResources();
	void Request_MetaInventory();
	void Request_LoadoutInventory();
	void Request_LeaveProspectByDropship();
	void Request_GetUserProfile();
	void Request_GetNotifications(bool RequestCompleteList);
	void Request_GetCharacterProfile(int32 CharSlot);
	void Request_ExchangeCurrency(const struct FCurrencyConversionsRowHandle& Conversion, int32 Iterations);
	void Request_Dropships();
	void Request_DeleteNotification(const class FString& NotificationID);
	void Request_DeleteDropship(int32 Index);
	void Request_Credits();
	void Request_CreateDropship();
	void Request_ClaimProspect(struct FProspectInfo& ProspectInfo);
	void Request_ClaimNotificationAttachements(const class FString& NotificationID);
	void Request_CharacterLoadout();
	void Request_AvailableProspects();
	void RemoveDropship(int32 DropshipID);
	bool RateLimitCheck(enum class ERateLimitedRequests RequestType);
	void ProcessSwapInventoryDelta(struct FInventoryDelta& InventoryDelta);
	void ProcessResourceDelta(const TArray<struct FMetaResource>& ResourcesDelta);
	void ProcessInventoryDelta(struct FInventoryDelta& InventoryDelta);
	void ProcessDropshipDelta(const struct FDropshipDelta& DropshipDelta);
	void PrepareEnvirosuit(class UInventory* Inventory, int32 InventorySlot);
	void PrepareDropship(int32 Index);
	void OnUpdateCharacterProspectLocation(struct FResUpdateCharacterProspectLocation& Response);
	void OnUpdateCharacterProgress(struct FResUpdateCharacterProgress& Response);
	void OnUnpackageLoadoutRequestSuccess(struct FResUnpackageLoadout& Response);
	void OnUnpackageLoadoutRequestFailure(struct FResUnpackageLoadout& Response);
	void OnUnlockWorkshopItemSuccess(struct FResUnlockWorkshopItem& Response);
	void OnUnlockWorkshopItemFailure(struct FResUnlockWorkshopItem& Response);
	void OnTrackedStatsUpdated(struct FResUpdateTrackedStats& Response);
	void OnTalentRefundSuccess(struct FResTalentRefund& Response);
	void OnTalentRefundFailure(struct FResTalentRefund& Response);
	void OnSyncCharacterTalents(struct FResSyncCharacterTalents& Response);
	void OnSyncAccountTalents(struct FResSyncAccountTalents& Response);
	void OnSyncAccountFlags(struct FResSyncAccountFlags& Response);
	void OnShiftMetaItemRequestSuccess(struct FResMoveMetaInventoryItem& Response);
	void OnShiftMetaItemRequestFailure(struct FResMoveMetaInventoryItem& Response);
	void OnSettleProspectSuccess(struct FResSettleProspect& Response);
	void OnSettleProspectFailure(struct FResSettleProspect& Response);
	void OnReplicateWorkshopItemSuccess(struct FResReplicateWorkshopItem& Response);
	void OnReplicateWorkshopItemFailure(struct FResReplicateWorkshopItem& Response);
	void OnRepairWorkshopItem(struct FResRepairWorkshopItem& Response);
	void OnRep_WorkshopPacks();
	void OnRep_PreparedLoadout();
	void OnRep_PreparedEnvirosuit();
	void OnRep_PreparedDropship();
	void OnRep_Notifications();
	void OnRep_MetaResources();
	void OnRep_MetaInventory();
	void OnRep_LoadoutInventory();
	void OnRep_Dropships();
	void OnRep_Credits();
	void OnRep_CharacterLoadout();
	void OnRep_AvailableProspects();
	void OnRemovePreparedEnvirosuitRequestSuccess(struct FResRemoveEnvirosuit& Response);
	void OnRemovePreparedEnvirosuitRequestFailure(struct FResRemoveEnvirosuit& Response);
	void OnRemovePreparedDropshipRequestSuccess(struct FResRemoveSelectedDropship& Response);
	void OnRemovePreparedDropshipRequestFailure(struct FResRemoveSelectedDropship& Response);
	void OnRemoveMetaItemRequestSuccess(struct FResRemoveMetaInventoryItem& Response);
	void OnRemoveMetaItemRequestFailure(struct FResRemoveMetaInventoryItem& Response);
	void OnReadNotificationSuccess(struct FResReadNotification& Response);
	void OnReadNotificationFailure(struct FResReadNotification& Response);
	void OnPrepareEnvirosuitRequestSuccess(struct FResSelectEnvirosuit& Response);
	void OnPrepareEnvirosuitRequestFailure(struct FResSelectEnvirosuit& Response);
	void OnPrepareDropshipRequestSuccess(struct FResSelectDropship& Response);
	void OnPrepareDropshipRequestFailure(struct FResSelectDropship& Response);
	void OnPreparedLoadoutRequestSuccess(struct FResPreparedLoadout& Response);
	void OnPreparedLoadoutRequestFailure(struct FResPreparedLoadout& Response);
	void OnPackageLoadoutRequestFailure(struct FResPackageLoadout& Response);
	void OnOnPackageLoadoutRequestSuccess(struct FResPackageLoadout& Response);
	void OnModifyDropshipsRequestSuccess(struct FResModifyDropship& Response);
	void OnModifyDropshipsRequestFailure(struct FResModifyDropship& Response);
	void OnMetaResourcesRequestSuccess(struct FResGetMetaResources& Response);
	void OnMetaResourcesRequestFailure(struct FResGetMetaResources& Response);
	void OnLoadoutInventoryRequest(struct FResLoadoutInventory& Response);
	void OnInventoryRequestSuccess(struct FResGetMetaInventory& Response);
	void OnInventoryRequestFailure(struct FResGetMetaInventory& Response);
	void OnGetUserProfile(struct FResGetUserProfile& Response);
	void OnGetNotificationsSuccess(struct FResGetNotifications& Response);
	void OnGetNotificationsFailure(struct FResGetNotifications& Response);
	void OnGetDropshipsRequestSuccess(struct FResGetDropships& Response);
	void OnGetDropshipsRequestFailure(struct FResGetDropships& Response);
	void OnGetCreditsRequestSuccess(struct FResGetCredits& Response);
	void OnGetCreditsRequestFailure(struct FResGetCredits& Response);
	void OnGetCharacterProfile(struct FResGetCharacterProfile& Response);
	void OnGetAllProspectsSuccess(struct FResGetAllProspects& Response);
	void OnGetAllProspectsFailure(struct FResGetAllProspects& Response);
	void OnFactionMissionProgressUpdated(struct FResUpdateFactionMissionProgress& Response);
	void OnExchangeCurrency(struct FResExchangeCurrency& Response);
	void OnDeleteNotificationSuccess(struct FResDeleteNotification& Response);
	void OnDeleteNotificationFailure(struct FResDeleteNotification& Response);
	void OnDeleteDropshipsRequestSuccess(struct FResDeleteDropship& Response);
	void OnDeleteDropshipsRequestFailure(struct FResDeleteDropship& Response);
	void OnCreateDropshipsRequestSuccess(struct FResCreateDropship& Response);
	void OnCreateDropshipsRequestFailure(struct FResCreateDropship& Response);
	void OnClaimProspectSuccess(struct FResClaimProspect& Response);
	void OnClaimProspectFailure(struct FResClaimProspect& Response);
	void OnClaimNotificationAttachmentsSuccess(struct FResClaimNotificationAttachments& Response);
	void OnClaimNotificationAttachmentsFailure(struct FResClaimNotificationAttachments& Response);
	void OnCharacterLoadoutRequest(struct FResGetCharacterLoadout& Response);
	void OnBackToHab(struct FResBackToHab& Response);
	void LoadoutInventoryRequestFailure(struct FResLoadoutInventory& Response);
	TArray<struct FProspectInfo> GetProspects();
	TArray<struct FNotification> GetNotifications();
	TArray<struct FMetaResource> GetMetaResources();
	TArray<struct FMetaItem> GetMetaInventory();
	TArray<struct FMetaItem> GetLoadoutInventory();
	TArray<struct FDropship> GetDropships();
	int32 GetCredits();
	struct FCharacterLoadout GetCharacterLoadout();
	void Client_Request_WorkshopPurchaseWorkshopPack(int32 Index);
	void Client_Request_WorkshopPacks();
	void Client_Request_UpdateTrackedStats();
	void Client_Request_UpdateFactionMissionProgress(struct FFactionMissionsRowHandle& Mission, int32 Progress);
	void Client_Request_UpdateCharacterProspectLocation(enum class EProspectLocation Location);
	void Client_Request_UpdateCharacterProgress();
	void Client_Request_UnpackageLoadout();
	void Client_Request_UnlockWorkshopItem(struct FTalentsRowHandle& TalentsRowHandle);
	void Client_Request_TalentRefund(struct FTalentsRowHandle& Talent, int32 CharacterSlot);
	void Client_Request_SyncCharacterTalents();
	void Client_Request_SyncAccountTalents();
	void Client_Request_SyncAccountFlags();
	void Client_Request_ShiftInventoryItem(class UInventory* SourceInventory, class UInventory* DestinationInventory, int32 SourceSlot, int32 DestinationSlot, int32 Amount);
	void Client_Request_SettleProspect(const class FString& ProspectID, bool SettleProspect);
	void Client_Request_ReplicateWorkshopItem(struct FTalentsRowHandle& TalentsRowHandle);
	void Client_Request_RepairWorkshopItem(const class FString& ItemId);
	void Client_Request_RemovePreparedEnvirosuit();
	void Client_Request_RemovePreparedDropship();
	void Client_Request_RemoveMetaItem(class UInventory* SourceInventory, int32 SourceSlot, int32 Amount);
	void Client_Request_ReadNotification(const class FString& NotificationID);
	void Client_Request_PrepareEnvirosuit(class UInventory* Inventory, int32 Slot);
	void Client_Request_PrepareDropship(int32 Index);
	void Client_Request_PreparedLoadout();
	void Client_Request_PackageLoadout_WithCharacter(struct FOnlineProfileCharacter& OnlineProfileCharacter);
	void Client_Request_ModifyDropship(int32 Index, struct FDropshipModification& Dropship);
	void Client_Request_MetaResources();
	void Client_Request_MetaInventory();
	void Client_Request_LoadoutInventory();
	void Client_Request_LeaveProspectByDropship();
	void Client_Request_GetUserProfile();
	void Client_Request_GetNotifications(bool RequestCompleteList);
	void Client_Request_GetCharacterProfile(int32 CharSlot);
	void Client_Request_ExchangeCurrency(const struct FCurrencyConversionsRowHandle& Conversion, int32 Iterations);
	void Client_Request_Dropships();
	void Client_Request_DeleteNotification(const class FString& NotificationID);
	void Client_Request_DeleteDropship(int32 Index);
	void Client_Request_Credits();
	void Client_Request_CreateDropship();
	void Client_Request_ClaimProspect(struct FProspectInfo& ProspectInfo);
	void Client_Request_ClaimNotificationAttachements(const class FString& NotificationID);
	void Client_Request_CharacterLoadout();
	void Client_Request_AvailableProspects();
	bool CanPerformCurrencyConversion(const struct FCurrencyConversionsRowHandle& Conversion, int32 Iterations);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BagPriorityLibrary
class UBagPriorityLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBagPriorityLibrary* GetDefaultObj();

	struct FBagPriorityRowHandle StructToRowHandle(const struct FBagPriorityEnum& EnumValue);
	class FName StructToName(const struct FBagPriorityEnum& EnumValue);
	int32 StructToInt(const struct FBagPriorityEnum& EnumValue);
	struct FBagPriorityEnum RowHandleToStruct(const struct FBagPriorityRowHandle& RowHandle);
	void RemoveRowFromBagPriorityTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBagPriorityEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBagPriorityEnum& A, const struct FBagPriorityEnum& B);
	struct FBagPriorityEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBagPriorityRowHandle MakeLiteralBagPriority(const struct FBagPriorityRowHandle& RowHandle);
	struct FBagPriorityRowHandle MakeBagPriorityFromIndex(int32 Index);
	struct FBagPriorityEnum MakeBagPriorityEnum(const struct FBagPriorityEnum& Enum);
	struct FBagPriorityRowHandle MakeBagPriority(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBagPriorityEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBagPriorityStruct(const struct FBagPriorityRowHandle& RowHandle, struct FBagPriorityData* BagPriority, enum class EValid* Paths);
	bool EqualEqual_FBagPriorityRowHandleFBagPriorityRowHandle(const struct FBagPriorityRowHandle& RowHandleA, const struct FBagPriorityRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBagPriorityEnum& A, const struct FBagPriorityEnum& B);
	struct FBagPriorityRowHandle CastToBagPriorityRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBagPriorityEnum(const struct FBagPriorityEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBagPriorityTable(class FName Name, const struct FBagPriorityData& Data, struct FBagPriorityRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BagPriorityTable
class UBagPriorityTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBagPriorityTable* GetDefaultObj();

};

// 0x328 (0x3F8 - 0xD0)
// Class Icarus.BallisticComponent
class UBallisticComponent : public UTraitComponent
{
public:
	FMulticastSparseDelegateProperty_            OnFireProjectile;                                  // 0xD0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                         bHasBeenFired;                                     // 0xD1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6F12[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusProjectileComponent*            ProjectileMovementComponent;                       // 0xD8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                      CollisionComponent;                                // 0xE0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnProjectileHit;                                   // 0xE8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                         bIsProjectileActive;                               // 0xE9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6F13[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBallisticData                        CachedBallisticData;                               // 0xF0(0x1E0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class AActor*                                FiringActor;                                       // 0x2D0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_6F14[0x120];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBallisticComponent* GetDefaultObj();

	void SetProjectileActive(bool Active);
	void ProjectileHit(struct FHitResult& Hit);
	void ProjectileBounce(struct FHitResult& Hit, struct FVector& ImpactVelocity);
	void OnRep_bIsProjectileActive();
	void OnProjectileDeactivated();
	void OnProjectileActivated();
	struct FStatContainer GetDamageStatContainer();
	int32 GetDamageStat(const struct FStatsEnum& InStat);
	bool GetBallisticData(struct FBallisticData* OutData);
	void FireProjectile_Internal(struct FVector& Impulse, struct FVector& InstigatorVelocity, struct FProjectileFireParams& AdvancedParameters, class AActor* FiredBy);
	void FireProjectile(struct FVector& Impulse, struct FVector& InstigatorVelocity, struct FProjectileFireParams& AdvancedParameters, class AActor* Instigator);
	bool CleanupBallistic();
	void CheckWithinCullDistance();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BallisticLibrary
class UBallisticLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBallisticLibrary* GetDefaultObj();

	struct FBallisticRowHandle StructToRowHandle(const struct FBallisticEnum& EnumValue);
	class FName StructToName(const struct FBallisticEnum& EnumValue);
	int32 StructToInt(const struct FBallisticEnum& EnumValue);
	struct FBallisticEnum RowHandleToStruct(const struct FBallisticRowHandle& RowHandle);
	void RemoveRowFromBallisticTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBallisticEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBallisticEnum& A, const struct FBallisticEnum& B);
	struct FBallisticEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBallisticRowHandle MakeLiteralBallistic(const struct FBallisticRowHandle& RowHandle);
	struct FBallisticRowHandle MakeBallisticFromIndex(int32 Index);
	struct FBallisticEnum MakeBallisticEnum(const struct FBallisticEnum& Enum);
	struct FBallisticRowHandle MakeBallistic(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBallisticEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBallisticStruct(const struct FBallisticRowHandle& RowHandle, struct FBallisticData* Ballistic, enum class EValid* Paths);
	bool EqualEqual_FBallisticRowHandleFBallisticRowHandle(const struct FBallisticRowHandle& RowHandleA, const struct FBallisticRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBallisticEnum& A, const struct FBallisticEnum& B);
	struct FBallisticRowHandle CastToBallisticRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBallisticEnum(const struct FBallisticEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBallisticTable(class FName Name, const struct FBallisticData& Data, struct FBallisticRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x50 (0x100 - 0xB0)
// Class Icarus.BallisticPoolManager
class UBallisticPoolManager : public UActorComponent
{
public:
	uint8                                        Pad_6F30[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBallisticPoolManager* GetDefaultObj();

	class AIcarusItem* RequestProjectile(struct FItemData& ProjectileData, struct FTransform& SpawnTransform, class AActor* Owner);
	void DestroyProjectile(class AIcarusItem* InProjectile, bool bSkipPoolRemoval);
	bool DeactivateProjectile(class AIcarusItem* InProjectile);
};

// 0x50 (0x80 - 0x30)
// Class Icarus.BallisticSubsystem
class UBallisticSubsystem : public UWorldSubsystem
{
public:
	TMap<class AIcarusPlayerCharacter*, struct FFiredProjectileInfo> PreviouslyFiredProjectiles;                        // 0x30(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBallisticSubsystem* GetDefaultObj();

	void RecordFiredProjectileInfo(class AIcarusPlayerCharacter* PlayerInstigator, class AIcarusItem* FiredProjectile);
	bool GetLastFiredProjectileInfo(class AIcarusPlayerCharacter* Player, struct FFiredProjectileInfo* ProjectileInfo);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BallisticTable
class UBallisticTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBallisticTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatsLibrary
class UStatsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatsLibrary* GetDefaultObj();

	struct FStatsRowHandle StructToRowHandle(const struct FStatsEnum& EnumValue);
	class FName StructToName(const struct FStatsEnum& EnumValue);
	int32 StructToInt(const struct FStatsEnum& EnumValue);
	struct FStatsEnum RowHandleToStruct(const struct FStatsRowHandle& RowHandle);
	void RemoveRowFromStatsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStatsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStatsEnum& A, const struct FStatsEnum& B);
	struct FStatsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStatsRowHandle MakeStatsFromIndex(int32 Index);
	struct FStatsEnum MakeStatsEnum(const struct FStatsEnum& Enum);
	struct FStatsRowHandle MakeStats(class FName RowName);
	struct FStatsRowHandle MakeLiteralStats(const struct FStatsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStatsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStatsStruct(const struct FStatsRowHandle& RowHandle, struct FIcarusStatDescription* Stats, enum class EValid* Paths);
	bool EqualEqual_FStatsRowHandleFStatsRowHandle(const struct FStatsRowHandle& RowHandleA, const struct FStatsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStatsEnum& A, const struct FStatsEnum& B);
	struct FStatsRowHandle CastToStatsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStatsEnum(const struct FStatsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStatsTable(class FName Name, const struct FIcarusStatDescription& Data, struct FStatsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BaseStatsLibrary
class UBaseStatsLibrary : public UStatsLibrary
{
public:

	static class UClass* StaticClass();
	static class UBaseStatsLibrary* GetDefaultObj();

	struct FBaseStatsEnum MakeBaseStatsEnum(const struct FBaseStatsEnum& Enum);
	bool Filter(int32 Index);
	void BreakBaseStatsEnum(const struct FBaseStatsEnum& Enum, class FName* Name, int32* Index);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BedRecorderInterface
class IBedRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IBedRecorderInterface* GetDefaultObj();

	void SetPlayerUIDArray(TArray<class FString>& PlayerUIDArray);
	TArray<class FString> GetPlayerUIDArray();
};

// 0x90 (0x238 - 0x1A8)
// Class Icarus.ItemStateRecorderComponent
class UItemStateRecorderComponent : public UActorStateRecorderComponent
{
public:
	class FName                                  StaticItemDataRowName;                             // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                DatabaseGUID;                                      // 0x1B0(0x10)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        ItemOwnerLookupId;                                 // 0x1C0(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_6F5E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FItemRecordDynamicData>        DynamicData;                                       // 0x1C8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemRecordStatData>           Stats;                                             // 0x1D8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemRecordAlterationData>     Alterations;                                       // 0x1E8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLivingItemSlotSaveData>       LivingItemSlots;                                   // 0x1F8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	enum class EIcarusItemContext                SpawnedContext;                                    // 0x208(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_6F5F[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FIcarusItemConstructionParameters     ConstructionParameters;                            // 0x210(0x28)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UItemStateRecorderComponent* GetDefaultObj();

};

// 0x20 (0x258 - 0x238)
// Class Icarus.DeployableRecorderComponent
class UDeployableRecorderComponent : public UItemStateRecorderComponent
{
public:
	struct FDeployableRecord                     DeployableRecord;                                  // 0x238(0x20)(SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UDeployableRecorderComponent* GetDefaultObj();

};

// 0x18 (0x270 - 0x258)
// Class Icarus.BedRecorderComponent
class UBedRecorderComponent : public UDeployableRecorderComponent
{
public:
	TArray<class FString>                        PlayerUIDArrayRecord;                              // 0x258(0x10)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	uint8                                        Pad_6F62[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBedRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BestiaryDataLibrary
class UBestiaryDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBestiaryDataLibrary* GetDefaultObj();

	struct FBestiaryDataRowHandle StructToRowHandle(const struct FBestiaryDataEnum& EnumValue);
	class FName StructToName(const struct FBestiaryDataEnum& EnumValue);
	int32 StructToInt(const struct FBestiaryDataEnum& EnumValue);
	struct FBestiaryDataEnum RowHandleToStruct(const struct FBestiaryDataRowHandle& RowHandle);
	void RemoveRowFromBestiaryDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBestiaryDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBestiaryDataEnum& A, const struct FBestiaryDataEnum& B);
	struct FBestiaryDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBestiaryDataRowHandle MakeLiteralBestiaryData(const struct FBestiaryDataRowHandle& RowHandle);
	struct FBestiaryDataRowHandle MakeBestiaryDataFromIndex(int32 Index);
	struct FBestiaryDataEnum MakeBestiaryDataEnum(const struct FBestiaryDataEnum& Enum);
	struct FBestiaryDataRowHandle MakeBestiaryData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBestiaryDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBestiaryDataStruct(const struct FBestiaryDataRowHandle& RowHandle, struct FBestiaryData* BestiaryData, enum class EValid* Paths);
	bool EqualEqual_FBestiaryDataRowHandleFBestiaryDataRowHandle(const struct FBestiaryDataRowHandle& RowHandleA, const struct FBestiaryDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBestiaryDataEnum& A, const struct FBestiaryDataEnum& B);
	struct FBestiaryDataRowHandle CastToBestiaryDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBestiaryDataEnum(const struct FBestiaryDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBestiaryDataTable(class FName Name, const struct FBestiaryData& Data, struct FBestiaryDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BestiaryDataTable
class UBestiaryDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBestiaryDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BestiaryFunctionLibrary
class UBestiaryFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UBestiaryFunctionLibrary* GetDefaultObj();

	class UBestiaryManagerComponent* GetLocalBestiaryManagerComponent(class UObject* WorldContext);
	TMap<enum class EFishType, struct FFishCategory> GetFishingCategories(class UObject* WorldContext);
	TMap<struct FTerrainsRowHandle, struct FBestiaryCategory> GetBestiaryCategories(class UObject* WorldContext);
	TArray<struct FFishDataRowHandle> GetAllFishOrderedForBestiary(class UObject* WorldContext);
	TArray<struct FBestiaryDataRowHandle> GetAllBeastsOrderedForBestiary(class UObject* WorldContext);
};

// 0x380 (0x430 - 0xB0)
// Class Icarus.BestiaryManagerComponent
class UBestiaryManagerComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_            OnReceivedPlayerBestiary;                          // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBestiaryFastArray                    BeastEntries;                                      // 0xC0(0x158)(Edit, BlueprintVisible, Net, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FFishDataFastArray                    FishEntries;                                       // 0x218(0x158)(Edit, BlueprintVisible, Net, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_6F9F[0xA8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AutoSaveRate;                                      // 0x418(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_6FA0[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBestiaryManagerComponent* GetDefaultObj();

	void Server_ReceiveBestiaryData(TArray<struct FBestiaryFastArrayItem>& ClientBestiaryData, TArray<struct FFishDataFastArrayItem>& ClientFishData);
	void PerformAutoSave();
	void OnFishEntryRemoved(struct FFishDataFastArrayItem& Entry);
	void OnFishEntryChanged(struct FFishDataFastArrayItem& Entry);
	void OnFishEntryAdded(struct FFishDataFastArrayItem& Entry);
	void OnBeastEntryRemoved(struct FBestiaryFastArrayItem& Entry);
	void OnBeastEntryChanged(struct FBestiaryFastArrayItem& Entry);
	void OnBeastEntryAdded(struct FBestiaryFastArrayItem& Entry);
	void OnAllFishEntriesChanged();
	void OnAllBeastEntriesChanged();
	bool IsFishEntryUnlocked(struct FFishDataRowHandle& Fish);
	bool IsBeastEntryUnlocked(struct FBestiaryDataRowHandle& Entry);
	void IncrementBeastProgress(struct FBestiaryDataRowHandle& Entry, struct FBestiaryPointsRowHandle& Points);
	bool HasLoadedData();
	struct FFishTypeTracking GetFishDetails(struct FFishDataRowHandle& Fish);
	int32 GetBeastUnlockPercent(struct FBestiaryDataRowHandle& Entry);
	void ForceSave();
	void Client_RequestBestiaryData();
	void Cheat_SetFishCaught(struct FFishDataRowHandle& FishRow, int32 NumCaught);
	void Cheat_SetBeastPoints(struct FBestiaryDataRowHandle& Entry, int32 TotalPoints);
	void AddFishDetails(struct FFishTypeTracking& Fish);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BestiaryPointsLibrary
class UBestiaryPointsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBestiaryPointsLibrary* GetDefaultObj();

	struct FBestiaryPointsRowHandle StructToRowHandle(const struct FBestiaryPointsEnum& EnumValue);
	class FName StructToName(const struct FBestiaryPointsEnum& EnumValue);
	int32 StructToInt(const struct FBestiaryPointsEnum& EnumValue);
	struct FBestiaryPointsEnum RowHandleToStruct(const struct FBestiaryPointsRowHandle& RowHandle);
	void RemoveRowFromBestiaryPointsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBestiaryPointsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBestiaryPointsEnum& A, const struct FBestiaryPointsEnum& B);
	struct FBestiaryPointsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBestiaryPointsRowHandle MakeLiteralBestiaryPoints(const struct FBestiaryPointsRowHandle& RowHandle);
	struct FBestiaryPointsRowHandle MakeBestiaryPointsFromIndex(int32 Index);
	struct FBestiaryPointsEnum MakeBestiaryPointsEnum(const struct FBestiaryPointsEnum& Enum);
	struct FBestiaryPointsRowHandle MakeBestiaryPoints(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBestiaryPointsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBestiaryPointsStruct(const struct FBestiaryPointsRowHandle& RowHandle, struct FBestiaryPoints* BestiaryPoints, enum class EValid* Paths);
	bool EqualEqual_FBestiaryPointsRowHandleFBestiaryPointsRowHandle(const struct FBestiaryPointsRowHandle& RowHandleA, const struct FBestiaryPointsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBestiaryPointsEnum& A, const struct FBestiaryPointsEnum& B);
	struct FBestiaryPointsRowHandle CastToBestiaryPointsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBestiaryPointsEnum(const struct FBestiaryPointsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBestiaryPointsTable(class FName Name, const struct FBestiaryPoints& Data, struct FBestiaryPointsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BestiaryPointsTable
class UBestiaryPointsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBestiaryPointsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BestiaryTraitsLibrary
class UBestiaryTraitsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBestiaryTraitsLibrary* GetDefaultObj();

	struct FBestiaryTraitsRowHandle StructToRowHandle(const struct FBestiaryTraitsEnum& EnumValue);
	class FName StructToName(const struct FBestiaryTraitsEnum& EnumValue);
	int32 StructToInt(const struct FBestiaryTraitsEnum& EnumValue);
	struct FBestiaryTraitsEnum RowHandleToStruct(const struct FBestiaryTraitsRowHandle& RowHandle);
	void RemoveRowFromBestiaryTraitsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBestiaryTraitsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBestiaryTraitsEnum& A, const struct FBestiaryTraitsEnum& B);
	struct FBestiaryTraitsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBestiaryTraitsRowHandle MakeLiteralBestiaryTraits(const struct FBestiaryTraitsRowHandle& RowHandle);
	struct FBestiaryTraitsRowHandle MakeBestiaryTraitsFromIndex(int32 Index);
	struct FBestiaryTraitsEnum MakeBestiaryTraitsEnum(const struct FBestiaryTraitsEnum& Enum);
	struct FBestiaryTraitsRowHandle MakeBestiaryTraits(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBestiaryTraitsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBestiaryTraitsStruct(const struct FBestiaryTraitsRowHandle& RowHandle, struct FBestiaryTraitData* BestiaryTraits, enum class EValid* Paths);
	bool EqualEqual_FBestiaryTraitsRowHandleFBestiaryTraitsRowHandle(const struct FBestiaryTraitsRowHandle& RowHandleA, const struct FBestiaryTraitsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBestiaryTraitsEnum& A, const struct FBestiaryTraitsEnum& B);
	struct FBestiaryTraitsRowHandle CastToBestiaryTraitsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBestiaryTraitsEnum(const struct FBestiaryTraitsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBestiaryTraitsTable(class FName Name, const struct FBestiaryTraitData& Data, struct FBestiaryTraitsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BestiaryTraitsTable
class UBestiaryTraitsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBestiaryTraitsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BestiaryTraitTypesLibrary
class UBestiaryTraitTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBestiaryTraitTypesLibrary* GetDefaultObj();

	struct FBestiaryTraitTypesRowHandle StructToRowHandle(const struct FBestiaryTraitTypesEnum& EnumValue);
	class FName StructToName(const struct FBestiaryTraitTypesEnum& EnumValue);
	int32 StructToInt(const struct FBestiaryTraitTypesEnum& EnumValue);
	struct FBestiaryTraitTypesEnum RowHandleToStruct(const struct FBestiaryTraitTypesRowHandle& RowHandle);
	void RemoveRowFromBestiaryTraitTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBestiaryTraitTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBestiaryTraitTypesEnum& A, const struct FBestiaryTraitTypesEnum& B);
	struct FBestiaryTraitTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBestiaryTraitTypesRowHandle MakeLiteralBestiaryTraitTypes(const struct FBestiaryTraitTypesRowHandle& RowHandle);
	struct FBestiaryTraitTypesRowHandle MakeBestiaryTraitTypesFromIndex(int32 Index);
	struct FBestiaryTraitTypesEnum MakeBestiaryTraitTypesEnum(const struct FBestiaryTraitTypesEnum& Enum);
	struct FBestiaryTraitTypesRowHandle MakeBestiaryTraitTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBestiaryTraitTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBestiaryTraitTypesStruct(const struct FBestiaryTraitTypesRowHandle& RowHandle, struct FBestiaryTraitType* BestiaryTraitTypes, enum class EValid* Paths);
	bool EqualEqual_FBestiaryTraitTypesRowHandleFBestiaryTraitTypesRowHandle(const struct FBestiaryTraitTypesRowHandle& RowHandleA, const struct FBestiaryTraitTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBestiaryTraitTypesEnum& A, const struct FBestiaryTraitTypesEnum& B);
	struct FBestiaryTraitTypesRowHandle CastToBestiaryTraitTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBestiaryTraitTypesEnum(const struct FBestiaryTraitTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBestiaryTraitTypesTable(class FName Name, const struct FBestiaryTraitType& Data, struct FBestiaryTraitTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BestiaryTraitTypesTable
class UBestiaryTraitTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBestiaryTraitTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BiomeAudioDataLibrary
class UBiomeAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBiomeAudioDataLibrary* GetDefaultObj();

	struct FBiomeAudioDataRowHandle StructToRowHandle(const struct FBiomeAudioDataEnum& EnumValue);
	class FName StructToName(const struct FBiomeAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FBiomeAudioDataEnum& EnumValue);
	struct FBiomeAudioDataEnum RowHandleToStruct(const struct FBiomeAudioDataRowHandle& RowHandle);
	void RemoveRowFromBiomeAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBiomeAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBiomeAudioDataEnum& A, const struct FBiomeAudioDataEnum& B);
	struct FBiomeAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBiomeAudioDataRowHandle MakeLiteralBiomeAudioData(const struct FBiomeAudioDataRowHandle& RowHandle);
	struct FBiomeAudioDataRowHandle MakeBiomeAudioDataFromIndex(int32 Index);
	struct FBiomeAudioDataEnum MakeBiomeAudioDataEnum(const struct FBiomeAudioDataEnum& Enum);
	struct FBiomeAudioDataRowHandle MakeBiomeAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBiomeAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBiomeAudioDataStruct(const struct FBiomeAudioDataRowHandle& RowHandle, struct FBiomeAudioData* BiomeAudioData, enum class EValid* Paths);
	bool EqualEqual_FBiomeAudioDataRowHandleFBiomeAudioDataRowHandle(const struct FBiomeAudioDataRowHandle& RowHandleA, const struct FBiomeAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBiomeAudioDataEnum& A, const struct FBiomeAudioDataEnum& B);
	struct FBiomeAudioDataRowHandle CastToBiomeAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBiomeAudioDataEnum(const struct FBiomeAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBiomeAudioDataTable(class FName Name, const struct FBiomeAudioData& Data, struct FBiomeAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BiomeAudioDataTable
class UBiomeAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBiomeAudioDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BiomesLibrary
class UBiomesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBiomesLibrary* GetDefaultObj();

	struct FBiomesRowHandle StructToRowHandle(const struct FBiomesEnum& EnumValue);
	class FName StructToName(const struct FBiomesEnum& EnumValue);
	int32 StructToInt(const struct FBiomesEnum& EnumValue);
	struct FBiomesEnum RowHandleToStruct(const struct FBiomesRowHandle& RowHandle);
	void RemoveRowFromBiomesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBiomesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBiomesEnum& A, const struct FBiomesEnum& B);
	struct FBiomesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBiomesRowHandle MakeLiteralBiomes(const struct FBiomesRowHandle& RowHandle);
	struct FBiomesRowHandle MakeBiomesRowFromColor(struct FColor& InColor);
	struct FBiomesRowHandle MakeBiomesFromIndex(int32 Index);
	struct FBiomesEnum MakeBiomesEnum(const struct FBiomesEnum& Enum);
	struct FBiomesRowHandle MakeBiomes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBiomesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBiomesStruct(const struct FBiomesRowHandle& RowHandle, struct FIcarusBiome* Biomes, enum class EValid* Paths);
	bool EqualEqual_FBiomesRowHandleFBiomesRowHandle(const struct FBiomesRowHandle& RowHandleA, const struct FBiomesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBiomesEnum& A, const struct FBiomesEnum& B);
	struct FBiomesRowHandle CastToBiomesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBiomesEnum(const struct FBiomesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBiomesTable(class FName Name, const struct FIcarusBiome& Data, struct FBiomesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BiomesTable
class UBiomesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBiomesTable* GetDefaultObj();

};

// 0x28 (0x1D0 - 0x1A8)
// Class Icarus.BlockerSpawnerRecorderComponent
class UBlockerSpawnerRecorderComponent : public UActorStateRecorderComponent
{
public:
	bool                                         bHasSpawned;                                       // 0x1A8(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7009[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPersistentBlockerRecord              PersistentBlockerRecord;                           // 0x1B0(0x20)(SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBlockerSpawnerRecorderComponent* GetDefaultObj();

};

// 0x48 (0xF8 - 0xB0)
// Class Icarus.TalentControllerComponent
class UTalentControllerComponent : public UActorComponent
{
public:
	uint8                                        Pad_700B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnModelViewChangedEvent;                           // 0xB8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTalentModelInterface*                 Model;                                             // 0xC8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTalentViewInterface*                  View;                                              // 0xD0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_700C[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTalentControllerComponent* GetDefaultObj();

	void TriggerModelStateRefresh();
	void Setup();
	void OnSessionFlagsUpdated();
	void OnModelViewChanged(class UTalentModelInterface* InModel, class UTalentViewInterface* InView);
	void OnLevelUp();
	void OnCharacterFlagsUpdated();
	void OnAccountFlagsUpdated();
	void NativeModelStateChanged(class UTalentModelInterface_Const* InModel);
	void BP_ForceRefresh();
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.BlueprintTalentControllerComponent
class UBlueprintTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class UBlueprintTalentControllerComponent* GetDefaultObj();

};

// 0xC0 (0xE8 - 0x28)
// Class Icarus.TalentModelInterface_Const
class UTalentModelInterface_Const : public UObject
{
public:
	FMulticastInlineDelegateProperty_            OnModelStateChanged;                               // 0x28(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnModelTalentStateChanged;                         // 0x38(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_701B[0xA0];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTalentModelInterface_Const* GetDefaultObj();

	void OnModelViewChanged(class UTalentModelInterface* InModel, class UTalentViewInterface* InView);
	bool IsTalentUnlocked(struct FTalentsRowHandle& Talent);
	int32 GetTotalTalentsForTree(struct FTalentTreesRowHandle& TalentTree);
	int32 GetTotalPoints();
	int32 GetTotalNonRestrictedTalentsForTree(struct FTalentTreesRowHandle& TalentTree);
	TArray<struct FTalentTreesRowHandle> GetTalentTreesForArchetype(const struct FTalentArchetypesRowHandle& Archetype);
	TArray<struct FTalentTreesRowHandle> GetTalentTrees();
	bool GetTalentState(struct FTalentsRowHandle& Talent, struct FTalentModelData* OutData);
	TArray<struct FTalentsRowHandle> GetTalents();
	int32 GetTalentRank(struct FTalentsRowHandle& Talent);
	int32 GetSpentPointsForTree(struct FTalentTreesRowHandle& TalentTree);
	int32 GetSpentPoints();
	int32 GetPointsForLevel(int32 InLevel);
	int32 GetNonRestrictedSpentPointsForTree(struct FTalentTreesRowHandle& TalentTree);
	struct FTalentModelsRowHandle GetModelRowHandle();
	struct FTalentModelsRowHandle GetModelData();
	int32 GetLevel();
	TScriptInterface<class ITalentControllerInterface> GetController();
	int32 GetAvailablePoints();
	TArray<struct FTalentArchetypesRowHandle> GetArchetypes();
	bool DoesModelContainTalent(struct FTalentsRowHandle& Talent);
	bool CanUnlockTalent(struct FTalentsRowHandle& Talent, int32 Rank, bool bIgnoreLockedState);
};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.TalentModelInterface
class UTalentModelInterface : public UTalentModelInterface_Const
{
public:

	static class UClass* StaticClass();
	static class UTalentModelInterface* GetDefaultObj();

	void SetLevel(int32 InLevel);
	void SetController(TScriptInterface<class ITalentControllerInterface>& InController);
	void ResetTalents();
};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.BlueprintTalentModel
class UBlueprintTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class UBlueprintTalentModel* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BlueprintUnlocksLibrary
class UBlueprintUnlocksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBlueprintUnlocksLibrary* GetDefaultObj();

	struct FBlueprintUnlocksRowHandle StructToRowHandle(const struct FBlueprintUnlocksEnum& EnumValue);
	class FName StructToName(const struct FBlueprintUnlocksEnum& EnumValue);
	int32 StructToInt(const struct FBlueprintUnlocksEnum& EnumValue);
	struct FBlueprintUnlocksEnum RowHandleToStruct(const struct FBlueprintUnlocksRowHandle& RowHandle);
	void RemoveRowFromBlueprintUnlocksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBlueprintUnlocksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBlueprintUnlocksEnum& A, const struct FBlueprintUnlocksEnum& B);
	struct FBlueprintUnlocksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBlueprintUnlocksRowHandle MakeLiteralBlueprintUnlocks(const struct FBlueprintUnlocksRowHandle& RowHandle);
	struct FBlueprintUnlocksRowHandle MakeBlueprintUnlocksFromIndex(int32 Index);
	struct FBlueprintUnlocksEnum MakeBlueprintUnlocksEnum(const struct FBlueprintUnlocksEnum& Enum);
	struct FBlueprintUnlocksRowHandle MakeBlueprintUnlocks(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBlueprintUnlocksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBlueprintUnlocksStruct(const struct FBlueprintUnlocksRowHandle& RowHandle, struct FBlueprintUnlock* BlueprintUnlocks, enum class EValid* Paths);
	bool EqualEqual_FBlueprintUnlocksRowHandleFBlueprintUnlocksRowHandle(const struct FBlueprintUnlocksRowHandle& RowHandleA, const struct FBlueprintUnlocksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBlueprintUnlocksEnum& A, const struct FBlueprintUnlocksEnum& B);
	struct FBlueprintUnlocksRowHandle CastToBlueprintUnlocksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBlueprintUnlocksEnum(const struct FBlueprintUnlocksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBlueprintUnlocksTable(class FName Name, const struct FBlueprintUnlock& Data, struct FBlueprintUnlocksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BlueprintUnlocksTable
class UBlueprintUnlocksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBlueprintUnlocksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BreakableRockDataLibrary
class UBreakableRockDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBreakableRockDataLibrary* GetDefaultObj();

	struct FBreakableRockDataRowHandle StructToRowHandle(const struct FBreakableRockDataEnum& EnumValue);
	class FName StructToName(const struct FBreakableRockDataEnum& EnumValue);
	int32 StructToInt(const struct FBreakableRockDataEnum& EnumValue);
	struct FBreakableRockDataEnum RowHandleToStruct(const struct FBreakableRockDataRowHandle& RowHandle);
	void RemoveRowFromBreakableRockDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBreakableRockDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBreakableRockDataEnum& A, const struct FBreakableRockDataEnum& B);
	struct FBreakableRockDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBreakableRockDataRowHandle MakeLiteralBreakableRockData(const struct FBreakableRockDataRowHandle& RowHandle);
	struct FBreakableRockDataRowHandle MakeBreakableRockDataFromIndex(int32 Index);
	struct FBreakableRockDataEnum MakeBreakableRockDataEnum(const struct FBreakableRockDataEnum& Enum);
	struct FBreakableRockDataRowHandle MakeBreakableRockData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBreakableRockDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBreakableRockDataStruct(const struct FBreakableRockDataRowHandle& RowHandle, struct FBreakableRockData* BreakableRockData, enum class EValid* Paths);
	bool EqualEqual_FBreakableRockDataRowHandleFBreakableRockDataRowHandle(const struct FBreakableRockDataRowHandle& RowHandleA, const struct FBreakableRockDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBreakableRockDataEnum& A, const struct FBreakableRockDataEnum& B);
	struct FBreakableRockDataRowHandle CastToBreakableRockDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBreakableRockDataEnum(const struct FBreakableRockDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBreakableRockDataTable(class FName Name, const struct FBreakableRockData& Data, struct FBreakableRockDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BreakableRockDataTable
class UBreakableRockDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBreakableRockDataTable* GetDefaultObj();

};

// 0x20 (0xB0 - 0x90)
// Class Icarus.BTComposite_SelectPseudoRandom
class UBTComposite_SelectPseudoRandom : public UBTCompositeNode
{
public:
	bool                                         bAlreadyRan;                                       // 0x90(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7060[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<int32>                                PossibleChildren;                                  // 0x98(0x10)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                        LastChild;                                         // 0xA8(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7061[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTComposite_SelectPseudoRandom* GetDefaultObj();

};

// 0x8 (0x98 - 0x90)
// Class Icarus.BTComposite_SelectRandom
class UBTComposite_SelectRandom : public UBTCompositeNode
{
public:
	bool                                         bAlreadyRan;                                       // 0x90(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7062[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTComposite_SelectRandom* GetDefaultObj();

};

// 0x10 (0xA0 - 0x90)
// Class Icarus.BTComposite_SequenceLoop
class UBTComposite_SequenceLoop : public UBTComposite_Sequence
{
public:
	int32                                        LoopCount;                                         // 0x90(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        LoopDeviation;                                     // 0x94(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CurrentLoopCount;                                  // 0x98(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ActiveLoopCount;                                   // 0x9C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBTComposite_SequenceLoop* GetDefaultObj();

};

// 0x18 (0xB8 - 0xA0)
// Class Icarus.BTComposite_SequenceLoop_Scaled
class UBTComposite_SequenceLoop_Scaled : public UBTComposite_SequenceLoop
{
public:
	struct FScalingRulesEnum                     LoopCountScalingRule;                              // 0xA0(0x10)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                OwningPawnReference;                               // 0xB0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UBTComposite_SequenceLoop_Scaled* GetDefaultObj();

};

// 0x28 (0x90 - 0x68)
// Class Icarus.BTD_CustomTagCooldown
class UBTD_CustomTagCooldown : public UBTDecorator
{
public:
	struct FGameplayTag                          CooldownTag;                                       // 0x68(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatsEnum                            ActionsPerMinuteStat;                              // 0x70(0x10)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultCooldownDuration;                           // 0x80(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAddToExistingDuration;                            // 0x84(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bActivatesCooldown;                                // 0x85(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7065[0xA];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTD_CustomTagCooldown* GetDefaultObj();

};

// 0x8 (0x70 - 0x68)
// Class Icarus.BTD_DoOnce
class UBTD_DoOnce : public UBTDecorator
{
public:
	bool                                         MustSucceed;                                       // 0x68(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SucceedOnSubsequentCalls;                          // 0x69(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7066[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTD_DoOnce* GetDefaultObj();

};

// 0x18 (0x80 - 0x68)
// Class Icarus.BTD_HasPerceivedTarget
class UBTD_HasPerceivedTarget : public UBTDecorator
{
public:
	TSubclassOf<class UAISense>                  SenseToUse;                                        // 0x68(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bOnlyCountAliveTargets;                            // 0x70(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFilterByRelationshipType;                         // 0x71(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ERelationshipType                 RelationshipType;                                  // 0x72(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7067[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AAIController*                         OwnerAIController;                                 // 0x78(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UBTD_HasPerceivedTarget* GetDefaultObj();

};

// 0x48 (0xE0 - 0x98)
// Class Icarus.BTT_ExecuteFunction
class UBTT_ExecuteFunction : public UBTTask_BlackboardBase
{
public:
	struct FFunctionContext                      FunctionContext;                                   // 0x98(0x18)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                Target;                                            // 0xB0(0x28)(Edit, NativeAccessSpecifierPublic)
	bool                                         bReturnSuccessIfInvalid;                           // 0xD8(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7068[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTT_ExecuteFunction* GetDefaultObj();

};

// 0x30 (0xE8 - 0xB8)
// Class Icarus.BTTask_IcarusMoveDirectlyToward
class UBTTask_IcarusMoveDirectlyToward : public UBTTask_MoveDirectlyToward
{
public:
	bool                                         bUseBlackboardDefinedAcceptanceRadius;             // 0xB8(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIgnoreInvalidRadiusValues;                        // 0xB9(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7069[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBlackboardKeySelector                AcceptableRadiusKey;                               // 0xC0(0x28)(Edit, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UBTTask_IcarusMoveDirectlyToward* GetDefaultObj();

};

// 0x30 (0xE0 - 0xB0)
// Class Icarus.BTTask_IcarusMoveTo
class UBTTask_IcarusMoveTo : public UBTTask_MoveTo
{
public:
	bool                                         bUseBlackboardDefinedAcceptanceRadius;             // 0xB0(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIgnoreInvalidRadiusValues;                        // 0xB1(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_706A[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBlackboardKeySelector                AcceptableRadiusKey;                               // 0xB8(0x28)(Edit, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UBTTask_IcarusMoveTo* GetDefaultObj();

};

// 0x18 (0x88 - 0x70)
// Class Icarus.BTTask_SetTagCooldownWithDeviation
class UBTTask_SetTagCooldownWithDeviation : public UBTTaskNode
{
public:
	struct FGameplayTag                          CooldownTag;                                       // 0x70(0x8)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAddToExistingDuration;                            // 0x78(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_706C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CooldownDuration;                                  // 0x7C(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RandomDeviation;                                   // 0x80(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_706D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBTTask_SetTagCooldownWithDeviation* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildableAudioDataLibrary
class UBuildableAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildableAudioDataLibrary* GetDefaultObj();

	struct FBuildableAudioDataRowHandle StructToRowHandle(const struct FBuildableAudioDataEnum& EnumValue);
	class FName StructToName(const struct FBuildableAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FBuildableAudioDataEnum& EnumValue);
	struct FBuildableAudioDataEnum RowHandleToStruct(const struct FBuildableAudioDataRowHandle& RowHandle);
	void RemoveRowFromBuildableAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildableAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildableAudioDataEnum& A, const struct FBuildableAudioDataEnum& B);
	struct FBuildableAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildableAudioDataRowHandle MakeLiteralBuildableAudioData(const struct FBuildableAudioDataRowHandle& RowHandle);
	struct FBuildableAudioDataRowHandle MakeBuildableAudioDataFromIndex(int32 Index);
	struct FBuildableAudioDataEnum MakeBuildableAudioDataEnum(const struct FBuildableAudioDataEnum& Enum);
	struct FBuildableAudioDataRowHandle MakeBuildableAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildableAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildableAudioDataStruct(const struct FBuildableAudioDataRowHandle& RowHandle, struct FBuildableAudioData* BuildableAudioData, enum class EValid* Paths);
	bool EqualEqual_FBuildableAudioDataRowHandleFBuildableAudioDataRowHandle(const struct FBuildableAudioDataRowHandle& RowHandleA, const struct FBuildableAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildableAudioDataEnum& A, const struct FBuildableAudioDataEnum& B);
	struct FBuildableAudioDataRowHandle CastToBuildableAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildableAudioDataEnum(const struct FBuildableAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildableAudioDataTable(class FName Name, const struct FBuildableAudioData& Data, struct FBuildableAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildableAudioDataTable
class UBuildableAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildableAudioDataTable* GetDefaultObj();

};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.BuildableComponent
class UBuildableComponent : public UTraitComponent
{
public:
	TSubclassOf<class AIcarusActor>              ClassToBuild;                                      // 0xD0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        Variation;                                         // 0xD8(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_708C[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBuildableComponent* GetDefaultObj();

	void SetVariation(int32 NewVariation);
	bool GetBuildableData(struct FBuildableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildableLibrary
class UBuildableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildableLibrary* GetDefaultObj();

	struct FBuildableRowHandle StructToRowHandle(const struct FBuildableEnum& EnumValue);
	class FName StructToName(const struct FBuildableEnum& EnumValue);
	int32 StructToInt(const struct FBuildableEnum& EnumValue);
	struct FBuildableEnum RowHandleToStruct(const struct FBuildableRowHandle& RowHandle);
	void RemoveRowFromBuildableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildableEnum& A, const struct FBuildableEnum& B);
	struct FBuildableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildableRowHandle MakeLiteralBuildable(const struct FBuildableRowHandle& RowHandle);
	struct FBuildableRowHandle MakeBuildableFromIndex(int32 Index);
	struct FBuildableEnum MakeBuildableEnum(const struct FBuildableEnum& Enum);
	struct FBuildableRowHandle MakeBuildable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildableStruct(const struct FBuildableRowHandle& RowHandle, struct FBuildableData* Buildable, enum class EValid* Paths);
	bool EqualEqual_FBuildableRowHandleFBuildableRowHandle(const struct FBuildableRowHandle& RowHandleA, const struct FBuildableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildableEnum& A, const struct FBuildableEnum& B);
	struct FBuildableRowHandle CastToBuildableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildableEnum(const struct FBuildableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildableTable(class FName Name, const struct FBuildableData& Data, struct FBuildableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildableTable
class UBuildableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildableTable* GetDefaultObj();

};

// 0xA0 (0x2C0 - 0x220)
// Class Icarus.IcarusActor
class AIcarusActor : public AActor
{
public:
	uint8                                        Pad_70A8[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusStatContainer*                  StatContainer;                                     // 0x240(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorState*                           ActorState;                                        // 0x248(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EProgressState                    ProgressState;                                     // 0x250(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActorPreDestroy;                                 // 0x251(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_70A9[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnModifierStateUpdated;                            // 0x258(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTerrainAnchorComponent*               TerrainAnchor;                                     // 0x268(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTerrainAnchorComponent>   TerrainAnchorClass;                                // 0x270(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70AA[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x280(0x20)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	uint8                                        Pad_70AB[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UIcarusStateRecorderComponent> RecorderClass;                                     // 0x2A8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSaveModifiersToDatabase;                          // 0x2B0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70AC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusStateRecorderComponent*         Recorder;                                          // 0x2B8(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AIcarusActor* GetDefaultObj();

	void SetRecorderShouldRetainOnDestroy(bool bShouldRetain);
	void SetIcarusUID(int32 ForcedUID);
	void RepairObject();
	void RecorderEndRecording();
	void RecorderBeginRecording();
	void RaiseTheCurtain();
	void OnTerrainAnchorStateChanged();
	void OnDatabaseLoadComplete();
	void IcarusBeginPlay();
	bool HasRecorder();
	int32 GetIcarusUID();
	void DestroyIcarusActorInternal(enum class EIcarusActorDestroyReason Reason);
	void DestroyIcarusActor(enum class EIcarusActorDestroyReason Reason);
	void ClaimUniqueIcarusUIDFromLibrary(int32 SuggestedUID);
};

// 0x2B0 (0x570 - 0x2C0)
// Class Icarus.IcarusItem
class AIcarusItem : public AIcarusActor
{
public:
	class UInventory*                            ItemInventory;                                     // 0x2C0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        ItemInventoryLocation;                             // 0x2C8(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         HasLink;                                           // 0x2CC(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastSparseDelegateProperty_            PickedUp;                                          // 0x2CD(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_70C4[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UTraitComponent*>               TraitComponents;                                   // 0x2D0(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FItemData                             ItemData;                                          // 0x2E0(0x1F0)(BlueprintVisible, Net, RepNotify, ContainsInstancedReference, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FIcarusItemConstructionParameters     ConstructionParameters;                            // 0x4D0(0x28)(Edit, BlueprintVisible, Net, RepNotify, NativeAccessSpecifierPublic)
	enum class EIcarusItemContext                SpawnedContext;                                    // 0x4F8(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70C6[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FItemTemplateRowHandle                OverrideInstanceItemTemplate;                      // 0x4FC(0x18)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70C7[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USmoothSync*                           SmoothSyncComponent;                               // 0x518(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSkipAttachmentReplication;                        // 0x520(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70C8[0xF];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FTransform                            ConstructionTransfrom;                             // 0x530(0x30)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            DynamicDataUpdated;                                // 0x560(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusItem* GetDefaultObj();

	bool WorldPickup(class UItemableComponent* ItemIn, class AActor* Interactor, struct FHitResult& HitResult);
	void StackUpdated();
	void SetItemVisible(bool bVisible);
	bool ServerSetupTraitComponents();
	void ServerSetItemData(struct FItemData& InItemData);
	bool ServerLoadItemData(const struct FItemTemplateRowHandle& ItemTemplate);
	void SerializeItemData(struct FItemData* OutItemData);
	void ResetDecaySpoilTime();
	void ReconstructItem(struct FIcarusItemConstructionParameters& NewConstructionParameters);
	void OverwriteInventoryItemDynamicProperty(enum class EDynamicItemProperties Property, int32 Value);
	void OnWorldPickup(class UItemableComponent* ItemIn, class AActor* Interactor, struct FHitResult& HitResult);
	void OnRep_ItemData();
	void OnRep_ConstructionParameters();
	bool OnPickedUp(class AIcarusItem* Item);
	void OnItemDataChanged();
	void OnDynamicDataUpdated();
	bool OnDropped();
	void ItemContainerDataUpdated();
	bool HasInventoryItemLink();
	struct FItemData GetSerialisedItemData();
	class UMeshComponent* GetRootMeshComponent();
	class AIcarusPlayerCharacter* GetOwningIcarusPlayerCharacter();
	TArray<struct FItemDynamicData> GetMutableItemDynamicData();
	struct FItemData GetItemData();
	void FillableUpdated();
	void EstablishLink(class UInventory* Inventory, int32 Location);
	void DurabilityUpdated();
	void DestroyLinkedInventoryItem();
	void DestroyLink();
	void DeserializeItemData(struct FItemData& InItemData);
	void DecayableDataUpdated();
	void ActionableUpdated();
};

// 0x90 (0x600 - 0x570)
// Class Icarus.BuildingBase
class ABuildingBase : public AIcarusItem
{
public:
	class UIcarusNavigationDirtier*              NavigationDirtier;                                 // 0x570(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnBuildingDestroyed;                               // 0x578(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnBuildingReplaced;                                // 0x588(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                               GridSpaceCenterLocation;                           // 0x598(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               GridLocation;                                      // 0x5A4(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVectorPair>                   BlockingLines;                                     // 0x5B0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bStartsDormant;                                    // 0x5C0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70CC[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UMaterialInterface*>            DefaultMainMeshMaterials;                          // 0x5C8(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bUseDestructibleMaterialMap;                       // 0x5D8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70CD[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<int32>                                DestructibleMaterialSlotsToMainMesh;               // 0x5E0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_70CE[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ABuildingBase* GetDefaultObj();

	void StartDestruction(class AIcarusPlayerController* TriggeringPlayer, enum class EBuildingDestroyReason DestroyReason);
	void NotifyBuildingReplaced(class ABuildingBase* NewBuilding);
	void NotifyBuildingDestroyed(enum class EBuildingDestroyReason Reason);
	void MarkDirty();
	int32 ManhattanDistanceToBuilding(class ABuildingBase* OtherBuilding);
	bool IsReceivingWindDamage();
	bool IsBuildingOutside();
	bool IsBuildingDestroyed();
	bool HasCachedData();
	class UDestructibleComponent* GetStrippedDestructibleMesh();
	class UStaticMeshComponent* GetStrippedBuildingMesh();
	enum class EBuildingPieceType GetPieceType();
	class ABuildingGridBase* GetParentGrid();
	class UStaticMeshComponent* GetMainBuildingMesh();
	class UDestructibleComponent* GetDestructibleBuildingMesh();
	class USceneComponent* GetCenterComponent();
	float GetBuildingTier();
	class UDestructibleComponent* CreateDestructibleMeshComponent();
	void CalculateStabilityState();
	void ApplyBuildingSkinMaterialOverrides();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingFunctionLibrary
class UBuildingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingFunctionLibrary* GetDefaultObj();

	struct FVector RoundVector(const struct FVector& Input);
	TMap<int32, TSoftObjectPtr<class UMaterialInterface>> GetMaterialOverridesForBuildingVariation(struct FBuildableData& BuildableData, int32 Variation, enum class EBuildingMeshType InMeshType, bool* bHasOverrideMaterials);
	TMap<int32, TSoftObjectPtr<class UMaterialInterface>> GetMaterialOverridesForBuilding(class ABuildingBase* Building, enum class EBuildingMeshType InMeshType, bool* bHasOverrideMaterials);
	int32 GetBuildingVariation(class ABuildingBase* Building);
	struct FBuildingPiecesRowHandle GetBuildingUpgrade(class ABuildingBase* Building, const struct FBuildingTypesEnum& Type);
	TArray<struct FVectorPair> AddReverseLinesToVectorPairArray(TArray<struct FVectorPair>& VectorPairs);
};

// 0x190 (0x450 - 0x2C0)
// Class Icarus.BuildingGridBase
class ABuildingGridBase : public AIcarusActor
{
public:
	int32                                        BuildingCount;                                     // 0x2C0(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_70E2[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class ABuildingBase*>                 BuildingsSelectedForWindDamage;                    // 0x2C8(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_70E3[0xF8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FVector, struct FGridPoint>      GridPoints;                                        // 0x3D0(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class ABuildingBase*>                 BuildingsRequiringNavUpdate;                       // 0x420(0x10)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_70E4[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ABuildingGridBase* GetDefaultObj();

	bool TryAddNewBuildingFromWorldSpace(const struct FTransform& WorldSpaceTransform, TSubclassOf<class ABuildingBase> DesiredClass, bool bAlternateRotation, const struct FItemData& Item, class ABuildingBase** Building);
	void StartDirtyingBuildingNavigation();
	void SetQueued(bool bQueued);
	void SetAutomaticResumingDestructionEnabled(bool bEnabled);
	struct FSerializedGrid SerializeForSaveGame(class AActor* Origin);
	void RemoveBuildingFromStabilityUpdateQueue(class ABuildingBase* BuildingPiece);
	void QueueStabilityUpdate(class ABuildingBase* BuildingPiece);
	void OnBuildingPieceRemoved(class ABuildingBase* BuildingPiece);
	void OnBuildingPieceAdded(class ABuildingBase* BuildingPiece);
	void LoadGridAndBuildingsFromRecord(class UBuildingGridRecorderComponent* RecorderComponent);
	bool GetIsQueued();
	void GetGridBuildingDataForRecord(class UBuildingGridRecorderComponent* RecorderComponent);
	void GetAllTouchingBuildings(TSubclassOf<class ABuildingBase> Class, const struct FTransform& InTransform, TArray<class ABuildingBase*>* NeighborBuildings);
	void FindNearbyTouchingBuildings(class ABuildingBase* StartingBuilding, class ABuildingBase* CurrentBuilding, int32 MaximumDepth, TArray<class ABuildingBase*>* FoundBuildings, TArray<class ABuildingBase*>* CheckedBuildings);
	void AddChildBuildingToDestroy(class ABuildingBase* BuildingToDestroy);
};

// 0x18 (0x58 - 0x40)
// Class Icarus.BuildingGridManagerSubsystem
class UBuildingGridManagerSubsystem : public UTickableWorldSubsystem
{
public:
	uint8                                        Pad_70E5[0x14];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        WeatherSortingBudget;                              // 0x54(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UBuildingGridManagerSubsystem* GetDefaultObj();

};

// 0x58 (0x200 - 0x1A8)
// Class Icarus.BuildingGridRecorderComponent
class UBuildingGridRecorderComponent : public UActorStateRecorderComponent
{
public:
	uint8                                        Pad_70E6[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBuildingGridSaveData                 BuildingGridRecord;                                // 0x1B0(0x50)(BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBuildingGridRecorderComponent* GetDefaultObj();

	void AddBuildingToGrid(struct FTransform& GridTransform, class FName& BuildableRowName, class FName& BuildingItemName, struct FItemData& BuildingItemData, const struct FBuildingInfo& BuildingInfo);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingLookupLibrary
class UBuildingLookupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingLookupLibrary* GetDefaultObj();

	struct FBuildingLookupRowHandle StructToRowHandle(const struct FBuildingLookupEnum& EnumValue);
	class FName StructToName(const struct FBuildingLookupEnum& EnumValue);
	int32 StructToInt(const struct FBuildingLookupEnum& EnumValue);
	struct FBuildingLookupEnum RowHandleToStruct(const struct FBuildingLookupRowHandle& RowHandle);
	void RemoveRowFromBuildingLookupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildingLookupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildingLookupEnum& A, const struct FBuildingLookupEnum& B);
	struct FBuildingLookupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildingLookupRowHandle MakeLiteralBuildingLookup(const struct FBuildingLookupRowHandle& RowHandle);
	struct FBuildingLookupRowHandle MakeBuildingLookupFromIndex(int32 Index);
	struct FBuildingLookupEnum MakeBuildingLookupEnum(const struct FBuildingLookupEnum& Enum);
	struct FBuildingLookupRowHandle MakeBuildingLookup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildingLookupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildingLookupStruct(const struct FBuildingLookupRowHandle& RowHandle, struct FBuildingLookup* BuildingLookup, enum class EValid* Paths);
	bool EqualEqual_FBuildingLookupRowHandleFBuildingLookupRowHandle(const struct FBuildingLookupRowHandle& RowHandleA, const struct FBuildingLookupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildingLookupEnum& A, const struct FBuildingLookupEnum& B);
	struct FBuildingLookupRowHandle CastToBuildingLookupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildingLookupEnum(const struct FBuildingLookupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildingLookupTable(class FName Name, const struct FBuildingLookup& Data, struct FBuildingLookupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildingLookupTable
class UBuildingLookupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildingLookupTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingPiecesLibrary
class UBuildingPiecesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingPiecesLibrary* GetDefaultObj();

	struct FBuildingPiecesRowHandle StructToRowHandle(const struct FBuildingPiecesEnum& EnumValue);
	class FName StructToName(const struct FBuildingPiecesEnum& EnumValue);
	int32 StructToInt(const struct FBuildingPiecesEnum& EnumValue);
	struct FBuildingPiecesEnum RowHandleToStruct(const struct FBuildingPiecesRowHandle& RowHandle);
	void RemoveRowFromBuildingPiecesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildingPiecesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildingPiecesEnum& A, const struct FBuildingPiecesEnum& B);
	struct FBuildingPiecesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildingPiecesRowHandle MakeLiteralBuildingPieces(const struct FBuildingPiecesRowHandle& RowHandle);
	struct FBuildingPiecesRowHandle MakeBuildingPiecesFromIndex(int32 Index);
	struct FBuildingPiecesEnum MakeBuildingPiecesEnum(const struct FBuildingPiecesEnum& Enum);
	struct FBuildingPiecesRowHandle MakeBuildingPieces(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildingPiecesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildingPiecesStruct(const struct FBuildingPiecesRowHandle& RowHandle, struct FBuildingPiece* BuildingPieces, enum class EValid* Paths);
	bool EqualEqual_FBuildingPiecesRowHandleFBuildingPiecesRowHandle(const struct FBuildingPiecesRowHandle& RowHandleA, const struct FBuildingPiecesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildingPiecesEnum& A, const struct FBuildingPiecesEnum& B);
	struct FBuildingPiecesRowHandle CastToBuildingPiecesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildingPiecesEnum(const struct FBuildingPiecesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildingPiecesTable(class FName Name, const struct FBuildingPiece& Data, struct FBuildingPiecesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildingPiecesTable
class UBuildingPiecesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildingPiecesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingSkinsLibrary
class UBuildingSkinsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingSkinsLibrary* GetDefaultObj();

	struct FBuildingSkinsRowHandle StructToRowHandle(const struct FBuildingSkinsEnum& EnumValue);
	class FName StructToName(const struct FBuildingSkinsEnum& EnumValue);
	int32 StructToInt(const struct FBuildingSkinsEnum& EnumValue);
	struct FBuildingSkinsEnum RowHandleToStruct(const struct FBuildingSkinsRowHandle& RowHandle);
	void RemoveRowFromBuildingSkinsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildingSkinsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildingSkinsEnum& A, const struct FBuildingSkinsEnum& B);
	struct FBuildingSkinsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildingSkinsRowHandle MakeLiteralBuildingSkins(const struct FBuildingSkinsRowHandle& RowHandle);
	struct FBuildingSkinsRowHandle MakeBuildingSkinsFromIndex(int32 Index);
	struct FBuildingSkinsEnum MakeBuildingSkinsEnum(const struct FBuildingSkinsEnum& Enum);
	struct FBuildingSkinsRowHandle MakeBuildingSkins(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildingSkinsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildingSkinsStruct(const struct FBuildingSkinsRowHandle& RowHandle, struct FBuildingSkin* BuildingSkins, enum class EValid* Paths);
	bool EqualEqual_FBuildingSkinsRowHandleFBuildingSkinsRowHandle(const struct FBuildingSkinsRowHandle& RowHandleA, const struct FBuildingSkinsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildingSkinsEnum& A, const struct FBuildingSkinsEnum& B);
	struct FBuildingSkinsRowHandle CastToBuildingSkinsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildingSkinsEnum(const struct FBuildingSkinsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildingSkinsTable(class FName Name, const struct FBuildingSkin& Data, struct FBuildingSkinsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildingSkinsTable
class UBuildingSkinsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildingSkinsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingStabilityLibrary
class UBuildingStabilityLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingStabilityLibrary* GetDefaultObj();

	struct FBuildingStabilityRowHandle StructToRowHandle(const struct FBuildingStabilityEnum& EnumValue);
	class FName StructToName(const struct FBuildingStabilityEnum& EnumValue);
	int32 StructToInt(const struct FBuildingStabilityEnum& EnumValue);
	struct FBuildingStabilityEnum RowHandleToStruct(const struct FBuildingStabilityRowHandle& RowHandle);
	void RemoveRowFromBuildingStabilityTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildingStabilityEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildingStabilityEnum& A, const struct FBuildingStabilityEnum& B);
	struct FBuildingStabilityEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildingStabilityRowHandle MakeLiteralBuildingStability(const struct FBuildingStabilityRowHandle& RowHandle);
	struct FBuildingStabilityRowHandle MakeBuildingStabilityFromIndex(int32 Index);
	struct FBuildingStabilityEnum MakeBuildingStabilityEnum(const struct FBuildingStabilityEnum& Enum);
	struct FBuildingStabilityRowHandle MakeBuildingStability(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildingStabilityEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildingStabilityStruct(const struct FBuildingStabilityRowHandle& RowHandle, struct FBuildingStability* BuildingStability, enum class EValid* Paths);
	bool EqualEqual_FBuildingStabilityRowHandleFBuildingStabilityRowHandle(const struct FBuildingStabilityRowHandle& RowHandleA, const struct FBuildingStabilityRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildingStabilityEnum& A, const struct FBuildingStabilityEnum& B);
	struct FBuildingStabilityRowHandle CastToBuildingStabilityRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildingStabilityEnum(const struct FBuildingStabilityEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildingStabilityTable(class FName Name, const struct FBuildingStability& Data, struct FBuildingStabilityRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildingStabilityTable
class UBuildingStabilityTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildingStabilityTable* GetDefaultObj();

};

// 0x20 (0x50 - 0x30)
// Class Icarus.BuildingSubsystem
class UBuildingSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnBuildingPiecePlacedNotify;                       // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnBuildingPieceRemovedNotify;                      // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UBuildingSubsystem* GetDefaultObj();

	void BroadcastBuildingPieceRemovedDelegate(class AIcarusPlayerCharacter* Player, class ABuildingBase* Building);
	void BroadcastBuildingPiecePlacedDelegate(class AIcarusPlayerCharacter* Player, class ABuildingBase* Building);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BuildingTypesLibrary
class UBuildingTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UBuildingTypesLibrary* GetDefaultObj();

	struct FBuildingTypesRowHandle StructToRowHandle(const struct FBuildingTypesEnum& EnumValue);
	class FName StructToName(const struct FBuildingTypesEnum& EnumValue);
	int32 StructToInt(const struct FBuildingTypesEnum& EnumValue);
	struct FBuildingTypesEnum RowHandleToStruct(const struct FBuildingTypesRowHandle& RowHandle);
	void RemoveRowFromBuildingTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FBuildingTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FBuildingTypesEnum& A, const struct FBuildingTypesEnum& B);
	struct FBuildingTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FBuildingTypesRowHandle MakeLiteralBuildingTypes(const struct FBuildingTypesRowHandle& RowHandle);
	struct FBuildingTypesRowHandle MakeBuildingTypesFromIndex(int32 Index);
	struct FBuildingTypesEnum MakeBuildingTypesEnum(const struct FBuildingTypesEnum& Enum);
	struct FBuildingTypesRowHandle MakeBuildingTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FBuildingTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetBuildingTypesStruct(const struct FBuildingTypesRowHandle& RowHandle, struct FIcarusBuildingType* BuildingTypes, enum class EValid* Paths);
	bool EqualEqual_FBuildingTypesRowHandleFBuildingTypesRowHandle(const struct FBuildingTypesRowHandle& RowHandleA, const struct FBuildingTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FBuildingTypesEnum& A, const struct FBuildingTypesEnum& B);
	struct FBuildingTypesRowHandle CastToBuildingTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakBuildingTypesEnum(const struct FBuildingTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToBuildingTypesTable(class FName Name, const struct FIcarusBuildingType& Data, struct FBuildingTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.BuildingTypesTable
class UBuildingTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UBuildingTypesTable* GetDefaultObj();

};

// 0x18 (0xE8 - 0xD0)
// Class Icarus.FloatableComponent
class UFloatableComponent : public UTraitComponent
{
public:
	TArray<class UPrimitiveComponent*>           OverlappedComponents;                              // 0xD0(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFloatableUpdated;                                // 0xE0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7166[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFloatableComponent* GetDefaultObj();

	void UpdateOverlappedState();
	void RemoveOverlap(class UPrimitiveComponent* Component);
	TArray<struct FWaterSetupRowHandle> GetWaterSetupsFromOverlaps();
	bool GetFloatableData(struct FFloatableData* OutData);
	void FloatableUpdated(bool bNewFloating);
	void CheckOverlapArray();
	void AddOverlap(class UPrimitiveComponent* Component);
};

// 0x30 (0x118 - 0xE8)
// Class Icarus.BuoyancyBehaviour
class UBuoyancyBehaviour : public UFloatableComponent
{
public:
	struct FVector                               VelocityDamper;                                    // 0xE8(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bBuoyancyEnabled;                                  // 0xF4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoGenerateFloatingPoints;                       // 0xF5(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7169[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FloatingPointRadius;                               // 0xF8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_716A[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FVector>                       FloatingPoints;                                    // 0x100(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_716C[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBuoyancyBehaviour* GetDefaultObj();

	void GenerateFloatingPoints();
	float FindWaterHeight();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.BW3ObjectiveRecorderInterface
class IBW3ObjectiveRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IBW3ObjectiveRecorderInterface* GetDefaultObj();

	void SetObjectiveState(int32 State);
	void GetObjectiveState(int32* State);
};

// 0x8 (0xE0 - 0xD8)
// Class Icarus.BW3ObjectiveRecorderComponent
class UBW3ObjectiveRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	int32                                        SavedState;                                        // 0xD8(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_716D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UBW3ObjectiveRecorderComponent* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.CargoLandingPadComponent
class UCargoLandingPadComponent : public UActorComponent
{
public:
	int32                                        LeftSlotUID;                                       // 0xB0(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        RightSlotUID;                                      // 0xB4(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UCargoLandingPadComponent* GetDefaultObj();

	bool HasAvailableSlot();
	bool HasAssignedSlot();
	int32 GetRightSlotUID();
	int32 GetLeftSlotUID();
	int32 ClearSlot(class AIcarusActor* Object);
	int32 AssignAvailableSlot(class AIcarusActor* Object);
};

// 0x8 (0x260 - 0x258)
// Class Icarus.CargoLandingPadRecorderComponent
class UCargoLandingPadRecorderComponent : public UDeployableRecorderComponent
{
public:
	struct FCargoLandingPadRecord                LandingPadRecord;                                  // 0x258(0x8)(SaveGame, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UCargoLandingPadRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CargoLandingPadSnapInterface
class ICargoLandingPadSnapInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ICargoLandingPadSnapInterface* GetDefaultObj();

	struct FVector GetSnapPoint(int32 Index);
};

// 0x10 (0x40 - 0x30)
// Class Icarus.CargoLandingPadSubsystem
class UCargoLandingPadSubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_7179[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCargoLandingPadSubsystem* GetDefaultObj();

	void UnRegisterLandingPad(class AIcarusActor* LandingPad);
	void TransportPodDeparted(class AIcarusActor* CargoPod);
	void RegisterLandingPad(class AIcarusActor* LandingPad);
	bool FindNearbyLandingPad(class AIcarusActor* CargoPod, class AActor* Querier, float MaxDistance, bool bIsPlayer, struct FVector& LocationOut);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CaveInterface
class ICaveInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ICaveInterface* GetDefaultObj();

	float GetSpelunkingDepthFromLocation(const struct FVector& Location);
	float GetCurrentSpelunkingDepth();
};

// 0x0 (0x220 - 0x220)
// Class Icarus.Cave
class ACave : public AActor
{
public:

	static class UClass* StaticClass();
	static class ACave* GetDefaultObj();

};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.CaveAIRecorderComponent
class UCaveAIRecorderComponent : public UActorStateRecorderComponent
{
public:
	TArray<struct FCaveActorSpawnTimeStamp>      SaveData;                                          // 0x1A8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_717B[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCaveAIRecorderComponent* GetDefaultObj();

};

// 0x0 (0x2C0 - 0x2C0)
// Class Icarus.CaveEntranceBase
class ACaveEntranceBase : public AIcarusActor
{
public:

	static class UClass* StaticClass();
	static class ACaveEntranceBase* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CaveEntranceRecorderInterface
class ICaveEntranceRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ICaveEntranceRecorderInterface* GetDefaultObj();

	void SetVoxelBlockerSaveData(TArray<struct FVoxelMinedSphere>& VoxelBlockerSaveData);
	class AVoxelResource* GetVoxelActor();
};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.CaveEntranceRecorderComponent
class UCaveEntranceRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FVoxelSaveData                        VoxelBlockerSaveData;                              // 0x1A8(0x38)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UCaveEntranceRecorderComponent* GetDefaultObj();

};

// 0x110 (0x140 - 0x30)
// Class Icarus.CavePrefabAsset
class UCavePrefabAsset : public UActorPrefabAsset
{
public:
	TArray<struct FPrefabStaticMesh>             StaticMeshes;                                      // 0x30(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabActorClass>             Voids;                                             // 0x40(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabTransform>              Volumes;                                           // 0x50(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabTransform>              Entrances;                                         // 0x60(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabLake>                   Lakes;                                             // 0x70(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabWaterfall>              Waterfalls;                                        // 0x80(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabLavaFlowPoint>          LavaFlowPoints;                                    // 0x90(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabFoliage>                Foliage;                                           // 0xA0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabCaveLight>              CaveLights;                                        // 0xB0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabActorClass>             EntranceActors;                                    // 0xC0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabTransform>              ExoticVoxels;                                      // 0xD0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabTransform>              DeepMiningOreDeposit;                              // 0xE0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AActor>, struct FCaveSpawnConfig> CaveActorSpawnMap;                                 // 0xF0(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCavePrefabAsset* GetDefaultObj();

};

// 0x18 (0x238 - 0x220)
// Class Icarus.CavePrefab
class ACavePrefab : public AActorPrefab
{
public:
	class UCavePrefabAsset*                      PrefabAsset;                                       // 0x220(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebug;                                            // 0x228(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseEntrance;                                      // 0x229(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        CombinedCaveIncludeFlags;                          // 0x22A(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bCaveInstanceResolved;                             // 0x22B(0x1)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_717F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UObject*                               CaveGroup;                                         // 0x230(0x8)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ACavePrefab* GetDefaultObj();

	bool HasResolved();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ChallengesLibrary
class UChallengesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UChallengesLibrary* GetDefaultObj();

	struct FChallengesRowHandle StructToRowHandle(const struct FChallengesEnum& EnumValue);
	class FName StructToName(const struct FChallengesEnum& EnumValue);
	int32 StructToInt(const struct FChallengesEnum& EnumValue);
	struct FChallengesEnum RowHandleToStruct(const struct FChallengesRowHandle& RowHandle);
	void RemoveRowFromChallengesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FChallengesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FChallengesEnum& A, const struct FChallengesEnum& B);
	struct FChallengesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FChallengesRowHandle MakeLiteralChallenges(const struct FChallengesRowHandle& RowHandle);
	struct FChallengesRowHandle MakeChallengesFromIndex(int32 Index);
	struct FChallengesEnum MakeChallengesEnum(const struct FChallengesEnum& Enum);
	struct FChallengesRowHandle MakeChallenges(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FChallengesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetChallengesStruct(const struct FChallengesRowHandle& RowHandle, struct FChallenge* Challenges, enum class EValid* Paths);
	bool EqualEqual_FChallengesRowHandleFChallengesRowHandle(const struct FChallengesRowHandle& RowHandleA, const struct FChallengesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FChallengesEnum& A, const struct FChallengesEnum& B);
	struct FChallengesRowHandle CastToChallengesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakChallengesEnum(const struct FChallengesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToChallengesTable(class FName Name, const struct FChallenge& Data, struct FChallengesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ChallengesTable
class UChallengesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UChallengesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterCreationDataLibrary
class UCharacterCreationDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterCreationDataLibrary* GetDefaultObj();

	struct FCharacterCreationDataRowHandle StructToRowHandle(const struct FCharacterCreationDataEnum& EnumValue);
	class FName StructToName(const struct FCharacterCreationDataEnum& EnumValue);
	int32 StructToInt(const struct FCharacterCreationDataEnum& EnumValue);
	struct FCharacterCreationDataEnum RowHandleToStruct(const struct FCharacterCreationDataRowHandle& RowHandle);
	void RemoveRowFromCharacterCreationDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterCreationDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterCreationDataEnum& A, const struct FCharacterCreationDataEnum& B);
	struct FCharacterCreationDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterCreationDataRowHandle MakeLiteralCharacterCreationData(const struct FCharacterCreationDataRowHandle& RowHandle);
	struct FCharacterCreationDataRowHandle MakeCharacterCreationDataFromIndex(int32 Index);
	struct FCharacterCreationDataEnum MakeCharacterCreationDataEnum(const struct FCharacterCreationDataEnum& Enum);
	struct FCharacterCreationDataRowHandle MakeCharacterCreationData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterCreationDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterCreationDataStruct(const struct FCharacterCreationDataRowHandle& RowHandle, struct FCharacterCreationData* CharacterCreationData, enum class EValid* Paths);
	bool EqualEqual_FCharacterCreationDataRowHandleFCharacterCreationDataRowHandle(const struct FCharacterCreationDataRowHandle& RowHandleA, const struct FCharacterCreationDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterCreationDataEnum& A, const struct FCharacterCreationDataEnum& B);
	struct FCharacterCreationDataRowHandle CastToCharacterCreationDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterCreationDataEnum(const struct FCharacterCreationDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterCreationDataTable(class FName Name, const struct FCharacterCreationData& Data, struct FCharacterCreationDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterCreationDataTable
class UCharacterCreationDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterCreationDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterFlagsLibrary
class UCharacterFlagsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterFlagsLibrary* GetDefaultObj();

	struct FCharacterFlagsRowHandle StructToRowHandle(const struct FCharacterFlagsEnum& EnumValue);
	class FName StructToName(const struct FCharacterFlagsEnum& EnumValue);
	int32 StructToInt(const struct FCharacterFlagsEnum& EnumValue);
	struct FCharacterFlagsEnum RowHandleToStruct(const struct FCharacterFlagsRowHandle& RowHandle);
	void RemoveRowFromCharacterFlagsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterFlagsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterFlagsEnum& A, const struct FCharacterFlagsEnum& B);
	struct FCharacterFlagsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterFlagsRowHandle MakeLiteralCharacterFlags(const struct FCharacterFlagsRowHandle& RowHandle);
	struct FCharacterFlagsRowHandle MakeCharacterFlagsFromIndex(int32 Index);
	struct FCharacterFlagsEnum MakeCharacterFlagsEnum(const struct FCharacterFlagsEnum& Enum);
	struct FCharacterFlagsRowHandle MakeCharacterFlags(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterFlagsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterFlagsStruct(const struct FCharacterFlagsRowHandle& RowHandle, struct FCharacterFlag* CharacterFlags, enum class EValid* Paths);
	bool EqualEqual_FCharacterFlagsRowHandleFCharacterFlagsRowHandle(const struct FCharacterFlagsRowHandle& RowHandleA, const struct FCharacterFlagsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterFlagsEnum& A, const struct FCharacterFlagsEnum& B);
	struct FCharacterFlagsRowHandle CastToCharacterFlagsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterFlagsEnum(const struct FCharacterFlagsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterFlagsTable(class FName Name, const struct FCharacterFlag& Data, struct FCharacterFlagsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterFlagsTable
class UCharacterFlagsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterFlagsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterGrowthLibrary
class UCharacterGrowthLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterGrowthLibrary* GetDefaultObj();

	struct FCharacterGrowthRowHandle StructToRowHandle(const struct FCharacterGrowthEnum& EnumValue);
	class FName StructToName(const struct FCharacterGrowthEnum& EnumValue);
	int32 StructToInt(const struct FCharacterGrowthEnum& EnumValue);
	struct FCharacterGrowthEnum RowHandleToStruct(const struct FCharacterGrowthRowHandle& RowHandle);
	void RemoveRowFromCharacterGrowthTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterGrowthEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterGrowthEnum& A, const struct FCharacterGrowthEnum& B);
	struct FCharacterGrowthEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterGrowthRowHandle MakeLiteralCharacterGrowth(const struct FCharacterGrowthRowHandle& RowHandle);
	struct FCharacterGrowthRowHandle MakeCharacterGrowthFromIndex(int32 Index);
	struct FCharacterGrowthEnum MakeCharacterGrowthEnum(const struct FCharacterGrowthEnum& Enum);
	struct FCharacterGrowthRowHandle MakeCharacterGrowth(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterGrowthEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterGrowthStruct(const struct FCharacterGrowthRowHandle& RowHandle, struct FCharacterGrowth* CharacterGrowth, enum class EValid* Paths);
	bool EqualEqual_FCharacterGrowthRowHandleFCharacterGrowthRowHandle(const struct FCharacterGrowthRowHandle& RowHandleA, const struct FCharacterGrowthRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterGrowthEnum& A, const struct FCharacterGrowthEnum& B);
	struct FCharacterGrowthRowHandle CastToCharacterGrowthRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterGrowthEnum(const struct FCharacterGrowthEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterGrowthTable(class FName Name, const struct FCharacterGrowth& Data, struct FCharacterGrowthRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterGrowthTable
class UCharacterGrowthTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterGrowthTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterPerksLibrary
class UCharacterPerksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterPerksLibrary* GetDefaultObj();

	struct FCharacterPerksRowHandle StructToRowHandle(const struct FCharacterPerksEnum& EnumValue);
	class FName StructToName(const struct FCharacterPerksEnum& EnumValue);
	int32 StructToInt(const struct FCharacterPerksEnum& EnumValue);
	struct FCharacterPerksEnum RowHandleToStruct(const struct FCharacterPerksRowHandle& RowHandle);
	void RemoveRowFromCharacterPerksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterPerksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterPerksEnum& A, const struct FCharacterPerksEnum& B);
	struct FCharacterPerksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterPerksRowHandle MakeLiteralCharacterPerks(const struct FCharacterPerksRowHandle& RowHandle);
	struct FCharacterPerksRowHandle MakeCharacterPerksFromIndex(int32 Index);
	struct FCharacterPerksEnum MakeCharacterPerksEnum(const struct FCharacterPerksEnum& Enum);
	struct FCharacterPerksRowHandle MakeCharacterPerks(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterPerksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterPerksStruct(const struct FCharacterPerksRowHandle& RowHandle, struct FCharacterPerk* CharacterPerks, enum class EValid* Paths);
	bool EqualEqual_FCharacterPerksRowHandleFCharacterPerksRowHandle(const struct FCharacterPerksRowHandle& RowHandleA, const struct FCharacterPerksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterPerksEnum& A, const struct FCharacterPerksEnum& B);
	struct FCharacterPerksRowHandle CastToCharacterPerksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterPerksEnum(const struct FCharacterPerksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterPerksTable(class FName Name, const struct FCharacterPerk& Data, struct FCharacterPerksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterPerksTable
class UCharacterPerksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterPerksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterStartingStatsLibrary
class UCharacterStartingStatsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterStartingStatsLibrary* GetDefaultObj();

	struct FCharacterStartingStatsRowHandle StructToRowHandle(const struct FCharacterStartingStatsEnum& EnumValue);
	class FName StructToName(const struct FCharacterStartingStatsEnum& EnumValue);
	int32 StructToInt(const struct FCharacterStartingStatsEnum& EnumValue);
	struct FCharacterStartingStatsEnum RowHandleToStruct(const struct FCharacterStartingStatsRowHandle& RowHandle);
	void RemoveRowFromCharacterStartingStatsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterStartingStatsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterStartingStatsEnum& A, const struct FCharacterStartingStatsEnum& B);
	struct FCharacterStartingStatsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterStartingStatsRowHandle MakeLiteralCharacterStartingStats(const struct FCharacterStartingStatsRowHandle& RowHandle);
	struct FCharacterStartingStatsRowHandle MakeCharacterStartingStatsFromIndex(int32 Index);
	struct FCharacterStartingStatsEnum MakeCharacterStartingStatsEnum(const struct FCharacterStartingStatsEnum& Enum);
	struct FCharacterStartingStatsRowHandle MakeCharacterStartingStats(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterStartingStatsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterStartingStatsStruct(const struct FCharacterStartingStatsRowHandle& RowHandle, struct FPlayerStartingStats* CharacterStartingStats, enum class EValid* Paths);
	bool EqualEqual_FCharacterStartingStatsRowHandleFCharacterStartingStatsRowHandle(const struct FCharacterStartingStatsRowHandle& RowHandleA, const struct FCharacterStartingStatsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterStartingStatsEnum& A, const struct FCharacterStartingStatsEnum& B);
	struct FCharacterStartingStatsRowHandle CastToCharacterStartingStatsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterStartingStatsEnum(const struct FCharacterStartingStatsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterStartingStatsTable(class FName Name, const struct FPlayerStartingStats& Data, struct FCharacterStartingStatsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterStartingStatsTable
class UCharacterStartingStatsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterStartingStatsTable* GetDefaultObj();

};

// 0xB0 (0x310 - 0x260)
// Class Icarus.CharacterState
class UCharacterState : public UActorState
{
public:
	FMulticastSparseDelegateProperty_            OnStaminaUpdated;                                  // 0x260(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnStaminaDepleted;                                 // 0x261(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnStaminaDepletedDuringAction;                     // 0x262(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnExperienceEvent;                                 // 0x263(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnExperienceUpdated;                               // 0x264(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLevelUpdated;                                    // 0x265(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7225[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        Stamina;                                           // 0x268(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxStamina;                                        // 0x26C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        TotalExperience;                                   // 0x270(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterGrowthRowHandle             GrowthRowHandle;                                   // 0x274(0x18)(Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        Level;                                             // 0x28C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FStaminaActionCostsRowHandle> StaminaTickEvents;                                 // 0x290(0x50)(NativeAccessSpecifierPrivate)
	uint8                                        Pad_7226[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bHasStaminaRegen;                                  // 0x300(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7227[0xF];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCharacterState* GetDefaultObj();

	void TickStaminaEvents();
	void StopStaminaAction(const struct FStaminaActionCostsRowHandle& Action, int32 UID);
	int32 StartStaminaAction(const struct FStaminaActionCostsRowHandle& Action, bool SkipTickCost);
	bool SetupAI(int32 Level, int32 New_Health, int32 New_Stamina, int32 New_Strength, int32 New_Agility, int32 New_Perception);
	void SetStamina(int32 Amount);
	void SetExperience(int32 Amount);
	void RecalculateStaminaRegenRate();
	void RecalculateCurrentStamina();
	void OnRep_TotalExperience();
	void OnRep_Stamina();
	void OnRep_Level();
	int32 GetStamina();
	int32 GetMaxStamina();
	int32 GetLevel();
	int32 GetExperienceRequired(int32 Level);
	int32 GetExperience();
	void ClientAddedExperienceEvent(struct FExperienceEventsRowHandle& ExperienceEvent, int32 ExperienceGained);
	bool CanRegenerateStamina();
	bool CanPerformStaminaActionRow(struct FStaminaActionCostsRowHandle& StaminaAction);
	bool CanPerformStaminaAction(struct FStaminaCost& ActionCost);
	void CancelStaminaAction(int32 UID);
	void BiomeTick(float DeltaTime);
	void AddStamina(int32 Amount);
	bool AddExperienceEvent(struct FExperienceEventsRowHandle& ExperienceEvent, int32 GrantedExperience);
	void AddExperience(int32 Amount);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterTimelineLibrary
class UCharacterTimelineLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterTimelineLibrary* GetDefaultObj();

	struct FCharacterTimelineRowHandle StructToRowHandle(const struct FCharacterTimelineEnum& EnumValue);
	class FName StructToName(const struct FCharacterTimelineEnum& EnumValue);
	int32 StructToInt(const struct FCharacterTimelineEnum& EnumValue);
	struct FCharacterTimelineEnum RowHandleToStruct(const struct FCharacterTimelineRowHandle& RowHandle);
	void RemoveRowFromCharacterTimelineTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterTimelineEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterTimelineEnum& A, const struct FCharacterTimelineEnum& B);
	struct FCharacterTimelineEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterTimelineRowHandle MakeLiteralCharacterTimeline(const struct FCharacterTimelineRowHandle& RowHandle);
	struct FCharacterTimelineRowHandle MakeCharacterTimelineFromIndex(int32 Index);
	struct FCharacterTimelineEnum MakeCharacterTimelineEnum(const struct FCharacterTimelineEnum& Enum);
	struct FCharacterTimelineRowHandle MakeCharacterTimeline(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterTimelineEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterTimelineStruct(const struct FCharacterTimelineRowHandle& RowHandle, struct FCharacterTimeline* CharacterTimeline, enum class EValid* Paths);
	bool EqualEqual_FCharacterTimelineRowHandleFCharacterTimelineRowHandle(const struct FCharacterTimelineRowHandle& RowHandleA, const struct FCharacterTimelineRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterTimelineEnum& A, const struct FCharacterTimelineEnum& B);
	struct FCharacterTimelineRowHandle CastToCharacterTimelineRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterTimelineEnum(const struct FCharacterTimelineEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterTimelineTable(class FName Name, const struct FCharacterTimeline& Data, struct FCharacterTimelineRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterTimelineTable
class UCharacterTimelineTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterTimelineTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CharacterVoicesLibrary
class UCharacterVoicesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCharacterVoicesLibrary* GetDefaultObj();

	struct FCharacterVoicesRowHandle StructToRowHandle(const struct FCharacterVoicesEnum& EnumValue);
	class FName StructToName(const struct FCharacterVoicesEnum& EnumValue);
	int32 StructToInt(const struct FCharacterVoicesEnum& EnumValue);
	struct FCharacterVoicesEnum RowHandleToStruct(const struct FCharacterVoicesRowHandle& RowHandle);
	void RemoveRowFromCharacterVoicesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCharacterVoicesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCharacterVoicesEnum& A, const struct FCharacterVoicesEnum& B);
	struct FCharacterVoicesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCharacterVoicesRowHandle MakeLiteralCharacterVoices(const struct FCharacterVoicesRowHandle& RowHandle);
	struct FCharacterVoicesRowHandle MakeCharacterVoicesFromIndex(int32 Index);
	struct FCharacterVoicesEnum MakeCharacterVoicesEnum(const struct FCharacterVoicesEnum& Enum);
	struct FCharacterVoicesRowHandle MakeCharacterVoices(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCharacterVoicesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCharacterVoicesStruct(const struct FCharacterVoicesRowHandle& RowHandle, struct FCharacterVoiceData* CharacterVoices, enum class EValid* Paths);
	bool EqualEqual_FCharacterVoicesRowHandleFCharacterVoicesRowHandle(const struct FCharacterVoicesRowHandle& RowHandleA, const struct FCharacterVoicesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCharacterVoicesEnum& A, const struct FCharacterVoicesEnum& B);
	struct FCharacterVoicesRowHandle CastToCharacterVoicesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCharacterVoicesEnum(const struct FCharacterVoicesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCharacterVoicesTable(class FName Name, const struct FCharacterVoiceData& Data, struct FCharacterVoicesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CharacterVoicesTable
class UCharacterVoicesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCharacterVoicesTable* GetDefaultObj();

};

// 0x8 (0x228 - 0x220)
// Class Icarus.CheatController
class ACheatController : public AActor
{
public:
	struct FPerPlayerCheatData                   PerPlayerCheats;                                   // 0x220(0x4)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7265[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ACheatController* GetDefaultObj();

	void SetVerboseDamageLoggingEnabled(bool bEnabled);
	void SetUnlockAllRecipes(bool bEnabled);
	void SetUnlimitedResourcesEnabled(bool bEnabled);
	void SetShelteredRequiredDisabled(bool bDisabled);
	void SetGodModeEnabled(bool bEnabled);
	void SetBuildingIntegrityDisabled(bool bDisabled);
	bool IsVerboseDamageLoggingEnabled(class AActor* Actor);
	bool IsUnlockAllRecipesEnabled(class AActor* Actor);
	bool IsUnlimitedResourcesEnabled(class AActor* Actor);
	bool IsShelteredRequiredDisabled(class UObject* WorldContextObject);
	bool IsGodModeEnabled(class AActor* Actor);
	bool IsBuildingIntegrityDisabled(class UObject* WorldContextObject);
};

// 0x48 (0x2A8 - 0x260)
// Class Icarus.CheatFunctionBase
class UCheatFunctionBase : public UUserWidget
{
public:
	class FString                                Name;                                              // 0x260(0x10)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                  Description;                                       // 0x270(0x18)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                          TitleColour;                                       // 0x288(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                          AreaColor;                                         // 0x298(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCheatFunctionBase* GetDefaultObj();

	void UpdatePreview(TArray<class FString>& Args);
	class FString GetName();
	bool ForceNoBorder();
	void Execute();
};

// 0xF0 (0x350 - 0x260)
// Class Icarus.CheatOverlayBase
class UCheatOverlayBase : public UUserWidget
{
public:
	uint8                                        Pad_7279[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnScriptQueueFinished;                             // 0x270(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_727A[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnCheatScriptFinished;                             // 0x298(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UCheatFunctionBase*>            CheatFunctionWidgets;                              // 0x2A8(0x10)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_727B[0x98];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCheatOverlayBase* GetDefaultObj();

	void StopWaiting();
	void StartWaiting();
	void SetShow(bool bInShow);
	void SetFilteredWidgets(TArray<class UCheatFunctionBase*>& Widgets);
	bool SetCheatVariable(const class FString& Variable, const class FString& Value);
	void SetCheatFunctionList(TArray<class UClass*>& List);
	void RequestReloadCheats();
	void PreviewCommand(const class FString& CommandText);
	class FString ParseCheatLineArguments(const class FString& Line, TArray<class FString>& Args);
	void OnWaitingChanged(bool bNewWaiting);
	void OnShowChanged(bool bNewShow);
	void OnBeginPlay();
	bool IsWaiting();
	bool IsShowing();
	bool IsCheatScriptExecuting();
	void EvaluateLines(TArray<class FString>& ScriptLines);
	void Evaluate(const class FString& Script);
	void Close();
	void ClearFilteredWidgets();
	void AddCustomFunction(const class FString& Name, TArray<class FString>& ScriptLines, const class FString& Description);
	void AddCustomAutomationFunction(const class FString& Name, TArray<class FString>& ScriptLines, const class FString& Description);
	void AddCheat(class UCheatFunctionBase* Widget);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CheatOverlayFunctionLibrary
class UCheatOverlayFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UCheatOverlayFunctionLibrary* GetDefaultObj();

	class UCheatOverlayBase* GetCheatOverlay(class UObject* WorldContextObject);
};

// 0xD00 (0xE08 - 0x108)
// Class Icarus.ComboBoxText
class UComboBoxText : public UWidget
{
public:
	TArray<class FText>                          DefaultOptions;                                    // 0x108(0x10)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                  SelectedOption;                                    // 0x118(0x18)(Edit, NativeAccessSpecifierPrivate)
	struct FComboBoxStyle                        WidgetStyle;                                       // 0x130(0x3F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                        ItemStyle;                                         // 0x520(0x7C8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                               ContentPadding;                                    // 0xCE8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                        MaxListHeight;                                     // 0xCF8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         HasDownArrow;                                      // 0xCFC(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         EnableGamepadNavigationMode;                       // 0xCFD(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_728E[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FSlateFontInfo                        Font;                                              // 0xD00(0x58)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                           ForegroundColor;                                   // 0xD58(0x28)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                         bIsFocusable;                                      // 0xD80(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_728F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FDelegateProperty_                           OnGenerateWidgetEvent;                             // 0xD84(0x10)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7290[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnSelectionChanged;                                // 0xD98(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnOpening;                                         // 0xDA8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_7291[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UComboBoxText* GetDefaultObj();

	void SetSelectedOption(class FText Option);
	void SetSelectedIndex(int32 Index);
	bool RemoveOption(class FText& Option);
	void RefreshOptions();
	void OnSelectionChangedEvent__DelegateSignature(class FText SelectedItem, enum class ESelectInfo SelectionType);
	void OnOpeningEvent__DelegateSignature();
	bool IsOpen();
	class FText GetSelectedOption();
	int32 GetSelectedIndex();
	int32 GetOptionCount();
	class FText GetOptionAtIndex(int32 Index);
	int32 FindOptionIndex(class FText& Option);
	void ClearSelection();
	void ClearOptions();
	void AddOption(class FText& Option);
};

// 0x8 (0xD8 - 0xD0)
// Class Icarus.CombustibleComponent
class UCombustibleComponent : public UTraitComponent
{
public:
	int32                                        MillijoulesRemaining;                              // 0xD0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7293[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCombustibleComponent* GetDefaultObj();

	bool GetCombustibleData(struct FCombustibleData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CombustibleLibrary
class UCombustibleLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCombustibleLibrary* GetDefaultObj();

	struct FCombustibleRowHandle StructToRowHandle(const struct FCombustibleEnum& EnumValue);
	class FName StructToName(const struct FCombustibleEnum& EnumValue);
	int32 StructToInt(const struct FCombustibleEnum& EnumValue);
	struct FCombustibleEnum RowHandleToStruct(const struct FCombustibleRowHandle& RowHandle);
	void RemoveRowFromCombustibleTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCombustibleEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCombustibleEnum& A, const struct FCombustibleEnum& B);
	struct FCombustibleEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCombustibleRowHandle MakeLiteralCombustible(const struct FCombustibleRowHandle& RowHandle);
	struct FCombustibleRowHandle MakeCombustibleFromIndex(int32 Index);
	struct FCombustibleEnum MakeCombustibleEnum(const struct FCombustibleEnum& Enum);
	struct FCombustibleRowHandle MakeCombustible(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCombustibleEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCombustibleStruct(const struct FCombustibleRowHandle& RowHandle, struct FCombustibleData* Combustible, enum class EValid* Paths);
	bool EqualEqual_FCombustibleRowHandleFCombustibleRowHandle(const struct FCombustibleRowHandle& RowHandleA, const struct FCombustibleRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCombustibleEnum& A, const struct FCombustibleEnum& B);
	struct FCombustibleRowHandle CastToCombustibleRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCombustibleEnum(const struct FCombustibleEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCombustibleTable(class FName Name, const struct FCombustibleData& Data, struct FCombustibleRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CombustibleTable
class UCombustibleTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCombustibleTable* GetDefaultObj();

};

// 0xA0 (0x580 - 0x4E0)
// Class Icarus.ConcaveHullMesh
class UConcaveHullMesh : public UProceduralMeshComponent
{
public:
	FMulticastSparseDelegateProperty_            OnMeshGenerated;                                   // 0x4E0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_72AD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        Concavity;                                         // 0x4E4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LengthThreshold;                                   // 0x4E8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bProjectToLandscape;                               // 0x4EC(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_72AE[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FVector2D>                     ConcaveHullPoints;                                 // 0x4F0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                       ConcaveHullVertices;                               // 0x500(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_72B0[0x70];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UConcaveHullMesh* GetDefaultObj();

	bool IsRunningAsyncGenerate();
	void GenerateConcaveHull(TArray<struct FVector>& Points, bool bIsWorldSpace, bool bCreateConvexCollision, bool bIsAsync);
	void DebugGeneratedHullPoints(float ZOffset);
};

// 0x20 (0x280 - 0x260)
// Class Icarus.ConfirmationPopupBase
class UConfirmationPopupBase : public UUserWidget
{
public:
	FDelegateProperty_                           OnOptionAClicked;                                  // 0x260(0x10)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FDelegateProperty_                           OnOptionBClicked;                                  // 0x270(0x10)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UConfirmationPopupBase* GetDefaultObj();

	void ShowConfirmationPopup(struct FConfirmationPopupDetails& ConfirmationPopupDetails, FDelegateProperty_ OnOptionA, FDelegateProperty_ OnOptionB);
	void SetPromptDetails(struct FConfirmationPopupDetails& ConfirmationPopupDetails);
	void OptionBClicked();
	void OptionAClicked();
	void HideConfirmationPopup();
};

// 0x50 (0x78 - 0x28)
// Class Icarus.ReplicatedConnectedPlayer
class UReplicatedConnectedPlayer : public UObject
{
public:
	struct FConnectedPlayer                      State;                                             // 0x28(0x38)(Edit, Net, EditConst, NativeAccessSpecifierPublic)
	bool                                         bLocallyInitialised;                               // 0x60(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_72B1[0x17];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UReplicatedConnectedPlayer* GetDefaultObj();

	void OnLongConnectionTimeOut();
};

// 0x38 (0xE8 - 0xB0)
// Class Icarus.ConnectedPlayers
class UConnectedPlayers : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_            OnConnectedPlayerInitialised;                      // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UReplicatedConnectedPlayer*>    ReplicatedConnectedPlayers;                        // 0xC0(0x10)(Edit, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FConnectedPlayer>              CachedInitialisedConnectedPlayers;                 // 0xD0(0x10)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                        Pad_72CE[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UConnectedPlayers* GetDefaultObj();

	bool ServerTryCompletePlayerInitialisation(class AIcarusPlayerController* Player);
	void OnRep_ConnectedPlayers();
	TArray<struct FConnectedPlayer> GetInitialisedConnectedPlayers();
	bool GetConnectedPlayerById(const class FString& PlayerID, int32 ChrSlot, struct FConnectedPlayer& Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ConnectedPlayersFunctionLibrary
class UConnectedPlayersFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UConnectedPlayersFunctionLibrary* GetDefaultObj();

	bool NotEqual_ConnectedPlayerPlayerCharacterID(struct FConnectedPlayer& A, struct FPlayerCharacterID& B);
	bool NotEqual_ConnectedPlayerConnectedPlayer(struct FConnectedPlayer& A, struct FConnectedPlayer& B);
	class UConnectedPlayers* GetConnectedPlayers(class UObject* WorldContextObject);
	bool FindInitialisedConnectedPlayerByPlayerState(class UObject* WorldContextObject, class AIcarusPlayerState* PlayerState, struct FConnectedPlayer* OutConnectedPlayer);
	bool FindInitialisedConnectedPlayerByPlayerID(class UObject* WorldContextObject, const class FString& PlayerID, struct FConnectedPlayer* OutConnectedPlayer);
	bool FindInitialisedConnectedPlayerByPlayerCharacterID(class UObject* WorldContextObject, struct FPlayerCharacterID& PlayerCharacterID, struct FConnectedPlayer* OutConnectedPlayer);
	bool FindInitialisedConnectedPlayerByPlayerCharacter(class UObject* WorldContextObject, class AIcarusPlayerCharacter* PlayerCharacter, struct FConnectedPlayer* OutConnectedPlayer);
	bool FindInitialisedConnectedPlayerByController(class UObject* WorldContextObject, class AIcarusPlayerController* Controller, struct FConnectedPlayer* OutConnectedPlayer);
	bool EqualEqual_ConnectedPlayerPlayerCharacterID(struct FConnectedPlayer& A, struct FPlayerCharacterID& B);
	bool EqualEqual_ConnectedPlayerConnectedPlayer(struct FConnectedPlayer& A, struct FConnectedPlayer& B);
};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.ConsumableComponent
class UConsumableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UConsumableComponent* GetDefaultObj();

	bool GetConsumableData(struct FConsumableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ConsumableLibrary
class UConsumableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UConsumableLibrary* GetDefaultObj();

	struct FConsumableRowHandle StructToRowHandle(const struct FConsumableEnum& EnumValue);
	class FName StructToName(const struct FConsumableEnum& EnumValue);
	int32 StructToInt(const struct FConsumableEnum& EnumValue);
	struct FConsumableEnum RowHandleToStruct(const struct FConsumableRowHandle& RowHandle);
	void RemoveRowFromConsumableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FConsumableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FConsumableEnum& A, const struct FConsumableEnum& B);
	struct FConsumableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FConsumableRowHandle MakeLiteralConsumable(const struct FConsumableRowHandle& RowHandle);
	struct FConsumableRowHandle MakeConsumableFromIndex(int32 Index);
	struct FConsumableEnum MakeConsumableEnum(const struct FConsumableEnum& Enum);
	struct FConsumableRowHandle MakeConsumable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FConsumableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetConsumableStruct(const struct FConsumableRowHandle& RowHandle, struct FConsumableData* Consumable, enum class EValid* Paths);
	bool EqualEqual_FConsumableRowHandleFConsumableRowHandle(const struct FConsumableRowHandle& RowHandleA, const struct FConsumableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FConsumableEnum& A, const struct FConsumableEnum& B);
	struct FConsumableRowHandle CastToConsumableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakConsumableEnum(const struct FConsumableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToConsumableTable(class FName Name, const struct FConsumableData& Data, struct FConsumableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ConsumableTable
class UConsumableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UConsumableTable* GetDefaultObj();

};

// 0x18 (0x238 - 0x220)
// Class Icarus.ContextMenuFactory
class AContextMenuFactory : public AActor
{
public:
	class APlayerController*                     OwningPlayer;                                      // 0x220(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FContextMenuItemData>          Items;                                             // 0x228(0x10)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AContextMenuFactory* GetDefaultObj();

	class UContextMenuWidget* ShowAsRadialMenu();
	class UContextMenuWidget* ShowAsContextMenu(const struct FVector2D& ScreenPosition);
	void SetContextMenuData(class FText& Name, TSoftObjectPtr<class UTexture2D>& Icon);
	void CreateMenu(class APlayerController* NewOwningPlayer);
	void AddItem(struct FContextMenuItemData& ContextMenuItemData, FDelegateProperty_ OnClickedDelegate);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ContextMenuGroupTypesLibrary
class UContextMenuGroupTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UContextMenuGroupTypesLibrary* GetDefaultObj();

	struct FContextMenuGroupTypesRowHandle StructToRowHandle(const struct FContextMenuGroupTypesEnum& EnumValue);
	class FName StructToName(const struct FContextMenuGroupTypesEnum& EnumValue);
	int32 StructToInt(const struct FContextMenuGroupTypesEnum& EnumValue);
	struct FContextMenuGroupTypesEnum RowHandleToStruct(const struct FContextMenuGroupTypesRowHandle& RowHandle);
	void RemoveRowFromContextMenuGroupTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FContextMenuGroupTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FContextMenuGroupTypesEnum& A, const struct FContextMenuGroupTypesEnum& B);
	struct FContextMenuGroupTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FContextMenuGroupTypesRowHandle MakeLiteralContextMenuGroupTypes(const struct FContextMenuGroupTypesRowHandle& RowHandle);
	struct FContextMenuGroupTypesRowHandle MakeContextMenuGroupTypesFromIndex(int32 Index);
	struct FContextMenuGroupTypesEnum MakeContextMenuGroupTypesEnum(const struct FContextMenuGroupTypesEnum& Enum);
	struct FContextMenuGroupTypesRowHandle MakeContextMenuGroupTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FContextMenuGroupTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetContextMenuGroupTypesStruct(const struct FContextMenuGroupTypesRowHandle& RowHandle, struct FContextMenuGroupType* ContextMenuGroupTypes, enum class EValid* Paths);
	bool EqualEqual_FContextMenuGroupTypesRowHandleFContextMenuGroupTypesRowHandle(const struct FContextMenuGroupTypesRowHandle& RowHandleA, const struct FContextMenuGroupTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FContextMenuGroupTypesEnum& A, const struct FContextMenuGroupTypesEnum& B);
	struct FContextMenuGroupTypesRowHandle CastToContextMenuGroupTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakContextMenuGroupTypesEnum(const struct FContextMenuGroupTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToContextMenuGroupTypesTable(class FName Name, const struct FContextMenuGroupType& Data, struct FContextMenuGroupTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ContextMenuGroupTypesTable
class UContextMenuGroupTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UContextMenuGroupTypesTable* GetDefaultObj();

};

// 0x0 (0x260 - 0x260)
// Class Icarus.ContextMenuWidget
class UContextMenuWidget : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UContextMenuWidget* GetDefaultObj();

	void ShowMenu(const struct FVector2D& ScreenPosition, class FText& MenuName, TSoftObjectPtr<class UTexture2D>& MenuIcon);
	void CloseMenu();
	void AddItems(TArray<struct FContextMenuItemData>& ContextMenuItems);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CosmeticsFunctionLibrary
class UCosmeticsFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UCosmeticsFunctionLibrary* GetDefaultObj();

	void LogDLCInfo();
	bool IsDLCPackageInstalled(const struct FDLCPackageDataRowHandle& DLCPackage);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CraftingAudioDataLibrary
class UCraftingAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCraftingAudioDataLibrary* GetDefaultObj();

	struct FCraftingAudioDataRowHandle StructToRowHandle(const struct FCraftingAudioDataEnum& EnumValue);
	class FName StructToName(const struct FCraftingAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FCraftingAudioDataEnum& EnumValue);
	struct FCraftingAudioDataEnum RowHandleToStruct(const struct FCraftingAudioDataRowHandle& RowHandle);
	void RemoveRowFromCraftingAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCraftingAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCraftingAudioDataEnum& A, const struct FCraftingAudioDataEnum& B);
	struct FCraftingAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCraftingAudioDataRowHandle MakeLiteralCraftingAudioData(const struct FCraftingAudioDataRowHandle& RowHandle);
	struct FCraftingAudioDataRowHandle MakeCraftingAudioDataFromIndex(int32 Index);
	struct FCraftingAudioDataEnum MakeCraftingAudioDataEnum(const struct FCraftingAudioDataEnum& Enum);
	struct FCraftingAudioDataRowHandle MakeCraftingAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCraftingAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCraftingAudioDataStruct(const struct FCraftingAudioDataRowHandle& RowHandle, struct FCraftingAudioData* CraftingAudioData, enum class EValid* Paths);
	bool EqualEqual_FCraftingAudioDataRowHandleFCraftingAudioDataRowHandle(const struct FCraftingAudioDataRowHandle& RowHandleA, const struct FCraftingAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCraftingAudioDataEnum& A, const struct FCraftingAudioDataEnum& B);
	struct FCraftingAudioDataRowHandle CastToCraftingAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCraftingAudioDataEnum(const struct FCraftingAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCraftingAudioDataTable(class FName Name, const struct FCraftingAudioData& Data, struct FCraftingAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CraftingAudioDataTable
class UCraftingAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCraftingAudioDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CraftingFunctionLibrary
class UCraftingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UCraftingFunctionLibrary* GetDefaultObj();

	float GetStatBasedResourceCostMultiplier(struct FProcessorRecipesRowHandle& Recipe, class AActor* CraftingActor);
	int32 GetScaledRecipeResourceItemCount(struct FProcessorRecipesRowHandle& Recipe, struct FResourceItem& Resource, class AActor* CraftingActor);
	int32 GetScaledRecipeInputCount(struct FProcessorRecipesRowHandle& Recipe, struct FCraftingInput& Input, class AActor* CraftingActor);
	TArray<struct FResourceItem> CreateRecipeOutputResourceData(struct FProcessorRecipesRowHandle& Input, class AActor* CraftingActor);
	TArray<struct FItemData> CreateRecipeOutputItemData(struct FProcessorRecipesRowHandle& Input, class AActor* CraftingActor);
	TArray<struct FResourceItem> CreateRecipeInputResourceData(struct FProcessorRecipesRowHandle& Input, class AActor* CraftingActor);
	TArray<struct FItemData> CreateRecipeInputItemData(struct FProcessorRecipesRowHandle& Input, class AActor* CraftingActor);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CraftingModificationsLibrary
class UCraftingModificationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCraftingModificationsLibrary* GetDefaultObj();

	struct FCraftingModificationsRowHandle StructToRowHandle(const struct FCraftingModificationsEnum& EnumValue);
	class FName StructToName(const struct FCraftingModificationsEnum& EnumValue);
	int32 StructToInt(const struct FCraftingModificationsEnum& EnumValue);
	struct FCraftingModificationsEnum RowHandleToStruct(const struct FCraftingModificationsRowHandle& RowHandle);
	void RemoveRowFromCraftingModificationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCraftingModificationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCraftingModificationsEnum& A, const struct FCraftingModificationsEnum& B);
	struct FCraftingModificationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCraftingModificationsRowHandle MakeLiteralCraftingModifications(const struct FCraftingModificationsRowHandle& RowHandle);
	struct FCraftingModificationsRowHandle MakeCraftingModificationsFromIndex(int32 Index);
	struct FCraftingModificationsEnum MakeCraftingModificationsEnum(const struct FCraftingModificationsEnum& Enum);
	struct FCraftingModificationsRowHandle MakeCraftingModifications(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCraftingModificationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCraftingModificationsStruct(const struct FCraftingModificationsRowHandle& RowHandle, struct FCraftingModifications* CraftingModifications, enum class EValid* Paths);
	bool EqualEqual_FCraftingModificationsRowHandleFCraftingModificationsRowHandle(const struct FCraftingModificationsRowHandle& RowHandleA, const struct FCraftingModificationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCraftingModificationsEnum& A, const struct FCraftingModificationsEnum& B);
	struct FCraftingModificationsRowHandle CastToCraftingModificationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCraftingModificationsEnum(const struct FCraftingModificationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCraftingModificationsTable(class FName Name, const struct FCraftingModifications& Data, struct FCraftingModificationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CraftingModificationsTable
class UCraftingModificationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCraftingModificationsTable* GetDefaultObj();

};

// 0x20 (0x50 - 0x30)
// Class Icarus.CraftingSubsystem
class UCraftingSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnCraftedRecipeNotify;                             // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCraftedItemNotify;                               // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCraftingSubsystem* GetDefaultObj();

	void BroadcastCraftedRecipeDelegate(class AActor* Player, class AActor* Device, const struct FProcessorRecipesRowHandle& Recipe);
	void BroadcastCraftedItemDelegate(class AActor* Player, class AActor* Device, const struct FItemData& Item);
};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.CreatureAudioComponent
class UCreatureAudioComponent : public UActorComponent
{
public:
	enum class EAudioShelterState                CurrentShelterState;                               // 0xB0(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_733B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CurrentWaterDepth;                                 // 0xB4(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCreatureAudioComponent* GetDefaultObj();

	void UpdateShelterState();
	float GetWaterImmersion();
};

// 0x38 (0xE8 - 0xB0)
// Class Icarus.CreatureAudioThreatComponent
class UCreatureAudioThreatComponent : public UActorComponent
{
public:
	uint8                                        Pad_733D[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIAudioDataRowHandle                 AudioDataRow;                                      // 0xB8(0x18)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_733E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusNPCCharacter*                   Creature;                                          // 0xD8(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_733F[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCreatureAudioThreatComponent* GetDefaultObj();

	void OnCreatureDeath(class UActorState* ActorState);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CreatureAudioThreatDataLibrary
class UCreatureAudioThreatDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCreatureAudioThreatDataLibrary* GetDefaultObj();

	struct FCreatureAudioThreatDataRowHandle StructToRowHandle(const struct FCreatureAudioThreatDataEnum& EnumValue);
	class FName StructToName(const struct FCreatureAudioThreatDataEnum& EnumValue);
	int32 StructToInt(const struct FCreatureAudioThreatDataEnum& EnumValue);
	struct FCreatureAudioThreatDataEnum RowHandleToStruct(const struct FCreatureAudioThreatDataRowHandle& RowHandle);
	void RemoveRowFromCreatureAudioThreatDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCreatureAudioThreatDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCreatureAudioThreatDataEnum& A, const struct FCreatureAudioThreatDataEnum& B);
	struct FCreatureAudioThreatDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCreatureAudioThreatDataRowHandle MakeLiteralCreatureAudioThreatData(const struct FCreatureAudioThreatDataRowHandle& RowHandle);
	struct FCreatureAudioThreatDataRowHandle MakeCreatureAudioThreatDataFromIndex(int32 Index);
	struct FCreatureAudioThreatDataEnum MakeCreatureAudioThreatDataEnum(const struct FCreatureAudioThreatDataEnum& Enum);
	struct FCreatureAudioThreatDataRowHandle MakeCreatureAudioThreatData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCreatureAudioThreatDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCreatureAudioThreatDataStruct(const struct FCreatureAudioThreatDataRowHandle& RowHandle, struct FCreatureAudioThreatData* CreatureAudioThreatData, enum class EValid* Paths);
	bool EqualEqual_FCreatureAudioThreatDataRowHandleFCreatureAudioThreatDataRowHandle(const struct FCreatureAudioThreatDataRowHandle& RowHandleA, const struct FCreatureAudioThreatDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCreatureAudioThreatDataEnum& A, const struct FCreatureAudioThreatDataEnum& B);
	struct FCreatureAudioThreatDataRowHandle CastToCreatureAudioThreatDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCreatureAudioThreatDataEnum(const struct FCreatureAudioThreatDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCreatureAudioThreatDataTable(class FName Name, const struct FCreatureAudioThreatData& Data, struct FCreatureAudioThreatDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CreatureAudioThreatDataTable
class UCreatureAudioThreatDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCreatureAudioThreatDataTable* GetDefaultObj();

};

// 0x50 (0x138 - 0xE8)
// Class Icarus.CreatureAudioThreatTargetTrackComponent
class UCreatureAudioThreatTargetTrackComponent : public UCreatureAudioThreatComponent
{
public:
	TMap<enum class ECreatureAudioThreatTargetType, float> CurrentTargets;                                    // 0xE8(0x50)(Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UCreatureAudioThreatTargetTrackComponent* GetDefaultObj();

};

// 0x0 (0x138 - 0x138)
// Class Icarus.CreatureAudioThreatGOAPComponent
class UCreatureAudioThreatGOAPComponent : public UCreatureAudioThreatTargetTrackComponent
{
public:

	static class UClass* StaticClass();
	static class UCreatureAudioThreatGOAPComponent* GetDefaultObj();

};

// 0x0 (0x138 - 0x138)
// Class Icarus.CreatureAudioThreatSimpleBossComponent
class UCreatureAudioThreatSimpleBossComponent : public UCreatureAudioThreatTargetTrackComponent
{
public:

	static class UClass* StaticClass();
	static class UCreatureAudioThreatSimpleBossComponent* GetDefaultObj();

};

// 0x30 (0x60 - 0x30)
// Class Icarus.CreatureSubsystem
class UCreatureSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnCreatureKilledNotify;                            // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCreatureSkinnedNotify;                           // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCorpseItemRemovedNotify;                         // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCreatureSubsystem* GetDefaultObj();

	void BroadcastCreatureSkinnedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusCorpse* Corpse);
	void BroadcastCreatureKilledDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Causer, class AActor* Creature, class AIcarusPlayerCharacter* KillingBlowFromPlayer);
	void BroadcastCorpseItemRemovedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
};

// 0x0 (0x220 - 0x220)
// Class Icarus.Crevasse
class ACrevasse : public AActor
{
public:

	static class UClass* StaticClass();
	static class ACrevasse* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CriticalHitAreaAudioDataLibrary
class UCriticalHitAreaAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitAreaAudioDataLibrary* GetDefaultObj();

	struct FCriticalHitAreaAudioDataRowHandle StructToRowHandle(const struct FCriticalHitAreaAudioDataEnum& EnumValue);
	class FName StructToName(const struct FCriticalHitAreaAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FCriticalHitAreaAudioDataEnum& EnumValue);
	struct FCriticalHitAreaAudioDataEnum RowHandleToStruct(const struct FCriticalHitAreaAudioDataRowHandle& RowHandle);
	void RemoveRowFromCriticalHitAreaAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCriticalHitAreaAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCriticalHitAreaAudioDataEnum& A, const struct FCriticalHitAreaAudioDataEnum& B);
	struct FCriticalHitAreaAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCriticalHitAreaAudioDataRowHandle MakeLiteralCriticalHitAreaAudioData(const struct FCriticalHitAreaAudioDataRowHandle& RowHandle);
	struct FCriticalHitAreaAudioDataRowHandle MakeCriticalHitAreaAudioDataFromIndex(int32 Index);
	struct FCriticalHitAreaAudioDataEnum MakeCriticalHitAreaAudioDataEnum(const struct FCriticalHitAreaAudioDataEnum& Enum);
	struct FCriticalHitAreaAudioDataRowHandle MakeCriticalHitAreaAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCriticalHitAreaAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCriticalHitAreaAudioDataStruct(const struct FCriticalHitAreaAudioDataRowHandle& RowHandle, struct FCriticalHitAreaAudioData* CriticalHitAreaAudioData, enum class EValid* Paths);
	bool EqualEqual_FCriticalHitAreaAudioDataRowHandleFCriticalHitAreaAudioDataRowHandle(const struct FCriticalHitAreaAudioDataRowHandle& RowHandleA, const struct FCriticalHitAreaAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCriticalHitAreaAudioDataEnum& A, const struct FCriticalHitAreaAudioDataEnum& B);
	struct FCriticalHitAreaAudioDataRowHandle CastToCriticalHitAreaAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCriticalHitAreaAudioDataEnum(const struct FCriticalHitAreaAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCriticalHitAreaAudioDataTable(class FName Name, const struct FCriticalHitAreaAudioData& Data, struct FCriticalHitAreaAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CriticalHitAreaAudioDataTable
class UCriticalHitAreaAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitAreaAudioDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CriticalHitAreasLibrary
class UCriticalHitAreasLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitAreasLibrary* GetDefaultObj();

	struct FCriticalHitAreasRowHandle StructToRowHandle(const struct FCriticalHitAreasEnum& EnumValue);
	class FName StructToName(const struct FCriticalHitAreasEnum& EnumValue);
	int32 StructToInt(const struct FCriticalHitAreasEnum& EnumValue);
	struct FCriticalHitAreasEnum RowHandleToStruct(const struct FCriticalHitAreasRowHandle& RowHandle);
	void RemoveRowFromCriticalHitAreasTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCriticalHitAreasEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCriticalHitAreasEnum& A, const struct FCriticalHitAreasEnum& B);
	struct FCriticalHitAreasEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCriticalHitAreasRowHandle MakeLiteralCriticalHitAreas(const struct FCriticalHitAreasRowHandle& RowHandle);
	struct FCriticalHitAreasRowHandle MakeCriticalHitAreasFromIndex(int32 Index);
	struct FCriticalHitAreasEnum MakeCriticalHitAreasEnum(const struct FCriticalHitAreasEnum& Enum);
	struct FCriticalHitAreasRowHandle MakeCriticalHitAreas(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCriticalHitAreasEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCriticalHitAreasStruct(const struct FCriticalHitAreasRowHandle& RowHandle, struct FCriticalHitArea* CriticalHitAreas, enum class EValid* Paths);
	bool EqualEqual_FCriticalHitAreasRowHandleFCriticalHitAreasRowHandle(const struct FCriticalHitAreasRowHandle& RowHandleA, const struct FCriticalHitAreasRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCriticalHitAreasEnum& A, const struct FCriticalHitAreasEnum& B);
	struct FCriticalHitAreasRowHandle CastToCriticalHitAreasRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCriticalHitAreasEnum(const struct FCriticalHitAreasEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCriticalHitAreasTable(class FName Name, const struct FCriticalHitArea& Data, struct FCriticalHitAreasRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CriticalHitAreasTable
class UCriticalHitAreasTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitAreasTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CriticalHitReceiver
class ICriticalHitReceiver : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ICriticalHitReceiver* GetDefaultObj();

	struct FCriticalHitAreasEnum GetDefaultCriticalArea();
	TMap<class UPrimitiveComponent*, struct FCriticalHitAreasEnum> GetCriticalHitAreas();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CriticalHitSetupLibrary
class UCriticalHitSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitSetupLibrary* GetDefaultObj();

	struct FCriticalHitSetupRowHandle StructToRowHandle(const struct FCriticalHitSetupEnum& EnumValue);
	class FName StructToName(const struct FCriticalHitSetupEnum& EnumValue);
	int32 StructToInt(const struct FCriticalHitSetupEnum& EnumValue);
	struct FCriticalHitSetupEnum RowHandleToStruct(const struct FCriticalHitSetupRowHandle& RowHandle);
	void RemoveRowFromCriticalHitSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCriticalHitSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCriticalHitSetupEnum& A, const struct FCriticalHitSetupEnum& B);
	struct FCriticalHitSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCriticalHitSetupRowHandle MakeLiteralCriticalHitSetup(const struct FCriticalHitSetupRowHandle& RowHandle);
	struct FCriticalHitSetupRowHandle MakeCriticalHitSetupFromIndex(int32 Index);
	struct FCriticalHitSetupEnum MakeCriticalHitSetupEnum(const struct FCriticalHitSetupEnum& Enum);
	struct FCriticalHitSetupRowHandle MakeCriticalHitSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCriticalHitSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCriticalHitSetupStruct(const struct FCriticalHitSetupRowHandle& RowHandle, struct FCriticalHitSetup* CriticalHitSetup, enum class EValid* Paths);
	bool EqualEqual_FCriticalHitSetupRowHandleFCriticalHitSetupRowHandle(const struct FCriticalHitSetupRowHandle& RowHandleA, const struct FCriticalHitSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCriticalHitSetupEnum& A, const struct FCriticalHitSetupEnum& B);
	struct FCriticalHitSetupRowHandle CastToCriticalHitSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCriticalHitSetupEnum(const struct FCriticalHitSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCriticalHitSetupTable(class FName Name, const struct FCriticalHitSetup& Data, struct FCriticalHitSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CriticalHitSetupTable
class UCriticalHitSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCriticalHitSetupTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.CropPlotFunctionLibrary
class UCropPlotFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UCropPlotFunctionLibrary* GetDefaultObj();

	void CheckOutdoorsAndGreenhouse(class ADeployable* CropPlot, const struct FVector& OutsideTestPushoutAmount, float GreenhouseTestRadius, bool* bIsOutdoors, int32* GreenhousePieceCount);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CropPlotRecorderInterface
class ICropPlotRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ICropPlotRecorderInterface* GetDefaultObj();

	void SetCropPlotValues(TArray<struct FCultivationSaveData>& SaveData);
	void GetCropPlotValues(TArray<struct FCultivationSaveData>* SaveData);
};

// 0x18 (0x270 - 0x258)
// Class Icarus.CropPlotRecorderComponent
class UCropPlotRecorderComponent : public UDeployableRecorderComponent
{
public:
	TArray<struct FCultivationSaveData>          CultivationSaveData;                               // 0x258(0x10)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	uint8                                        Pad_738C[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCropPlotRecorderComponent* GetDefaultObj();

};

// 0x40 (0x100 - 0xC0)
// Class Icarus.Cultivation
class UCultivation : public UTraitBehaviour
{
public:
	FMulticastSparseDelegateProperty_            OnSeedUpdated;                                     // 0xC0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnGrowthStateUpdated;                              // 0xC1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_739B[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FFarmingSeedsRowHandle                CurrentSeed;                                       // 0xC4(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFarmableRowHandle                    FarmingData;                                       // 0xDC(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EPlantGrowthStates                CurrentGrowthState;                                // 0xF4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_739C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CurrentGrowthTime;                                 // 0xF8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_739D[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCultivation* GetDefaultObj();

	void TriggerFatigue();
	bool StartCultivation(const struct FFarmingSeedsRowHandle& Seed);
	void ResetCultivation();
	void ReseedCultivation();
	void RemoveFatigue();
	void OnRep_CurrentSeed();
	void OnRep_CurrentGrowthState();
	void LoadSaveData(struct FCultivationSaveData& SaveData);
	bool HarvestCultivation(class AIcarusPlayerCharacter* Player, bool bUsingSickle, TArray<struct FItemData>* HarvestedItems);
	struct FCultivationSaveData GetSaveData();
	bool ForceSetCultivation(const struct FFarmingSeedsRowHandle& Seed, enum class EPlantGrowthStates GrowthState);
	void ClearCultivation();
	void Cheat_InstantGrow();
	bool CanStartCultivation(const struct FFarmingSeedsRowHandle& Seed);
	bool CanHarvestCultivation();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.CurrencyConversionsLibrary
class UCurrencyConversionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UCurrencyConversionsLibrary* GetDefaultObj();

	struct FCurrencyConversionsRowHandle StructToRowHandle(const struct FCurrencyConversionsEnum& EnumValue);
	class FName StructToName(const struct FCurrencyConversionsEnum& EnumValue);
	int32 StructToInt(const struct FCurrencyConversionsEnum& EnumValue);
	struct FCurrencyConversionsEnum RowHandleToStruct(const struct FCurrencyConversionsRowHandle& RowHandle);
	void RemoveRowFromCurrencyConversionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FCurrencyConversionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FCurrencyConversionsEnum& A, const struct FCurrencyConversionsEnum& B);
	struct FCurrencyConversionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FCurrencyConversionsRowHandle MakeLiteralCurrencyConversions(const struct FCurrencyConversionsRowHandle& RowHandle);
	struct FCurrencyConversionsRowHandle MakeCurrencyConversionsFromIndex(int32 Index);
	struct FCurrencyConversionsEnum MakeCurrencyConversionsEnum(const struct FCurrencyConversionsEnum& Enum);
	struct FCurrencyConversionsRowHandle MakeCurrencyConversions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FCurrencyConversionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetCurrencyConversionsStruct(const struct FCurrencyConversionsRowHandle& RowHandle, struct FCurrencyConversion* CurrencyConversions, enum class EValid* Paths);
	bool EqualEqual_FCurrencyConversionsRowHandleFCurrencyConversionsRowHandle(const struct FCurrencyConversionsRowHandle& RowHandleA, const struct FCurrencyConversionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FCurrencyConversionsEnum& A, const struct FCurrencyConversionsEnum& B);
	struct FCurrencyConversionsRowHandle CastToCurrencyConversionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakCurrencyConversionsEnum(const struct FCurrencyConversionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToCurrencyConversionsTable(class FName Name, const struct FCurrencyConversion& Data, struct FCurrencyConversionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.CurrencyConversionsTable
class UCurrencyConversionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UCurrencyConversionsTable* GetDefaultObj();

};

// 0x210 (0x240 - 0x30)
// Class Icarus.CursorSubsystem
class UCursorSubsystem : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_            CursorCleared;                                     // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            CursorUpdated;                                     // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FItemData                             CurrentItem;                                       // 0x50(0x1F0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UCursorSubsystem* GetDefaultObj();

	void UpdateCursor(const struct FItemData& Item);
};

// 0x490 (0x598 - 0x108)
// Class Icarus.CustomComboBox
class UCustomComboBox : public UWidget
{
public:
	struct FComboButtonStyle                     ComboStyle;                                        // 0x108(0x3B8)(Edit, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemSet;                                         // 0x4C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_73C1[0x40];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UUserWidget*>                   WidgetsRef;                                        // 0x510(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_73C2[0x78];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UCustomComboBox* GetDefaultObj();

	void SortItems();
	void SetSelectedName(const class FString& Name, bool bApplyToCombo);
	void SetSelectedIndex(int32 Index, bool bApplyToCombo);
	void SetOpen(bool bOpen);
	void SetFilter(const class FString& FilterText);
	bool IsOpen();
	void HideSearchBox(bool bHide);
	class UUserWidget* GetSelectedWidget();
	void ClearChildren();
	void AddItem(const class FString& Name, class UUserWidget* Widget);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DamageFunctionLibrary
class UDamageFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UDamageFunctionLibrary* GetDefaultObj();

	bool PrepareProjectileDamage(class AActor* Instigator, class AActor* Projectile);
	int32 PredictResistedDamage(class AActor* Attacker, class AActor* Weapon, class AActor* Defender, bool bKillCam);
	TMap<enum class EIcarusDamageType, int32> PredictDamage(class AActor* Attacker, class AActor* Weapon, bool bUseDamageVariation);
	bool PartiallyRepairItem(class AIcarusItem* ItemInstance, float RepairPercent);
	void LargeScaleDestroy(struct FLargeScaleDestroyParams& Params, class AActor* Instigator);
	bool IsCriticalHit(class AActor* Defender, struct FHitResult& HitInfo, struct FCriticalHitAreasEnum* CriticalHitType);
	float GetDefenderBasedDamageMultiplier(class AActor* Causer, class AActor* Defender);
	enum class EIcarusDamageType GetDamageTypeFromEvent(struct FDamageEvent& DamageEvent);
	TSubclassOf<class UDamageType> GetDamageTypeClass(enum class EIcarusDamageType DamageType);
	struct FColor GetDamageColor(enum class EIcarusDamageType DamageType);
	bool GetCriticalHitArea(class AActor* Defender, struct FHitResult& HitInfo, struct FCriticalHitAreasRowHandle* CriticalHitArea);
	int32 GetCriticalDamagePlusPercent(class AActor* Attacker);
	struct FStatContainer GetBestStatContainer(class AActor* Attacker);
	int32 GetAttackerBasedResistance(class AActor* Causer, class AActor* Defender);
	bool DealSelfDamage(enum class EIcarusDamageType DamageType, int32 DamageAmount, class AActor* Defender);
	bool DealRadialDamageWithFalloff(class UObject* WorldContextObject, enum class EIcarusDamageType DamageType, float BaseDamage, float MinimumDamage, struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TArray<class AActor*>& IgnoreActors, TArray<class AActor*>* HitActors, class AActor* Attacker, class AController* AttackInstigator, enum class ECollisionChannel DamagePreventionChannel);
	bool DealRadialDamage(class UObject* WorldContextObject, enum class EIcarusDamageType DamageType, float BaseDamage, struct FVector& Origin, float DamageRadius, TArray<class AActor*>& IgnoreActors, class AActor* Attacker, class AController* AttackInstigator, bool bDoFullDamage, enum class ECollisionChannel DamagePreventionChannel);
	bool DealPointDamage(class AActor* Attacker, class AActor* Weapon, class AActor* Defender, bool bIsKillCam, struct FVector& HitNormal, struct FHitResult& HitInfo, bool* WasCriticalHit);
	bool DealFlatDamage(enum class EIcarusDamageType DamageType, int32 DamageAmount, class AActor* Defender, class AController* Instigator);
	bool DealExplosiveDamage(class AActor* Attacker, class AController* Instigator, class AActor* Defender, int32 Value, struct FHitResult& HitInfo);
	bool DealDamageToInventoryItems(enum class EIcarusDamageType DamageType, int32 DamageAmount, class UInventory* Inventory, const struct FGameplayTagQuery& TagQuery);
	bool DealDamageToInventoryItem(enum class EIcarusDamageType DamageType, int32 DamageAmount, class UInventory* Inventory, int32 Location);
	bool DealDamage(class AActor* Attacker, class AActor* Weapon, class AActor* Defender);
	bool DealCollisionDamage(class AActor* Attacker, class AActor* Defender, float ImpulseDamage, struct FHitResult& HitInfo);
	bool CheckForStealthHit(enum class EIcarusDamageType DamageType, class AActor* Causer, class AActor* Defender);
	int32 CalculateDamageTaken(enum class EIcarusDamageType DamageType, int32 DamageValue, class AActor* Causer, class AActor* Defender);
	void AppendNewCriticalHitAreas(TMap<class UPrimitiveComponent*, struct FCriticalHitAreasEnum> InitialHitAreas, TMap<class UPrimitiveComponent*, struct FCriticalHitAreasEnum> AreasToAppend, TMap<class UPrimitiveComponent*, struct FCriticalHitAreasEnum>* CombinedAreas);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DamageTypeInfoLibrary
class UDamageTypeInfoLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDamageTypeInfoLibrary* GetDefaultObj();

	struct FDamageTypeInfoRowHandle StructToRowHandle(const struct FDamageTypeInfoEnum& EnumValue);
	class FName StructToName(const struct FDamageTypeInfoEnum& EnumValue);
	int32 StructToInt(const struct FDamageTypeInfoEnum& EnumValue);
	struct FDamageTypeInfoEnum RowHandleToStruct(const struct FDamageTypeInfoRowHandle& RowHandle);
	void RemoveRowFromDamageTypeInfoTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDamageTypeInfoEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDamageTypeInfoEnum& A, const struct FDamageTypeInfoEnum& B);
	struct FDamageTypeInfoEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDamageTypeInfoRowHandle MakeLiteralDamageTypeInfo(const struct FDamageTypeInfoRowHandle& RowHandle);
	struct FDamageTypeInfoRowHandle MakeDamageTypeInfoFromIndex(int32 Index);
	struct FDamageTypeInfoEnum MakeDamageTypeInfoEnum(const struct FDamageTypeInfoEnum& Enum);
	struct FDamageTypeInfoRowHandle MakeDamageTypeInfo(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDamageTypeInfoEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDamageTypeInfoStruct(const struct FDamageTypeInfoRowHandle& RowHandle, struct FDamageTypeInfo* DamageTypeInfo, enum class EValid* Paths);
	bool EqualEqual_FDamageTypeInfoRowHandleFDamageTypeInfoRowHandle(const struct FDamageTypeInfoRowHandle& RowHandleA, const struct FDamageTypeInfoRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDamageTypeInfoEnum& A, const struct FDamageTypeInfoEnum& B);
	struct FDamageTypeInfoRowHandle CastToDamageTypeInfoRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDamageTypeInfoEnum(const struct FDamageTypeInfoEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDamageTypeInfoTable(class FName Name, const struct FDamageTypeInfo& Data, struct FDamageTypeInfoRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DamageTypeInfoTable
class UDamageTypeInfoTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDamageTypeInfoTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DataMigratorBase
class UDataMigratorBase : public UObject
{
public:

	static class UClass* StaticClass();
	static class UDataMigratorBase* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DataMigratorAccolades
class UDataMigratorAccolades : public UDataMigratorBase
{
public:

	static class UClass* StaticClass();
	static class UDataMigratorAccolades* GetDefaultObj();

};

// 0xA0 (0xC8 - 0x28)
// Class Icarus.PlayerTrackerSaveData
class UPlayerTrackerSaveData : public USaveGame
{
public:
	TMap<struct FPlayerTrackersRowHandle, int32> PlayerTrackers;                                    // 0x28(0x50)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	TMap<struct FPlayerTrackersRowHandle, struct FTrackerTaskListProgress> PlayerTaskListTrackers;                            // 0x78(0x50)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPlayerTrackerSaveData* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DataMigratorLoadoutGUIDs
class UDataMigratorLoadoutGUIDs : public UDataMigratorBase
{
public:

	static class UClass* StaticClass();
	static class UDataMigratorLoadoutGUIDs* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DataMigratorManager
class UDataMigratorManager : public UObject
{
public:

	static class UClass* StaticClass();
	static class UDataMigratorManager* GetDefaultObj();

	bool PerformMigrations();
};

// 0xF0 (0x118 - 0x28)
// Class Icarus.DataTableValidationLibrary
class UDataTableValidationLibrary : public UObject
{
public:
	uint8                                        Pad_745A[0x98];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class UClass*, TWeakObjectPtr<class AActor>> TempTestActors;                                    // 0xC0(0x50)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class UWorld*                                TempTestWorld;                                     // 0x110(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UDataTableValidationLibrary* GetDefaultObj();

	void Warn(const class FString& Message);
	void Validate_WorldData_RowHandle(struct FWorldDataRowHandle& RowHandle);
	void Validate_WorldBosses_RowHandle(struct FWorldBossesRowHandle& RowHandle);
	void Validate_WorkshopItems_RowHandle(struct FWorkshopItemsRowHandle& RowHandle);
	void Validate_Weight_RowHandle(struct FWeightRowHandle& RowHandle);
	void Validate_WeatherTierIcon_RowHandle(struct FWeatherTierIconRowHandle& RowHandle);
	void Validate_WeatherPools_RowHandle(struct FWeatherPoolsRowHandle& RowHandle);
	void Validate_WeatherEvents_RowHandle(struct FWeatherEventsRowHandle& RowHandle);
	void Validate_WeatherBiomeGroups_RowHandle(struct FWeatherBiomeGroupsRowHandle& RowHandle);
	void Validate_WeatherActions_RowHandle(struct FWeatherActionsRowHandle& RowHandle);
	void Validate_WaterSetup_RowHandle(struct FWaterSetupRowHandle& RowHandle);
	void Validate_Water_RowHandle(struct FWaterRowHandle& RowHandle);
	void Validate_VoxelSetupData_RowHandle(struct FVoxelSetupDataRowHandle& RowHandle);
	void Validate_VoxelMaterialMap_RowHandle(struct FVoxelMaterialMapRowHandle& RowHandle);
	void Validate_VoxelDistributionRegion_RowHandle(struct FVoxelDistributionRegionRowHandle& RowHandle);
	void Validate_VocalisationSettings_RowHandle(struct FVocalisationSettingsRowHandle& RowHandle);
	void Validate_Vocalisations_RowHandle(struct FVocalisationsRowHandle& RowHandle);
	void Validate_ValidInteractQueries_RowHandle(struct FValidInteractQueriesRowHandle& RowHandle);
	void Validate_ValidHitTypes_RowHandle(struct FValidHitTypesRowHandle& RowHandle);
	void Validate_ValidHitQueries_RowHandle(struct FValidHitQueriesRowHandle& RowHandle);
	void Validate_ValidAmmoTypes_RowHandle(struct FValidAmmoTypesRowHandle& RowHandle);
	void Validate_Uses_RowHandle(struct FUsesRowHandle& RowHandle);
	void Validate_Usable_RowHandle(struct FUsableRowHandle& RowHandle);
	void Validate_Turret_RowHandle(struct FTurretRowHandle& RowHandle);
	void Validate_TreeAudioData_RowHandle(struct FTreeAudioDataRowHandle& RowHandle);
	void Validate_Transmutable_RowHandle(struct FTransmutableRowHandle& RowHandle);
	void Validate_ToolTypes_RowHandle(struct FToolTypesRowHandle& RowHandle);
	void Validate_ToolDamage_RowHandle(struct FToolDamageRowHandle& RowHandle);
	void Validate_TimeOfDay_RowHandle(struct FTimeOfDayRowHandle& RowHandle);
	void Validate_TimelineRanks_RowHandle(struct FTimelineRanksRowHandle& RowHandle);
	void Validate_Thermal_RowHandle(struct FThermalRowHandle& RowHandle);
	void Validate_TerrainZoneAudioData_RowHandle(struct FTerrainZoneAudioDataRowHandle& RowHandle);
	void Validate_Terrains_RowHandle(struct FTerrainsRowHandle& RowHandle);
	void Validate_Tames_RowHandle(struct FTamesRowHandle& RowHandle);
	void Validate_TamedCreatureModifiers_RowHandle(struct FTamedCreatureModifiersRowHandle& RowHandle);
	void Validate_TalentViews_RowHandle(struct FTalentViewsRowHandle& RowHandle);
	void Validate_TalentTrees_RowHandle(struct FTalentTreesRowHandle& RowHandle);
	void Validate_Talents_RowHandle(struct FTalentsRowHandle& RowHandle);
	void Validate_TalentRanks_RowHandle(struct FTalentRanksRowHandle& RowHandle);
	void Validate_TalentModelViews_RowHandle(struct FTalentModelViewsRowHandle& RowHandle);
	void Validate_TalentModels_RowHandle(struct FTalentModelsRowHandle& RowHandle);
	void Validate_TalentArchetypes_RowHandle(struct FTalentArchetypesRowHandle& RowHandle);
	void Validate_TagQueries_RowHandle(struct FTagQueriesRowHandle& RowHandle);
	void Validate_SurvivalTriggers_RowHandle(struct FSurvivalTriggersRowHandle& RowHandle);
	void Validate_Surfaces_RowHandle(struct FSurfacesRowHandle& RowHandle);
	void Validate_Stats_RowHandle(struct FStatsRowHandle& RowHandle);
	void Validate_Statistics_RowHandle(struct FStatisticsRowHandle& RowHandle);
	void Validate_StatGameplayTags_RowHandle(struct FStatGameplayTagsRowHandle& RowHandle);
	void Validate_StatCategories_RowHandle(struct FStatCategoriesRowHandle& RowHandle);
	void Validate_StatAfflictions_RowHandle(struct FStatAfflictionsRowHandle& RowHandle);
	void Validate_StaminaActionCosts_RowHandle(struct FStaminaActionCostsRowHandle& RowHandle);
	void Validate_SortTypePriority_RowHandle(struct FSortTypePriorityRowHandle& RowHandle);
	void Validate_Slotable_RowHandle(struct FSlotableRowHandle& RowHandle);
	void Validate_SessionFlags_RowHandle(struct FSessionFlagsRowHandle& RowHandle);
	void Validate_SeedModifications_RowHandle(struct FSeedModificationsRowHandle& RowHandle);
	void Validate_ScriptedEvents_RowHandle(struct FScriptedEventsRowHandle& RowHandle);
	void Validate_ScalingRules_RowHandle(struct FScalingRulesRowHandle& RowHandle);
	void Validate_Saddles_RowHandle(struct FSaddlesRowHandle& RowHandle);
	void Validate_Rulesets_RowHandle(struct FRulesetsRowHandle& RowHandle);
	void Validate_RTXGIVolumes_RowHandle(struct FRTXGIVolumesRowHandle& RowHandle);
	void Validate_RowHandle(struct FRowHandle& RowHandle);
	void Validate_Rocketable_RowHandle(struct FRocketableRowHandle& RowHandle);
	void Validate_RiverAudioData_RowHandle(struct FRiverAudioDataRowHandle& RowHandle);
	void Validate_ResourceNodeAudioData_RowHandle(struct FResourceNodeAudioDataRowHandle& RowHandle);
	void Validate_RepGraphClassSettings_RowHandle(struct FRepGraphClassSettingsRowHandle& RowHandle);
	void Validate_RepGraphClassPolicies_RowHandle(struct FRepGraphClassPoliciesRowHandle& RowHandle);
	void Validate_RecipeSets_RowHandle(struct FRecipeSetsRowHandle& RowHandle);
	void Validate_RCONCommand_RowHandle(struct FRCONCommandRowHandle& RowHandle);
	void Validate_RangedWeaponData_RowHandle(struct FRangedWeaponDataRowHandle& RowHandle);
	void Validate_RadialOptions_RowHandle(struct FRadialOptionsRowHandle& RowHandle);
	void Validate_RadialMenuData_RowHandle(struct FRadialMenuDataRowHandle& RowHandle);
	void Validate_QuickMove_RowHandle(struct FQuickMoveRowHandle& RowHandle);
	void Validate_QuestWeatherModifiers_RowHandle(struct FQuestWeatherModifiersRowHandle& RowHandle);
	void Validate_QuestVocalisationModifiers_RowHandle(struct FQuestVocalisationModifiersRowHandle& RowHandle);
	void Validate_Quests_RowHandle(struct FQuestsRowHandle& RowHandle);
	void Validate_QuestQueries_RowHandle(struct FQuestQueriesRowHandle& RowHandle);
	void Validate_QuestEvents_RowHandle(struct FQuestEventsRowHandle& RowHandle);
	void Validate_QuestEnemyModifiers_RowHandle(struct FQuestEnemyModifiersRowHandle& RowHandle);
	void Validate_ProspectStats_RowHandle(struct FProspectStatsRowHandle& RowHandle);
	void Validate_ProspectList_RowHandle(struct FProspectListRowHandle& RowHandle);
	void Validate_ProspectForecast_RowHandle(struct FProspectForecastRowHandle& RowHandle);
	void Validate_ProjectileTypes_RowHandle(struct FProjectileTypesRowHandle& RowHandle);
	void Validate_ProcessorRecipes_RowHandle(struct FProcessorRecipesRowHandle& RowHandle);
	void Validate_Processing_RowHandle(struct FProcessingRowHandle& RowHandle);
	void Validate_PreviewCameraSettings_RowHandle(struct FPreviewCameraSettingsRowHandle& RowHandle);
	void Validate_PrebuiltStructures_RowHandle(struct FPrebuiltStructuresRowHandle& RowHandle);
	void Validate_PlayerTrackers_RowHandle(struct FPlayerTrackersRowHandle& RowHandle);
	void Validate_PlayerTrackerCategories_RowHandle(struct FPlayerTrackerCategoriesRowHandle& RowHandle);
	void Validate_PlayerIdentity_RowHandle(struct FPlayerIdentityRowHandle& RowHandle);
	void Validate_PlayerFootstepAudioData_RowHandle(struct FPlayerFootstepAudioDataRowHandle& RowHandle);
	void Validate_PlayerAccoladeCategories_RowHandle(struct FPlayerAccoladeCategoriesRowHandle& RowHandle);
	void Validate_Paintings_RowHandle(struct FPaintingsRowHandle& RowHandle);
	void Validate_Oxygen_RowHandle(struct FOxygenRowHandle& RowHandle);
	void Validate_Outposts_RowHandle(struct FOutpostsRowHandle& RowHandle);
	void Validate_OreDeposit_RowHandle(struct FOreDepositRowHandle& RowHandle);
	void Validate_OrchestrationStateFlags_RowHandle(struct FOrchestrationStateFlagsRowHandle& RowHandle);
	void Validate_OrchestrationEvents_RowHandle(struct FOrchestrationEventsRowHandle& RowHandle);
	void Validate_MusicTrackStateGroups_RowHandle(struct FMusicTrackStateGroupsRowHandle& RowHandle);
	void Validate_MusicTracks_RowHandle(struct FMusicTracksRowHandle& RowHandle);
	void Validate_MusicQuestConditions_RowHandle(struct FMusicQuestConditionsRowHandle& RowHandle);
	void Validate_MusicLocationConditions_RowHandle(struct FMusicLocationConditionsRowHandle& RowHandle);
	void Validate_Mounts_RowHandle(struct FMountsRowHandle& RowHandle);
	void Validate_ModifierStates_RowHandle(struct FModifierStatesRowHandle& RowHandle);
	void Validate_ModifierStateAudioData_RowHandle(struct FModifierStateAudioDataRowHandle& RowHandle);
	void Validate_MetaResourceNodes_RowHandle(struct FMetaResourceNodesRowHandle& RowHandle);
	void Validate_MetaCurrency_RowHandle(struct FMetaCurrencyRowHandle& RowHandle);
	void Validate_Meshable_RowHandle(struct FMeshableRowHandle& RowHandle);
	void Validate_MapSearchArea_RowHandle(struct FMapSearchAreaRowHandle& RowHandle);
	void Validate_MapIcons_RowHandle(struct FMapIconsRowHandle& RowHandle);
	void Validate_LogCategories_RowHandle(struct FLogCategoriesRowHandle& RowHandle);
	void Validate_LivingItemUpgrades_RowHandle(struct FLivingItemUpgradesRowHandle& RowHandle);
	void Validate_LivingItemShopItems_RowHandle(struct FLivingItemShopItemsRowHandle& RowHandle);
	void Validate_LivingItem_RowHandle(struct FLivingItemRowHandle& RowHandle);
	void Validate_LevelSequences_RowHandle(struct FLevelSequencesRowHandle& RowHandle);
	void Validate_Languages_RowHandle(struct FLanguagesRowHandle& RowHandle);
	void Validate_Keys_RowHandle(struct FKeysRowHandle& RowHandle);
	void Validate_KeyIcons_RowHandle(struct FKeyIconsRowHandle& RowHandle);
	void Validate_Keybindings_RowHandle(struct FKeybindingsRowHandle& RowHandle);
	void Validate_KeybindContexts_RowHandle(struct FKeybindContextsRowHandle& RowHandle);
	void Validate_ItemWeightStatQueries_RowHandle(struct FItemWeightStatQueriesRowHandle& RowHandle);
	void Validate_ItemTraitMasks_RowHandle(struct FItemTraitMasksRowHandle& RowHandle);
	void Validate_ItemTemplate_RowHandle(struct FItemTemplateRowHandle& RowHandle);
	void Validate_ItemsStatic_RowHandle(struct FItemsStaticRowHandle& RowHandle);
	void Validate_ItemRewards_RowHandle(struct FItemRewardsRowHandle& RowHandle);
	void Validate_ItemRanks_RowHandle(struct FItemRanksRowHandle& RowHandle);
	void Validate_ItemClassificationsIcons_RowHandle(struct FItemClassificationsIconsRowHandle& RowHandle);
	void Validate_ItemAudioData_RowHandle(struct FItemAudioDataRowHandle& RowHandle);
	void Validate_ItemAttachment_RowHandle(struct FItemAttachmentRowHandle& RowHandle);
	void Validate_ItemAnimations_RowHandle(struct FItemAnimationsRowHandle& RowHandle);
	void Validate_Itemable_RowHandle(struct FItemableRowHandle& RowHandle);
	void Validate_InventoryInfo_RowHandle(struct FInventoryInfoRowHandle& RowHandle);
	void Validate_InventoryID_RowHandle(struct FInventoryIDRowHandle& RowHandle);
	void Validate_InventoryContainer_RowHandle(struct FInventoryContainerRowHandle& RowHandle);
	void Validate_Inventory_RowHandle(struct FInventoryRowHandle& RowHandle);
	void Validate_Interactions_RowHandle(struct FInteractionsRowHandle& RowHandle);
	void Validate_Interactable_RowHandle(struct FInteractableRowHandle& RowHandle);
	void Validate_IcarusAttachments_RowHandle(struct FIcarusAttachmentsRowHandle& RowHandle);
	void Validate_HuntingSetup_RowHandle(struct FHuntingSetupRowHandle& RowHandle);
	void Validate_HuntingClueSetup_RowHandle(struct FHuntingClueSetupRowHandle& RowHandle);
	void Validate_HordeWave_RowHandle(struct FHordeWaveRowHandle& RowHandle);
	void Validate_Horde_RowHandle(struct FHordeRowHandle& RowHandle);
	void Validate_Hitable_RowHandle(struct FHitableRowHandle& RowHandle);
	void Validate_Hints_RowHandle(struct FHintsRowHandle& RowHandle);
	void Validate_Highlightable_RowHandle(struct FHighlightableRowHandle& RowHandle);
	void Validate_GraphicsTierDescriptionMods_RowHandle(struct FGraphicsTierDescriptionModsRowHandle& RowHandle);
	void Validate_GraphicsTierDescription_RowHandle(struct FGraphicsTierDescriptionRowHandle& RowHandle);
	void Validate_GrantedAuras_RowHandle(struct FGrantedAurasRowHandle& RowHandle);
	void Validate_GOAPSetup_RowHandle(struct FGOAPSetupRowHandle& RowHandle);
	void Validate_GOAPProperties_RowHandle(struct FGOAPPropertiesRowHandle& RowHandle);
	void Validate_GOAPMotivations_RowHandle(struct FGOAPMotivationsRowHandle& RowHandle);
	void Validate_GOAPGoals_RowHandle(struct FGOAPGoalsRowHandle& RowHandle);
	void Validate_GOAPActions_RowHandle(struct FGOAPActionsRowHandle& RowHandle);
	void Validate_Generator_RowHandle(struct FGeneratorRowHandle& RowHandle);
	void Validate_GameplayConfig_RowHandle(struct FGameplayConfigRowHandle& RowHandle);
	void Validate_Fuel_RowHandle(struct FFuelRowHandle& RowHandle);
	void Validate_FoodTypes_RowHandle(struct FFoodTypesRowHandle& RowHandle);
	void Validate_Focusable_RowHandle(struct FFocusableRowHandle& RowHandle);
	void Validate_FLODDescriptions_RowHandle(struct FFLODDescriptionsRowHandle& RowHandle);
	void Validate_Floatable_RowHandle(struct FFloatableRowHandle& RowHandle);
	void Validate_Flammable_RowHandle(struct FFlammableRowHandle& RowHandle);
	void Validate_FishSpawnZones_RowHandle(struct FFishSpawnZonesRowHandle& RowHandle);
	void Validate_FishSpawnConfig_RowHandle(struct FFishSpawnConfigRowHandle& RowHandle);
	void Validate_FishSetup_RowHandle(struct FFishSetupRowHandle& RowHandle);
	void Validate_FishData_RowHandle(struct FFishDataRowHandle& RowHandle);
	void Validate_FirearmData_RowHandle(struct FFirearmDataRowHandle& RowHandle);
	void Validate_FirearmAudioData_RowHandle(struct FFirearmAudioDataRowHandle& RowHandle);
	void Validate_Fillable_RowHandle(struct FFillableRowHandle& RowHandle);
	void Validate_FieldGuideSets_RowHandle(struct FFieldGuideSetsRowHandle& RowHandle);
	void Validate_FieldGuideMetaData_RowHandle(struct FFieldGuideMetaDataRowHandle& RowHandle);
	void Validate_FieldGuideCategories_RowHandle(struct FFieldGuideCategoriesRowHandle& RowHandle);
	void Validate_FeatureLevels_RowHandle(struct FFeatureLevelsRowHandle& RowHandle);
	void Validate_FarmingSeeds_RowHandle(struct FFarmingSeedsRowHandle& RowHandle);
	void Validate_FarmingGrowthStates_RowHandle(struct FFarmingGrowthStatesRowHandle& RowHandle);
	void Validate_Farmable_RowHandle(struct FFarmableRowHandle& RowHandle);
	void Validate_FactionMissions_RowHandle(struct FFactionMissionsRowHandle& RowHandle);
	void Validate_FactionInfo_RowHandle(struct FFactionInfoRowHandle& RowHandle);
	void Validate_ExperienceEvents_RowHandle(struct FExperienceEventsRowHandle& RowHandle);
	void Validate_Experience_RowHandle(struct FExperienceRowHandle& RowHandle);
	void Validate_ExoticSpawn_RowHandle(struct FExoticSpawnRowHandle& RowHandle);
	void Validate_ErrorCodes_RowHandle(struct FErrorCodesRowHandle& RowHandle);
	void Validate_Equippable_RowHandle(struct FEquippableRowHandle& RowHandle);
	void Validate_EpicCreatures_RowHandle(struct FEpicCreaturesRowHandle& RowHandle);
	void Validate_Energy_RowHandle(struct FEnergyRowHandle& RowHandle);
	void Validate_DynamicQuests_RowHandle(struct FDynamicQuestsRowHandle& RowHandle);
	void Validate_DynamicQuestRewards_RowHandle(struct FDynamicQuestRewardsRowHandle& RowHandle);
	void Validate_DynamicQuestRewardItems_RowHandle(struct FDynamicQuestRewardItemsRowHandle& RowHandle);
	void Validate_Durable_RowHandle(struct FDurableRowHandle& RowHandle);
	void Validate_DropShipSequences_RowHandle(struct FDropShipSequencesRowHandle& RowHandle);
	void Validate_DropShipActions_RowHandle(struct FDropShipActionsRowHandle& RowHandle);
	void Validate_DropGroups_RowHandle(struct FDropGroupsRowHandle& RowHandle);
	void Validate_DLCPackageData_RowHandle(struct FDLCPackageDataRowHandle& RowHandle);
	void Validate_DialogueSpeaker_RowHandle(struct FDialogueSpeakerRowHandle& RowHandle);
	void Validate_DialoguePool_RowHandle(struct FDialoguePoolRowHandle& RowHandle);
	void Validate_Dialogue_RowHandle(struct FDialogueRowHandle& RowHandle);
	void Validate_DeployableTypes_RowHandle(struct FDeployableTypesRowHandle& RowHandle);
	void Validate_DeployableSetup_RowHandle(struct FDeployableSetupRowHandle& RowHandle);
	void Validate_Deployable_RowHandle(struct FDeployableRowHandle& RowHandle);
	void Validate_Decayable_RowHandle(struct FDecayableRowHandle& RowHandle);
	void Validate_DataTable(class UIcarusDataTable* DataTable);
	void Validate_DamageTypeInfo_RowHandle(struct FDamageTypeInfoRowHandle& RowHandle);
	void Validate_CurrencyConversions_RowHandle(struct FCurrencyConversionsRowHandle& RowHandle);
	void Validate_CriticalHitSetup_RowHandle(struct FCriticalHitSetupRowHandle& RowHandle);
	void Validate_CriticalHitAreas_RowHandle(struct FCriticalHitAreasRowHandle& RowHandle);
	void Validate_CriticalHitAreaAudioData_RowHandle(struct FCriticalHitAreaAudioDataRowHandle& RowHandle);
	void Validate_CreatureAudioThreatData_RowHandle(struct FCreatureAudioThreatDataRowHandle& RowHandle);
	void Validate_CraftingModifications_RowHandle(struct FCraftingModificationsRowHandle& RowHandle);
	void Validate_CraftingAudioData_RowHandle(struct FCraftingAudioDataRowHandle& RowHandle);
	void Validate_ContextMenuGroupTypes_RowHandle(struct FContextMenuGroupTypesRowHandle& RowHandle);
	void Validate_Consumable_RowHandle(struct FConsumableRowHandle& RowHandle);
	void Validate_Combustible_RowHandle(struct FCombustibleRowHandle& RowHandle);
	void Validate_CharacterVoices_RowHandle(struct FCharacterVoicesRowHandle& RowHandle);
	void Validate_CharacterTimeline_RowHandle(struct FCharacterTimelineRowHandle& RowHandle);
	void Validate_CharacterStartingStats_RowHandle(struct FCharacterStartingStatsRowHandle& RowHandle);
	void Validate_CharacterPerks_RowHandle(struct FCharacterPerksRowHandle& RowHandle);
	void Validate_CharacterGrowth_RowHandle(struct FCharacterGrowthRowHandle& RowHandle);
	void Validate_CharacterFlags_RowHandle(struct FCharacterFlagsRowHandle& RowHandle);
	void Validate_CharacterCreationData_RowHandle(struct FCharacterCreationDataRowHandle& RowHandle);
	void Validate_Challenges_RowHandle(struct FChallengesRowHandle& RowHandle);
	void Validate_BuildingTypes_RowHandle(struct FBuildingTypesRowHandle& RowHandle);
	void Validate_BuildingStability_RowHandle(struct FBuildingStabilityRowHandle& RowHandle);
	void Validate_BuildingSkins_RowHandle(struct FBuildingSkinsRowHandle& RowHandle);
	void Validate_BuildingPieces_RowHandle(struct FBuildingPiecesRowHandle& RowHandle);
	void Validate_BuildingLookup_RowHandle(struct FBuildingLookupRowHandle& RowHandle);
	void Validate_BuildableAudioData_RowHandle(struct FBuildableAudioDataRowHandle& RowHandle);
	void Validate_Buildable_RowHandle(struct FBuildableRowHandle& RowHandle);
	void Validate_BreakableRockData_RowHandle(struct FBreakableRockDataRowHandle& RowHandle);
	void Validate_BlueprintUnlocks_RowHandle(struct FBlueprintUnlocksRowHandle& RowHandle);
	void Validate_Biomes_RowHandle(struct FBiomesRowHandle& RowHandle);
	void Validate_BiomeAudioData_RowHandle(struct FBiomeAudioDataRowHandle& RowHandle);
	void Validate_BestiaryTraitTypes_RowHandle(struct FBestiaryTraitTypesRowHandle& RowHandle);
	void Validate_BestiaryTraits_RowHandle(struct FBestiaryTraitsRowHandle& RowHandle);
	void Validate_BestiaryPoints_RowHandle(struct FBestiaryPointsRowHandle& RowHandle);
	void Validate_BestiaryData_RowHandle(struct FBestiaryDataRowHandle& RowHandle);
	void Validate_Ballistic_RowHandle(struct FBallisticRowHandle& RowHandle);
	void Validate_BagPriority_RowHandle(struct FBagPriorityRowHandle& RowHandle);
	void Validate_AutonomousSpawns_RowHandle(struct FAutonomousSpawnsRowHandle& RowHandle);
	void Validate_AttachmentIcons_RowHandle(struct FAttachmentIconsRowHandle& RowHandle);
	void Validate_Atmospheres_RowHandle(struct FAtmospheresRowHandle& RowHandle);
	void Validate_AssetReferences_RowHandle(struct FAssetReferencesRowHandle& RowHandle);
	void Validate_ArmourSets_RowHandle(struct FArmourSetsRowHandle& RowHandle);
	void Validate_ArmourSetBonus_RowHandle(struct FArmourSetBonusRowHandle& RowHandle);
	void Validate_Armour_RowHandle(struct FArmourRowHandle& RowHandle);
	void Validate_AmmoTypes_RowHandle(struct FAmmoTypesRowHandle& RowHandle);
	void Validate_Alterations_RowHandle(struct FAlterationsRowHandle& RowHandle);
	void Validate_AISpawnZones_RowHandle(struct FAISpawnZonesRowHandle& RowHandle);
	void Validate_AISpawnRules_RowHandle(struct FAISpawnRulesRowHandle& RowHandle);
	void Validate_AISpawnConfig_RowHandle(struct FAISpawnConfigRowHandle& RowHandle);
	void Validate_AISetup_RowHandle(struct FAISetupRowHandle& RowHandle);
	void Validate_AIRelationships_RowHandle(struct FAIRelationshipsRowHandle& RowHandle);
	void Validate_AIGrowth_RowHandle(struct FAIGrowthRowHandle& RowHandle);
	void Validate_AIEvents_RowHandle(struct FAIEventsRowHandle& RowHandle);
	void Validate_AIDescriptors_RowHandle(struct FAIDescriptorsRowHandle& RowHandle);
	void Validate_AICreatureType_RowHandle(struct FAICreatureTypeRowHandle& RowHandle);
	void Validate_AIAudioData_RowHandle(struct FAIAudioDataRowHandle& RowHandle);
	void Validate_AfflictionChance_RowHandle(struct FAfflictionChanceRowHandle& RowHandle);
	void Validate_Actions_RowHandle(struct FActionsRowHandle& RowHandle);
	void Validate_Actionable_RowHandle(struct FActionableRowHandle& RowHandle);
	void Validate_AccountFlags_RowHandle(struct FAccountFlagsRowHandle& RowHandle);
	void Validate_Accolades_RowHandle(struct FAccoladesRowHandle& RowHandle);
	void Info(const class FString& Message);
	class AActor* GetOrSpawnTempTestActor(class UClass* ActorClass);
	void Fatal(const class FString& Message);
	void Error(const class FString& Message);
	void Detail(const class FString& Message);
};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.DecayableComponent
class UDecayableComponent : public UTraitComponent
{
public:
	int32                                        DecayTime;                                         // 0xD0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SpoilTime;                                         // 0xD4(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CurrentTime;                                       // 0xD8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7461[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDecayableComponent* GetDefaultObj();

	bool GetDecayableData(struct FDecayableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DecayableLibrary
class UDecayableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDecayableLibrary* GetDefaultObj();

	struct FDecayableRowHandle StructToRowHandle(const struct FDecayableEnum& EnumValue);
	class FName StructToName(const struct FDecayableEnum& EnumValue);
	int32 StructToInt(const struct FDecayableEnum& EnumValue);
	struct FDecayableEnum RowHandleToStruct(const struct FDecayableRowHandle& RowHandle);
	void RemoveRowFromDecayableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDecayableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDecayableEnum& A, const struct FDecayableEnum& B);
	struct FDecayableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDecayableRowHandle MakeLiteralDecayable(const struct FDecayableRowHandle& RowHandle);
	struct FDecayableRowHandle MakeDecayableFromIndex(int32 Index);
	struct FDecayableEnum MakeDecayableEnum(const struct FDecayableEnum& Enum);
	struct FDecayableRowHandle MakeDecayable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDecayableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDecayableStruct(const struct FDecayableRowHandle& RowHandle, struct FDecayableData* Decayable, enum class EValid* Paths);
	bool EqualEqual_FDecayableRowHandleFDecayableRowHandle(const struct FDecayableRowHandle& RowHandleA, const struct FDecayableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDecayableEnum& A, const struct FDecayableEnum& B);
	struct FDecayableRowHandle CastToDecayableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDecayableEnum(const struct FDecayableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDecayableTable(class FName Name, const struct FDecayableData& Data, struct FDecayableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DecayableTable
class UDecayableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDecayableTable* GetDefaultObj();

};

// 0x0 (0x308 - 0x308)
// Class Icarus.IcarusGameModeBase
class AIcarusGameModeBase : public AGameMode
{
public:

	static class UClass* StaticClass();
	static class AIcarusGameModeBase* GetDefaultObj();

	void UnbanPlayer(class APawn* Executor, const class FString& IdOrName);
	void SendServerMessage(const class FString& Message);
	void PrintAIDebug(class APawn* Executor);
	void OnConnectedPlayerInitialised(struct FConnectedPlayer& ConnectedPlayer);
	void KickPlayer(class APawn* Executor, const class FString& IdOrName, class FText Reason);
	void Help(class APawn* Executor);
	class AIcarusGameSession* GetIcarusGameSession();
	void ForceErrorCmd(int32 InErrorNumber, int32 ErrorDestination, int32 ErrorAction);
	void BanPlayer(class APawn* Executor, const class FString& IdOrName, class FText Reason);
	void AdminSay(class APawn* Executor, const class FString& Message);
	void AdminLogin(class APawn* Executor, const class FString& Password);
};

// 0x40 (0x348 - 0x308)
// Class Icarus.DedicatedServerEntryGameMode
class ADedicatedServerEntryGameMode : public AIcarusGameModeBase
{
public:
	uint8                                        Pad_7484[0x40];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ADedicatedServerEntryGameMode* GetDefaultObj();

	bool ResumeProspect();
	void OnGenerateProspectSuccess(struct FResGenerateProspects& GenerateProspectResponse);
	void OnGenerateProspectFailed(struct FResGenerateProspects& GenerateProspectResponse);
	void OnClaimProspectSuccess(struct FResClaimProspect& ClaimProspectResponse);
	void OnClaimProspectFailed(struct FResClaimProspect& ClaimProspectResponse);
	bool LoadProspect(const class FString& ProspectID);
	bool CreateProspect(const class FString& ProspectName, int32 ProspectDifficulty, bool bHardcore, const class FString& ProspectIdOverride);
	void CommitMapChange();
};

// 0x80 (0xB8 - 0x38)
// Class Icarus.DedicatedServerSettings
class UDedicatedServerSettings : public UDeveloperSettings
{
public:
	class FString                                SessionName;                                       // 0x38(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                JoinPassword;                                      // 0x48(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxPlayers;                                        // 0x58(0x4)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ShutdownIfNotJoinedFor;                            // 0x5C(0x4)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ShutdownIfEmptyFor;                                // 0x60(0x4)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7485[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                AdminPassword;                                     // 0x68(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                LoadProspect;                                      // 0x78(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                CreateProspect;                                    // 0x88(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ResumeProspect;                                    // 0x98(0x1)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7487[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FString                                LastProspectName;                                  // 0xA0(0x10)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowNonAdminsToLaunchProspects;                   // 0xB0(0x1)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowNonAdminsToDeleteProspects;                   // 0xB1(0x1)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7488[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDedicatedServerSettings* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DensityAudioInterface
class IDensityAudioInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IDensityAudioInterface* GetDefaultObj();

	bool WantsDensityUpdate();
	void UpdateDensity(float Density);
	class UClass* GetTargetClass();
	struct FVector GetLocation();
	struct FVector2D GetDistanceRange();
};

// 0x50 (0x90 - 0x40)
// Class Icarus.DensityAudioSubsystem
class UDensityAudioSubsystem : public UTickableWorldSubsystem
{
public:
	TMap<class UClass*, struct FDensityAudioRecordSet> RecordSets;                                        // 0x40(0x50)(NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UDensityAudioSubsystem* GetDefaultObj();

	void UnsubscribeFromDensityUpdates(class UObject* Target);
	void SubscribeToDensityUpdates(class UObject* Target);
};

// 0x40 (0x5B0 - 0x570)
// Class Icarus.Deployable
class ADeployable : public AIcarusItem
{
public:
	uint8                                        Pad_7495[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                FoundationActor;                                   // 0x578(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADeployable*>                   AttachedDeployableActors;                          // 0x580(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	TArray<class AResourceNetwork*>              LinkedNetworks;                                    // 0x590(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class UResourceComponent*                    ResourceComponent;                                 // 0x5A0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bWantsDeployableTick;                              // 0x5A8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7496[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ADeployable* GetDefaultObj();

	void UpdateConnectedResourceNetworks(class UResourceNetworkComponent* Component);
	void SetFoundationActor(class AActor* NewFoundationActor);
	struct FSerializedDeployable SerializeForSaveGame(class AActor* Origin);
	void OnServer_DisconnectFromNetworks();
	void OnRestoreFoundationFromDatabase(class AIcarusActor* FoundationFromDatabase);
	void OnRep_FoundationActor();
	void OnRep_AttachedDeployableActors();
	bool HasAccessToResourceNetwork(enum class EIcarusResourceType Type, int32 Rate, bool bActivate);
	class UInventoryComponent* GetSlotInventory(enum class EObjectSlotType InventoryType);
	bool GetIsInCave();
	class ADeployable* GetAttachedDeployableParent();
	TArray<class ADeployable*> GetAttachedDeployableChildren();
	void FoundationActorUpdated();
	void DeployableTick(float DeltaSeconds);
	void Deployable_StopInteract(class AActor* Interactor);
	void Deployable_Interact(class AActor* Interactor);
	bool DeactivateResourceNetwork(enum class EIcarusResourceType Type);
	void AttachedDeployableActorsUpdated();
	bool ActorCanConnectToNetwork(enum class EIcarusResourceType Type);
};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.DeployableComponent
class UDeployableComponent : public UTraitComponent
{
public:
	FMulticastSparseDelegateProperty_            OnDeployed;                                        // 0xD0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, BlueprintCallable, NativeAccessSpecifierPublic)
	enum class EIcarusItemContext                SpawnContext;                                      // 0xD1(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7499[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UNavModifierComponent*                 NavModifierComponent;                              // 0xD8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UDeployableComponent* GetDefaultObj();

	void Server_RequestDeploy(const struct FTransform& DeployTransform, class AActor* FoundationActor, const struct FItemData& ItemData, int32 VariantIndex);
	void Multicast_DeploySuccess(class ADeployable* SpawnedDeployable);
	bool GetDeployableData(struct FDeployableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DeployableFoundationInterface
class IDeployableFoundationInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IDeployableFoundationInterface* GetDefaultObj();

	void RemoveAttachedDeployable(class ADeployable* Deployable);
	void AddAttachedDeployable(class ADeployable* Deployable);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DeployableLibrary
class UDeployableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDeployableLibrary* GetDefaultObj();

	struct FDeployableRowHandle StructToRowHandle(const struct FDeployableEnum& EnumValue);
	class FName StructToName(const struct FDeployableEnum& EnumValue);
	int32 StructToInt(const struct FDeployableEnum& EnumValue);
	struct FDeployableEnum RowHandleToStruct(const struct FDeployableRowHandle& RowHandle);
	void RemoveRowFromDeployableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDeployableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDeployableEnum& A, const struct FDeployableEnum& B);
	struct FDeployableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDeployableRowHandle MakeLiteralDeployable(const struct FDeployableRowHandle& RowHandle);
	struct FDeployableRowHandle MakeDeployableFromIndex(int32 Index);
	struct FDeployableEnum MakeDeployableEnum(const struct FDeployableEnum& Enum);
	struct FDeployableRowHandle MakeDeployable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDeployableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDeployableStruct(const struct FDeployableRowHandle& RowHandle, struct FDeployableData* Deployable, enum class EValid* Paths);
	bool EqualEqual_FDeployableRowHandleFDeployableRowHandle(const struct FDeployableRowHandle& RowHandleA, const struct FDeployableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDeployableEnum& A, const struct FDeployableEnum& B);
	struct FDeployableRowHandle CastToDeployableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDeployableEnum(const struct FDeployableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDeployableTable(class FName Name, const struct FDeployableData& Data, struct FDeployableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DeployableSetupLibrary
class UDeployableSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDeployableSetupLibrary* GetDefaultObj();

	struct FDeployableSetupRowHandle StructToRowHandle(const struct FDeployableSetupEnum& EnumValue);
	class FName StructToName(const struct FDeployableSetupEnum& EnumValue);
	int32 StructToInt(const struct FDeployableSetupEnum& EnumValue);
	struct FDeployableSetupEnum RowHandleToStruct(const struct FDeployableSetupRowHandle& RowHandle);
	void RemoveRowFromDeployableSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDeployableSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDeployableSetupEnum& A, const struct FDeployableSetupEnum& B);
	struct FDeployableSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDeployableSetupRowHandle MakeLiteralDeployableSetup(const struct FDeployableSetupRowHandle& RowHandle);
	struct FDeployableSetupRowHandle MakeDeployableSetupFromIndex(int32 Index);
	struct FDeployableSetupEnum MakeDeployableSetupEnum(const struct FDeployableSetupEnum& Enum);
	struct FDeployableSetupRowHandle MakeDeployableSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDeployableSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDeployableSetupStruct(const struct FDeployableSetupRowHandle& RowHandle, struct FDeployableSetup* DeployableSetup, enum class EValid* Paths);
	bool EqualEqual_FDeployableSetupRowHandleFDeployableSetupRowHandle(const struct FDeployableSetupRowHandle& RowHandleA, const struct FDeployableSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDeployableSetupEnum& A, const struct FDeployableSetupEnum& B);
	struct FDeployableSetupRowHandle CastToDeployableSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDeployableSetupEnum(const struct FDeployableSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDeployableSetupTable(class FName Name, const struct FDeployableSetup& Data, struct FDeployableSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DeployableSetupTable
class UDeployableSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDeployableSetupTable* GetDefaultObj();

};

// 0x90 (0xC0 - 0x30)
// Class Icarus.DeployableSubsystem
class UDeployableSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnDeployNotify;                                    // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnGeneratorActivatedNotify;                        // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnGeneratorDeactivatedNotify;                      // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFactionDeployableActivatedNotify;                // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDeployableInteractedNotify;                      // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDeployablePickedUpNotify;                        // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDeployableDestroyedNotify;                       // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnThumperActivatedNotify;                          // 0xA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnThumperEventCompletedNotify;                     // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UDeployableSubsystem* GetDefaultObj();

	void BroadcastThumperEventCompletedDelegate(class ADeployable* Thumper, int32 OresRegenerated, int32 VoxelsRegenerated);
	void BroadcastThumperActivatedDelegate(class ADeployable* Thumper);
	void BroadcastGeneratorDeactivatedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Deployable);
	void BroadcastGeneratorActivatedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Deployable);
	void BroadcastFactionDeployableActivatedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Deployable);
	void BroadcastDeployDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Deployable);
	void BroadcastDeployablePickedUpDelegate(class AIcarusPlayerCharacter* Player, class ADeployable* Deployable);
	void BroadcastDeployableInteractedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Deployable);
	void BroadcastDeployableDestroyedDelegate(class ADeployable* Deployable, const struct FIcarusDamagePacket& LastDamagePacket, class AIcarusPlayerCharacter* InstigatingPlayer);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DeployableTable
class UDeployableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDeployableTable* GetDefaultObj();

};

// 0x70 (0xB0 - 0x40)
// Class Icarus.DeployableTickSubsystem
class UDeployableTickSubsystem : public UTickableWorldSubsystem
{
public:
	uint8                                        Pad_74C3[0x70];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDeployableTickSubsystem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DeployableTypesLibrary
class UDeployableTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDeployableTypesLibrary* GetDefaultObj();

	struct FDeployableTypesRowHandle StructToRowHandle(const struct FDeployableTypesEnum& EnumValue);
	class FName StructToName(const struct FDeployableTypesEnum& EnumValue);
	int32 StructToInt(const struct FDeployableTypesEnum& EnumValue);
	struct FDeployableTypesEnum RowHandleToStruct(const struct FDeployableTypesRowHandle& RowHandle);
	void RemoveRowFromDeployableTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDeployableTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDeployableTypesEnum& A, const struct FDeployableTypesEnum& B);
	struct FDeployableTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDeployableTypesRowHandle MakeLiteralDeployableTypes(const struct FDeployableTypesRowHandle& RowHandle);
	struct FDeployableTypesRowHandle MakeDeployableTypesFromIndex(int32 Index);
	struct FDeployableTypesEnum MakeDeployableTypesEnum(const struct FDeployableTypesEnum& Enum);
	struct FDeployableTypesRowHandle MakeDeployableTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDeployableTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDeployableTypesStruct(const struct FDeployableTypesRowHandle& RowHandle, struct FIcarusDeployableType* DeployableTypes, enum class EValid* Paths);
	bool EqualEqual_FDeployableTypesRowHandleFDeployableTypesRowHandle(const struct FDeployableTypesRowHandle& RowHandleA, const struct FDeployableTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDeployableTypesEnum& A, const struct FDeployableTypesEnum& B);
	struct FDeployableTypesRowHandle CastToDeployableTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDeployableTypesEnum(const struct FDeployableTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDeployableTypesTable(class FName Name, const struct FIcarusDeployableType& Data, struct FDeployableTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DeployableTypesTable
class UDeployableTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDeployableTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DialogueLibrary
class UDialogueLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDialogueLibrary* GetDefaultObj();

	struct FDialogueRowHandle StructToRowHandle(const struct FDialogueEnum& EnumValue);
	class FName StructToName(const struct FDialogueEnum& EnumValue);
	int32 StructToInt(const struct FDialogueEnum& EnumValue);
	struct FDialogueEnum RowHandleToStruct(const struct FDialogueRowHandle& RowHandle);
	void RemoveRowFromDialogueTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDialogueEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDialogueEnum& A, const struct FDialogueEnum& B);
	struct FDialogueEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDialogueRowHandle MakeLiteralDialogue(const struct FDialogueRowHandle& RowHandle);
	struct FDialogueRowHandle MakeDialogueFromIndex(int32 Index);
	struct FDialogueEnum MakeDialogueEnum(const struct FDialogueEnum& Enum);
	struct FDialogueRowHandle MakeDialogue(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDialogueEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDialogueStruct(const struct FDialogueRowHandle& RowHandle, struct FDialogue* Dialogue, enum class EValid* Paths);
	bool EqualEqual_FDialogueRowHandleFDialogueRowHandle(const struct FDialogueRowHandle& RowHandleA, const struct FDialogueRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDialogueEnum& A, const struct FDialogueEnum& B);
	struct FDialogueRowHandle CastToDialogueRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDialogueEnum(const struct FDialogueEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDialogueTable(class FName Name, const struct FDialogue& Data, struct FDialogueRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x48 (0x268 - 0x220)
// Class Icarus.DialogueManager
class ADialogueManager : public AActor
{
public:
	class UFMODEvent*                            InterruptFMODEvent;                                // 0x220(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InterruptionDelayLength;                           // 0x228(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_74DF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x230(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_74E0[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ADialogueManager* GetDefaultObj();

	void QueueDialogue(struct FDialogueRowHandle& Dialogue);
	void OnDialoguePlayed(const struct FDialogueRowHandle& Dialogue);
	void OnDialogueCleared();
	float GetCurrentDialogueLength();
	void ClearCurrentDialogue();
	void ClearAllDialogues();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DialoguePoolLibrary
class UDialoguePoolLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDialoguePoolLibrary* GetDefaultObj();

	struct FDialoguePoolRowHandle StructToRowHandle(const struct FDialoguePoolEnum& EnumValue);
	class FName StructToName(const struct FDialoguePoolEnum& EnumValue);
	int32 StructToInt(const struct FDialoguePoolEnum& EnumValue);
	struct FDialoguePoolEnum RowHandleToStruct(const struct FDialoguePoolRowHandle& RowHandle);
	void RemoveRowFromDialoguePoolTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDialoguePoolEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDialoguePoolEnum& A, const struct FDialoguePoolEnum& B);
	struct FDialoguePoolEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDialoguePoolRowHandle MakeLiteralDialoguePool(const struct FDialoguePoolRowHandle& RowHandle);
	struct FDialoguePoolRowHandle MakeDialoguePoolFromIndex(int32 Index);
	struct FDialoguePoolEnum MakeDialoguePoolEnum(const struct FDialoguePoolEnum& Enum);
	struct FDialoguePoolRowHandle MakeDialoguePool(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDialoguePoolEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDialoguePoolStruct(const struct FDialoguePoolRowHandle& RowHandle, struct FDialoguePool* DialoguePool, enum class EValid* Paths);
	bool EqualEqual_FDialoguePoolRowHandleFDialoguePoolRowHandle(const struct FDialoguePoolRowHandle& RowHandleA, const struct FDialoguePoolRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDialoguePoolEnum& A, const struct FDialoguePoolEnum& B);
	struct FDialoguePoolRowHandle CastToDialoguePoolRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDialoguePoolEnum(const struct FDialoguePoolEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDialoguePoolTable(class FName Name, const struct FDialoguePool& Data, struct FDialoguePoolRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DialoguePoolTable
class UDialoguePoolTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDialoguePoolTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DialogueSpeakerLibrary
class UDialogueSpeakerLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDialogueSpeakerLibrary* GetDefaultObj();

	struct FDialogueSpeakerRowHandle StructToRowHandle(const struct FDialogueSpeakerEnum& EnumValue);
	class FName StructToName(const struct FDialogueSpeakerEnum& EnumValue);
	int32 StructToInt(const struct FDialogueSpeakerEnum& EnumValue);
	struct FDialogueSpeakerEnum RowHandleToStruct(const struct FDialogueSpeakerRowHandle& RowHandle);
	void RemoveRowFromDialogueSpeakerTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDialogueSpeakerEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDialogueSpeakerEnum& A, const struct FDialogueSpeakerEnum& B);
	struct FDialogueSpeakerEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDialogueSpeakerRowHandle MakeLiteralDialogueSpeaker(const struct FDialogueSpeakerRowHandle& RowHandle);
	struct FDialogueSpeakerRowHandle MakeDialogueSpeakerFromIndex(int32 Index);
	struct FDialogueSpeakerEnum MakeDialogueSpeakerEnum(const struct FDialogueSpeakerEnum& Enum);
	struct FDialogueSpeakerRowHandle MakeDialogueSpeaker(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDialogueSpeakerEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDialogueSpeakerStruct(const struct FDialogueSpeakerRowHandle& RowHandle, struct FDialogueSpeaker* DialogueSpeaker, enum class EValid* Paths);
	bool EqualEqual_FDialogueSpeakerRowHandleFDialogueSpeakerRowHandle(const struct FDialogueSpeakerRowHandle& RowHandleA, const struct FDialogueSpeakerRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDialogueSpeakerEnum& A, const struct FDialogueSpeakerEnum& B);
	struct FDialogueSpeakerRowHandle CastToDialogueSpeakerRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDialogueSpeakerEnum(const struct FDialogueSpeakerEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDialogueSpeakerTable(class FName Name, const struct FDialogueSpeaker& Data, struct FDialogueSpeakerRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DialogueSpeakerTable
class UDialogueSpeakerTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDialogueSpeakerTable* GetDefaultObj();

};

// 0x28 (0xD8 - 0xB0)
// Class Icarus.DialogueSystem
class UDialogueSystem : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_            OnPlayDialogue;                                    // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnClearDialogues;                                  // 0xC0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_7503[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDialogueSystem* GetDefaultObj();

	void TriggerDialogueFromPool(struct FDialoguePoolRowHandle& DialoguePool);
	void TriggerDialogue(struct FDialogueRowHandle& Dialogue);
	void Multi_TriggerDialogue(const struct FDialogueRowHandle& Dialogue);
	void LocalTriggerDialogueFromPool(struct FDialoguePoolRowHandle& DialoguePool);
	void LocalTriggerDialogue(struct FDialogueRowHandle& Dialogue);
	void LocalClearAllDialogues();
	void ClearAllDialogues();
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DialogueTable
class UDialogueTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDialogueTable* GetDefaultObj();

};

// 0x10 (0x230 - 0x220)
// Class Icarus.DisasterController
class ADisasterController : public AInfo
{
public:
	class UFireControllerComponent*              FireController;                                    // 0x220(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIcarusStatContainer*                  StatContainer;                                     // 0x228(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ADisasterController* GetDefaultObj();

	void StopGeneratingLightning(const struct FBiomesEnum& Biome);
	void SetWorldStats();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DLCPackageDataLibrary
class UDLCPackageDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDLCPackageDataLibrary* GetDefaultObj();

	struct FDLCPackageDataRowHandle StructToRowHandle(const struct FDLCPackageDataEnum& EnumValue);
	class FName StructToName(const struct FDLCPackageDataEnum& EnumValue);
	int32 StructToInt(const struct FDLCPackageDataEnum& EnumValue);
	struct FDLCPackageDataEnum RowHandleToStruct(const struct FDLCPackageDataRowHandle& RowHandle);
	void RemoveRowFromDLCPackageDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDLCPackageDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDLCPackageDataEnum& A, const struct FDLCPackageDataEnum& B);
	struct FDLCPackageDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDLCPackageDataRowHandle MakeLiteralDLCPackageData(const struct FDLCPackageDataRowHandle& RowHandle);
	struct FDLCPackageDataRowHandle MakeDLCPackageDataFromIndex(int32 Index);
	struct FDLCPackageDataEnum MakeDLCPackageDataEnum(const struct FDLCPackageDataEnum& Enum);
	struct FDLCPackageDataRowHandle MakeDLCPackageData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDLCPackageDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDLCPackageDataStruct(const struct FDLCPackageDataRowHandle& RowHandle, struct FDLCPackageData* DLCPackageData, enum class EValid* Paths);
	bool EqualEqual_FDLCPackageDataRowHandleFDLCPackageDataRowHandle(const struct FDLCPackageDataRowHandle& RowHandleA, const struct FDLCPackageDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDLCPackageDataEnum& A, const struct FDLCPackageDataEnum& B);
	struct FDLCPackageDataRowHandle CastToDLCPackageDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDLCPackageDataEnum(const struct FDLCPackageDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDLCPackageDataTable(class FName Name, const struct FDLCPackageData& Data, struct FDLCPackageDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DLCPackageDataTable
class UDLCPackageDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDLCPackageDataTable* GetDefaultObj();

};

// 0x8 (0x260 - 0x258)
// Class Icarus.DrillRecorderComponent
class UDrillRecorderComponent : public UDeployableRecorderComponent
{
public:
	struct FDrillSaveData                        DrillSaveData;                                     // 0x258(0x2)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_751E[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDrillRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DrillRecorderInterface
class IDrillRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IDrillRecorderInterface* GetDefaultObj();

	struct FDrillSaveData SaveDrillData();
	void LoadDrillData(struct FDrillSaveData& DrillData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DropGroupsLibrary
class UDropGroupsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDropGroupsLibrary* GetDefaultObj();

	struct FDropGroupsRowHandle StructToRowHandle(const struct FDropGroupsEnum& EnumValue);
	class FName StructToName(const struct FDropGroupsEnum& EnumValue);
	int32 StructToInt(const struct FDropGroupsEnum& EnumValue);
	struct FDropGroupsEnum RowHandleToStruct(const struct FDropGroupsRowHandle& RowHandle);
	void RemoveRowFromDropGroupsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDropGroupsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDropGroupsEnum& A, const struct FDropGroupsEnum& B);
	struct FDropGroupsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDropGroupsRowHandle MakeLiteralDropGroups(const struct FDropGroupsRowHandle& RowHandle);
	struct FDropGroupsRowHandle MakeDropGroupsFromIndex(int32 Index);
	struct FDropGroupsEnum MakeDropGroupsEnum(const struct FDropGroupsEnum& Enum);
	struct FDropGroupsRowHandle MakeDropGroups(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDropGroupsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDropGroupsStruct(const struct FDropGroupsRowHandle& RowHandle, struct FDropGroupCosmeticData* DropGroups, enum class EValid* Paths);
	bool EqualEqual_FDropGroupsRowHandleFDropGroupsRowHandle(const struct FDropGroupsRowHandle& RowHandleA, const struct FDropGroupsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDropGroupsEnum& A, const struct FDropGroupsEnum& B);
	struct FDropGroupsRowHandle CastToDropGroupsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDropGroupsEnum(const struct FDropGroupsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDropGroupsTable(class FName Name, const struct FDropGroupCosmeticData& Data, struct FDropGroupsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DropGroupsTable
class UDropGroupsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDropGroupsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DropShipActionsLibrary
class UDropShipActionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDropShipActionsLibrary* GetDefaultObj();

	struct FDropShipActionsRowHandle StructToRowHandle(const struct FDropShipActionsEnum& EnumValue);
	class FName StructToName(const struct FDropShipActionsEnum& EnumValue);
	int32 StructToInt(const struct FDropShipActionsEnum& EnumValue);
	struct FDropShipActionsEnum RowHandleToStruct(const struct FDropShipActionsRowHandle& RowHandle);
	void RemoveRowFromDropShipActionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDropShipActionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDropShipActionsEnum& A, const struct FDropShipActionsEnum& B);
	struct FDropShipActionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDropShipActionsRowHandle MakeLiteralDropShipActions(const struct FDropShipActionsRowHandle& RowHandle);
	struct FDropShipActionsRowHandle MakeDropShipActionsFromIndex(int32 Index);
	struct FDropShipActionsEnum MakeDropShipActionsEnum(const struct FDropShipActionsEnum& Enum);
	struct FDropShipActionsRowHandle MakeDropShipActions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDropShipActionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDropShipActionsStruct(const struct FDropShipActionsRowHandle& RowHandle, struct FDropShipAction* DropShipActions, enum class EValid* Paths);
	bool EqualEqual_FDropShipActionsRowHandleFDropShipActionsRowHandle(const struct FDropShipActionsRowHandle& RowHandleA, const struct FDropShipActionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDropShipActionsEnum& A, const struct FDropShipActionsEnum& B);
	struct FDropShipActionsRowHandle CastToDropShipActionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDropShipActionsEnum(const struct FDropShipActionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDropShipActionsTable(class FName Name, const struct FDropShipAction& Data, struct FDropShipActionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DropShipActionsTable
class UDropShipActionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDropShipActionsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DropShipSequencesLibrary
class UDropShipSequencesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDropShipSequencesLibrary* GetDefaultObj();

	struct FDropShipSequencesRowHandle StructToRowHandle(const struct FDropShipSequencesEnum& EnumValue);
	class FName StructToName(const struct FDropShipSequencesEnum& EnumValue);
	int32 StructToInt(const struct FDropShipSequencesEnum& EnumValue);
	struct FDropShipSequencesEnum RowHandleToStruct(const struct FDropShipSequencesRowHandle& RowHandle);
	void RemoveRowFromDropShipSequencesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDropShipSequencesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDropShipSequencesEnum& A, const struct FDropShipSequencesEnum& B);
	struct FDropShipSequencesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDropShipSequencesRowHandle MakeLiteralDropShipSequences(const struct FDropShipSequencesRowHandle& RowHandle);
	struct FDropShipSequencesRowHandle MakeDropShipSequencesFromIndex(int32 Index);
	struct FDropShipSequencesEnum MakeDropShipSequencesEnum(const struct FDropShipSequencesEnum& Enum);
	struct FDropShipSequencesRowHandle MakeDropShipSequences(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDropShipSequencesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDropShipSequencesStruct(const struct FDropShipSequencesRowHandle& RowHandle, struct FDropShipSequence* DropShipSequences, enum class EValid* Paths);
	bool EqualEqual_FDropShipSequencesRowHandleFDropShipSequencesRowHandle(const struct FDropShipSequencesRowHandle& RowHandleA, const struct FDropShipSequencesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDropShipSequencesEnum& A, const struct FDropShipSequencesEnum& B);
	struct FDropShipSequencesRowHandle CastToDropShipSequencesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDropShipSequencesEnum(const struct FDropShipSequencesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDropShipSequencesTable(class FName Name, const struct FDropShipSequence& Data, struct FDropShipSequencesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DropShipSequencesTable
class UDropShipSequencesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDropShipSequencesTable* GetDefaultObj();

};

// 0x40 (0x70 - 0x30)
// Class Icarus.DropShipSubsystem
class UDropShipSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnDropShipInteractNotify;                          // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDropShipEnterNotify;                             // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDropShipExitNotify;                              // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDropShipLaunchNotify;                            // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UDropShipSubsystem* GetDefaultObj();

	void BroadcastDropShipLaunchDelegate(class AIcarusRocket* Dropship);
	void BroadcastDropShipInteractDelegate(class AIcarusPlayerCharacter* Player, class AIcarusRocket* Dropship);
	void BroadcastDropShipExitDelegate(class AIcarusPlayerCharacter* Player, class AIcarusRocket* Dropship);
	void BroadcastDropShipEnterDelegate(class AIcarusPlayerCharacter* Player, class AIcarusRocket* Dropship);
};

// 0x8 (0xD8 - 0xD0)
// Class Icarus.DurableComponent
class UDurableComponent : public UTraitComponent
{
public:
	int32                                        Durability;                                        // 0xD0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActorBroken;                                     // 0xD4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bSkipBroadcastBrokenSteps;                         // 0xD5(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7562[0x2];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UDurableComponent* GetDefaultObj();

	void SetSkipBrokenDelegateSteps(bool bSkip);
	void SetDurability(int32 NewDurability);
	void OnHealthUpdated(class UActorState* ActorState, float NewHealth);
	void InitialiseComponent(int32 DurabilityValue);
	bool GetDurableData(struct FDurableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.DurableLibrary
class UDurableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDurableLibrary* GetDefaultObj();

	struct FDurableRowHandle StructToRowHandle(const struct FDurableEnum& EnumValue);
	class FName StructToName(const struct FDurableEnum& EnumValue);
	int32 StructToInt(const struct FDurableEnum& EnumValue);
	struct FDurableEnum RowHandleToStruct(const struct FDurableRowHandle& RowHandle);
	void RemoveRowFromDurableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDurableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDurableEnum& A, const struct FDurableEnum& B);
	struct FDurableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDurableRowHandle MakeLiteralDurable(const struct FDurableRowHandle& RowHandle);
	struct FDurableRowHandle MakeDurableFromIndex(int32 Index);
	struct FDurableEnum MakeDurableEnum(const struct FDurableEnum& Enum);
	struct FDurableRowHandle MakeDurable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDurableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDurableStruct(const struct FDurableRowHandle& RowHandle, struct FDurableData* Durable, enum class EValid* Paths);
	bool EqualEqual_FDurableRowHandleFDurableRowHandle(const struct FDurableRowHandle& RowHandleA, const struct FDurableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDurableEnum& A, const struct FDurableEnum& B);
	struct FDurableRowHandle CastToDurableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDurableEnum(const struct FDurableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDurableTable(class FName Name, const struct FDurableData& Data, struct FDurableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DurableTable
class UDurableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDurableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DynamicQuestRewardItemsLibrary
class UDynamicQuestRewardItemsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestRewardItemsLibrary* GetDefaultObj();

	struct FDynamicQuestRewardItemsRowHandle StructToRowHandle(const struct FDynamicQuestRewardItemsEnum& EnumValue);
	class FName StructToName(const struct FDynamicQuestRewardItemsEnum& EnumValue);
	int32 StructToInt(const struct FDynamicQuestRewardItemsEnum& EnumValue);
	struct FDynamicQuestRewardItemsEnum RowHandleToStruct(const struct FDynamicQuestRewardItemsRowHandle& RowHandle);
	void RemoveRowFromDynamicQuestRewardItemsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDynamicQuestRewardItemsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDynamicQuestRewardItemsEnum& A, const struct FDynamicQuestRewardItemsEnum& B);
	struct FDynamicQuestRewardItemsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDynamicQuestRewardItemsRowHandle MakeLiteralDynamicQuestRewardItems(const struct FDynamicQuestRewardItemsRowHandle& RowHandle);
	struct FDynamicQuestRewardItemsRowHandle MakeDynamicQuestRewardItemsFromIndex(int32 Index);
	struct FDynamicQuestRewardItemsEnum MakeDynamicQuestRewardItemsEnum(const struct FDynamicQuestRewardItemsEnum& Enum);
	struct FDynamicQuestRewardItemsRowHandle MakeDynamicQuestRewardItems(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDynamicQuestRewardItemsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDynamicQuestRewardItemsStruct(const struct FDynamicQuestRewardItemsRowHandle& RowHandle, struct FDynamicQuestRewardItem* DynamicQuestRewardItems, enum class EValid* Paths);
	bool EqualEqual_FDynamicQuestRewardItemsRowHandleFDynamicQuestRewardItemsRowHandle(const struct FDynamicQuestRewardItemsRowHandle& RowHandleA, const struct FDynamicQuestRewardItemsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDynamicQuestRewardItemsEnum& A, const struct FDynamicQuestRewardItemsEnum& B);
	struct FDynamicQuestRewardItemsRowHandle CastToDynamicQuestRewardItemsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDynamicQuestRewardItemsEnum(const struct FDynamicQuestRewardItemsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDynamicQuestRewardItemsTable(class FName Name, const struct FDynamicQuestRewardItem& Data, struct FDynamicQuestRewardItemsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DynamicQuestRewardItemsTable
class UDynamicQuestRewardItemsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestRewardItemsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DynamicQuestRewardsLibrary
class UDynamicQuestRewardsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestRewardsLibrary* GetDefaultObj();

	struct FDynamicQuestRewardsRowHandle StructToRowHandle(const struct FDynamicQuestRewardsEnum& EnumValue);
	class FName StructToName(const struct FDynamicQuestRewardsEnum& EnumValue);
	int32 StructToInt(const struct FDynamicQuestRewardsEnum& EnumValue);
	struct FDynamicQuestRewardsEnum RowHandleToStruct(const struct FDynamicQuestRewardsRowHandle& RowHandle);
	void RemoveRowFromDynamicQuestRewardsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDynamicQuestRewardsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDynamicQuestRewardsEnum& A, const struct FDynamicQuestRewardsEnum& B);
	struct FDynamicQuestRewardsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDynamicQuestRewardsRowHandle MakeLiteralDynamicQuestRewards(const struct FDynamicQuestRewardsRowHandle& RowHandle);
	struct FDynamicQuestRewardsRowHandle MakeDynamicQuestRewardsFromIndex(int32 Index);
	struct FDynamicQuestRewardsEnum MakeDynamicQuestRewardsEnum(const struct FDynamicQuestRewardsEnum& Enum);
	struct FDynamicQuestRewardsRowHandle MakeDynamicQuestRewards(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDynamicQuestRewardsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDynamicQuestRewardsStruct(const struct FDynamicQuestRewardsRowHandle& RowHandle, struct FDynamicQuestReward* DynamicQuestRewards, enum class EValid* Paths);
	bool EqualEqual_FDynamicQuestRewardsRowHandleFDynamicQuestRewardsRowHandle(const struct FDynamicQuestRewardsRowHandle& RowHandleA, const struct FDynamicQuestRewardsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDynamicQuestRewardsEnum& A, const struct FDynamicQuestRewardsEnum& B);
	struct FDynamicQuestRewardsRowHandle CastToDynamicQuestRewardsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDynamicQuestRewardsEnum(const struct FDynamicQuestRewardsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDynamicQuestRewardsTable(class FName Name, const struct FDynamicQuestReward& Data, struct FDynamicQuestRewardsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DynamicQuestRewardsTable
class UDynamicQuestRewardsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestRewardsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.DynamicQuestsLibrary
class UDynamicQuestsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestsLibrary* GetDefaultObj();

	struct FDynamicQuestsRowHandle StructToRowHandle(const struct FDynamicQuestsEnum& EnumValue);
	class FName StructToName(const struct FDynamicQuestsEnum& EnumValue);
	int32 StructToInt(const struct FDynamicQuestsEnum& EnumValue);
	struct FDynamicQuestsEnum RowHandleToStruct(const struct FDynamicQuestsRowHandle& RowHandle);
	void RemoveRowFromDynamicQuestsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FDynamicQuestsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FDynamicQuestsEnum& A, const struct FDynamicQuestsEnum& B);
	struct FDynamicQuestsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FDynamicQuestsRowHandle MakeLiteralDynamicQuests(const struct FDynamicQuestsRowHandle& RowHandle);
	struct FDynamicQuestsRowHandle MakeDynamicQuestsFromIndex(int32 Index);
	struct FDynamicQuestsEnum MakeDynamicQuestsEnum(const struct FDynamicQuestsEnum& Enum);
	struct FDynamicQuestsRowHandle MakeDynamicQuests(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FDynamicQuestsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetDynamicQuestsStruct(const struct FDynamicQuestsRowHandle& RowHandle, struct FDynamicQuest* DynamicQuests, enum class EValid* Paths);
	bool EqualEqual_FDynamicQuestsRowHandleFDynamicQuestsRowHandle(const struct FDynamicQuestsRowHandle& RowHandleA, const struct FDynamicQuestsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FDynamicQuestsEnum& A, const struct FDynamicQuestsEnum& B);
	struct FDynamicQuestsRowHandle CastToDynamicQuestsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakDynamicQuestsEnum(const struct FDynamicQuestsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToDynamicQuestsTable(class FName Name, const struct FDynamicQuest& Data, struct FDynamicQuestsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.DynamicQuestsTable
class UDynamicQuestsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UDynamicQuestsTable* GetDefaultObj();

};

// 0x28 (0x1D0 - 0x1A8)
// Class Icarus.RocketSpawnRecorderComponent
class URocketSpawnRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FRocketSpawnStateRecord               SpawnRecord;                                       // 0x1A8(0x20)(SaveGame, Protected, NativeAccessSpecifierProtected)
	int32                                        RocketSpawnRecorderVersion;                        // 0x1C8(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_75D7[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URocketSpawnRecorderComponent* GetDefaultObj();

};

// 0x0 (0x1D0 - 0x1D0)
// Class Icarus.DynamicRocketSpawnRecorderComponent
class UDynamicRocketSpawnRecorderComponent : public URocketSpawnRecorderComponent
{
public:

	static class UClass* StaticClass();
	static class UDynamicRocketSpawnRecorderComponent* GetDefaultObj();

};

// 0x18 (0x560 - 0x548)
// Class Icarus.EdgeSplineComponent
class UEdgeSplineComponent : public USplineComponent
{
public:
	float                                        DefaultRadius;                                     // 0x548(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        DefaultDistanceBetweenPoints;                      // 0x54C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESplineLoopDirection              SplineDirection;                                   // 0x550(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_75E1[0xF];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UEdgeSplineComponent* GetDefaultObj();

	void SimplifySpline(int32 SimplificationFactor);
	bool IsValidEdgeSpline();
	void GetSplinePointsBoundingSphere(struct FVector* OutOrigin, float* OutRadius);
	void GetSplineInfoFromLocation(struct FVector& Location, struct FVector* OutClosestPointOnEdge, bool* OutIsLocationWithinSpline);
	void GenerateSpline(TArray<struct FVector>& EdgePoints, float PointDensity);
	void GenerateGenericSpline();
	void ForceSplinePointLocationsToComponentZValue();
};

// 0x28 (0xF8 - 0xD0)
// Class Icarus.ResourceNetworkComponent
class UResourceNetworkComponent : public UTraitComponent
{
public:
	uint8                                        Pad_75E9[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AResourceNetwork*                      InputNetwork;                                      // 0xD8(0x8)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AResourceNetwork*                      OutputNetwork;                                     // 0xE0(0x8)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ResourceComponentActive;                           // 0xE8(0x1)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_75EA[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        CurrentResourceFlow;                               // 0xEC(0x4)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPreventAutoActivate;                              // 0xF0(0x1)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnResourceDepleted;                                // 0xF1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnResourceLeaking;                                 // 0xF2(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnActiveStateUpdated;                              // 0xF3(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnResourceNetworkUpdated;                          // 0xF4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_75ED[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UResourceNetworkComponent* GetDefaultObj();

	void SetNetwork(bool Input, class AResourceNetwork* Network);
	void ProcessNetworkComponent(float Delta);
	void OnRep_ResourceComponentActive();
	void OnRep_OutputNetwork();
	void OnRep_InputNetwork();
	bool HasConnectedNetwork();
	bool GetResourceNetworkData(struct FResourceNetworkData* OutData);
	enum class EIcarusResourceType GetResourceComponentType();
	void DeactivateResourceComponent();
	bool CheckActivationOverdraw();
	bool CanReceiveRequiredNetworkResourceFlow();
	bool ActivateResourceComponent();
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.EnergyComponent
class UEnergyComponent : public UResourceNetworkComponent
{
public:

	static class UClass* StaticClass();
	static class UEnergyComponent* GetDefaultObj();

	bool GetEnergyData(struct FEnergyData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.EnergyLibrary
class UEnergyLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UEnergyLibrary* GetDefaultObj();

	struct FEnergyRowHandle StructToRowHandle(const struct FEnergyEnum& EnumValue);
	class FName StructToName(const struct FEnergyEnum& EnumValue);
	int32 StructToInt(const struct FEnergyEnum& EnumValue);
	struct FEnergyEnum RowHandleToStruct(const struct FEnergyRowHandle& RowHandle);
	void RemoveRowFromEnergyTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FEnergyEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FEnergyEnum& A, const struct FEnergyEnum& B);
	struct FEnergyEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FEnergyRowHandle MakeLiteralEnergy(const struct FEnergyRowHandle& RowHandle);
	struct FEnergyRowHandle MakeEnergyFromIndex(int32 Index);
	struct FEnergyEnum MakeEnergyEnum(const struct FEnergyEnum& Enum);
	struct FEnergyRowHandle MakeEnergy(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FEnergyEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetEnergyStruct(const struct FEnergyRowHandle& RowHandle, struct FEnergyData* Energy, enum class EValid* Paths);
	bool EqualEqual_FEnergyRowHandleFEnergyRowHandle(const struct FEnergyRowHandle& RowHandleA, const struct FEnergyRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FEnergyEnum& A, const struct FEnergyEnum& B);
	struct FEnergyRowHandle CastToEnergyRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakEnergyEnum(const struct FEnergyEnum& Enum, class FName* Name, int32* Index);
	void AddRowToEnergyTable(class FName Name, const struct FEnergyData& Data, struct FEnergyRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.EnergyTable
class UEnergyTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UEnergyTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.EnvQueryContext_BackOfQuerier
class UEnvQueryContext_BackOfQuerier : public UEnvQueryContext
{
public:

	static class UClass* StaticClass();
	static class UEnvQueryContext_BackOfQuerier* GetDefaultObj();

};

// 0x40 (0x90 - 0x50)
// Class Icarus.EnvQueryGenerator_CachedSpawns
class UEnvQueryGenerator_CachedSpawns : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x50(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             MaxPointRadius;                                    // 0x58(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryGenerator_CachedSpawns* GetDefaultObj();

};

// 0x60 (0xB0 - 0x50)
// Class Icarus.EnvQueryGenerator_NearbyTargets
class UEnvQueryGenerator_NearbyTargets : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>          TargetableContext;                                 // 0x50(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                    TargetClassFilter;                                 // 0x58(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bOnlyAliveActors;                                  // 0x60(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFilterByRelationship;                             // 0x61(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ERelationshipType                 RelationshipToQuerier;                             // 0x62(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_760B[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIDataProviderFloatValue             NearbyRadius;                                      // 0x68(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         bIgnoreZHeight;                                    // 0xA0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_760C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UEnvQueryContext>          SearchCenter;                                      // 0xA8(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryGenerator_NearbyTargets* GetDefaultObj();

};

// 0x20 (0x70 - 0x50)
// Class Icarus.EnvQueryGenerator_PerceivedTargets
class UEnvQueryGenerator_PerceivedTargets : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x50(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                  SenseToUse;                                        // 0x58(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bOnlyAliveActors;                                  // 0x60(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFilterByRelationship;                             // 0x61(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ERelationshipType                 RelationshipToQuerier;                             // 0x62(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_760D[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UEnvQueryContext>          SearchCenter;                                      // 0x68(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryGenerator_PerceivedTargets* GetDefaultObj();

};

// 0xA8 (0xF8 - 0x50)
// Class Icarus.EnvQueryGenerator_RecentDamageCausers
class UEnvQueryGenerator_RecentDamageCausers : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>          DamagedActorContext;                               // 0x50(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             RecentDuration;                                    // 0x58(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                    TargetClassFilter;                                 // 0x90(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bOnlyAliveActors;                                  // 0x98(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_760F[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIDataProviderFloatValue             NearbyRadius;                                      // 0xA0(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>          NearbyRadiusCenter;                                // 0xD8(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFilterByRelationship;                             // 0xE0(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7610[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<enum class ERelationshipType>         RelationshipFilters;                               // 0xE8(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryGenerator_RecentDamageCausers* GetDefaultObj();

};

// 0x40 (0x238 - 0x1F8)
// Class Icarus.EnvQueryTest_ActorOverlap
class UEnvQueryTest_ActorOverlap : public UEnvQueryTest
{
public:
	struct FEnvOverlapData                       OverlapData;                                       // 0x1F8(0x20)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<enum class ECollisionChannel>         AdditionalTraceChannels;                           // 0x218(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class AActor>>          ActorClassFilters;                                 // 0x228(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_ActorOverlap* GetDefaultObj();

};

// 0x100 (0x2F8 - 0x1F8)
// Class Icarus.EnvQueryTest_AITrace
class UEnvQueryTest_AITrace : public UEnvQueryTest
{
public:
	struct FAIDataProviderBoolValue              TraceFromContext;                                  // 0x1F8(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         UseComplex;                                        // 0x230(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIgnoreAllAITargetable;                            // 0x231(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7611[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class AActor>>          IgnoreClasses;                                     // 0x238(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                        MaxTraceDistance;                                  // 0x248(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MinTraceDistance;                                  // 0x24C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ItemHeightOffset;                                  // 0x250(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ContextHeightOffset;                               // 0x288(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x2C0(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7612[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UEnvQueryTest_AITrace* GetDefaultObj();

};

// 0x30 (0x228 - 0x1F8)
// Class Icarus.EnvQueryTest_BoundsMask
class UEnvQueryTest_BoundsMask : public UEnvQueryTest
{
public:
	TSoftObjectPtr<class UGameplayTexture>       OverrideBoundsMask;                                // 0x1F8(0x28)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TestRadius;                                        // 0x220(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7613[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UEnvQueryTest_BoundsMask* GetDefaultObj();

};

// 0xB8 (0x2B0 - 0x1F8)
// Class Icarus.EnvQueryTest_DownwardTrace
class UEnvQueryTest_DownwardTrace : public UEnvQueryTest
{
public:
	bool                                         bTraceComplex;                                     // 0x1F8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7616[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<enum class ECollisionChannel>         CollisionChannels;                                 // 0x200(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class AActor>>          IgnoreClasses;                                     // 0x210(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             DownwardsTraceDistance;                            // 0x220(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ItemHeightOffset;                                  // 0x258(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                         bShowDebug;                                        // 0x290(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7617[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSoftClassPtr<class AActor>>          BlacklistActors;                                   // 0x298(0x10)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x2A8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_DownwardTrace* GetDefaultObj();

};

// 0xC0 (0x2B8 - 0x1F8)
// Class Icarus.EnvQueryTest_FlatArea
class UEnvQueryTest_FlatArea : public UEnvQueryTest
{
public:
	float                                        RequiredRadius;                                    // 0x1F8(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7619[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIDataProviderFloatValue             MaxHeightChange;                                   // 0x200(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ItemHeightOffset;                                  // 0x238(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             DownwardsTraceDistance;                            // 0x270(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         bShowDebug;                                        // 0x2A8(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_761A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x2B0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_FlatArea* GetDefaultObj();

};

// 0xE8 (0x2E0 - 0x1F8)
// Class Icarus.EnvQueryTest_IsShallowWater
class UEnvQueryTest_IsShallowWater : public UEnvQueryTest
{
public:
	struct FEnvTraceData                         TraceData;                                         // 0x1F8(0x30)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	enum class ECollisionChannel                 WaterChannel;                                      // 0x228(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_761C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIDataProviderFloatValue             PermitWaterDepthCm;                                // 0x230(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             UpwardsTraceDistance;                              // 0x268(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ItemHeightOffset;                                  // 0x2A0(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x2D8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_IsShallowWater* GetDefaultObj();

};

// 0xB0 (0x2A8 - 0x1F8)
// Class Icarus.EnvQueryTest_IsUnderwater
class UEnvQueryTest_IsUnderwater : public UEnvQueryTest
{
public:
	struct FEnvTraceData                         TraceData;                                         // 0x1F8(0x30)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	enum class ECollisionChannel                 WaterChannel;                                      // 0x228(0x1)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_761E[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAIDataProviderFloatValue             UpwardsTraceDistance;                              // 0x230(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue             ItemHeightOffset;                                  // 0x268(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>          Context;                                           // 0x2A0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_IsUnderwater* GetDefaultObj();

};

// 0x30 (0x228 - 0x1F8)
// Class Icarus.EnvQueryTest_ProjectBox
class UEnvQueryTest_ProjectBox : public UEnvQueryTest
{
public:
	struct FEnvTraceData                         ProjectionData;                                    // 0x1F8(0x30)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UEnvQueryTest_ProjectBox* GetDefaultObj();

};

// 0x38 (0x230 - 0x1F8)
// Class Icarus.EnvQueryTest_RecentDamage
class UEnvQueryTest_RecentDamage : public UEnvQueryTest
{
public:
	struct FAIDataProviderFloatValue             RecentDuration;                                    // 0x1F8(0x38)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_RecentDamage* GetDefaultObj();

};

// 0x8 (0x200 - 0x1F8)
// Class Icarus.EnvQueryTest_WithinSpawnBlocker
class UEnvQueryTest_WithinSpawnBlocker : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>          SpawnBlockersContext;                              // 0x1F8(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UEnvQueryTest_WithinSpawnBlocker* GetDefaultObj();

};

// 0x20 (0x2E0 - 0x2C0)
// Class Icarus.EnzymeGeyser
class AEnzymeGeyser : public AIcarusActor
{
public:
	int32                                        Completions;                                       // 0x2C0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHordeRowHandle                       HordeRowHandle;                                    // 0x2C4(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7621[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AEnzymeGeyser* GetDefaultObj();

};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.EnzymeGeyserRecorderComponent
class UEnzymeGeyserRecorderComponent : public UActorStateRecorderComponent
{
public:
	int32                                        Completions;                                       // 0x1A8(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  HordeDTKey;                                        // 0x1AC(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7622[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UEnzymeGeyserRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.EpicCreaturesLibrary
class UEpicCreaturesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UEpicCreaturesLibrary* GetDefaultObj();

	struct FEpicCreaturesRowHandle StructToRowHandle(const struct FEpicCreaturesEnum& EnumValue);
	class FName StructToName(const struct FEpicCreaturesEnum& EnumValue);
	int32 StructToInt(const struct FEpicCreaturesEnum& EnumValue);
	struct FEpicCreaturesEnum RowHandleToStruct(const struct FEpicCreaturesRowHandle& RowHandle);
	void RemoveRowFromEpicCreaturesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FEpicCreaturesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FEpicCreaturesEnum& A, const struct FEpicCreaturesEnum& B);
	struct FEpicCreaturesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FEpicCreaturesRowHandle MakeLiteralEpicCreatures(const struct FEpicCreaturesRowHandle& RowHandle);
	struct FEpicCreaturesRowHandle MakeEpicCreaturesFromIndex(int32 Index);
	struct FEpicCreaturesEnum MakeEpicCreaturesEnum(const struct FEpicCreaturesEnum& Enum);
	struct FEpicCreaturesRowHandle MakeEpicCreatures(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FEpicCreaturesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetEpicCreaturesStruct(const struct FEpicCreaturesRowHandle& RowHandle, struct FEpicCreatures* EpicCreatures, enum class EValid* Paths);
	bool EqualEqual_FEpicCreaturesRowHandleFEpicCreaturesRowHandle(const struct FEpicCreaturesRowHandle& RowHandleA, const struct FEpicCreaturesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FEpicCreaturesEnum& A, const struct FEpicCreaturesEnum& B);
	struct FEpicCreaturesRowHandle CastToEpicCreaturesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakEpicCreaturesEnum(const struct FEpicCreaturesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToEpicCreaturesTable(class FName Name, const struct FEpicCreatures& Data, struct FEpicCreaturesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.EpicCreaturesTable
class UEpicCreaturesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UEpicCreaturesTable* GetDefaultObj();

};

// 0x18 (0x238 - 0x220)
// Class Icarus.EquipmentRequestInventoryContainer
class AEquipmentRequestInventoryContainer : public AActor
{
public:
	class UInventoryComponent*                   InventoryComponent;                                // 0x220(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            MetaInventory;                                     // 0x228(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            CargoInventory;                                    // 0x230(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AEquipmentRequestInventoryContainer* GetDefaultObj();

	void OnMetaInventoryChanged();
};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.EquippableComponent
class UEquippableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UEquippableComponent* GetDefaultObj();

	bool GetEquippableData(struct FEquippableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.EquippableLibrary
class UEquippableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UEquippableLibrary* GetDefaultObj();

	struct FEquippableRowHandle StructToRowHandle(const struct FEquippableEnum& EnumValue);
	class FName StructToName(const struct FEquippableEnum& EnumValue);
	int32 StructToInt(const struct FEquippableEnum& EnumValue);
	struct FEquippableEnum RowHandleToStruct(const struct FEquippableRowHandle& RowHandle);
	void RemoveRowFromEquippableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FEquippableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FEquippableEnum& A, const struct FEquippableEnum& B);
	struct FEquippableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FEquippableRowHandle MakeLiteralEquippable(const struct FEquippableRowHandle& RowHandle);
	struct FEquippableRowHandle MakeEquippableFromIndex(int32 Index);
	struct FEquippableEnum MakeEquippableEnum(const struct FEquippableEnum& Enum);
	struct FEquippableRowHandle MakeEquippable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FEquippableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetEquippableStruct(const struct FEquippableRowHandle& RowHandle, struct FEquippableData* Equippable, enum class EValid* Paths);
	bool EqualEqual_FEquippableRowHandleFEquippableRowHandle(const struct FEquippableRowHandle& RowHandleA, const struct FEquippableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FEquippableEnum& A, const struct FEquippableEnum& B);
	struct FEquippableRowHandle CastToEquippableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakEquippableEnum(const struct FEquippableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToEquippableTable(class FName Name, const struct FEquippableData& Data, struct FEquippableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x30 (0xE0 - 0xB0)
// Class Icarus.EquippableModifier
class UEquippableModifier : public UActorComponent
{
public:
	class UInventory*                            Inventory;                                         // 0xB0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        InventorySlot;                                     // 0xB8(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquippableRowHandle                  EquippableRow;                                     // 0xBC(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CachedUID;                                         // 0xD4(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         SelfDestruct;                                      // 0xD8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_764D[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UEquippableModifier* GetDefaultObj();

	void OnItemRemoved(class UInventory* RemovedInventory, int32 RemovedSlot);
	bool ItemUnequipped();
	bool ItemEquipped();
	float GetStackedModifierMultiplier();
	void GetEquippableStatsToAdd(TMap<struct FStatsEnum, int32>* Stats);
	void EquippedTick(float DeltaTime);
	bool CheckTickConditions();
	void ArmourSlotUpdated(class UInventory* SourceInventory, int32 Location);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.EquippableTable
class UEquippableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UEquippableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ErrorCodesLibrary
class UErrorCodesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UErrorCodesLibrary* GetDefaultObj();

	struct FErrorCodesRowHandle StructToRowHandle(const struct FErrorCodesEnum& EnumValue);
	class FName StructToName(const struct FErrorCodesEnum& EnumValue);
	int32 StructToInt(const struct FErrorCodesEnum& EnumValue);
	struct FErrorCodesEnum RowHandleToStruct(const struct FErrorCodesRowHandle& RowHandle);
	void RemoveRowFromErrorCodesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FErrorCodesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FErrorCodesEnum& A, const struct FErrorCodesEnum& B);
	struct FErrorCodesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FErrorCodesRowHandle MakeLiteralErrorCodes(const struct FErrorCodesRowHandle& RowHandle);
	struct FErrorCodesRowHandle MakeErrorCodesFromIndex(int32 Index);
	struct FErrorCodesEnum MakeErrorCodesEnum(const struct FErrorCodesEnum& Enum);
	struct FErrorCodesRowHandle MakeErrorCodes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FErrorCodesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetErrorCodesStruct(const struct FErrorCodesRowHandle& RowHandle, struct FErrorCode* ErrorCodes, enum class EValid* Paths);
	bool EqualEqual_FErrorCodesRowHandleFErrorCodesRowHandle(const struct FErrorCodesRowHandle& RowHandleA, const struct FErrorCodesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FErrorCodesEnum& A, const struct FErrorCodesEnum& B);
	struct FErrorCodesRowHandle CastToErrorCodesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakErrorCodesEnum(const struct FErrorCodesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToErrorCodesTable(class FName Name, const struct FErrorCode& Data, struct FErrorCodesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ErrorCodesTable
class UErrorCodesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UErrorCodesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ExoticSpawnLibrary
class UExoticSpawnLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UExoticSpawnLibrary* GetDefaultObj();

	struct FExoticSpawnRowHandle StructToRowHandle(const struct FExoticSpawnEnum& EnumValue);
	class FName StructToName(const struct FExoticSpawnEnum& EnumValue);
	int32 StructToInt(const struct FExoticSpawnEnum& EnumValue);
	struct FExoticSpawnEnum RowHandleToStruct(const struct FExoticSpawnRowHandle& RowHandle);
	void RemoveRowFromExoticSpawnTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FExoticSpawnEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FExoticSpawnEnum& A, const struct FExoticSpawnEnum& B);
	struct FExoticSpawnEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FExoticSpawnRowHandle MakeLiteralExoticSpawn(const struct FExoticSpawnRowHandle& RowHandle);
	struct FExoticSpawnRowHandle MakeExoticSpawnFromIndex(int32 Index);
	struct FExoticSpawnEnum MakeExoticSpawnEnum(const struct FExoticSpawnEnum& Enum);
	struct FExoticSpawnRowHandle MakeExoticSpawn(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FExoticSpawnEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetExoticSpawnStruct(const struct FExoticSpawnRowHandle& RowHandle, struct FExoticSpawn* ExoticSpawn, enum class EValid* Paths);
	bool EqualEqual_FExoticSpawnRowHandleFExoticSpawnRowHandle(const struct FExoticSpawnRowHandle& RowHandleA, const struct FExoticSpawnRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FExoticSpawnEnum& A, const struct FExoticSpawnEnum& B);
	struct FExoticSpawnRowHandle CastToExoticSpawnRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakExoticSpawnEnum(const struct FExoticSpawnEnum& Enum, class FName* Name, int32* Index);
	void AddRowToExoticSpawnTable(class FName Name, const struct FExoticSpawn& Data, struct FExoticSpawnRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ExoticSpawnTable
class UExoticSpawnTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UExoticSpawnTable* GetDefaultObj();

};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.ExperienceComponent
class UExperienceComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UExperienceComponent* GetDefaultObj();

	bool TriggerExperienceEvent(enum class EExperienceSource Type, class AActor* Target);
	bool GetExperienceData(struct FExperienceData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ExperienceEventsLibrary
class UExperienceEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UExperienceEventsLibrary* GetDefaultObj();

	struct FExperienceEventsRowHandle StructToRowHandle(const struct FExperienceEventsEnum& EnumValue);
	class FName StructToName(const struct FExperienceEventsEnum& EnumValue);
	int32 StructToInt(const struct FExperienceEventsEnum& EnumValue);
	struct FExperienceEventsEnum RowHandleToStruct(const struct FExperienceEventsRowHandle& RowHandle);
	void RemoveRowFromExperienceEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FExperienceEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FExperienceEventsEnum& A, const struct FExperienceEventsEnum& B);
	struct FExperienceEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FExperienceEventsRowHandle MakeLiteralExperienceEvents(const struct FExperienceEventsRowHandle& RowHandle);
	struct FExperienceEventsRowHandle MakeExperienceEventsFromIndex(int32 Index);
	struct FExperienceEventsEnum MakeExperienceEventsEnum(const struct FExperienceEventsEnum& Enum);
	struct FExperienceEventsRowHandle MakeExperienceEvents(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FExperienceEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetExperienceEventsStruct(const struct FExperienceEventsRowHandle& RowHandle, struct FExperienceEvent* ExperienceEvents, enum class EValid* Paths);
	bool EqualEqual_FExperienceEventsRowHandleFExperienceEventsRowHandle(const struct FExperienceEventsRowHandle& RowHandleA, const struct FExperienceEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FExperienceEventsEnum& A, const struct FExperienceEventsEnum& B);
	struct FExperienceEventsRowHandle CastToExperienceEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakExperienceEventsEnum(const struct FExperienceEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToExperienceEventsTable(class FName Name, const struct FExperienceEvent& Data, struct FExperienceEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ExperienceEventsTable
class UExperienceEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UExperienceEventsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ExperienceLibrary
class UExperienceLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UExperienceLibrary* GetDefaultObj();

	struct FExperienceRowHandle StructToRowHandle(const struct FExperienceEnum& EnumValue);
	class FName StructToName(const struct FExperienceEnum& EnumValue);
	int32 StructToInt(const struct FExperienceEnum& EnumValue);
	struct FExperienceEnum RowHandleToStruct(const struct FExperienceRowHandle& RowHandle);
	void RemoveRowFromExperienceTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FExperienceEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FExperienceEnum& A, const struct FExperienceEnum& B);
	struct FExperienceEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FExperienceRowHandle MakeLiteralExperience(const struct FExperienceRowHandle& RowHandle);
	struct FExperienceRowHandle MakeExperienceFromIndex(int32 Index);
	struct FExperienceEnum MakeExperienceEnum(const struct FExperienceEnum& Enum);
	struct FExperienceRowHandle MakeExperience(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FExperienceEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetExperienceStruct(const struct FExperienceRowHandle& RowHandle, struct FExperienceData* Experience, enum class EValid* Paths);
	bool EqualEqual_FExperienceRowHandleFExperienceRowHandle(const struct FExperienceRowHandle& RowHandleA, const struct FExperienceRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FExperienceEnum& A, const struct FExperienceEnum& B);
	struct FExperienceRowHandle CastToExperienceRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakExperienceEnum(const struct FExperienceEnum& Enum, class FName* Name, int32* Index);
	void AddRowToExperienceTable(class FName Name, const struct FExperienceData& Data, struct FExperienceRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ExperienceTable
class UExperienceTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UExperienceTable* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.ExtractionSubsystem
class UExtractionSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnItemExtractedNotify;                             // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UExtractionSubsystem* GetDefaultObj();

	void BroadcastItemExtractedDelegate(class AActor* Device, const struct FItemData& Item);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FactionInfoLibrary
class UFactionInfoLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFactionInfoLibrary* GetDefaultObj();

	struct FFactionInfoRowHandle StructToRowHandle(const struct FFactionInfoEnum& EnumValue);
	class FName StructToName(const struct FFactionInfoEnum& EnumValue);
	int32 StructToInt(const struct FFactionInfoEnum& EnumValue);
	struct FFactionInfoEnum RowHandleToStruct(const struct FFactionInfoRowHandle& RowHandle);
	void RemoveRowFromFactionInfoTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFactionInfoEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFactionInfoEnum& A, const struct FFactionInfoEnum& B);
	struct FFactionInfoEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFactionInfoRowHandle MakeLiteralFactionInfo(const struct FFactionInfoRowHandle& RowHandle);
	struct FFactionInfoRowHandle MakeFactionInfoFromIndex(int32 Index);
	struct FFactionInfoEnum MakeFactionInfoEnum(const struct FFactionInfoEnum& Enum);
	struct FFactionInfoRowHandle MakeFactionInfo(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFactionInfoEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFactionInfoStruct(const struct FFactionInfoRowHandle& RowHandle, struct FFactionInfo* FactionInfo, enum class EValid* Paths);
	bool EqualEqual_FFactionInfoRowHandleFFactionInfoRowHandle(const struct FFactionInfoRowHandle& RowHandleA, const struct FFactionInfoRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFactionInfoEnum& A, const struct FFactionInfoEnum& B);
	struct FFactionInfoRowHandle CastToFactionInfoRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFactionInfoEnum(const struct FFactionInfoEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFactionInfoTable(class FName Name, const struct FFactionInfo& Data, struct FFactionInfoRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FactionInfoTable
class UFactionInfoTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFactionInfoTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FactionMissionsLibrary
class UFactionMissionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFactionMissionsLibrary* GetDefaultObj();

	struct FFactionMissionsRowHandle StructToRowHandle(const struct FFactionMissionsEnum& EnumValue);
	class FName StructToName(const struct FFactionMissionsEnum& EnumValue);
	int32 StructToInt(const struct FFactionMissionsEnum& EnumValue);
	struct FFactionMissionsEnum RowHandleToStruct(const struct FFactionMissionsRowHandle& RowHandle);
	void RemoveRowFromFactionMissionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFactionMissionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFactionMissionsEnum& A, const struct FFactionMissionsEnum& B);
	struct FFactionMissionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFactionMissionsRowHandle MakeLiteralFactionMissions(const struct FFactionMissionsRowHandle& RowHandle);
	struct FFactionMissionsRowHandle MakeFactionMissionsFromIndex(int32 Index);
	struct FFactionMissionsEnum MakeFactionMissionsEnum(const struct FFactionMissionsEnum& Enum);
	struct FFactionMissionsRowHandle MakeFactionMissions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFactionMissionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFactionMissionsStruct(const struct FFactionMissionsRowHandle& RowHandle, struct FFactionMission* FactionMissions, enum class EValid* Paths);
	bool EqualEqual_FFactionMissionsRowHandleFFactionMissionsRowHandle(const struct FFactionMissionsRowHandle& RowHandleA, const struct FFactionMissionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFactionMissionsEnum& A, const struct FFactionMissionsEnum& B);
	struct FFactionMissionsRowHandle CastToFactionMissionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFactionMissionsEnum(const struct FFactionMissionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFactionMissionsTable(class FName Name, const struct FFactionMission& Data, struct FFactionMissionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FactionMissionsTable
class UFactionMissionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFactionMissionsTable* GetDefaultObj();

};

// 0x10 (0xF8 - 0xE8)
// Class Icarus.FarmableComponent
class UFarmableComponent : public UTraitBehaviours
{
public:
	TArray<class UCultivation*>                  Cultivations;                                      // 0xE8(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFarmableComponent* GetDefaultObj();

	bool GetFarmableData(struct FFarmableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FarmableLibrary
class UFarmableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFarmableLibrary* GetDefaultObj();

	struct FFarmableRowHandle StructToRowHandle(const struct FFarmableEnum& EnumValue);
	class FName StructToName(const struct FFarmableEnum& EnumValue);
	int32 StructToInt(const struct FFarmableEnum& EnumValue);
	struct FFarmableEnum RowHandleToStruct(const struct FFarmableRowHandle& RowHandle);
	void RemoveRowFromFarmableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFarmableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFarmableEnum& A, const struct FFarmableEnum& B);
	struct FFarmableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFarmableRowHandle MakeLiteralFarmable(const struct FFarmableRowHandle& RowHandle);
	struct FFarmableRowHandle MakeFarmableFromIndex(int32 Index);
	struct FFarmableEnum MakeFarmableEnum(const struct FFarmableEnum& Enum);
	struct FFarmableRowHandle MakeFarmable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFarmableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFarmableStruct(const struct FFarmableRowHandle& RowHandle, struct FFarmableData* Farmable, enum class EValid* Paths);
	bool EqualEqual_FFarmableRowHandleFFarmableRowHandle(const struct FFarmableRowHandle& RowHandleA, const struct FFarmableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFarmableEnum& A, const struct FFarmableEnum& B);
	struct FFarmableRowHandle CastToFarmableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFarmableEnum(const struct FFarmableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFarmableTable(class FName Name, const struct FFarmableData& Data, struct FFarmableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FarmableTable
class UFarmableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFarmableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FarmingFunctionLibrary
class UFarmingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFarmingFunctionLibrary* GetDefaultObj();

	bool UpdateCropPlotModifiers(class AIcarusPlayerCharacter* Player, const struct FItemData& Seed, class AIcarusItem* Item);
	bool GetTotalGrowthTime(const struct FFarmingSeedsRowHandle& Seed, float* RemainingTime);
	bool GetSeedRow(const struct FItemData& Item, struct FFarmingSeedsRowHandle* SeedRow);
	bool GetSeedRewards(const struct FFarmingSeedsRowHandle& Seed, enum class EPlantGrowthStates GrowthState, struct FItemRewardsRowHandle* ItemRewardRow);
	bool GetGrowthStateData(const struct FFarmingSeedsRowHandle& Seed, enum class EPlantGrowthStates GrowthState, struct FFarmingGrowthStatesRowHandle* GrowthStateRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FarmingGrowthStatesLibrary
class UFarmingGrowthStatesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFarmingGrowthStatesLibrary* GetDefaultObj();

	struct FFarmingGrowthStatesRowHandle StructToRowHandle(const struct FFarmingGrowthStatesEnum& EnumValue);
	class FName StructToName(const struct FFarmingGrowthStatesEnum& EnumValue);
	int32 StructToInt(const struct FFarmingGrowthStatesEnum& EnumValue);
	struct FFarmingGrowthStatesEnum RowHandleToStruct(const struct FFarmingGrowthStatesRowHandle& RowHandle);
	void RemoveRowFromFarmingGrowthStatesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFarmingGrowthStatesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFarmingGrowthStatesEnum& A, const struct FFarmingGrowthStatesEnum& B);
	struct FFarmingGrowthStatesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFarmingGrowthStatesRowHandle MakeLiteralFarmingGrowthStates(const struct FFarmingGrowthStatesRowHandle& RowHandle);
	struct FFarmingGrowthStatesRowHandle MakeFarmingGrowthStatesFromIndex(int32 Index);
	struct FFarmingGrowthStatesEnum MakeFarmingGrowthStatesEnum(const struct FFarmingGrowthStatesEnum& Enum);
	struct FFarmingGrowthStatesRowHandle MakeFarmingGrowthStates(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFarmingGrowthStatesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFarmingGrowthStatesStruct(const struct FFarmingGrowthStatesRowHandle& RowHandle, struct FFarmingGrowthState* FarmingGrowthStates, enum class EValid* Paths);
	bool EqualEqual_FFarmingGrowthStatesRowHandleFFarmingGrowthStatesRowHandle(const struct FFarmingGrowthStatesRowHandle& RowHandleA, const struct FFarmingGrowthStatesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFarmingGrowthStatesEnum& A, const struct FFarmingGrowthStatesEnum& B);
	struct FFarmingGrowthStatesRowHandle CastToFarmingGrowthStatesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFarmingGrowthStatesEnum(const struct FFarmingGrowthStatesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFarmingGrowthStatesTable(class FName Name, const struct FFarmingGrowthState& Data, struct FFarmingGrowthStatesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FarmingGrowthStatesTable
class UFarmingGrowthStatesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFarmingGrowthStatesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FarmingPlotRecorderInterface
class IFarmingPlotRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IFarmingPlotRecorderInterface* GetDefaultObj();

	void SetFarmingPlotValues(bool bIsSeededRecord, bool bIsHarvestableRecord, int32 CurrentGrowthStageRecord, float CurrentTimeRecord, const struct FFarmingSeedsRowHandle& CurrentSeedRowRecord, float NextStageTimeRecord, float GrowthCompleteTimeRecord);
	void GetFarmingPlotValues(bool* bIsSeededRecord, bool* bIsHarvestableRecord, int32* CurrentGrowthStageRecord, float* CurrentTimeRecord, struct FFarmingSeedsRowHandle* CurrentSeedRowRecord, float* NextStageTimeRecord, float* GrowthCompleteTimeRecord);
};

// 0x28 (0x280 - 0x258)
// Class Icarus.FarmingPlotRecorderComponent
class UFarmingPlotRecorderComponent : public UDeployableRecorderComponent
{
public:
	bool                                         bIsSeeded;                                         // 0x258(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsHarvestable;                                    // 0x259(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7726[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        CurrentGrowthStage;                                // 0x25C(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CurrentTime;                                       // 0x260(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  CurrentSeedRow;                                    // 0x264(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        NextStageTime;                                     // 0x26C(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        GrowthCompleteTime;                                // 0x270(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7727[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFarmingPlotRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FarmingSeedsLibrary
class UFarmingSeedsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFarmingSeedsLibrary* GetDefaultObj();

	struct FFarmingSeedsRowHandle StructToRowHandle(const struct FFarmingSeedsEnum& EnumValue);
	class FName StructToName(const struct FFarmingSeedsEnum& EnumValue);
	int32 StructToInt(const struct FFarmingSeedsEnum& EnumValue);
	struct FFarmingSeedsEnum RowHandleToStruct(const struct FFarmingSeedsRowHandle& RowHandle);
	void RemoveRowFromFarmingSeedsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFarmingSeedsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFarmingSeedsEnum& A, const struct FFarmingSeedsEnum& B);
	struct FFarmingSeedsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFarmingSeedsRowHandle MakeLiteralFarmingSeeds(const struct FFarmingSeedsRowHandle& RowHandle);
	struct FFarmingSeedsRowHandle MakeFarmingSeedsFromIndex(int32 Index);
	struct FFarmingSeedsEnum MakeFarmingSeedsEnum(const struct FFarmingSeedsEnum& Enum);
	struct FFarmingSeedsRowHandle MakeFarmingSeeds(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFarmingSeedsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFarmingSeedsStruct(const struct FFarmingSeedsRowHandle& RowHandle, struct FFarmingSeedData* FarmingSeeds, enum class EValid* Paths);
	bool EqualEqual_FFarmingSeedsRowHandleFFarmingSeedsRowHandle(const struct FFarmingSeedsRowHandle& RowHandleA, const struct FFarmingSeedsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFarmingSeedsEnum& A, const struct FFarmingSeedsEnum& B);
	struct FFarmingSeedsRowHandle CastToFarmingSeedsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFarmingSeedsEnum(const struct FFarmingSeedsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFarmingSeedsTable(class FName Name, const struct FFarmingSeedData& Data, struct FFarmingSeedsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FarmingSeedsTable
class UFarmingSeedsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFarmingSeedsTable* GetDefaultObj();

};

// 0x30 (0x60 - 0x30)
// Class Icarus.FarmingSubsystem
class UFarmingSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnItemHarvestedNotify;                             // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSeedPlantedNotify;                               // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCropMaturedNotify;                               // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFarmingSubsystem* GetDefaultObj();

	void BroadcastSeedPlantedDelegate(class AIcarusPlayerCharacter* Player, const struct FFarmingSeedsRowHandle& Seed);
	void BroadcastItemHarvestedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastCropMaturedDelegate(const struct FFarmingSeedsRowHandle& Seed);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FieldGuideCategoriesLibrary
class UFieldGuideCategoriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideCategoriesLibrary* GetDefaultObj();

	struct FFieldGuideCategoriesRowHandle StructToRowHandle(const struct FFieldGuideCategoriesEnum& EnumValue);
	class FName StructToName(const struct FFieldGuideCategoriesEnum& EnumValue);
	int32 StructToInt(const struct FFieldGuideCategoriesEnum& EnumValue);
	struct FFieldGuideCategoriesEnum RowHandleToStruct(const struct FFieldGuideCategoriesRowHandle& RowHandle);
	void RemoveRowFromFieldGuideCategoriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFieldGuideCategoriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFieldGuideCategoriesEnum& A, const struct FFieldGuideCategoriesEnum& B);
	struct FFieldGuideCategoriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFieldGuideCategoriesRowHandle MakeLiteralFieldGuideCategories(const struct FFieldGuideCategoriesRowHandle& RowHandle);
	struct FFieldGuideCategoriesRowHandle MakeFieldGuideCategoriesFromIndex(int32 Index);
	struct FFieldGuideCategoriesEnum MakeFieldGuideCategoriesEnum(const struct FFieldGuideCategoriesEnum& Enum);
	struct FFieldGuideCategoriesRowHandle MakeFieldGuideCategories(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFieldGuideCategoriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFieldGuideCategoriesStruct(const struct FFieldGuideCategoriesRowHandle& RowHandle, struct FFieldGuideCategories* FieldGuideCategories, enum class EValid* Paths);
	bool EqualEqual_FFieldGuideCategoriesRowHandleFFieldGuideCategoriesRowHandle(const struct FFieldGuideCategoriesRowHandle& RowHandleA, const struct FFieldGuideCategoriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFieldGuideCategoriesEnum& A, const struct FFieldGuideCategoriesEnum& B);
	struct FFieldGuideCategoriesRowHandle CastToFieldGuideCategoriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFieldGuideCategoriesEnum(const struct FFieldGuideCategoriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFieldGuideCategoriesTable(class FName Name, const struct FFieldGuideCategories& Data, struct FFieldGuideCategoriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FieldGuideCategoriesTable
class UFieldGuideCategoriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideCategoriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FieldGuideFunctionLibrary
class UFieldGuideFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideFunctionLibrary* GetDefaultObj();

	bool IsUsedInRecipes(const struct FItemsStaticRowHandle& IngredientRow);
	bool IsRecipeOutputProduct(const struct FItemsStaticRowHandle& IngredientRow);
	bool IsRecipeInputIngredient(const struct FItemsStaticRowHandle& IngredientRow);
	bool IsItemBuildableDlc(const struct FItemsStaticRowHandle& Item);
	bool IsFreshWaterFish(const struct FItemsStaticRowHandle& Item);
	struct FItemsStaticRowHandle GetWorkshopSeedPackFromPlant(const struct FItemsStaticRowHandle& Item);
	struct FWorkshopItemsRowHandle GetWorkshopItem(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetTrophyKnives();
	struct FItemableRowHandle GetSeedDescriptionFromPack(const struct FItemsStaticRowHandle& Item, int32& CountOut);
	struct FItemableRowHandle GetSeedDescriptionForPlant(const struct FItemsStaticRowHandle& Item);
	void GetRecipesThatProduceOutput(const struct FItemsStaticRowHandle& IngredientRow, TArray<struct FFieldGuideRecipeInfo>& RecipesOut);
	void GetRecipeProductsRequiringInput(const struct FItemsStaticRowHandle& IngredientRow, TArray<struct FItemsStaticRowHandle>& RecipeRowsOut);
	struct FItemsStaticRowHandle GetPackFromItem(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetKnivesCanHarvestWith(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetItemsWithDisplayNameMatchingQuery(const class FString& FilterQuery);
	TArray<struct FItemsStaticRowHandle> GetItemsForAttachment(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetItemSet(const struct FItemsStaticRowHandle& Item, bool bIncludeItem);
	struct FFieldGuideMetaDataRowHandle GetItemMeta(const struct FItemsStaticRowHandle& Item);
	enum class EFieldGuideItemHotToObtain GetItemHowToObtain(const struct FItemsStaticRowHandle& Item);
	struct FItemsStaticRowHandle GetItemFromItemPack(const struct FItemsStaticRowHandle& Item, int32& StackCountOut);
	bool GetIsFish(const struct FItemsStaticRowHandle& Item);
	struct FFishDataRowHandle GetFishData(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetFirearmsThatCanUseAmmo(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetCorpseVestige(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetCorpsesProvidingReward(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetCorpseSkinningKnifeRewards(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetCorpseSkinningBenchRewards(const struct FItemsStaticRowHandle& Item);
	struct FItemsStaticRowHandle GetCorpseFromVestige(const struct FItemsStaticRowHandle& Item);
	struct FFieldGuideCategoriesRowHandle GetCategoryForItem(const struct FItemsStaticRowHandle& Item);
	struct FBestiaryDataRowHandle GetBeastFromVestige(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetAttachments(const struct FItemsStaticRowHandle& Item);
	void GetArmorSetFromItem(const struct FItemsStaticRowHandle& Item, TArray<struct FItemsStaticRowHandle>& ArmorSetOut);
	TArray<struct FItemsStaticRowHandle> GetAmmoTypesForFirearm(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetAllItemsRequiringSameTalent(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetAllItemsForCategory(const struct FFieldGuideCategoriesRowHandle& Category);
	TArray<struct FItemsStaticRowHandle> GetAllItemsCraftedAt(const struct FItemsStaticRowHandle& Item);
	TArray<struct FItemsStaticRowHandle> GetAllCropPlots();
	TArray<struct FFieldGuideCategoriesRowHandle> GetAllCategoryDisplayOrder();
	TArray<struct FItemsStaticRowHandle> GetAllArmorHelmets();
};

// 0x50 (0x2B0 - 0x260)
// Class Icarus.FieldGuideItemWidgetBase
class UFieldGuideItemWidgetBase : public UUserWidget
{
public:
	struct FFieldGuideCategoriesRowHandle        CategoryRow;                                       // 0x260(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemsStaticRowHandle                 ItemRow;                                           // 0x278(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnClosed;                                          // 0x290(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnResourceClicked;                                 // 0x2A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFieldGuideItemWidgetBase* GetDefaultObj();

	void InitFieldGuideView(const struct FItemsStaticRowHandle& ItemIn, const struct FFieldGuideCategoriesRowHandle& CategoryIn);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FieldGuideMetaDataLibrary
class UFieldGuideMetaDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideMetaDataLibrary* GetDefaultObj();

	struct FFieldGuideMetaDataRowHandle StructToRowHandle(const struct FFieldGuideMetaDataEnum& EnumValue);
	class FName StructToName(const struct FFieldGuideMetaDataEnum& EnumValue);
	int32 StructToInt(const struct FFieldGuideMetaDataEnum& EnumValue);
	struct FFieldGuideMetaDataEnum RowHandleToStruct(const struct FFieldGuideMetaDataRowHandle& RowHandle);
	void RemoveRowFromFieldGuideMetaDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFieldGuideMetaDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFieldGuideMetaDataEnum& A, const struct FFieldGuideMetaDataEnum& B);
	struct FFieldGuideMetaDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFieldGuideMetaDataRowHandle MakeLiteralFieldGuideMetaData(const struct FFieldGuideMetaDataRowHandle& RowHandle);
	struct FFieldGuideMetaDataRowHandle MakeFieldGuideMetaDataFromIndex(int32 Index);
	struct FFieldGuideMetaDataEnum MakeFieldGuideMetaDataEnum(const struct FFieldGuideMetaDataEnum& Enum);
	struct FFieldGuideMetaDataRowHandle MakeFieldGuideMetaData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFieldGuideMetaDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFieldGuideMetaDataStruct(const struct FFieldGuideMetaDataRowHandle& RowHandle, struct FFieldGuideMetaData* FieldGuideMetaData, enum class EValid* Paths);
	bool EqualEqual_FFieldGuideMetaDataRowHandleFFieldGuideMetaDataRowHandle(const struct FFieldGuideMetaDataRowHandle& RowHandleA, const struct FFieldGuideMetaDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFieldGuideMetaDataEnum& A, const struct FFieldGuideMetaDataEnum& B);
	struct FFieldGuideMetaDataRowHandle CastToFieldGuideMetaDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFieldGuideMetaDataEnum(const struct FFieldGuideMetaDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFieldGuideMetaDataTable(class FName Name, const struct FFieldGuideMetaData& Data, struct FFieldGuideMetaDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FieldGuideMetaDataTable
class UFieldGuideMetaDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideMetaDataTable* GetDefaultObj();

};

// 0x20 (0x2D0 - 0x2B0)
// Class Icarus.FieldGuidePageWidgetBase
class UFieldGuidePageWidgetBase : public UFieldGuideItemWidgetBase
{
public:
	FMulticastInlineDelegateProperty_            OnFishLinkClicked;                                 // 0x2B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnBeastLinkClicked;                                // 0x2C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UFieldGuidePageWidgetBase* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FieldGuideSetsLibrary
class UFieldGuideSetsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideSetsLibrary* GetDefaultObj();

	struct FFieldGuideSetsRowHandle StructToRowHandle(const struct FFieldGuideSetsEnum& EnumValue);
	class FName StructToName(const struct FFieldGuideSetsEnum& EnumValue);
	int32 StructToInt(const struct FFieldGuideSetsEnum& EnumValue);
	struct FFieldGuideSetsEnum RowHandleToStruct(const struct FFieldGuideSetsRowHandle& RowHandle);
	void RemoveRowFromFieldGuideSetsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFieldGuideSetsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFieldGuideSetsEnum& A, const struct FFieldGuideSetsEnum& B);
	struct FFieldGuideSetsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFieldGuideSetsRowHandle MakeLiteralFieldGuideSets(const struct FFieldGuideSetsRowHandle& RowHandle);
	struct FFieldGuideSetsRowHandle MakeFieldGuideSetsFromIndex(int32 Index);
	struct FFieldGuideSetsEnum MakeFieldGuideSetsEnum(const struct FFieldGuideSetsEnum& Enum);
	struct FFieldGuideSetsRowHandle MakeFieldGuideSets(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFieldGuideSetsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFieldGuideSetsStruct(const struct FFieldGuideSetsRowHandle& RowHandle, struct FFieldGuideSets* FieldGuideSets, enum class EValid* Paths);
	bool EqualEqual_FFieldGuideSetsRowHandleFFieldGuideSetsRowHandle(const struct FFieldGuideSetsRowHandle& RowHandleA, const struct FFieldGuideSetsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFieldGuideSetsEnum& A, const struct FFieldGuideSetsEnum& B);
	struct FFieldGuideSetsRowHandle CastToFieldGuideSetsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFieldGuideSetsEnum(const struct FFieldGuideSetsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFieldGuideSetsTable(class FName Name, const struct FFieldGuideSets& Data, struct FFieldGuideSetsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FieldGuideSetsTable
class UFieldGuideSetsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFieldGuideSetsTable* GetDefaultObj();

};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.FillableComponent
class UFillableComponent : public UTraitComponent
{
public:
	int32                                        FillableType;                                      // 0xD0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        StoredUnits;                                       // 0xD4(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            Client_OnResourceTypeUpdated;                      // 0xD8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            Client_OnStoredUnitsUpdated;                       // 0xD9(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_77CB[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFillableComponent* GetDefaultObj();

	void SetStoredUnits(int32 NewCapacity);
	bool SetResourceType(enum class EIcarusResourceType NewResourceType);
	int32 RemoveUnits(int32 AmountToRemove, enum class EIcarusResourceType Type);
	void OnRep_StoredUnits();
	void OnRep_ResourceType();
	bool IsFull();
	bool IsEmpty();
	int32 GetStoredUnits();
	enum class EIcarusResourceType GetFillableType();
	bool GetFillableData(struct FFillableData* OutData);
	int32 AddUnits(int32 AmountToAdd, enum class EIcarusResourceType Type);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FillableLibrary
class UFillableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFillableLibrary* GetDefaultObj();

	struct FFillableRowHandle StructToRowHandle(const struct FFillableEnum& EnumValue);
	class FName StructToName(const struct FFillableEnum& EnumValue);
	int32 StructToInt(const struct FFillableEnum& EnumValue);
	struct FFillableEnum RowHandleToStruct(const struct FFillableRowHandle& RowHandle);
	void RemoveRowFromFillableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFillableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFillableEnum& A, const struct FFillableEnum& B);
	struct FFillableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFillableRowHandle MakeLiteralFillable(const struct FFillableRowHandle& RowHandle);
	struct FFillableRowHandle MakeFillableFromIndex(int32 Index);
	struct FFillableEnum MakeFillableEnum(const struct FFillableEnum& Enum);
	struct FFillableRowHandle MakeFillable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFillableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFillableStruct(const struct FFillableRowHandle& RowHandle, struct FFillableData* Fillable, enum class EValid* Paths);
	bool EqualEqual_FFillableRowHandleFFillableRowHandle(const struct FFillableRowHandle& RowHandleA, const struct FFillableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFillableEnum& A, const struct FFillableEnum& B);
	struct FFillableRowHandle CastToFillableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFillableEnum(const struct FFillableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFillableTable(class FName Name, const struct FFillableData& Data, struct FFillableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FillableTable
class UFillableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFillableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FirearmAudioDataLibrary
class UFirearmAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFirearmAudioDataLibrary* GetDefaultObj();

	struct FFirearmAudioDataRowHandle StructToRowHandle(const struct FFirearmAudioDataEnum& EnumValue);
	class FName StructToName(const struct FFirearmAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FFirearmAudioDataEnum& EnumValue);
	struct FFirearmAudioDataEnum RowHandleToStruct(const struct FFirearmAudioDataRowHandle& RowHandle);
	void RemoveRowFromFirearmAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFirearmAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFirearmAudioDataEnum& A, const struct FFirearmAudioDataEnum& B);
	struct FFirearmAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFirearmAudioDataRowHandle MakeLiteralFirearmAudioData(const struct FFirearmAudioDataRowHandle& RowHandle);
	struct FFirearmAudioDataRowHandle MakeFirearmAudioDataFromIndex(int32 Index);
	struct FFirearmAudioDataEnum MakeFirearmAudioDataEnum(const struct FFirearmAudioDataEnum& Enum);
	struct FFirearmAudioDataRowHandle MakeFirearmAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFirearmAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFirearmAudioDataStruct(const struct FFirearmAudioDataRowHandle& RowHandle, struct FFirearmAudioData* FirearmAudioData, enum class EValid* Paths);
	bool EqualEqual_FFirearmAudioDataRowHandleFFirearmAudioDataRowHandle(const struct FFirearmAudioDataRowHandle& RowHandleA, const struct FFirearmAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFirearmAudioDataEnum& A, const struct FFirearmAudioDataEnum& B);
	struct FFirearmAudioDataRowHandle CastToFirearmAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFirearmAudioDataEnum(const struct FFirearmAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFirearmAudioDataTable(class FName Name, const struct FFirearmAudioData& Data, struct FFirearmAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FirearmAudioDataTable
class UFirearmAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFirearmAudioDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FirearmDataLibrary
class UFirearmDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFirearmDataLibrary* GetDefaultObj();

	struct FFirearmDataRowHandle StructToRowHandle(const struct FFirearmDataEnum& EnumValue);
	class FName StructToName(const struct FFirearmDataEnum& EnumValue);
	int32 StructToInt(const struct FFirearmDataEnum& EnumValue);
	struct FFirearmDataEnum RowHandleToStruct(const struct FFirearmDataRowHandle& RowHandle);
	void RemoveRowFromFirearmDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFirearmDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFirearmDataEnum& A, const struct FFirearmDataEnum& B);
	struct FFirearmDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFirearmDataRowHandle MakeLiteralFirearmData(const struct FFirearmDataRowHandle& RowHandle);
	struct FFirearmDataRowHandle MakeFirearmDataFromIndex(int32 Index);
	struct FFirearmDataEnum MakeFirearmDataEnum(const struct FFirearmDataEnum& Enum);
	struct FFirearmDataRowHandle MakeFirearmData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFirearmDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFirearmDataStruct(const struct FFirearmDataRowHandle& RowHandle, struct FFirearmData* FirearmData, enum class EValid* Paths);
	bool EqualEqual_FFirearmDataRowHandleFFirearmDataRowHandle(const struct FFirearmDataRowHandle& RowHandleA, const struct FFirearmDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFirearmDataEnum& A, const struct FFirearmDataEnum& B);
	struct FFirearmDataRowHandle CastToFirearmDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFirearmDataEnum(const struct FFirearmDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFirearmDataTable(class FName Name, const struct FFirearmData& Data, struct FFirearmDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FirearmDataTable
class UFirearmDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFirearmDataTable* GetDefaultObj();

};

// 0x90 (0x140 - 0xB0)
// Class Icarus.FireControllerComponent
class UFireControllerComponent : public UActorComponent
{
public:
	TSubclassOf<class AFireInstance>             FireInstanceClass;                                 // 0xB0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFireInstanceShadow>       FireInstanceShadowClass;                           // 0xB8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTagQueriesRowHandle                  CanIgniteFireQueryRowHandle;                       // 0xC0(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFireInstance*>                 ActiveFireInstances;                               // 0xD8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AFireInstanceShadow*>           ActiveFireInstanceShadows;                         // 0xE8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlammableInstance*>            ActiveFlammableInstances;                          // 0xF8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlammableInstance*>            DynamicInstances;                                  // 0x108(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                         bReplicatedStatesDirty;                            // 0x118(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_782A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TSubclassOf<class UFlammableComponent>> DebugFlammableClasses;                             // 0x120(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                        CurrentFlammableInstanceIndex;                     // 0x130(0x4)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_782B[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFireControllerComponent* GetDefaultObj();

	void SetDebugFlammableState(TSubclassOf<class UFlammableComponent> FlammableClass, bool bState);
	void SetDebugDisableFires(bool bState);
	void OnFlammableInstanceState_Destroyed_Enter(class UFlammableInstance* Instance, class UFlammableState* FlammableState);
	void OnFlammableInstanceState_Combusting_Enter(class UFlammableInstance* Instance, class UFlammableState* FlammableState);
	void OnFireInstanceShadowDestroyed(class AActor* DestroyedFireInstance);
	void OnFireInstanceDestroyed(class AActor* DestroyedFireInstance);
	bool IsDebugDisableFiresEnabled();
	TArray<class UFlammableInstance*> GetFlammableInstancesWithinBiome(const struct FBiomesRowHandle& Biome);
	TArray<class UFlammableInstance*> GetFlammableInstancesIntersectingBounds(struct FBoxSphereBounds& Bounds);
	TArray<class AFireInstance*> GetFireInstancesIntersectingBounds(struct FBoxSphereBounds& Bounds);
	bool GetDebugFlammableState(TSubclassOf<class UFlammableComponent> FlammableClass);
	TArray<class UClass*> GetAllFlammableComponentClasses();
};

// 0x48 (0x308 - 0x2C0)
// Class Icarus.FireInstanceBase
class AFireInstanceBase : public AIcarusActor
{
public:
	class UConcaveHullMesh*                      PropagatedMesh;                                    // 0x2C0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPropagatedMeshDirty;                              // 0x2C8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7835[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CurrentLifeTime;                                   // 0x2CC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlammableInstance*>            Instances;                                         // 0x2D0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                         bDebugPropagationMesh;                             // 0x2E0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7836[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBoxSphereBounds                      InstancesBounds;                                   // 0x2E4(0x1C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bInstanceBoundsDirty;                              // 0x300(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7837[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AFireInstanceBase* GetDefaultObj();

	void OnTransferredTo(class AFireInstanceBase* Dest, class UFlammableInstance* Instance);
	void OnTransferredFrom(class AFireInstanceBase* Source, class UFlammableInstance* Instance);
	void OnPropagatedMeshGenerated();
	void OnFlammableInstanceState_Destroyed_Enter(class UFlammableInstance* Instance, class UFlammableState* FlammableState);
	void OnFlammableInstanceRemoved(class UFlammableInstance* Instance);
	void OnFlammableInstanceAdded(class UFlammableInstance* Instance);
	class UFireControllerComponent* GetFireController();
	float GetAverageTemperature();
	bool CheckBoundsOverlapPropagationMesh(struct FBoxSphereBounds& Bounds);
};

// 0x10 (0x318 - 0x308)
// Class Icarus.FireInstance
class AFireInstance : public AFireInstanceBase
{
public:
	float                                        MinTimeBetweenPropagation;                         // 0x308(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxTimeBetweenPropagation;                         // 0x30C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        NextPropagationTime;                               // 0x310(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7839[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AFireInstance* GetDefaultObj();

	void ResetFirePropagation();
	void OnFlammableInstanceState_Combusting_Exit(class UFlammableInstance* Instance, class UFlammableState* FlammableState);
};

// 0x18 (0x320 - 0x308)
// Class Icarus.FireInstanceShadow
class AFireInstanceShadow : public AFireInstanceBase
{
public:
	TArray<struct FBox>                          InstanceBoxes;                                     // 0x308(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                         bReadyToDestroy;                                   // 0x318(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_783A[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AFireInstanceShadow* GetDefaultObj();

};

// 0x140 (0x400 - 0x2C0)
// Class Icarus.FishActor
class AFishActor : public AIcarusActor
{
public:
	class USkeletalMeshComponent*                Mesh;                                              // 0x2C0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFishManager*                          FishManager;                                       // 0x2C8(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFishSetupRowHandle                   FishSetup;                                         // 0x2D0(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDead;                                             // 0x2E8(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7844[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        Scale;                                             // 0x2EC(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                AttachActor;                                       // 0x2F0(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                   RepLocation;                                       // 0x2F8(0xC)(Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                   TargetLocation;                                    // 0x304(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusPlayerCharacter*                AwarenessTarget;                                   // 0x310(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AwarenessTimerInterval;                            // 0x318(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        AwarenessCooldownLength;                           // 0x31C(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CorrectionVariance;                                // 0x320(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        FindNewTargetAttempts;                             // 0x324(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFishSetup                            FishSetupData;                                     // 0x328(0xC8)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                          AwarenessTimerHandle;                              // 0x3F0(0x8)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                        NextAwarenessTimestamp;                            // 0x3F8(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7846[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AFishActor* GetDefaultObj();

	void SetScale(float NewScale);
	void SetDead(bool bNewDead);
	void SetAttachActor(class AActor* NewAttachActor);
	void OnRep_Scale();
	void OnRep_Dead();
	void OnRep_AwarenessTarget();
	void OnRep_AttachActor();
	bool IsAware();
	bool IsAggressive();
	float GetMovementSpeed();
	struct FVector GetGoalLocation();
	void BPOnRep_Scale();
	void BPOnRep_Dead();
	void BPOnRep_AttachActor();
	void AttackPlayer(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FishDataLibrary
class UFishDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFishDataLibrary* GetDefaultObj();

	struct FFishDataRowHandle StructToRowHandle(const struct FFishDataEnum& EnumValue);
	class FName StructToName(const struct FFishDataEnum& EnumValue);
	int32 StructToInt(const struct FFishDataEnum& EnumValue);
	struct FFishDataEnum RowHandleToStruct(const struct FFishDataRowHandle& RowHandle);
	void RemoveRowFromFishDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFishDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFishDataEnum& A, const struct FFishDataEnum& B);
	struct FFishDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFishDataRowHandle MakeLiteralFishData(const struct FFishDataRowHandle& RowHandle);
	struct FFishDataRowHandle MakeFishDataFromIndex(int32 Index);
	struct FFishDataEnum MakeFishDataEnum(const struct FFishDataEnum& Enum);
	struct FFishDataRowHandle MakeFishData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFishDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFishDataStruct(const struct FFishDataRowHandle& RowHandle, struct FFishData* FishData, enum class EValid* Paths);
	bool EqualEqual_FFishDataRowHandleFFishDataRowHandle(const struct FFishDataRowHandle& RowHandleA, const struct FFishDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFishDataEnum& A, const struct FFishDataEnum& B);
	struct FFishDataRowHandle CastToFishDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFishDataEnum(const struct FFishDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFishDataTable(class FName Name, const struct FFishData& Data, struct FFishDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FishDataTable
class UFishDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFishDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FishingFunctionLibrary
class UFishingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFishingFunctionLibrary* GetDefaultObj();

	bool IsMatch(int32 Bitmask, int32 PopType);
	struct FFishTypeTracking GetFishStatsFromItem(class UObject* WorldContext, struct FFishDataRowHandle& FishRow, struct FItemData& FishItemIn);
	struct FFishSpawnZonesRowHandle GetFishSpawnZone(class UObject* WorldContext, const struct FTerrainsRowHandle& Terrain, struct FVector& Location);
	float GetFishScale(class UObject* WorldContext, const struct FItemData& Fish);
	bool GenerateFishStats(class UObject* WorldContext, struct FFishDataRowHandle& FishData, float ZoneQuality, class UIcarusStatContainer* Stats, struct FItemData* Fish);
	bool GenerateFish(class UObject* WorldContext, struct FVector& Location, struct FFishDataRowHandle* Fish, float* ZoneQuality);
	bool CatchFishInZone(class AActor* Fisher, const struct FFishSpawnZonesRowHandle& SpawnZone, struct FItemData* Fish);
	bool CatchFish(class UObject* WorldContext, class AActor* Fisher, struct FItemData* Fish);
	void BestiaryTrackFish(class UObject* WorldContext, class AIcarusPlayerCharacter* PlayerFisher, struct FItemData& Fish);
};

// 0x10 (0x40 - 0x30)
// Class Icarus.FishingSubsystem
class UFishingSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnCaughtFishNotify;                                // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFishingSubsystem* GetDefaultObj();

	void BroadcastCaughtFishDelegate(class AActor* Fisher, const struct FItemData& Fish);
};

// 0x30 (0xE0 - 0xB0)
// Class Icarus.FishManager
class UFishManager : public UActorComponent
{
public:
	uint8                                        Pad_788E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bFishEnabled;                                      // 0xB4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7891[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AFishActor*>                    TotalFish;                                         // 0xB8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                        WaterZHeight;                                      // 0xC8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxFishToSpawnPerFrame;                            // 0xCC(0x4)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7892[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFishManager* GetDefaultObj();

	struct FVector_NetQuantize GetNextPoint();
	void FishRemoved();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FishSetupLibrary
class UFishSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFishSetupLibrary* GetDefaultObj();

	struct FFishSetupRowHandle StructToRowHandle(const struct FFishSetupEnum& EnumValue);
	class FName StructToName(const struct FFishSetupEnum& EnumValue);
	int32 StructToInt(const struct FFishSetupEnum& EnumValue);
	struct FFishSetupEnum RowHandleToStruct(const struct FFishSetupRowHandle& RowHandle);
	void RemoveRowFromFishSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFishSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFishSetupEnum& A, const struct FFishSetupEnum& B);
	struct FFishSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFishSetupRowHandle MakeLiteralFishSetup(const struct FFishSetupRowHandle& RowHandle);
	struct FFishSetupRowHandle MakeFishSetupFromIndex(int32 Index);
	struct FFishSetupEnum MakeFishSetupEnum(const struct FFishSetupEnum& Enum);
	struct FFishSetupRowHandle MakeFishSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFishSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFishSetupStruct(const struct FFishSetupRowHandle& RowHandle, struct FFishSetup* FishSetup, enum class EValid* Paths);
	bool EqualEqual_FFishSetupRowHandleFFishSetupRowHandle(const struct FFishSetupRowHandle& RowHandleA, const struct FFishSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFishSetupEnum& A, const struct FFishSetupEnum& B);
	struct FFishSetupRowHandle CastToFishSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFishSetupEnum(const struct FFishSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFishSetupTable(class FName Name, const struct FFishSetup& Data, struct FFishSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FishSetupTable
class UFishSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFishSetupTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FishSpawnConfigLibrary
class UFishSpawnConfigLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFishSpawnConfigLibrary* GetDefaultObj();

	struct FFishSpawnConfigRowHandle StructToRowHandle(const struct FFishSpawnConfigEnum& EnumValue);
	class FName StructToName(const struct FFishSpawnConfigEnum& EnumValue);
	int32 StructToInt(const struct FFishSpawnConfigEnum& EnumValue);
	struct FFishSpawnConfigEnum RowHandleToStruct(const struct FFishSpawnConfigRowHandle& RowHandle);
	void RemoveRowFromFishSpawnConfigTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFishSpawnConfigEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFishSpawnConfigEnum& A, const struct FFishSpawnConfigEnum& B);
	struct FFishSpawnConfigEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFishSpawnConfigRowHandle MakeLiteralFishSpawnConfig(const struct FFishSpawnConfigRowHandle& RowHandle);
	struct FFishSpawnConfigRowHandle MakeFishSpawnConfigFromIndex(int32 Index);
	struct FFishSpawnConfigEnum MakeFishSpawnConfigEnum(const struct FFishSpawnConfigEnum& Enum);
	struct FFishSpawnConfigRowHandle MakeFishSpawnConfig(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFishSpawnConfigEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFishSpawnConfigStruct(const struct FFishSpawnConfigRowHandle& RowHandle, struct FFishSpawnConfig* FishSpawnConfig, enum class EValid* Paths);
	bool EqualEqual_FFishSpawnConfigRowHandleFFishSpawnConfigRowHandle(const struct FFishSpawnConfigRowHandle& RowHandleA, const struct FFishSpawnConfigRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFishSpawnConfigEnum& A, const struct FFishSpawnConfigEnum& B);
	struct FFishSpawnConfigRowHandle CastToFishSpawnConfigRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFishSpawnConfigEnum(const struct FFishSpawnConfigEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFishSpawnConfigTable(class FName Name, const struct FFishSpawnConfig& Data, struct FFishSpawnConfigRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FishSpawnConfigTable
class UFishSpawnConfigTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFishSpawnConfigTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FishSpawnZonesLibrary
class UFishSpawnZonesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFishSpawnZonesLibrary* GetDefaultObj();

	struct FFishSpawnZonesRowHandle StructToRowHandle(const struct FFishSpawnZonesEnum& EnumValue);
	class FName StructToName(const struct FFishSpawnZonesEnum& EnumValue);
	int32 StructToInt(const struct FFishSpawnZonesEnum& EnumValue);
	struct FFishSpawnZonesEnum RowHandleToStruct(const struct FFishSpawnZonesRowHandle& RowHandle);
	void RemoveRowFromFishSpawnZonesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFishSpawnZonesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFishSpawnZonesEnum& A, const struct FFishSpawnZonesEnum& B);
	struct FFishSpawnZonesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFishSpawnZonesRowHandle MakeLiteralFishSpawnZones(const struct FFishSpawnZonesRowHandle& RowHandle);
	struct FFishSpawnZonesRowHandle MakeFishSpawnZonesFromIndex(int32 Index);
	struct FFishSpawnZonesEnum MakeFishSpawnZonesEnum(const struct FFishSpawnZonesEnum& Enum);
	struct FFishSpawnZonesRowHandle MakeFishSpawnZones(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFishSpawnZonesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFishSpawnZonesStruct(const struct FFishSpawnZonesRowHandle& RowHandle, struct FFishSpawnZones* FishSpawnZones, enum class EValid* Paths);
	bool EqualEqual_FFishSpawnZonesRowHandleFFishSpawnZonesRowHandle(const struct FFishSpawnZonesRowHandle& RowHandleA, const struct FFishSpawnZonesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFishSpawnZonesEnum& A, const struct FFishSpawnZonesEnum& B);
	struct FFishSpawnZonesRowHandle CastToFishSpawnZonesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFishSpawnZonesEnum(const struct FFishSpawnZonesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFishSpawnZonesTable(class FName Name, const struct FFishSpawnZones& Data, struct FFishSpawnZonesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FishSpawnZonesTable
class UFishSpawnZonesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFishSpawnZonesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FlagInterface
class IFlagInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IFlagInterface* GetDefaultObj();

	void SetFlag(struct FFlagsMultiRowHandle& Flag, bool bSet);
	bool HasFlag(struct FFlagsMultiRowHandle& Flag);
	bool HasAnyFlags(TArray<struct FFlagsMultiRowHandle>& Flags);
	bool HasAllFlags(TArray<struct FFlagsMultiRowHandle>& Flags);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FlagsMultiRowHandleLibrary
class UFlagsMultiRowHandleLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFlagsMultiRowHandleLibrary* GetDefaultObj();

	struct FSessionFlagsRowHandle ToSessionFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle);
	struct FDLCPackageDataRowHandle ToDLCPackageDataRowHandle(const struct FFlagsMultiRowHandle& MultiHandle);
	struct FCharacterFlagsRowHandle ToCharacterFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle);
	struct FAccountFlagsRowHandle ToAccountFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle);
	bool NotEqual_FlagsMultiRowHandleFSessionFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FSessionFlagsRowHandle& RowHandle);
	bool NotEqual_FlagsMultiRowHandleFlagsMultiRowHandle(const struct FFlagsMultiRowHandle& A, const struct FFlagsMultiRowHandle& B);
	bool NotEqual_FlagsMultiRowHandleFDLCPackageDataRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FDLCPackageDataRowHandle& RowHandle);
	bool NotEqual_FlagsMultiRowHandleFCharacterFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FCharacterFlagsRowHandle& RowHandle);
	bool NotEqual_FlagsMultiRowHandleFAccountFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FAccountFlagsRowHandle& RowHandle);
	struct FFlagsMultiRowHandle Make(enum class EFlagsTableType Enum, class FName RowName);
	bool IsValid(const struct FFlagsMultiRowHandle& MultiRowHandle);
	bool IsNone(const struct FFlagsMultiRowHandle& MultiRowHandle);
	class FName GetTableNameByIndex(uint8 TableIndex);
	uint8 GetTableIndexByName(class FName TableName);
	void GetSessionFlagsStruct(const struct FFlagsMultiRowHandle& MultiHandle, struct FSessionFlag* SessionFlagsStruct, enum class EValid* Paths);
	struct FRowMetadata GetMetadata(const struct FFlagsMultiRowHandle& MultiRowHandle);
	void GetDLCPackageDataStruct(const struct FFlagsMultiRowHandle& MultiHandle, struct FDLCPackageData* DLCPackageDataStruct, enum class EValid* Paths);
	void GetCharacterFlagsStruct(const struct FFlagsMultiRowHandle& MultiHandle, struct FCharacterFlag* CharacterFlagsStruct, enum class EValid* Paths);
	void GetAccountFlagsStruct(const struct FFlagsMultiRowHandle& MultiHandle, struct FAccountFlag* AccountFlagsStruct, enum class EValid* Paths);
	struct FFlagsMultiRowHandle FromSessionFlagsRowHandle(const struct FSessionFlagsRowHandle& RowHandle);
	struct FFlagsMultiRowHandle FromDLCPackageDataRowHandle(const struct FDLCPackageDataRowHandle& RowHandle);
	struct FFlagsMultiRowHandle FromCharacterFlagsRowHandle(const struct FCharacterFlagsRowHandle& RowHandle);
	struct FFlagsMultiRowHandle FromAccountFlagsRowHandle(const struct FAccountFlagsRowHandle& RowHandle);
	bool EqualEqual_FlagsMultiRowHandleFSessionFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FSessionFlagsRowHandle& RowHandle);
	bool EqualEqual_FlagsMultiRowHandleFlagsMultiRowHandle(const struct FFlagsMultiRowHandle& A, const struct FFlagsMultiRowHandle& B);
	bool EqualEqual_FlagsMultiRowHandleFDLCPackageDataRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FDLCPackageDataRowHandle& RowHandle);
	bool EqualEqual_FlagsMultiRowHandleFCharacterFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FCharacterFlagsRowHandle& RowHandle);
	bool EqualEqual_FlagsMultiRowHandleFAccountFlagsRowHandle(const struct FFlagsMultiRowHandle& MultiHandle, const struct FAccountFlagsRowHandle& RowHandle);
	void Break(const struct FFlagsMultiRowHandle& MultiRowHandle, enum class EFlagsTableType* OutEnum, class FName* OutName);
};

// 0x30 (0x60 - 0x30)
// Class Icarus.FlagSubsystem
class UFlagSubsystem : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnCharacterFlagsUpdated;                           // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSessionFlagsUpdated;                             // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAccountFlagsUpdated;                             // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFlagSubsystem* GetDefaultObj();

	void ServerSetSessionFlag(struct FSessionFlagsRowHandle& SessionFlag, bool State);
	void ServerSetCharacterFlagsForPlayer(class AIcarusPlayerState* PlayerState, TMap<struct FCharacterFlagsRowHandle, bool>& FlagMap);
	void ServerSetCharacterFlagForPlayer(class AIcarusPlayerState* PlayerState, struct FCharacterFlagsRowHandle& CharacterFlag, bool State);
	void ServerSetAccountFlagsForPlayer(class AIcarusPlayerState* PlayerState, TMap<struct FAccountFlagsRowHandle, bool>& FlagMap);
	void ServerSetAccountFlagForPlayer(class AIcarusPlayerState* PlayerState, struct FAccountFlagsRowHandle& AccountFlag, bool State);
	bool HasSessionFlag(struct FSessionFlagsRowHandle& SessionFlag);
	bool HasPackageFlagPlayer(class AIcarusPlayerState* PlayerState, struct FDLCPackageDataRowHandle& PackageFlag);
	bool HasFlagPlayer(class AIcarusPlayerState* PlayerState, struct FFlagsMultiRowHandle& Flag);
	bool HasCharacterFlagPlayer(class AIcarusPlayerState* PlayerState, struct FCharacterFlagsRowHandle& CharacterFlag);
	bool HasAccountFlagPlayer(class AIcarusPlayerState* PlayerState, struct FAccountFlagsRowHandle& AccountFlag);
};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.FlammableComponent
class UFlammableComponent : public UTraitComponent
{
public:
	class UFlammableInstance*                    CurrentFlammableInstance;                          // 0xD0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugFlammableInstances;                          // 0xD8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_794B[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFlammableComponent* GetDefaultObj();

	void OnFlammableInstanceState_Any_Enter(class UFlammableInstance* Instance, class UFlammableState* FlammableState);
	void OnFlammableInstanceDetached(class UFlammableInstance* Instance);
	void OnFlammableInstanceAttached(class UFlammableInstance* Instance);
	bool HasStaticMovement();
	struct FTransform GetWorldTransform();
	struct FBoxSphereBounds GetLocalBounds();
	bool GetFlammableData(struct FFlammableData* OutData);
	float GetCombustionTemperature();
	float GetCombustionMaximumTemperature();
	TArray<struct FFlammableTargetIgnite> GatherPropagationIgnitions(class UFlammableInstance* Instance);
	bool CanPropagateToTarget(const struct FFlammableTargetIgnite& Target);
	bool CanPropagate(enum class EFlammablePropagationType PropagationType);
	bool CanIgnite();
};

// 0x20 (0x100 - 0xE0)
// Class Icarus.FlammableActor
class UFlammableActor : public UFlammableComponent
{
public:
	struct FFlammableRepState                    ReplicatedState;                                   // 0xE0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bReplicatesState;                                  // 0xF8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_794C[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFlammableActor* GetDefaultObj();

	void OnRep_ReplicatedState();
};

// 0x10 (0x110 - 0x100)
// Class Icarus.FlammableActorFLOD
class UFlammableActorFLOD : public UFlammableActor
{
public:
	class UFLODActorComponent*                   FLODActorComponent;                                // 0x100(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlammableFISM*                        FlammableFISM;                                     // 0x108(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFlammableActorFLOD* GetDefaultObj();

	void RegisterRecordFlammableFISM(class UFLODRecord* Record);
	void OnUpdateInstanceVisuals(float FireSpread, float FireTemperature);
	void OnRevealing(class UFLODActorComponent* Component, class AActor* Actor, struct FTransform& Transform);
	void OnConceal(class UFLODActorComponent* Component, class AActor* Actor);
};

// 0x268 (0x348 - 0xE0)
// Class Icarus.FlammableFISM
class UFlammableFISM : public UFlammableComponent
{
public:
	class UFLODRecord*                           RegisteredRecord;                                  // 0xE0(0x8)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UFlammableInstanceFLOD*>   CurrentFlammableInstances;                         // 0xE8(0x50)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FFlammableFISMVisualData> InstanceVisualData;                                // 0x138(0x50)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FFlammableFISMVQueuedVisualData> QueuedInstanceVisualData;                          // 0x188(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FFlammableRepStateArray               ReplicatedStatesArray;                             // 0x1D8(0x148)(Edit, Net, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                         bReplicatedStatesDirty;                            // 0x320(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7959[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        VisualFireTemperatureCombustion;                   // 0x324(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireTemperatureCombustionAdded;              // 0x328(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireSpreadCombustion;                        // 0x32C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireSpreadCombustionAdded;                   // 0x330(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireSpreadLerpSpeed;                         // 0x334(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireTemperatureLerpUpSpeed;                  // 0x338(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualFireTemperatureLerpDownSpeed;                // 0x33C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualEffectsFireSpreadLerpUpSpeed;                // 0x340(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VisualEffectsFireSpreadLerpDownSpeed;              // 0x344(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFlammableFISM* GetDefaultObj();

	bool UpdateQueuedInstanceEffects(int32 InstanceIndex, struct FFlammableFISMVisualData& VisualData);
	void UpdateInstanceVisualData_Pyrolysis(class UFlammableInstanceFLOD* Instance, float DeltaSeconds, struct FFlammableFISMVisualData& TargetVisualData);
	void UpdateInstanceVisualData_Detached(class UFlammableInstanceFLOD* Instance, float DeltaSeconds, struct FFlammableFISMVisualData& TargetVisualData);
	void UpdateInstanceVisualData_Combustion(class UFlammableInstanceFLOD* Instance, float DeltaSeconds, struct FFlammableFISMVisualData& TargetVisualData);
	void UpdateInstanceVisualData_Combusted(class UFlammableInstanceFLOD* Instance, float DeltaSeconds, struct FFlammableFISMVisualData& TargetVisualData);
	void RegisterRecord(class UFLODRecord* RegisteredRecord);
	void OnReplicatedStateRemoved(struct FFlammableRepState& State);
	void OnReplicatedStateChanged(struct FFlammableRepState& State);
	void OnReplicatedStateAdded(struct FFlammableRepState& State);
	void OnRep_Record();
	void OnRecordFISMChanged(class UFLODRecord* InRecord);
	void OnFlammableInstanceFLODTick(class UFlammableInstanceFLOD* Instance, float DeltaSeconds);
	bool HasValidFISM();
	class UFLODRecord* GetRegisteredRecord();
	struct FTransform GetInstanceWorldTransform(int32 InstanceIndex);
	struct FBoxSphereBounds GetInstanceLocalBounds(int32 InstanceIndex);
	struct FFlammableRepState GetInstanceFlammableState(int32 InstanceIndex);
	TMap<int32, struct FFlammableFISMVisualData> GetInstanceCustomPrimitiveData();
	TMap<int32, class UFlammableInstanceFLOD*> GetFlammableInstances();
	class UFLODRecord* FindReplacementBurntRecord();
};

// 0x290 (0x2B8 - 0x28)
// Class Icarus.FlammableInstance
class UFlammableInstance : public UObject
{
public:
	uint8                                        Pad_7967[0x80];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<int32, class UFlammableInstance*>       QueuedAsyncPayloadInstances;                       // 0xA8(0x50)(NativeAccessSpecifierPrivate)
	bool                                         bForceNextTickTemperatureUpdate;                   // 0xF8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugInstance;                                    // 0xF9(0x1)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7968[0xE];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFlammableComponent*                   FlammableComponent;                                // 0x108(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFlammableTargetIgnite                IgnitionTarget;                                    // 0x110(0x30)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurrentInstanceTime;                               // 0x140(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LastInstanceTime;                                  // 0x144(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurrentTemperature;                                // 0x148(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LastTemperatureUpdate;                             // 0x14C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CombustionFuelMass;                                // 0x150(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurrentHeatRate;                                   // 0x154(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBiomesRowHandle                      CurrentBiome;                                      // 0x158(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        EnvironmentTemperature;                            // 0x170(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ExtinguishStartTime;                               // 0x174(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ExtinguishRampTimeAmount;                          // 0x178(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ExtinguishTimeAmount;                              // 0x17C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlammableState*                       CurrentFlammableState;                             // 0x180(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasInitialized;                                   // 0x188(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasStaticMovement;                                // 0x189(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHeatRateAffectedByTouching;                       // 0x18A(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7969[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<enum class EFlammableState, class UFlammableState*> FlammableStates;                                   // 0x190(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FBoxSphereBounds                      CachedWorldBounds;                                 // 0x1E0(0x1C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoxSphereBounds                      CachedLocalBounds;                                 // 0x1FC(0x1C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_796A[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FTransform                            CachedWorldTransform;                              // 0x220(0x30)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UFlammableInstance*, struct FBox> CachedInstanceTouchingBoxes;                       // 0x250(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_796B[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFlammableInstance* GetDefaultObj();

	void SetFlammableState(enum class EFlammableState FlammableState, bool bAllowClient);
	bool IsValidFlammable();
	bool IsExtinguished();
	bool IsCurrentState(enum class EFlammableState FlammableState);
	struct FTransform GetFlammableWorldTransform();
	struct FBoxSphereBounds GetFlammableWorldBounds();
	class UFlammableState* GetFlammableState(enum class EFlammableState FlammableState);
	struct FBoxSphereBounds GetFlammablePropagationBounds();
	struct FBoxSphereBounds GetFlammableLocalBounds();
	class UFireControllerComponent* GetFireController();
	float GetCurrentFlammableStateElapsedTime();
	float GetCombustionTemperature();
	float GetCombustionMaximumTemperature();
	TArray<class UFlammableState*> GetAllFlammableStates();
	void Extinguish(float InExtinguishRampTimeAmount, float InExtinguishTimeAmount, bool bStopCombustionImmediately);
	void DebugVisualStats(float DeltaSeconds);
};

// 0x18 (0x2D0 - 0x2B8)
// Class Icarus.FlammableInstanceFLOD
class UFlammableInstanceFLOD : public UFlammableInstance
{
public:
	class UFlammableFISM*                        FlammableFISMComponent;                            // 0x2B8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        InstanceIndex;                                     // 0x2C0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_796E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFlammableActorFLOD*                   FlammableFLODActor;                                // 0x2C8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFlammableInstanceFLOD* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FlammableLibrary
class UFlammableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFlammableLibrary* GetDefaultObj();

	struct FFlammableRowHandle StructToRowHandle(const struct FFlammableEnum& EnumValue);
	class FName StructToName(const struct FFlammableEnum& EnumValue);
	int32 StructToInt(const struct FFlammableEnum& EnumValue);
	struct FFlammableEnum RowHandleToStruct(const struct FFlammableRowHandle& RowHandle);
	void RemoveRowFromFlammableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFlammableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFlammableEnum& A, const struct FFlammableEnum& B);
	struct FFlammableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFlammableRowHandle MakeLiteralFlammable(const struct FFlammableRowHandle& RowHandle);
	struct FFlammableRowHandle MakeFlammableFromIndex(int32 Index);
	struct FFlammableEnum MakeFlammableEnum(const struct FFlammableEnum& Enum);
	struct FFlammableRowHandle MakeFlammable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFlammableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFlammableStruct(const struct FFlammableRowHandle& RowHandle, struct FFlammableData* Flammable, enum class EValid* Paths);
	bool EqualEqual_FFlammableRowHandleFFlammableRowHandle(const struct FFlammableRowHandle& RowHandleA, const struct FFlammableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFlammableEnum& A, const struct FFlammableEnum& B);
	struct FFlammableRowHandle CastToFlammableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFlammableEnum(const struct FFlammableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFlammableTable(class FName Name, const struct FFlammableData& Data, struct FFlammableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x8 (0x30 - 0x28)
// Class Icarus.FlammableState
class UFlammableState : public UObject
{
public:
	FMulticastSparseDelegateProperty_            OnInit;                                            // 0x28(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnEnter;                                           // 0x29(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnExit;                                            // 0x2A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTick;                                            // 0x2B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	float                                        EnterStateTime;                                    // 0x2C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFlammableState* GetDefaultObj();

	enum class EFlammableState GetFlammableState();
};

// 0x0 (0x30 - 0x30)
// Class Icarus.FlammableState_Detached
class UFlammableState_Detached : public UFlammableState
{
public:

	static class UClass* StaticClass();
	static class UFlammableState_Detached* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.FlammableState_Pyrolysis
class UFlammableState_Pyrolysis : public UFlammableState
{
public:

	static class UClass* StaticClass();
	static class UFlammableState_Pyrolysis* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.FlammableState_Combusting
class UFlammableState_Combusting : public UFlammableState
{
public:
	float                                        FuelMassRemaining;                                 // 0x30(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        NextPropagateSelfTime;                             // 0x34(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        HeatOfCombustion;                                  // 0x38(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bInfiniteCombustionFuel;                           // 0x3C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7989[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFlammableState_Combusting* GetDefaultObj();

};

// 0x8 (0x38 - 0x30)
// Class Icarus.FlammableState_Combusted
class UFlammableState_Combusted : public UFlammableState
{
public:
	bool                                         bDetachAfterCombusted;                             // 0x30(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_798A[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFlammableState_Combusted* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.FlammableState_Destroyed
class UFlammableState_Destroyed : public UFlammableState
{
public:

	static class UClass* StaticClass();
	static class UFlammableState_Destroyed* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FlammableTable
class UFlammableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFlammableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FlammableTargetFunctionLibrary
class UFlammableTargetFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFlammableTargetFunctionLibrary* GetDefaultObj();

	bool TryIgniteFlammableTarget(class UObject* WorldContextObject, struct FFlammableTargetIgnite& Target, class UFlammableInstance** OutInstance);
	enum class EFireExtinguishResult TryExtinguishFlammableTarget(class UObject* WorldContextObject, struct FFlammableTargetExtinguish& Target, class UFlammableInstance** OutFlammableInstance);
	bool NotEqual_FlammableTargetFlammableTarget(struct FFlammableTarget& A, struct FFlammableTarget& B);
	struct FFlammableTargetIgnite MakeFlammableTargetIgniteFromInstance(class AActor* Causer, class UFlammableInstance* Instance, float DesiredTemperatureValue, bool bFromPropagation);
	struct FFlammableTargetIgnite MakeFlammableTargetIgniteFromHitResult(class AActor* Causer, const struct FHitResult& HitResult, float DesiredTemperatureValue, bool bFromPropagation);
	struct FFlammableTargetIgnite MakeFlammableTargetIgniteFromActor(class AActor* Causer, class AActor* Actor, float DesiredTemperatureValue, bool bFromPropagation);
	struct FFlammableTargetExtinguish MakeFlammableTargetExtinguishFromInstance(class AActor* Causer, class UFlammableInstance* Instance, float ExtinguishRampTime, float ExtinguishTime, bool bStopCombustionImmediately);
	struct FFlammableTargetExtinguish MakeFlammableTargetExtinguishFromHitResult(class AActor* Causer, const struct FHitResult& HitResult, float ExtinguishRampTime, float ExtinguishTime, bool bStopCombustionImmediately);
	struct FFlammableTargetExtinguish MakeFlammableTargetExtinguishFromActor(class AActor* Causer, class AActor* Actor, float ExtinguishRampTime, float ExtinguishTime, bool bStopCombustionImmediately);
	struct FBoxSphereBounds GetFlammableWorldBoundsFromTarget(struct FFlammableTarget& Target);
	class UFlammableInstance* GetFlammableInstanceFromTarget(struct FFlammableTarget& Target);
	class UFlammableComponent* GetFlammableComponentFromTarget(struct FFlammableTarget& Target);
	struct FFlammableTarget FlammableTargetIgniteToFlammableTarget(struct FFlammableTargetIgnite& Target);
	struct FFlammableTarget FlammableTargetExtinguishToFlammableTarget(struct FFlammableTargetExtinguish& Target);
	bool EqualEqual_FlammableTargetFlammableTarget(struct FFlammableTarget& A, struct FFlammableTarget& B);
	bool CanIgniteFlammableTarget(class UObject* WorldContextObject, struct FFlammableTargetIgnite& Target);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FloatableLibrary
class UFloatableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFloatableLibrary* GetDefaultObj();

	struct FFloatableRowHandle StructToRowHandle(const struct FFloatableEnum& EnumValue);
	class FName StructToName(const struct FFloatableEnum& EnumValue);
	int32 StructToInt(const struct FFloatableEnum& EnumValue);
	struct FFloatableEnum RowHandleToStruct(const struct FFloatableRowHandle& RowHandle);
	void RemoveRowFromFloatableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFloatableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFloatableEnum& A, const struct FFloatableEnum& B);
	struct FFloatableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFloatableRowHandle MakeLiteralFloatable(const struct FFloatableRowHandle& RowHandle);
	struct FFloatableRowHandle MakeFloatableFromIndex(int32 Index);
	struct FFloatableEnum MakeFloatableEnum(const struct FFloatableEnum& Enum);
	struct FFloatableRowHandle MakeFloatable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFloatableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFloatableStruct(const struct FFloatableRowHandle& RowHandle, struct FFloatableData* Floatable, enum class EValid* Paths);
	bool EqualEqual_FFloatableRowHandleFFloatableRowHandle(const struct FFloatableRowHandle& RowHandleA, const struct FFloatableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFloatableEnum& A, const struct FFloatableEnum& B);
	struct FFloatableRowHandle CastToFloatableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFloatableEnum(const struct FFloatableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFloatableTable(class FName Name, const struct FFloatableData& Data, struct FFloatableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FloatableTable
class UFloatableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFloatableTable* GetDefaultObj();

};

// 0xD0 (0x2F0 - 0x220)
// Class Icarus.FLOD
class AFLOD : public AInfo
{
public:
	TArray<struct FFLODDescription>              Descriptions;                                      // 0x220(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bDebugStats;                                       // 0x230(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_79E4[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  DebugTileName;                                     // 0x234(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDisabled;                                         // 0x23C(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_79E5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class AFLODTile>                 TileClass;                                         // 0x240(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFLODTile*>                     Tiles;                                             // 0x248(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, RepNotify, NativeAccessSpecifierPublic)
	TArray<class UFLODActorPool*>                ActorPools;                                        // 0x258(0x10)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class UFLODInfluenceComponent*>       RegisteredInfluences;                              // 0x268(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<struct FFLODInstanceInfluence>          PreviousActiveInfluencedInstances;                 // 0x278(0x50)(NativeAccessSpecifierPublic)
	bool                                         bHasInitialisedDescriptions;                       // 0x2C8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_79E6[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FPendingRegisterFISM>          PendingRegisterFISMs;                              // 0x2D0(0x10)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                          ResolvePendingRegisterFISMsCallTimer;              // 0x2E0(0x8)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFLODRecorderComponent*                Recorder;                                          // 0x2E8(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AFLOD* GetDefaultObj();

	void OnRep_FLODTileActors();
	void OnPooledActorSpawned(class UFLODActorPool* ActorPool, struct FFLODLevelDescription& LevelDesc, class AActor* SpawnedPooledActor);
	bool IsReady();
	TArray<class AFLODTile*> GetWithinBoundsFLODTiles(struct FVector& Location);
	struct FFLODDescriptionDVInfo GetDescriptionDataValidation(struct FFLODDescription& Description);
	struct FFLODDescription FindFLODDescriptionForFISM(class UFLODFISMComponent* FISM);
};

// 0x78 (0x128 - 0xB0)
// Class Icarus.FLODActorComponent
class UFLODActorComponent : public UActorComponent
{
public:
	bool                                         bSpawnedFromPool;                                  // 0xB0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EFLODActorState                   CurrentFLODState;                                  // 0xB1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsReservingInstance;                              // 0xB2(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_79F0[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FFLODActorRecordInstance              RecordInstance;                                    // 0xB4(0x1C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnRecordInstanceAssigned;                          // 0xD0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnRevealing;                                       // 0xE0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReveal;                                          // 0xF0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnConcealing;                                      // 0x100(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnConceal;                                         // 0x110(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_79F1[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFLODActorComponent* GetDefaultObj();

	bool RevealingImpl(struct FTransform& Transform);
	void Revealing(struct FTransform& Transform);
	bool RevealImpl(struct FTransform& Transform);
	void Reveal(struct FTransform& Transform);
	void ReserveInstance();
	void ReleaseInstance();
	bool ConcealingImpl();
	void Concealing();
	bool ConcealImpl();
	void Conceal();
};

// 0x20 (0x48 - 0x28)
// Class Icarus.FLODActorPool
class UFLODActorPool : public UObject
{
public:
	TSubclassOf<class AActor>                    ActorClass;                                        // 0x28(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        InstancesInUse;                                    // 0x30(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        InitBucketSize;                                    // 0x34(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                        FreeBucket;                                        // 0x38(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFLODActorPool* GetDefaultObj();

	void OnRetrievedActorDestroyed(class AActor* DestroyedActor);
	TSubclassOf<class UFLODActorPool> DeterminePoolForActorClass(TSubclassOf<class AActor>& ActorClass);
};

// 0x8 (0x50 - 0x48)
// Class Icarus.FLODTreePrefabPool
class UFLODTreePrefabPool : public UFLODActorPool
{
public:
	class ATreePrefab*                           TreePrefab;                                        // 0x48(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UFLODTreePrefabPool* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.UFLODItemActorPool
class UUFLODItemActorPool : public UFLODActorPool
{
public:

	static class UClass* StaticClass();
	static class UUFLODItemActorPool* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FLODDescriptionsLibrary
class UFLODDescriptionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFLODDescriptionsLibrary* GetDefaultObj();

	struct FFLODDescriptionsRowHandle StructToRowHandle(const struct FFLODDescriptionsEnum& EnumValue);
	class FName StructToName(const struct FFLODDescriptionsEnum& EnumValue);
	int32 StructToInt(const struct FFLODDescriptionsEnum& EnumValue);
	struct FFLODDescriptionsEnum RowHandleToStruct(const struct FFLODDescriptionsRowHandle& RowHandle);
	void RemoveRowFromFLODDescriptionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFLODDescriptionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFLODDescriptionsEnum& A, const struct FFLODDescriptionsEnum& B);
	struct FFLODDescriptionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFLODDescriptionsRowHandle MakeLiteralFLODDescriptions(const struct FFLODDescriptionsRowHandle& RowHandle);
	struct FFLODDescriptionsRowHandle MakeFLODDescriptionsFromIndex(int32 Index);
	struct FFLODDescriptionsEnum MakeFLODDescriptionsEnum(const struct FFLODDescriptionsEnum& Enum);
	struct FFLODDescriptionsRowHandle MakeFLODDescriptions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFLODDescriptionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFLODDescriptionsStruct(const struct FFLODDescriptionsRowHandle& RowHandle, struct FFLODDescription* FLODDescriptions, enum class EValid* Paths);
	bool EqualEqual_FFLODDescriptionsRowHandleFFLODDescriptionsRowHandle(const struct FFLODDescriptionsRowHandle& RowHandleA, const struct FFLODDescriptionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFLODDescriptionsEnum& A, const struct FFLODDescriptionsEnum& B);
	struct FFLODDescriptionsRowHandle CastToFLODDescriptionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFLODDescriptionsEnum(const struct FFLODDescriptionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFLODDescriptionsTable(class FName Name, const struct FFLODDescription& Data, struct FFLODDescriptionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FLODDescriptionsTable
class UFLODDescriptionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFLODDescriptionsTable* GetDefaultObj();

};

// 0xB0 (0x760 - 0x6B0)
// Class Icarus.FLODFISMComponent
class UFLODFISMComponent : public UFoliageInstancedStaticMeshComponent
{
public:
	int32                                        RegisteredRecordIndex;                             // 0x6B0(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AFLODTile>              RegisteredFLODTile;                                // 0x6B4(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFlammableFISM>         RegisteredFlammable;                               // 0x6BC(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A18[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x6C8(0x20)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UFoliageType*                          CachedFoliageType;                                 // 0x6E8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7A19[0x70];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFLODFISMComponent* GetDefaultObj();

	void SetInfluencePhysicsRadius(class UObject* WorldContextObject, float NewRadius);
	void SetInfluenceOverlapRadius(class UObject* WorldContextObject, float NewRadius);
	void SetInfluenceFireInstanceRadius(class UObject* WorldContextObject, float NewRadius);
	void SetFISMPhysDebugEnabled(bool bNewEnabled);
	bool HasRegisteredToFLOD();
	int32 GetTotalFISMPhysInstances();
	void GetTotalFISMPhysInstanceChanges(int32* TotalAdded, int32* TotalRemoved);
	class FName GetLevelTileName();
	float GetInfluencePhysicsRadius();
	float GetInfluenceOverlapRadius();
	bool GetFISMPhysDebugEnabled();
};

// 0x18 (0xC8 - 0xB0)
// Class Icarus.FLODInfluenceComponent
class UFLODInfluenceComponent : public UActorComponent
{
public:
	bool                                         bTryRegisterSelf;                                  // 0xB0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasRegisteredAsInfluence;                         // 0xB1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7A1E[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FFLODInstanceInfluence>        ActiveInstanceInfluences;                          // 0xB8(0x10)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UFLODInfluenceComponent* GetDefaultObj();

	void UpdateActiveInfluences();
	void UpdateActiveInfluencedInstance(struct FFLODInstanceID& InstanceId, int32 InfluenceLevelIndex, float TimeoutDuration);
	void UnregisterInfluence();
	bool RemoveActiveInstanceInfluence(struct FFLODInstanceInfluence& InstanceInfluence);
	bool RegisterInfluence();
	void OnActiveInfluencedInstanceUpdated(struct FFLODInstanceInfluence& InstanceInfluence);
	void OnActiveInfluencedInstanceTimeout(struct FFLODInstanceInfluence& InstanceInfluence);
	void OnActiveInfluencedInstanceRemoved(struct FFLODInstanceInfluence& InstanceInfluence);
	void OnActiveInfluencedInstanceAdded(struct FFLODInstanceInfluence& InstanceInfluence);
	bool HasRegisteredToFLOD();
	TArray<struct FFLODInstanceInfluence> GetActiveInstanceInfluences();
};

// 0x8 (0xD0 - 0xC8)
// Class Icarus.FLODInfluenceDistance
class UFLODInfluenceDistance : public UFLODInfluenceComponent
{
public:
	float                                        DistanceInfluenceTimeout;                          // 0xC8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A1F[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFLODInfluenceDistance* GetDefaultObj();

};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.FLODInfluencePlayer
class UFLODInfluencePlayer : public UFLODInfluenceDistance
{
public:
	float                                        ViewTraceInfluenceTimeout;                         // 0xD0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A20[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusPlayerController*               RegisteredIcarusPlayerController;                  // 0xD8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFLODInfluencePlayer* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FLODLibrary
class UFLODLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFLODLibrary* GetDefaultObj();

	TArray<struct FFLODInstanceID> GetFLODInstancesOverlappingSphere(class UObject* WorldContextObject, struct FVector& Location, float Radius, struct FGameplayTagQuery& TagQuery, bool bIncludeDestroyed);
	class AFLOD* GetFLOD(class UObject* WorldContextObject);
	class AActor* FindActorFromInstanceID(struct FFLODInstanceID& InstanceId, uint8 StateMask);
	bool EqualEqual_FFLODInstanceIDFFLODInstanceID(const struct FFLODInstanceID& A, const struct FFLODInstanceID& B);
	bool EqualEqual_FFLODInstanceFFLODInstance(const struct FFLODRecordInstance& A, const struct FFLODRecordInstance& B);
};

// 0x590 (0x5B8 - 0x28)
// Class Icarus.FLODRecord
class UFLODRecord : public UObject
{
public:
	FMulticastSparseDelegateProperty_            OnRecordFISMChanged;                               // 0x28(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A30[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        RecordIndex;                                       // 0x2C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFLODTile*                             Owner;                                             // 0x30(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFLODFISMComponent>     RegisteredFISM;                                    // 0x38(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                ActorPoolIndices;                                  // 0x40(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FFLODRecordInstanceIndices>    DesiredLevelStates;                                // 0x50(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FFLODRecordStateView                  CurrentStateView;                                  // 0x60(0xC0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FFLODRecordStateView                  TargetStateView;                                   // 0x120(0xC0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FFLODRecordStateView                  PristineStateView;                                 // 0x1E0(0xC0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                         bHasInitialized;                                   // 0x2A0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ENetRole                          RecordRole;                                        // 0x2A1(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A32[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<uint32>                               DestroyedInstanceData;                             // 0x2A8(0x10)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	struct FFLODRecordInstanceArray              ReplicatedInstanceArray;                           // 0x2B8(0x148)(Edit, Net, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FFLODRecordInstance>           SanitizedInstances;                                // 0x400(0x10)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	struct FFLODRecordDynamicInstanceArray       ReplicatedDynamicInstanceArray;                    // 0x410(0x148)(Edit, Net, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FFLODRecordDynamicInstance>    SanitizedDynamicInstances;                         // 0x558(0x10)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	bool                                         bCheckPendingInstanceChanges;                      // 0x568(0x1)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7A34[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        CheckPendingInstanceChangesFrame;                  // 0x56C(0x4)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFLODRecordPendingInstanceChange> PendingInstanceChanges;                            // 0x570(0x10)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FFLODRecordInstanceChangeSet          ActiveInstanceChangeSet;                           // 0x580(0x30)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7A35[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFLODRecord* GetDefaultObj();

	void SetPristineStateViewModified();
	void RestoreInstances(const TArray<int32>& RestoreIndices);
	void OnRep_DestroyedInstanceData();
	bool HasRegisteredFISM();
	class AFLOD* GetOwnerFLOD();
	struct FFLODDescription GetDescription();
	void DestroyInstances(const TArray<int32>& DestroyIndices);
	int32 AddDynamicInstance(struct FTransform& Transform);
};

// 0x8 (0xE0 - 0xD8)
// Class Icarus.FLODRecorderComponent
class UFLODRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	struct FFLODRecorderRecord                   Record;                                            // 0xD8(0x4)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7A37[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFLODRecorderComponent* GetDefaultObj();

};

// 0x18 (0xC8 - 0xB0)
// Class Icarus.FLODRewardComponent
class UFLODRewardComponent : public UActorComponent
{
public:
	struct FItemRewardsRowHandle                 ItemRewards;                                       // 0xB0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UFLODRewardComponent* GetDefaultObj();

};

// 0xC0 (0x2E0 - 0x220)
// Class Icarus.FLODTile
class AFLODTile : public AInfo
{
public:
	class FName                                  TileName;                                          // 0x220(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RelevanceRadius;                                   // 0x228(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A42[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AFLODTileBehaviourHarness*             BehaviourHarness;                                  // 0x230(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UFLODRecord*>              Records;                                           // 0x238(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                         bDebugInstancesCurrent;                            // 0x288(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugInstancesCurrentAdv;                         // 0x289(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugPhysicsInstancesCurrent;                     // 0x28A(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugStats;                                       // 0x28B(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DebugRecordIndex;                                  // 0x28C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>            DebugInstanceCurrentMaterials;                     // 0x290(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                    DebugPhysicsInstancesMaterial;                     // 0x2A0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7A44[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UFLODRecord*>                   ReplicatedRecords;                                 // 0x2C0(0x10)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                         bReadingGameStateFromDatabase;                     // 0x2D0(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7A45[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFLODTileRecorderComponent*            Recorder;                                          // 0x2D8(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AFLODTile* GetDefaultObj();

	int32 SwapRecordInstance(class UFLODRecord* SourceRecord, class UFLODRecord* TargetRecord, int32 InstanceIndex);
	void SetDebugInstancesCurrent(bool bState);
	void OnRep_ReplicatedRecords();
	bool IsBasedOnLandscapeProxy(class ALandscapeProxy* LandscapeProxy);
	class AFLOD* GetOwnerFLOD();
	class UFLODRecord* FindRecordByRecordIndex(int32 RecordIndex);
	class UFLODFISMComponent* FindFISMFromRecordIndex(int32 RecordIndex);
	void DebugDestroyAllInstances(int32 RecordIndex, bool bRestore);
};

// 0x18 (0x238 - 0x220)
// Class Icarus.FLODTileBehaviourHarness
class AFLODTileBehaviourHarness : public AActor
{
public:
	class AFLODTile*                             OwnerTile;                                         // 0x220(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlammableFISM*>                FlammableComponents;                               // 0x228(0x10)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AFLODTileBehaviourHarness* GetDefaultObj();

};

// 0x68 (0x140 - 0xD8)
// Class Icarus.FLODTileRecorderComponent
class UFLODTileRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	uint8                                        Pad_7A46[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FFLODTileRecorderRecord               Record;                                            // 0xE0(0x60)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UFLODTileRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FMODParameterFunctionLibrary
class UFMODParameterFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UFMODParameterFunctionLibrary* GetDefaultObj();

	void SetGlobalVolumeSoundeffectsParameter(float FloatValue);
	void SetGlobalVolumeMusicParameter(float FloatValue);
	void SetGlobalVolumeMasterParameter(float FloatValue);
	void SetGlobalVolumeDialogueParameter(float FloatValue);
	void SetGlobalVolumeCharacterVoiceParameter(float FloatValue);
	void SetGlobalVolumeAmbientParameter(float FloatValue);
	void SetGlobalQuadStrengthRightParameter(float FloatValue);
	void SetGlobalQuadStrengthLeftParameter(float FloatValue);
	void SetGlobalQuadStrengthFRParameter(float FloatValue);
	void SetGlobalQuadStrengthFLParameter(float FloatValue);
	void SetGlobalQuadStrengthBRParameter(float FloatValue);
	void SetGlobalQuadStrengthBLParameter(float FloatValue);
	void SetGlobalQuadStrengthAverageParameter(float FloatValue);
	void SetGlobalQuadDistFRParameter(float FloatValue);
	void SetGlobalQuadDistFLParameter(float FloatValue);
	void SetGlobalQuadDistBRParameter(float FloatValue);
	void SetGlobalQuadDistBLParameter(float FloatValue);
	void SetGlobalPlayerZPositionParameter(float FloatValue);
	void SetGlobalPlayerUnderwaterParameter(float FloatValue);
	void SetGlobalPlayerStaminaParameter(float FloatValue);
	void SetGlobalPlayerShelterSurfaceReflectionParameter(float FloatValue);
	void SetGlobalPlayerShelterSurfaceLowFreqParameter(float FloatValue);
	void SetGlobalPlayerShelterSurfaceHighFreqParameter(float FloatValue);
	void SetGlobalPlayerShelterParameter(float FloatValue);
	void SetGlobalPlayerReflectionLowFreqParameter(float FloatValue);
	void SetGlobalPlayerReflectionHighFreqParameter(float FloatValue);
	void SetGlobalPlayerKillcamParameter(float FloatValue);
	void SetGlobalPlayerHealthParameter(float FloatValue);
	void SetGlobalPlayerDeadParameter(float FloatValue);
	void SetGlobalPlayerClosestReflectionParameter(float FloatValue);
	void SetGlobalPlayerCharacterVoiceParameter(enum class EGlobalPlayerCharacterVoiceFMODParam GlobalPlayerCharacterVoiceValue);
	void SetGlobalPlayerAverageReflectionParameter(float FloatValue);
	void SetGlobalPlayerAsleepParameter(float FloatValue);
	void SetGlobalMusicIcarusThemePlayCountParameter(int32 IntegerValue);
	void SetGlobalLoadingScreenStateParameter(enum class EGlobalLoadingScreenStateFMODParam GlobalLoadingScreenStateValue);
	void SetGlobalHabMasterParameter(float FloatValue);
	void SetGlobalFoliageTreeDensityParameter(float FloatValue);
	void SetGlobalFoliageTreeCoverParameter(float FloatValue);
	void SetGlobalFoliageTreeCountParameter(float FloatValue);
	void SetGlobalFoliageTreeCloseCountParameter(float FloatValue);
	void SetGlobalFoliageBushCountParameter(float FloatValue);
	void SetGlobalEnvironmentWindParameter(float FloatValue);
	void SetGlobalEnvironmentWindExposureParameter(float FloatValue);
	void SetGlobalEnvironmentVolcanicEmbersParameter(float FloatValue);
	void SetGlobalEnvironmentVolcanicAshParameter(float FloatValue);
	void SetGlobalEnvironmentTimeParameter(float FloatValue);
	void SetGlobalEnvironmentThunderParameter(float FloatValue);
	void SetGlobalEnvironmentTerrainZoneParameter(enum class EGlobalEnvironmentTerrainZoneFMODParam GlobalEnvironmentTerrainZoneValue);
	void SetGlobalEnvironmentTerrainZoneCanyonWideParameter(float FloatValue);
	void SetGlobalEnvironmentTerrainZoneCanyonNarrowParameter(float FloatValue);
	void SetGlobalEnvironmentTerrainZoneCanyonMedParameter(float FloatValue);
	void SetGlobalEnvironmentStormParameter(float FloatValue);
	void SetGlobalEnvironmentSnowstormParameter(float FloatValue);
	void SetGlobalEnvironmentSnowParameter(float FloatValue);
	void SetGlobalEnvironmentSandstormParameter(float FloatValue);
	void SetGlobalEnvironmentRainParameter(float FloatValue);
	void SetGlobalEnvironmentOvercastParameter(float FloatValue);
	void SetGlobalEnvironmentMegatreeDistToEdgeParameter(float FloatValue);
	void SetGlobalEnvironmentMegatreeClimbUpParameter(float FloatValue);
	void SetGlobalEnvironmentHailParameter(float FloatValue);
	void SetGlobalEnvironmentFireIntensityParameter(float FloatValue);
	void SetGlobalEnvironmentDebrisParameter(float FloatValue);
	void SetGlobalEnvironmentCrevasseDepthParameter(float FloatValue);
	void SetGlobalEnvironmentCaveParameter(float FloatValue);
	void SetGlobalEnvironmentBiomeParameter(enum class EGlobalEnvironmentBiomeFMODParam GlobalEnvironmentBiomeValue);
	void SetGlobalEnvironmentAcidRainParameter(float FloatValue);
	void SetGlobalDropStateParameter(enum class EGlobalDropStateFMODParam GlobalDropStateValue);
	void SetEventWeaponReloadingParameter(const struct FFMODEventInstance& EventInstance, enum class EWeaponReloadingFMODParam WeaponReloadingValue);
	void SetEventWeaponChargingParameter(const struct FFMODEventInstance& EventInstance, enum class EWeaponChargingFMODParam WeaponChargingValue);
	void SetEventWeaponChargeParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWeaponBallisticLaunchVelocityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWeaponAmmoParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWeaponAimingParameter(const struct FFMODEventInstance& EventInstance, enum class EWeaponAimingFMODParam WeaponAimingValue);
	void SetEventWaterWaterfallWidthParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterWaterfallHeightParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterProximityInfluenceParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterPlayerZPositionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterIslandDistanceParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterImmersionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventWaterEnvelopmentParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventUiMapZoomRocParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventUiCharacterLevelParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventTreeVelocityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventTreeSplitPiecesParameter(const struct FFMODEventInstance& EventInstance, int32 IntegerValue);
	void SetEventTreeMassParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventTreeFallSpeedParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventTreeFallAmountParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventTreeDetachContextParameter(const struct FFMODEventInstance& EventInstance, enum class ETreeDetachContextFMODParam TreeDetachContextValue);
	void SetEventTreeBranchBreaksParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventSurveyTransmitParameter(const struct FFMODEventInstance& EventInstance, enum class ESurveyTransmitFMODParam SurveyTransmitValue);
	void SetEventSurveyLaserParameter(const struct FFMODEventInstance& EventInstance, enum class ESurveyLaserFMODParam SurveyLaserValue);
	void SetEventSurfaceParameter(const struct FFMODEventInstance& EventInstance, enum class ESurfaceFMODParam SurfaceValue);
	void SetEventStationCollisionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerWaterDepthParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerVelocityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerTypeParameter(const struct FFMODEventInstance& EventInstance, enum class EPlayerTypeFMODParam PlayerTypeValue);
	void SetEventPlayerStanceParameter(const struct FFMODEventInstance& EventInstance, enum class EPlayerStanceFMODParam PlayerStanceValue);
	void SetEventPlayerModifierStackSizeParameter(const struct FFMODEventInstance& EventInstance, int32 IntegerValue);
	void SetEventPlayerModifierEffectivenessParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerGroundStateParameter(const struct FFMODEventInstance& EventInstance, enum class EPlayerGroundStateFMODParam PlayerGroundStateValue);
	void SetEventPlayerFoliageParameter(const struct FFMODEventInstance& EventInstance, enum class EPlayerFoliageFMODParam PlayerFoliageValue);
	void SetEventPlayerFloorSlopeParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerDamageParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerClothCollisionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerBoneVelocityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventPlayerArmourTypeParameter(const struct FFMODEventInstance& EventInstance, enum class EPlayerArmourTypeFMODParam PlayerArmourTypeValue);
	void SetEventParticleCountParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventOcclusionShelterContextParameter(const struct FFMODEventInstance& EventInstance, enum class EOcclusionShelterContextFMODParam OcclusionShelterContextValue);
	void SetEventOcclusionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventMusicTrackStateParameter(const struct FFMODEventInstance& EventInstance, int32 IntegerValue);
	void SetEventMusicNarrativemusictestParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventMusicFadeParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventMultiPointSpreadParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventMultiPointCountParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventItemWeatherExposureParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventItemHitSuccessParameter(const struct FFMODEventInstance& EventInstance, int32 IntegerValue);
	void SetEventItemHealthParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventItemFlameMovementParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventItemDamageParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventItemCraftingTypeParameter(const struct FFMODEventInstance& EventInstance, enum class EItemCraftingTypeFMODParam ItemCraftingTypeValue);
	void SetEventItemCraftingCountParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventIntensityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventFireStateParameter(const struct FFMODEventInstance& EventInstance, enum class EFireStateFMODParam FireStateValue);
	void SetEventEnvironmentLightningTargetParameter(const struct FFMODEventInstance& EventInstance, enum class EEnvironmentLightningTargetFMODParam EnvironmentLightningTargetValue);
	void SetEventEnvironmentLavaFlowParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventEnvironmentBiomeInfluenceParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventDropshipOcclusionParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventDropshipDescentStateParameter(const struct FFMODEventInstance& EventInstance, enum class EDropshipDescentStateFMODParam DropshipDescentStateValue);
	void SetEventDepOxitedBalloonsizeParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventDamageTypeParameter(const struct FFMODEventInstance& EventInstance, enum class EDamageTypeFMODParam DamageTypeValue);
	void SetEventCreatureVelocityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventCreatureFootstepTypeParameter(const struct FFMODEventInstance& EventInstance, enum class ECreatureFootstepTypeFMODParam CreatureFootstepTypeValue);
	void SetEventCreatureFoliageParameter(const struct FFMODEventInstance& EventInstance, enum class ECreatureFoliageFMODParam CreatureFoliageValue);
	void SetEventCaveListenerCorrelationParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventCaveContextParameter(const struct FFMODEventInstance& EventInstance, enum class ECaveContextFMODParam CaveContextValue);
	void SetEventBuildingUnzipParameter(const struct FFMODEventInstance& EventInstance, enum class EBuildingUnzipFMODParam BuildingUnzipValue);
	void SetEventBuildingStabilityParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventBuildingSnowParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetEventBuildingOpenParameter(const struct FFMODEventInstance& EventInstance, enum class EBuildingOpenFMODParam BuildingOpenValue);
	void SetEventAnimStateParameter(const struct FFMODEventInstance& EventInstance, enum class EAnimStateFMODParam AnimStateValue);
	void SetEventAnimSpeedParameter(const struct FFMODEventInstance& EventInstance, float FloatValue);
	void SetComponentWeaponReloadingParameter(class UFMODAudioComponent* AudioComponent, enum class EWeaponReloadingFMODParam WeaponReloadingValue);
	void SetComponentWeaponChargingParameter(class UFMODAudioComponent* AudioComponent, enum class EWeaponChargingFMODParam WeaponChargingValue);
	void SetComponentWeaponChargeParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWeaponBallisticLaunchVelocityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWeaponAmmoParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWeaponAimingParameter(class UFMODAudioComponent* AudioComponent, enum class EWeaponAimingFMODParam WeaponAimingValue);
	void SetComponentWaterWaterfallWidthParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterWaterfallHeightParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterProximityInfluenceParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterPlayerZPositionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterIslandDistanceParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterImmersionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentWaterEnvelopmentParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentUiMapZoomRocParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentUiCharacterLevelParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentTreeVelocityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentTreeSplitPiecesParameter(class UFMODAudioComponent* AudioComponent, int32 IntegerValue);
	void SetComponentTreeMassParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentTreeFallSpeedParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentTreeFallAmountParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentTreeDetachContextParameter(class UFMODAudioComponent* AudioComponent, enum class ETreeDetachContextFMODParam TreeDetachContextValue);
	void SetComponentTreeBranchBreaksParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentSurveyTransmitParameter(class UFMODAudioComponent* AudioComponent, enum class ESurveyTransmitFMODParam SurveyTransmitValue);
	void SetComponentSurveyLaserParameter(class UFMODAudioComponent* AudioComponent, enum class ESurveyLaserFMODParam SurveyLaserValue);
	void SetComponentSurfaceParameter(class UFMODAudioComponent* AudioComponent, enum class ESurfaceFMODParam SurfaceValue);
	void SetComponentStationCollisionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerWaterDepthParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerVelocityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerTypeParameter(class UFMODAudioComponent* AudioComponent, enum class EPlayerTypeFMODParam PlayerTypeValue);
	void SetComponentPlayerStanceParameter(class UFMODAudioComponent* AudioComponent, enum class EPlayerStanceFMODParam PlayerStanceValue);
	void SetComponentPlayerModifierStackSizeParameter(class UFMODAudioComponent* AudioComponent, int32 IntegerValue);
	void SetComponentPlayerModifierEffectivenessParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerGroundStateParameter(class UFMODAudioComponent* AudioComponent, enum class EPlayerGroundStateFMODParam PlayerGroundStateValue);
	void SetComponentPlayerFoliageParameter(class UFMODAudioComponent* AudioComponent, enum class EPlayerFoliageFMODParam PlayerFoliageValue);
	void SetComponentPlayerFloorSlopeParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerDamageParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerClothCollisionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerBoneVelocityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentPlayerArmourTypeParameter(class UFMODAudioComponent* AudioComponent, enum class EPlayerArmourTypeFMODParam PlayerArmourTypeValue);
	void SetComponentParticleCountParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentOcclusionShelterContextParameter(class UFMODAudioComponent* AudioComponent, enum class EOcclusionShelterContextFMODParam OcclusionShelterContextValue);
	void SetComponentOcclusionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentMusicTrackStateParameter(class UFMODAudioComponent* AudioComponent, int32 IntegerValue);
	void SetComponentMusicNarrativemusictestParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentMusicFadeParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentMultiPointSpreadParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentMultiPointCountParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentItemWeatherExposureParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentItemHitSuccessParameter(class UFMODAudioComponent* AudioComponent, int32 IntegerValue);
	void SetComponentItemHealthParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentItemFlameMovementParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentItemDamageParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentItemCraftingTypeParameter(class UFMODAudioComponent* AudioComponent, enum class EItemCraftingTypeFMODParam ItemCraftingTypeValue);
	void SetComponentItemCraftingCountParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentIntensityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentFireStateParameter(class UFMODAudioComponent* AudioComponent, enum class EFireStateFMODParam FireStateValue);
	void SetComponentEnvironmentLightningTargetParameter(class UFMODAudioComponent* AudioComponent, enum class EEnvironmentLightningTargetFMODParam EnvironmentLightningTargetValue);
	void SetComponentEnvironmentLavaFlowParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentEnvironmentBiomeInfluenceParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentDropshipOcclusionParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentDropshipDescentStateParameter(class UFMODAudioComponent* AudioComponent, enum class EDropshipDescentStateFMODParam DropshipDescentStateValue);
	void SetComponentDepOxitedBalloonsizeParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentDamageTypeParameter(class UFMODAudioComponent* AudioComponent, enum class EDamageTypeFMODParam DamageTypeValue);
	void SetComponentCreatureVelocityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentCreatureFootstepTypeParameter(class UFMODAudioComponent* AudioComponent, enum class ECreatureFootstepTypeFMODParam CreatureFootstepTypeValue);
	void SetComponentCreatureFoliageParameter(class UFMODAudioComponent* AudioComponent, enum class ECreatureFoliageFMODParam CreatureFoliageValue);
	void SetComponentCaveListenerCorrelationParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentCaveContextParameter(class UFMODAudioComponent* AudioComponent, enum class ECaveContextFMODParam CaveContextValue);
	void SetComponentBuildingUnzipParameter(class UFMODAudioComponent* AudioComponent, enum class EBuildingUnzipFMODParam BuildingUnzipValue);
	void SetComponentBuildingStabilityParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentBuildingSnowParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
	void SetComponentBuildingOpenParameter(class UFMODAudioComponent* AudioComponent, enum class EBuildingOpenFMODParam BuildingOpenValue);
	void SetComponentAnimStateParameter(class UFMODAudioComponent* AudioComponent, enum class EAnimStateFMODParam AnimStateValue);
	void SetComponentAnimSpeedParameter(class UFMODAudioComponent* AudioComponent, float FloatValue);
};

// 0x8 (0xD8 - 0xD0)
// Class Icarus.FocusableComponent
class UFocusableComponent : public UTraitComponent
{
public:
	bool                                         IsFocused;                                         // 0xD0(0x1)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7B35[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UFocusableComponent* GetDefaultObj();

	void Unfocus();
	void OnUnfocused();
	void OnRep_IsFocused();
	void OnFocused();
	void NotifyMeshChanged();
	class AActor* GetInvokingActor();
	bool GetFocusableData(struct FFocusableData* OutData);
	void Focus();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FocusableLibrary
class UFocusableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFocusableLibrary* GetDefaultObj();

	struct FFocusableRowHandle StructToRowHandle(const struct FFocusableEnum& EnumValue);
	class FName StructToName(const struct FFocusableEnum& EnumValue);
	int32 StructToInt(const struct FFocusableEnum& EnumValue);
	struct FFocusableEnum RowHandleToStruct(const struct FFocusableRowHandle& RowHandle);
	void RemoveRowFromFocusableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFocusableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFocusableEnum& A, const struct FFocusableEnum& B);
	struct FFocusableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFocusableRowHandle MakeLiteralFocusable(const struct FFocusableRowHandle& RowHandle);
	struct FFocusableRowHandle MakeFocusableFromIndex(int32 Index);
	struct FFocusableEnum MakeFocusableEnum(const struct FFocusableEnum& Enum);
	struct FFocusableRowHandle MakeFocusable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFocusableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFocusableStruct(const struct FFocusableRowHandle& RowHandle, struct FFocusableData* Focusable, enum class EValid* Paths);
	bool EqualEqual_FFocusableRowHandleFFocusableRowHandle(const struct FFocusableRowHandle& RowHandleA, const struct FFocusableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFocusableEnum& A, const struct FFocusableEnum& B);
	struct FFocusableRowHandle CastToFocusableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFocusableEnum(const struct FFocusableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFocusableTable(class FName Name, const struct FFocusableData& Data, struct FFocusableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FocusableTable
class UFocusableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFocusableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FoodTypesLibrary
class UFoodTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFoodTypesLibrary* GetDefaultObj();

	struct FFoodTypesRowHandle StructToRowHandle(const struct FFoodTypesEnum& EnumValue);
	class FName StructToName(const struct FFoodTypesEnum& EnumValue);
	int32 StructToInt(const struct FFoodTypesEnum& EnumValue);
	struct FFoodTypesEnum RowHandleToStruct(const struct FFoodTypesRowHandle& RowHandle);
	void RemoveRowFromFoodTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFoodTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFoodTypesEnum& A, const struct FFoodTypesEnum& B);
	struct FFoodTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFoodTypesRowHandle MakeLiteralFoodTypes(const struct FFoodTypesRowHandle& RowHandle);
	struct FFoodTypesRowHandle MakeFoodTypesFromIndex(int32 Index);
	struct FFoodTypesEnum MakeFoodTypesEnum(const struct FFoodTypesEnum& Enum);
	struct FFoodTypesRowHandle MakeFoodTypes(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFoodTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFoodTypesStruct(const struct FFoodTypesRowHandle& RowHandle, struct FIcarusFoodType* FoodTypes, enum class EValid* Paths);
	bool EqualEqual_FFoodTypesRowHandleFFoodTypesRowHandle(const struct FFoodTypesRowHandle& RowHandleA, const struct FFoodTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFoodTypesEnum& A, const struct FFoodTypesEnum& B);
	struct FFoodTypesRowHandle CastToFoodTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFoodTypesEnum(const struct FFoodTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFoodTypesTable(class FName Name, const struct FIcarusFoodType& Data, struct FFoodTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FoodTypesTable
class UFoodTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFoodTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.FootstepReceiverInterface
class IFootstepReceiverInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IFootstepReceiverInterface* GetDefaultObj();

	void ReceivedFootstep(class AActor* Actor, const struct FVector& Location);
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.FuelComponent
class UFuelComponent : public UResourceNetworkComponent
{
public:

	static class UClass* StaticClass();
	static class UFuelComponent* GetDefaultObj();

	bool GetFuelData(struct FFuelData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.FuelLibrary
class UFuelLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UFuelLibrary* GetDefaultObj();

	struct FFuelRowHandle StructToRowHandle(const struct FFuelEnum& EnumValue);
	class FName StructToName(const struct FFuelEnum& EnumValue);
	int32 StructToInt(const struct FFuelEnum& EnumValue);
	struct FFuelEnum RowHandleToStruct(const struct FFuelRowHandle& RowHandle);
	void RemoveRowFromFuelTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FFuelEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FFuelEnum& A, const struct FFuelEnum& B);
	struct FFuelEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FFuelRowHandle MakeLiteralFuel(const struct FFuelRowHandle& RowHandle);
	struct FFuelRowHandle MakeFuelFromIndex(int32 Index);
	struct FFuelEnum MakeFuelEnum(const struct FFuelEnum& Enum);
	struct FFuelRowHandle MakeFuel(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FFuelEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetFuelStruct(const struct FFuelRowHandle& RowHandle, struct FFuelData* Fuel, enum class EValid* Paths);
	bool EqualEqual_FFuelRowHandleFFuelRowHandle(const struct FFuelRowHandle& RowHandleA, const struct FFuelRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FFuelEnum& A, const struct FFuelEnum& B);
	struct FFuelRowHandle CastToFuelRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakFuelEnum(const struct FFuelEnum& Enum, class FName* Name, int32* Index);
	void AddRowToFuelTable(class FName Name, const struct FFuelData& Data, struct FFuelRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.FuelTable
class UFuelTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UFuelTable* GetDefaultObj();

};

// 0xD8 (0x280 - 0x1A8)
// Class Icarus.GameModeStateRecorderComponent
class UGameModeStateRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FGameModeRecord                       GameModeRecord;                                    // 0x1A8(0x40)(Edit, EditConst, SaveGame, NativeAccessSpecifierPrivate)
	struct FSpawnRecord                          GameModeSpawnRecord;                               // 0x1E8(0x1)(Edit, EditConst, SaveGame, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7B82[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class FString, int32>                   PreviouslyAssignedPlayerColors;                    // 0x1F0(0x50)(Edit, EditConst, SaveGame, NativeAccessSpecifierPrivate)
	int32                                        PlayerColorIndex;                                  // 0x240(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        DynamicQuestSeed;                                  // 0x244(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerRewardScheduleRecord>   PlayerRewards;                                     // 0x248(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FMissionHistoryRecord>         MissionHistory;                                    // 0x258(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FStoredPlayerItemsRecord>      StoredPlayerItems;                                 // 0x268(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, NativeAccessSpecifierPrivate)
	int32                                        NextMeteorShowerTime;                              // 0x278(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        Version;                                           // 0x27C(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UGameModeStateRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GameplayConfigLibrary
class UGameplayConfigLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGameplayConfigLibrary* GetDefaultObj();

	struct FGameplayConfigRowHandle StructToRowHandle(const struct FGameplayConfigEnum& EnumValue);
	class FName StructToName(const struct FGameplayConfigEnum& EnumValue);
	int32 StructToInt(const struct FGameplayConfigEnum& EnumValue);
	struct FGameplayConfigEnum RowHandleToStruct(const struct FGameplayConfigRowHandle& RowHandle);
	void RemoveRowFromGameplayConfigTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGameplayConfigEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGameplayConfigEnum& A, const struct FGameplayConfigEnum& B);
	struct FGameplayConfigEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGameplayConfigRowHandle MakeLiteralGameplayConfig(const struct FGameplayConfigRowHandle& RowHandle);
	struct FGameplayConfigRowHandle MakeGameplayConfigFromIndex(int32 Index);
	struct FGameplayConfigEnum MakeGameplayConfigEnum(const struct FGameplayConfigEnum& Enum);
	struct FGameplayConfigRowHandle MakeGameplayConfig(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGameplayConfigEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGameplayConfigStruct(const struct FGameplayConfigRowHandle& RowHandle, struct FGameplayConfig* GameplayConfig, enum class EValid* Paths);
	bool EqualEqual_FGameplayConfigRowHandleFGameplayConfigRowHandle(const struct FGameplayConfigRowHandle& RowHandleA, const struct FGameplayConfigRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGameplayConfigEnum& A, const struct FGameplayConfigEnum& B);
	struct FGameplayConfigRowHandle CastToGameplayConfigRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGameplayConfigEnum(const struct FGameplayConfigEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGameplayConfigTable(class FName Name, const struct FGameplayConfig& Data, struct FGameplayConfigRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GameplayConfigTable
class UGameplayConfigTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGameplayConfigTable* GetDefaultObj();

};

// 0x28 (0x248 - 0x220)
// Class Icarus.GameplayTagActor
class AGameplayTagActor : public AActor
{
public:
	uint8                                        Pad_7BA6[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x228(0x20)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AGameplayTagActor* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.GameUserSettingsSubsystem
class UGameUserSettingsSubsystem : public UGameInstanceSubsystem
{
public:

	static class UClass* StaticClass();
	static class UGameUserSettingsSubsystem* GetDefaultObj();

	bool RebindAxis(struct FKeybindContextsRowHandle& Context, struct FInputAxisKeyMapping& NewMapping, bool bController);
	bool RebindAction(struct FKeybindContextsRowHandle& Context, struct FInputActionKeyMapping& NewMapping, bool bController);
	struct FInputAxisKeyMapping GetDefaultAxisMapping(struct FKeybindContextsRowHandle& Context, const struct FKeybindingsRowHandle& RowHandle, bool bController, enum class EValid* Paths);
	struct FInputActionKeyMapping GetDefaultActionMapping(struct FKeybindContextsRowHandle& Context, const struct FKeybindingsRowHandle& RowHandle, bool bController, enum class EValid* Paths);
	void GetCurrentAxisMapping(const struct FKeybindingsRowHandle& RowHandle, struct FInputAxisKeyMapping* Out, enum class EValid* Paths);
	void GetCurrentActionMapping(const struct FKeybindingsRowHandle& RowHandle, struct FInputActionKeyMapping* Out, enum class EValid* Paths);
	bool CheckForExistingMapping(struct FKey& Key, struct FKeybindContextsRowHandle& Context, struct FKeybindingsRowHandle& RowHandle, struct FKeybindContextsRowHandle* ConflictingInputContext, struct FKeybindingsRowHandle* ConflictingKeybind);
};

// 0x10 (0x40 - 0x30)
// Class Icarus.GatheringSubsystem
class UGatheringSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnFoliageResourceCollectedNotify;                  // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UGatheringSubsystem* GetDefaultObj();

	void BroadcastFoliageResourceCollectedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
};

// 0x8 (0x30 - 0x28)
// Class Icarus.GeneratedPlayerTrackerListener
class UGeneratedPlayerTrackerListener : public UObject
{
public:
	class UPlayerTrackerSubsystem*               PlayerTrackerSubsystem;                            // 0x28(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UGeneratedPlayerTrackerListener* GetDefaultObj();

	void OnVoxelResourceMinedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnVoxelHitNotify(class AIcarusPlayerCharacter* Player, class AVoxelResource* Voxel);
	void OnVoxelCompletedNotify(class AIcarusPlayerCharacter* Player, class AVoxelResource* Voxel);
	void OnTreeResourceCollectedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnTreeFelledNotify(class AIcarusPlayerCharacter* Player);
	void OnTimeSurvivedNotify(class AIcarusPlayerCharacter* Player, int32 MinutesSurvived, enum class EProspectLocation Biome);
	void OnThumperEventCompletedNotify(class ADeployable* Thumper, int32 OresRegenerated, int32 VoxelsRegenerated);
	void OnThumperActivatedNotify(class ADeployable* Thumper);
	void OnStruckByLightningNotify(class AIcarusPlayerCharacter* Player);
	void OnSeedPlantedNotify(class AIcarusPlayerCharacter* Player, const struct FFarmingSeedsRowHandle& Seed);
	void OnProspectTalentsUpdatedNotify(class AIcarusPlayerCharacter* Player);
	void OnProspectMissionCompleteNotify(class AIcarusPlayerCharacter* Player);
	void OnProjectileFiredNotify(class AIcarusPlayerCharacter* Player, class AIcarusItem* Projectile);
	void OnPlayerTalentsUpdatedNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerRevivedNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerRespawnedNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerPerformedStealthAttackNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerPerformedCriticalHitNotify(class AIcarusPlayerCharacter* Player, const struct FVector& HitLocation, const struct FCriticalHitAreasEnum& CriticalHitArea);
	void OnPlayerIgnitedBuildingPieceNotify(class AIcarusPlayerCharacter* Player, class ABuildingBase* Building);
	void OnPlayerEquipmentChangedNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerEarnedCurrencyNotify(class AIcarusPlayerCharacter* Player, const struct FMetaCurrencyRowHandle& Currency, int32 Amount);
	void OnPlayerDownedNotify(class AIcarusPlayerCharacter* Player, const struct FIcarusDamagePacket& LastDamagePacket);
	void OnPlayerCompletedDynamicMissionNotify(class AIcarusPlayerCharacter* Player, const struct FFactionMissionsRowHandle& FactionMission);
	void OnPlayerCaughtFishNotify(class AIcarusPlayerCharacter* Player, const struct FFishDataRowHandle& FishType);
	void OnPlayerBestiaryMaxRankNotify(class AIcarusPlayerCharacter* Player, const struct FBestiaryDataRowHandle& BestiaryGroup);
	void OnOtherPlayerRevivedNotify(class AIcarusPlayerCharacter* Player, class AIcarusPlayerCharacter* OtherPlayer);
	void OnNightSkippedNotify(class AIcarusPlayerCharacter* Player);
	void OnLivingItemSlotUnlockedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnLevelUpdatedNotify(class AIcarusPlayerCharacter* Player, int32 CurrentLevel);
	void OnItemHarvestedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnItemCraftedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnItemConsumedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnItemAlteredNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item, const struct FIcarusAttachmentsRowHandle& Attachment);
	void OnFoliageResourceCollectedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnFireExtinguishedNotify(class AIcarusPlayerCharacter* Player);
	void OnDistanceTraveledNotify(class AIcarusPlayerCharacter* Player, int32 Distance, enum class EProspectLocation Biome);
	void OnDeployableDestroyedNotify(class ADeployable* Deployable, const struct FIcarusDamagePacket& LastDamagePacket, class AIcarusPlayerCharacter* InstigatingPlayer);
	void OnCropMaturedNotify(const struct FFarmingSeedsRowHandle& Seed);
	void OnCreatureSkinnedNotify(class AIcarusPlayerCharacter* Player, class AIcarusCorpse* Corpse);
	void OnCreatureKilledNotify(class AIcarusPlayerCharacter* Player, class AIcarusActor* Causer, class AActor* Creature, class AIcarusPlayerCharacter* KillingBlowFromPlayer);
	void OnCorpseItemRemovedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnBlueprintTalentsUpdatedNotify(class AIcarusPlayerCharacter* Player);
	void OnBiomeUpdatedNotify(class AIcarusPlayerCharacter* Player);
};

// 0x228 (0x2F8 - 0xD0)
// Class Icarus.GeneratorComponent
class UGeneratorComponent : public UTraitComponent
{
public:
	uint8                                        Pad_7C41[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bGeneratorActive;                                  // 0xD8(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7C42[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        CurrentGenerationRate;                             // 0xDC(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnGeneratorActiveStateUpdated;                     // 0xE0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnGeneratorOutOfFuel;                              // 0xE1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7C45[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UInventory*                            TransmutationInventory;                            // 0xE8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventory*>                    AdditionalInventories;                             // 0xF0(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FItemData                             CurrentTransmutationItem;                          // 0x100(0x1F0)(Edit, BlueprintVisible, Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                        PartialTransmuationResource;                       // 0x2F0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7C47[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UGeneratorComponent* GetDefaultObj();

	bool TransmuteItems(float Delta);
	void ProduceByproduct(const struct FItemData& Item);
	void ProcessGenerator(float Delta);
	void OnRep_GeneratorActive();
	void InitialiseComponent(class UInventory* NewTransmutationInventory, const TArray<class UInventory*>& NewAdditionalInventories);
	bool GetGeneratorData(struct FGeneratorData* OutData);
	float GetAdjustedRequiredTransmutationUnits(float CurrentUnits);
	void GeneratorOutOfFuel();
	bool GenerateResource(float Delta);
	void DeactivateGenerator();
	bool ActivateGenerator();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.GeneratorLibrary
class UGeneratorLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGeneratorLibrary* GetDefaultObj();

	struct FGeneratorRowHandle StructToRowHandle(const struct FGeneratorEnum& EnumValue);
	class FName StructToName(const struct FGeneratorEnum& EnumValue);
	int32 StructToInt(const struct FGeneratorEnum& EnumValue);
	struct FGeneratorEnum RowHandleToStruct(const struct FGeneratorRowHandle& RowHandle);
	void RemoveRowFromGeneratorTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGeneratorEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGeneratorEnum& A, const struct FGeneratorEnum& B);
	struct FGeneratorEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGeneratorRowHandle MakeLiteralGenerator(const struct FGeneratorRowHandle& RowHandle);
	struct FGeneratorRowHandle MakeGeneratorFromIndex(int32 Index);
	struct FGeneratorEnum MakeGeneratorEnum(const struct FGeneratorEnum& Enum);
	struct FGeneratorRowHandle MakeGenerator(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGeneratorEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGeneratorStruct(const struct FGeneratorRowHandle& RowHandle, struct FGeneratorData* Generator, enum class EValid* Paths);
	bool EqualEqual_FGeneratorRowHandleFGeneratorRowHandle(const struct FGeneratorRowHandle& RowHandleA, const struct FGeneratorRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGeneratorEnum& A, const struct FGeneratorEnum& B);
	struct FGeneratorRowHandle CastToGeneratorRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGeneratorEnum(const struct FGeneratorEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGeneratorTable(class FName Name, const struct FGeneratorData& Data, struct FGeneratorRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GeneratorTable
class UGeneratorTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGeneratorTable* GetDefaultObj();

};

// 0x50 (0x100 - 0xB0)
// Class Icarus.GenericAITargetComponent
class UGenericAITargetComponent : public UActorComponent
{
public:
	uint8                                        Pad_7C62[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UAIPerceptionStimuliSourceComponent*   PerceptionComponent;                               // 0xC0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIRelationshipsRowHandle             TargetableRelationship;                            // 0xC8(0x18)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                       TargetComponent;                                   // 0xE0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               ActorRootPerceptionTargetOffset;                   // 0xE8(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7C63[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UActorState*                           ActorState;                                        // 0xF8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UGenericAITargetComponent* GetDefaultObj();

};

// 0x18 (0x2D8 - 0x2C0)
// Class Icarus.GenericResourceBase
class AGenericResourceBase : public AIcarusActor
{
public:
	uint8                                        Pad_7C65[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USceneComponent*                       ViewPointOverrideComponent;                        // 0x2C8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  ViewPointOverrideSocket;                           // 0x2D0(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AGenericResourceBase* GetDefaultObj();

};

// 0x10 (0x48 - 0x38)
// Class Icarus.GOAPActionAnimNotify
class UGOAPActionAnimNotify : public UAnimNotify
{
public:
	class FString                                NotifyName;                                        // 0x38(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UGOAPActionAnimNotify* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GOAPActionsLibrary
class UGOAPActionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGOAPActionsLibrary* GetDefaultObj();

	struct FGOAPActionsRowHandle StructToRowHandle(const struct FGOAPActionsEnum& EnumValue);
	class FName StructToName(const struct FGOAPActionsEnum& EnumValue);
	int32 StructToInt(const struct FGOAPActionsEnum& EnumValue);
	struct FGOAPActionsEnum RowHandleToStruct(const struct FGOAPActionsRowHandle& RowHandle);
	void RemoveRowFromGOAPActionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGOAPActionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGOAPActionsEnum& A, const struct FGOAPActionsEnum& B);
	struct FGOAPActionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGOAPActionsRowHandle MakeLiteralGOAPActions(const struct FGOAPActionsRowHandle& RowHandle);
	struct FGOAPActionsRowHandle MakeGOAPActionsFromIndex(int32 Index);
	struct FGOAPActionsEnum MakeGOAPActionsEnum(const struct FGOAPActionsEnum& Enum);
	struct FGOAPActionsRowHandle MakeGOAPActions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGOAPActionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGOAPActionsStruct(const struct FGOAPActionsRowHandle& RowHandle, struct FGOAPAction* GOAPActions, enum class EValid* Paths);
	bool EqualEqual_FGOAPActionsRowHandleFGOAPActionsRowHandle(const struct FGOAPActionsRowHandle& RowHandleA, const struct FGOAPActionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGOAPActionsEnum& A, const struct FGOAPActionsEnum& B);
	struct FGOAPActionsRowHandle CastToGOAPActionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGOAPActionsEnum(const struct FGOAPActionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGOAPActionsTable(class FName Name, const struct FGOAPAction& Data, struct FGOAPActionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GOAPActionsTable
class UGOAPActionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGOAPActionsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GOAPGoalsLibrary
class UGOAPGoalsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGOAPGoalsLibrary* GetDefaultObj();

	struct FGOAPGoalsRowHandle StructToRowHandle(const struct FGOAPGoalsEnum& EnumValue);
	class FName StructToName(const struct FGOAPGoalsEnum& EnumValue);
	int32 StructToInt(const struct FGOAPGoalsEnum& EnumValue);
	struct FGOAPGoalsEnum RowHandleToStruct(const struct FGOAPGoalsRowHandle& RowHandle);
	void RemoveRowFromGOAPGoalsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGOAPGoalsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGOAPGoalsEnum& A, const struct FGOAPGoalsEnum& B);
	struct FGOAPGoalsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGOAPGoalsRowHandle MakeLiteralGOAPGoals(const struct FGOAPGoalsRowHandle& RowHandle);
	struct FGOAPGoalsRowHandle MakeGOAPGoalsFromIndex(int32 Index);
	struct FGOAPGoalsEnum MakeGOAPGoalsEnum(const struct FGOAPGoalsEnum& Enum);
	struct FGOAPGoalsRowHandle MakeGOAPGoals(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGOAPGoalsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGOAPGoalsStruct(const struct FGOAPGoalsRowHandle& RowHandle, struct FGOAPGoal* GOAPGoals, enum class EValid* Paths);
	bool EqualEqual_FGOAPGoalsRowHandleFGOAPGoalsRowHandle(const struct FGOAPGoalsRowHandle& RowHandleA, const struct FGOAPGoalsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGOAPGoalsEnum& A, const struct FGOAPGoalsEnum& B);
	struct FGOAPGoalsRowHandle CastToGOAPGoalsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGOAPGoalsEnum(const struct FGOAPGoalsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGOAPGoalsTable(class FName Name, const struct FGOAPGoal& Data, struct FGOAPGoalsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GOAPGoalsTable
class UGOAPGoalsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGOAPGoalsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GOAPMotivationsLibrary
class UGOAPMotivationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGOAPMotivationsLibrary* GetDefaultObj();

	struct FGOAPMotivationsRowHandle StructToRowHandle(const struct FGOAPMotivationsEnum& EnumValue);
	class FName StructToName(const struct FGOAPMotivationsEnum& EnumValue);
	int32 StructToInt(const struct FGOAPMotivationsEnum& EnumValue);
	struct FGOAPMotivationsEnum RowHandleToStruct(const struct FGOAPMotivationsRowHandle& RowHandle);
	void RemoveRowFromGOAPMotivationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGOAPMotivationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGOAPMotivationsEnum& A, const struct FGOAPMotivationsEnum& B);
	struct FGOAPMotivationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGOAPMotivationsRowHandle MakeLiteralGOAPMotivations(const struct FGOAPMotivationsRowHandle& RowHandle);
	struct FGOAPMotivationsRowHandle MakeGOAPMotivationsFromIndex(int32 Index);
	struct FGOAPMotivationsEnum MakeGOAPMotivationsEnum(const struct FGOAPMotivationsEnum& Enum);
	struct FGOAPMotivationsRowHandle MakeGOAPMotivations(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGOAPMotivationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGOAPMotivationsStruct(const struct FGOAPMotivationsRowHandle& RowHandle, struct FGOAPMotivation* GOAPMotivations, enum class EValid* Paths);
	bool EqualEqual_FGOAPMotivationsRowHandleFGOAPMotivationsRowHandle(const struct FGOAPMotivationsRowHandle& RowHandleA, const struct FGOAPMotivationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGOAPMotivationsEnum& A, const struct FGOAPMotivationsEnum& B);
	struct FGOAPMotivationsRowHandle CastToGOAPMotivationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGOAPMotivationsEnum(const struct FGOAPMotivationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGOAPMotivationsTable(class FName Name, const struct FGOAPMotivation& Data, struct FGOAPMotivationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GOAPMotivationsTable
class UGOAPMotivationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGOAPMotivationsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GOAPPropertiesLibrary
class UGOAPPropertiesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGOAPPropertiesLibrary* GetDefaultObj();

	struct FGOAPPropertiesRowHandle StructToRowHandle(const struct FGOAPPropertiesEnum& EnumValue);
	class FName StructToName(const struct FGOAPPropertiesEnum& EnumValue);
	int32 StructToInt(const struct FGOAPPropertiesEnum& EnumValue);
	struct FGOAPPropertiesEnum RowHandleToStruct(const struct FGOAPPropertiesRowHandle& RowHandle);
	void RemoveRowFromGOAPPropertiesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGOAPPropertiesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGOAPPropertiesEnum& A, const struct FGOAPPropertiesEnum& B);
	struct FGOAPPropertiesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGOAPPropertiesRowHandle MakeLiteralGOAPProperties(const struct FGOAPPropertiesRowHandle& RowHandle);
	struct FGOAPPropertiesRowHandle MakeGOAPPropertiesFromIndex(int32 Index);
	struct FGOAPPropertiesEnum MakeGOAPPropertiesEnum(const struct FGOAPPropertiesEnum& Enum);
	struct FGOAPPropertiesRowHandle MakeGOAPProperties(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGOAPPropertiesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGOAPPropertiesStruct(const struct FGOAPPropertiesRowHandle& RowHandle, struct FGOAPProperties* GOAPProperties, enum class EValid* Paths);
	bool EqualEqual_FGOAPPropertiesRowHandleFGOAPPropertiesRowHandle(const struct FGOAPPropertiesRowHandle& RowHandleA, const struct FGOAPPropertiesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGOAPPropertiesEnum& A, const struct FGOAPPropertiesEnum& B);
	struct FGOAPPropertiesRowHandle CastToGOAPPropertiesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGOAPPropertiesEnum(const struct FGOAPPropertiesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGOAPPropertiesTable(class FName Name, const struct FGOAPProperties& Data, struct FGOAPPropertiesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GOAPPropertiesTable
class UGOAPPropertiesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGOAPPropertiesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GOAPSetupLibrary
class UGOAPSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGOAPSetupLibrary* GetDefaultObj();

	struct FGOAPSetupRowHandle StructToRowHandle(const struct FGOAPSetupEnum& EnumValue);
	class FName StructToName(const struct FGOAPSetupEnum& EnumValue);
	int32 StructToInt(const struct FGOAPSetupEnum& EnumValue);
	struct FGOAPSetupEnum RowHandleToStruct(const struct FGOAPSetupRowHandle& RowHandle);
	void RemoveRowFromGOAPSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGOAPSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGOAPSetupEnum& A, const struct FGOAPSetupEnum& B);
	struct FGOAPSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGOAPSetupRowHandle MakeLiteralGOAPSetup(const struct FGOAPSetupRowHandle& RowHandle);
	struct FGOAPSetupRowHandle MakeGOAPSetupFromIndex(int32 Index);
	struct FGOAPSetupEnum MakeGOAPSetupEnum(const struct FGOAPSetupEnum& Enum);
	struct FGOAPSetupRowHandle MakeGOAPSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGOAPSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGOAPSetupStruct(const struct FGOAPSetupRowHandle& RowHandle, struct FGOAPSetup* GOAPSetup, enum class EValid* Paths);
	bool EqualEqual_FGOAPSetupRowHandleFGOAPSetupRowHandle(const struct FGOAPSetupRowHandle& RowHandleA, const struct FGOAPSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGOAPSetupEnum& A, const struct FGOAPSetupEnum& B);
	struct FGOAPSetupRowHandle CastToGOAPSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGOAPSetupEnum(const struct FGOAPSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGOAPSetupTable(class FName Name, const struct FGOAPSetup& Data, struct FGOAPSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GOAPSetupTable
class UGOAPSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGOAPSetupTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GrantedAurasLibrary
class UGrantedAurasLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGrantedAurasLibrary* GetDefaultObj();

	struct FGrantedAurasRowHandle StructToRowHandle(const struct FGrantedAurasEnum& EnumValue);
	class FName StructToName(const struct FGrantedAurasEnum& EnumValue);
	int32 StructToInt(const struct FGrantedAurasEnum& EnumValue);
	struct FGrantedAurasEnum RowHandleToStruct(const struct FGrantedAurasRowHandle& RowHandle);
	void RemoveRowFromGrantedAurasTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGrantedAurasEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGrantedAurasEnum& A, const struct FGrantedAurasEnum& B);
	struct FGrantedAurasEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGrantedAurasRowHandle MakeLiteralGrantedAuras(const struct FGrantedAurasRowHandle& RowHandle);
	struct FGrantedAurasRowHandle MakeGrantedAurasFromIndex(int32 Index);
	struct FGrantedAurasEnum MakeGrantedAurasEnum(const struct FGrantedAurasEnum& Enum);
	struct FGrantedAurasRowHandle MakeGrantedAuras(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGrantedAurasEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGrantedAurasStruct(const struct FGrantedAurasRowHandle& RowHandle, struct FAuraInfo* GrantedAuras, enum class EValid* Paths);
	bool EqualEqual_FGrantedAurasRowHandleFGrantedAurasRowHandle(const struct FGrantedAurasRowHandle& RowHandleA, const struct FGrantedAurasRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGrantedAurasEnum& A, const struct FGrantedAurasEnum& B);
	struct FGrantedAurasRowHandle CastToGrantedAurasRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGrantedAurasEnum(const struct FGrantedAurasEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGrantedAurasTable(class FName Name, const struct FAuraInfo& Data, struct FGrantedAurasRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GrantedAurasTable
class UGrantedAurasTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGrantedAurasTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.GraphicsTierHelper
class UGraphicsTierHelper : public UObject
{
public:

	static class UClass* StaticClass();
	static class UGraphicsTierHelper* GetDefaultObj();

	struct FIcarusGraphicsExtraInfo GetExtraInfo();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.GraphicsTierDescriptionLibrary
class UGraphicsTierDescriptionLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGraphicsTierDescriptionLibrary* GetDefaultObj();

	struct FGraphicsTierDescriptionRowHandle StructToRowHandle(const struct FGraphicsTierDescriptionEnum& EnumValue);
	class FName StructToName(const struct FGraphicsTierDescriptionEnum& EnumValue);
	int32 StructToInt(const struct FGraphicsTierDescriptionEnum& EnumValue);
	struct FGraphicsTierDescriptionEnum RowHandleToStruct(const struct FGraphicsTierDescriptionRowHandle& RowHandle);
	void RemoveRowFromGraphicsTierDescriptionTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGraphicsTierDescriptionEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGraphicsTierDescriptionEnum& A, const struct FGraphicsTierDescriptionEnum& B);
	struct FGraphicsTierDescriptionEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGraphicsTierDescriptionRowHandle MakeLiteralGraphicsTierDescription(const struct FGraphicsTierDescriptionRowHandle& RowHandle);
	struct FGraphicsTierDescriptionRowHandle MakeGraphicsTierDescriptionFromIndex(int32 Index);
	struct FGraphicsTierDescriptionEnum MakeGraphicsTierDescriptionEnum(const struct FGraphicsTierDescriptionEnum& Enum);
	struct FGraphicsTierDescriptionRowHandle MakeGraphicsTierDescription(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGraphicsTierDescriptionEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGraphicsTierDescriptionStruct(const struct FGraphicsTierDescriptionRowHandle& RowHandle, struct FGraphicsTierDescription* GraphicsTierDescription, enum class EValid* Paths);
	bool EqualEqual_FGraphicsTierDescriptionRowHandleFGraphicsTierDescriptionRowHandle(const struct FGraphicsTierDescriptionRowHandle& RowHandleA, const struct FGraphicsTierDescriptionRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGraphicsTierDescriptionEnum& A, const struct FGraphicsTierDescriptionEnum& B);
	struct FGraphicsTierDescriptionRowHandle CastToGraphicsTierDescriptionRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGraphicsTierDescriptionEnum(const struct FGraphicsTierDescriptionEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGraphicsTierDescriptionTable(class FName Name, const struct FGraphicsTierDescription& Data, struct FGraphicsTierDescriptionRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.GraphicsTierDescriptionModsLibrary
class UGraphicsTierDescriptionModsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UGraphicsTierDescriptionModsLibrary* GetDefaultObj();

	struct FGraphicsTierDescriptionModsRowHandle StructToRowHandle(const struct FGraphicsTierDescriptionModsEnum& EnumValue);
	class FName StructToName(const struct FGraphicsTierDescriptionModsEnum& EnumValue);
	int32 StructToInt(const struct FGraphicsTierDescriptionModsEnum& EnumValue);
	struct FGraphicsTierDescriptionModsEnum RowHandleToStruct(const struct FGraphicsTierDescriptionModsRowHandle& RowHandle);
	void RemoveRowFromGraphicsTierDescriptionModsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FGraphicsTierDescriptionModsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FGraphicsTierDescriptionModsEnum& A, const struct FGraphicsTierDescriptionModsEnum& B);
	struct FGraphicsTierDescriptionModsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FGraphicsTierDescriptionModsRowHandle MakeLiteralGraphicsTierDescriptionMods(const struct FGraphicsTierDescriptionModsRowHandle& RowHandle);
	struct FGraphicsTierDescriptionModsRowHandle MakeGraphicsTierDescriptionModsFromIndex(int32 Index);
	struct FGraphicsTierDescriptionModsEnum MakeGraphicsTierDescriptionModsEnum(const struct FGraphicsTierDescriptionModsEnum& Enum);
	struct FGraphicsTierDescriptionModsRowHandle MakeGraphicsTierDescriptionMods(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FGraphicsTierDescriptionModsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetGraphicsTierDescriptionModsStruct(const struct FGraphicsTierDescriptionModsRowHandle& RowHandle, struct FGraphicsTierDescriptionMods* GraphicsTierDescriptionMods, enum class EValid* Paths);
	bool EqualEqual_FGraphicsTierDescriptionModsRowHandleFGraphicsTierDescriptionModsRowHandle(const struct FGraphicsTierDescriptionModsRowHandle& RowHandleA, const struct FGraphicsTierDescriptionModsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FGraphicsTierDescriptionModsEnum& A, const struct FGraphicsTierDescriptionModsEnum& B);
	struct FGraphicsTierDescriptionModsRowHandle CastToGraphicsTierDescriptionModsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakGraphicsTierDescriptionModsEnum(const struct FGraphicsTierDescriptionModsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToGraphicsTierDescriptionModsTable(class FName Name, const struct FGraphicsTierDescriptionMods& Data, struct FGraphicsTierDescriptionModsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GraphicsTierDescriptionModsTable
class UGraphicsTierDescriptionModsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGraphicsTierDescriptionModsTable* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.GraphicsTierDescriptionTable
class UGraphicsTierDescriptionTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UGraphicsTierDescriptionTable* GetDefaultObj();

};

// 0x8 (0x578 - 0x570)
// Class Icarus.SkeletalItem
class ASkeletalItem : public AIcarusItem
{
public:
	class USkeletalMeshComponent*                SkeletalMeshRoot;                                  // 0x570(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ASkeletalItem* GetDefaultObj();

};

// 0x38 (0x5B0 - 0x578)
// Class Icarus.IcarusCorpse
class AIcarusCorpse : public ASkeletalItem
{
public:
	class UAnimSequence*                         FPCarryAnim;                                       // 0x578(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                         TPCarryAnim;                                       // 0x580(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISetupRowHandle                     AISetupRowHandle;                                  // 0x588(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        AttachedCorpseActors;                              // 0x5A0(0x10)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusCorpse* GetDefaultObj();

	void SetAttachedCorpseActors(const TArray<class AActor*>& AttachedActors);
	void OnRep_AttachedCorpseActors();
	void InitialiseAttachedActors();
	void HideInstigator();
	struct FPoseSnapshot GetRagdollPose();
	class UAnimSequence* GetCarryAnim();
	void EnableFrozenRagdollOptimisations();
	bool AttachActorToSelf(class AActor* AttachedActor);
};

// 0xD0 (0x680 - 0x5B0)
// Class Icarus.GravestoneBase
class AGravestoneBase : public AIcarusCorpse
{
public:
	struct FPlayerCharacterID                    AssignedPlayerCharacterID;                         // 0x5B0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                          RagdollHitEventBones;                              // 0x5C8(0x10)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGravestoneData                       GravestoneData;                                    // 0x5D8(0x90)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FArmourRowHandle>              PlayerArmour;                                      // 0x668(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	bool                                         bWasReloaded;                                      // 0x678(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E26[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AGravestoneBase* GetDefaultObj();

	void SetPlayerArmour(const TArray<struct FArmourRowHandle>& InArmour);
	void SetHitEventsEnabled(bool bEnabled);
	void SetGravestoneData(struct FGravestoneData& InData);
	void OnRep_PlayerArmour();
	void OnRep_GravestoneData();
	void OnRep_AssignedPlayerCharacterID();
};

// 0x158 (0x390 - 0x238)
// Class Icarus.GravestoneRecorderComponent
class UGravestoneRecorderComponent : public UItemStateRecorderComponent
{
public:
	struct FPlayerCharacterID                    AssignedPlayerCharacterID;                         // 0x238(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGravestoneDataRecord                 GravestoneData;                                    // 0x250(0x128)(Edit, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                          PlayerArmour;                                      // 0x378(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	int32                                        GravestoneRecorderVersion;                         // 0x388(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7E27[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UGravestoneRecorderComponent* GetDefaultObj();

};

// 0x58 (0x108 - 0xB0)
// Class Icarus.GridObjectPlacementComponent
class UGridObjectPlacementComponent : public UActorComponent
{
public:
	float                                        GridUnitSize;                                      // 0xB0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7E28[0x54];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UGridObjectPlacementComponent* GetDefaultObj();

	class AActor* AddObject(struct FVector& GridCenter, struct FVector& GridSize);
	void AddLocation(struct FVector& Location);
};

// 0x18 (0xE8 - 0xD0)
// Class Icarus.HighlightableComponent
class UHighlightableComponent : public UTraitComponent
{
public:
	FMulticastSparseDelegateProperty_            OnHighlightChanged;                                // 0xD0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bAlwaysHighlight;                                  // 0xD1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E2B[0x16];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UHighlightableComponent* GetDefaultObj();

	void SetHighlight(class UPrimitiveComponent* Component, bool bHighlighted, int32 StencilValue);
	bool IsHighlighted();
	bool GetHighlightableData(struct FHighlightableData* OutData);
	bool CanUnhighlight();
	bool CanHighlight();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.HighlightableLibrary
class UHighlightableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHighlightableLibrary* GetDefaultObj();

	struct FHighlightableRowHandle StructToRowHandle(const struct FHighlightableEnum& EnumValue);
	class FName StructToName(const struct FHighlightableEnum& EnumValue);
	int32 StructToInt(const struct FHighlightableEnum& EnumValue);
	struct FHighlightableEnum RowHandleToStruct(const struct FHighlightableRowHandle& RowHandle);
	void RemoveRowFromHighlightableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHighlightableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHighlightableEnum& A, const struct FHighlightableEnum& B);
	struct FHighlightableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHighlightableRowHandle MakeLiteralHighlightable(const struct FHighlightableRowHandle& RowHandle);
	struct FHighlightableRowHandle MakeHighlightableFromIndex(int32 Index);
	struct FHighlightableEnum MakeHighlightableEnum(const struct FHighlightableEnum& Enum);
	struct FHighlightableRowHandle MakeHighlightable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHighlightableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHighlightableStruct(const struct FHighlightableRowHandle& RowHandle, struct FHighlightableData* Highlightable, enum class EValid* Paths);
	bool EqualEqual_FHighlightableRowHandleFHighlightableRowHandle(const struct FHighlightableRowHandle& RowHandleA, const struct FHighlightableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHighlightableEnum& A, const struct FHighlightableEnum& B);
	struct FHighlightableRowHandle CastToHighlightableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHighlightableEnum(const struct FHighlightableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHighlightableTable(class FName Name, const struct FHighlightableData& Data, struct FHighlightableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HighlightableTable
class UHighlightableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHighlightableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HintsLibrary
class UHintsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHintsLibrary* GetDefaultObj();

	struct FHintsRowHandle StructToRowHandle(const struct FHintsEnum& EnumValue);
	class FName StructToName(const struct FHintsEnum& EnumValue);
	int32 StructToInt(const struct FHintsEnum& EnumValue);
	struct FHintsEnum RowHandleToStruct(const struct FHintsRowHandle& RowHandle);
	void RemoveRowFromHintsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHintsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHintsEnum& A, const struct FHintsEnum& B);
	struct FHintsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHintsRowHandle MakeLiteralHints(const struct FHintsRowHandle& RowHandle);
	struct FHintsRowHandle MakeHintsFromIndex(int32 Index);
	struct FHintsEnum MakeHintsEnum(const struct FHintsEnum& Enum);
	struct FHintsRowHandle MakeHints(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHintsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHintsStruct(const struct FHintsRowHandle& RowHandle, struct FHintsData* Hints, enum class EValid* Paths);
	bool EqualEqual_FHintsRowHandleFHintsRowHandle(const struct FHintsRowHandle& RowHandleA, const struct FHintsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHintsEnum& A, const struct FHintsEnum& B);
	struct FHintsRowHandle CastToHintsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHintsEnum(const struct FHintsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHintsTable(class FName Name, const struct FHintsData& Data, struct FHintsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HintsTable
class UHintsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHintsTable* GetDefaultObj();

};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.HitableComponent
class UHitableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UHitableComponent* GetDefaultObj();

	void OnHit();
	void Hitable();
	bool GetHitableData(struct FHitableData* OutData);
	bool ConsumeHit(class UActorState* ActorStateIn, const struct FIcarusDamagePacket& DamagePacket);
	bool CanConsumeHit(class UActorState* ActorStateIn, const struct FIcarusDamagePacket& DamagePacket);
};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.HitableBehaviourRock
class UHitableBehaviourRock : public UHitableComponent
{
public:

	static class UClass* StaticClass();
	static class UHitableBehaviourRock* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HitableLibrary
class UHitableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHitableLibrary* GetDefaultObj();

	struct FHitableRowHandle StructToRowHandle(const struct FHitableEnum& EnumValue);
	class FName StructToName(const struct FHitableEnum& EnumValue);
	int32 StructToInt(const struct FHitableEnum& EnumValue);
	struct FHitableEnum RowHandleToStruct(const struct FHitableRowHandle& RowHandle);
	void RemoveRowFromHitableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHitableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHitableEnum& A, const struct FHitableEnum& B);
	struct FHitableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHitableRowHandle MakeLiteralHitable(const struct FHitableRowHandle& RowHandle);
	struct FHitableRowHandle MakeHitableFromIndex(int32 Index);
	struct FHitableEnum MakeHitableEnum(const struct FHitableEnum& Enum);
	struct FHitableRowHandle MakeHitable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHitableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHitableStruct(const struct FHitableRowHandle& RowHandle, struct FHitableData* Hitable, enum class EValid* Paths);
	bool EqualEqual_FHitableRowHandleFHitableRowHandle(const struct FHitableRowHandle& RowHandleA, const struct FHitableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHitableEnum& A, const struct FHitableEnum& B);
	struct FHitableRowHandle CastToHitableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHitableEnum(const struct FHitableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHitableTable(class FName Name, const struct FHitableData& Data, struct FHitableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HitableTable
class UHitableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHitableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HordeLibrary
class UHordeLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHordeLibrary* GetDefaultObj();

	struct FHordeRowHandle StructToRowHandle(const struct FHordeEnum& EnumValue);
	class FName StructToName(const struct FHordeEnum& EnumValue);
	int32 StructToInt(const struct FHordeEnum& EnumValue);
	struct FHordeEnum RowHandleToStruct(const struct FHordeRowHandle& RowHandle);
	void RemoveRowFromHordeTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHordeEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHordeEnum& A, const struct FHordeEnum& B);
	struct FHordeEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHordeRowHandle MakeLiteralHorde(const struct FHordeRowHandle& RowHandle);
	struct FHordeRowHandle MakeHordeFromIndex(int32 Index);
	struct FHordeEnum MakeHordeEnum(const struct FHordeEnum& Enum);
	struct FHordeRowHandle MakeHorde(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHordeEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHordeStruct(const struct FHordeRowHandle& RowHandle, struct FHorde* Horde, enum class EValid* Paths);
	bool EqualEqual_FHordeRowHandleFHordeRowHandle(const struct FHordeRowHandle& RowHandleA, const struct FHordeRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHordeEnum& A, const struct FHordeEnum& B);
	struct FHordeRowHandle CastToHordeRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHordeEnum(const struct FHordeEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHordeTable(class FName Name, const struct FHorde& Data, struct FHordeRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HordeTable
class UHordeTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHordeTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HordeWaveLibrary
class UHordeWaveLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHordeWaveLibrary* GetDefaultObj();

	struct FHordeWaveRowHandle StructToRowHandle(const struct FHordeWaveEnum& EnumValue);
	class FName StructToName(const struct FHordeWaveEnum& EnumValue);
	int32 StructToInt(const struct FHordeWaveEnum& EnumValue);
	struct FHordeWaveEnum RowHandleToStruct(const struct FHordeWaveRowHandle& RowHandle);
	void RemoveRowFromHordeWaveTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHordeWaveEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHordeWaveEnum& A, const struct FHordeWaveEnum& B);
	struct FHordeWaveEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHordeWaveRowHandle MakeLiteralHordeWave(const struct FHordeWaveRowHandle& RowHandle);
	struct FHordeWaveRowHandle MakeHordeWaveFromIndex(int32 Index);
	struct FHordeWaveEnum MakeHordeWaveEnum(const struct FHordeWaveEnum& Enum);
	struct FHordeWaveRowHandle MakeHordeWave(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHordeWaveEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHordeWaveStruct(const struct FHordeWaveRowHandle& RowHandle, struct FHordeWave* HordeWave, enum class EValid* Paths);
	bool EqualEqual_FHordeWaveRowHandleFHordeWaveRowHandle(const struct FHordeWaveRowHandle& RowHandleA, const struct FHordeWaveRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHordeWaveEnum& A, const struct FHordeWaveEnum& B);
	struct FHordeWaveRowHandle CastToHordeWaveRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHordeWaveEnum(const struct FHordeWaveEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHordeWaveTable(class FName Name, const struct FHordeWave& Data, struct FHordeWaveRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HordeWaveTable
class UHordeWaveTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHordeWaveTable* GetDefaultObj();

};

// 0x0 (0x2C0 - 0x2C0)
// Class Icarus.HuntingClue
class AHuntingClue : public AIcarusActor
{
public:

	static class UClass* StaticClass();
	static class AHuntingClue* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HuntingClueSetupLibrary
class UHuntingClueSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHuntingClueSetupLibrary* GetDefaultObj();

	struct FHuntingClueSetupRowHandle StructToRowHandle(const struct FHuntingClueSetupEnum& EnumValue);
	class FName StructToName(const struct FHuntingClueSetupEnum& EnumValue);
	int32 StructToInt(const struct FHuntingClueSetupEnum& EnumValue);
	struct FHuntingClueSetupEnum RowHandleToStruct(const struct FHuntingClueSetupRowHandle& RowHandle);
	void RemoveRowFromHuntingClueSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHuntingClueSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHuntingClueSetupEnum& A, const struct FHuntingClueSetupEnum& B);
	struct FHuntingClueSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHuntingClueSetupRowHandle MakeLiteralHuntingClueSetup(const struct FHuntingClueSetupRowHandle& RowHandle);
	struct FHuntingClueSetupRowHandle MakeHuntingClueSetupFromIndex(int32 Index);
	struct FHuntingClueSetupEnum MakeHuntingClueSetupEnum(const struct FHuntingClueSetupEnum& Enum);
	struct FHuntingClueSetupRowHandle MakeHuntingClueSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHuntingClueSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHuntingClueSetupStruct(const struct FHuntingClueSetupRowHandle& RowHandle, struct FHuntingClueSetup* HuntingClueSetup, enum class EValid* Paths);
	bool EqualEqual_FHuntingClueSetupRowHandleFHuntingClueSetupRowHandle(const struct FHuntingClueSetupRowHandle& RowHandleA, const struct FHuntingClueSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHuntingClueSetupEnum& A, const struct FHuntingClueSetupEnum& B);
	struct FHuntingClueSetupRowHandle CastToHuntingClueSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHuntingClueSetupEnum(const struct FHuntingClueSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHuntingClueSetupTable(class FName Name, const struct FHuntingClueSetup& Data, struct FHuntingClueSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HuntingClueSetupTable
class UHuntingClueSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHuntingClueSetupTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.HuntingSetupLibrary
class UHuntingSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UHuntingSetupLibrary* GetDefaultObj();

	struct FHuntingSetupRowHandle StructToRowHandle(const struct FHuntingSetupEnum& EnumValue);
	class FName StructToName(const struct FHuntingSetupEnum& EnumValue);
	int32 StructToInt(const struct FHuntingSetupEnum& EnumValue);
	struct FHuntingSetupEnum RowHandleToStruct(const struct FHuntingSetupRowHandle& RowHandle);
	void RemoveRowFromHuntingSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FHuntingSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FHuntingSetupEnum& A, const struct FHuntingSetupEnum& B);
	struct FHuntingSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FHuntingSetupRowHandle MakeLiteralHuntingSetup(const struct FHuntingSetupRowHandle& RowHandle);
	struct FHuntingSetupRowHandle MakeHuntingSetupFromIndex(int32 Index);
	struct FHuntingSetupEnum MakeHuntingSetupEnum(const struct FHuntingSetupEnum& Enum);
	struct FHuntingSetupRowHandle MakeHuntingSetup(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FHuntingSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetHuntingSetupStruct(const struct FHuntingSetupRowHandle& RowHandle, struct FHuntingSetup* HuntingSetup, enum class EValid* Paths);
	bool EqualEqual_FHuntingSetupRowHandleFHuntingSetupRowHandle(const struct FHuntingSetupRowHandle& RowHandleA, const struct FHuntingSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FHuntingSetupEnum& A, const struct FHuntingSetupEnum& B);
	struct FHuntingSetupRowHandle CastToHuntingSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakHuntingSetupEnum(const struct FHuntingSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToHuntingSetupTable(class FName Name, const struct FHuntingSetup& Data, struct FHuntingSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.HuntingSetupTable
class UHuntingSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UHuntingSetupTable* GetDefaultObj();

};

// 0x0 (0x260 - 0x260)
// Class Icarus.HuntingWidget
class UHuntingWidget : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UHuntingWidget* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAchievementsFunctionLibrary
class UIcarusAchievementsFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusAchievementsFunctionLibrary* GetDefaultObj();

	void ResetAllStats(class APlayerController* Player);
	void ResetAllAchievements(class APlayerController* Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusActorUIDInterface
class IIcarusActorUIDInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IIcarusActorUIDInterface* GetDefaultObj();

	void SetIcarusUID(int32 UID);
	int32 GetIcarusUID();
};

// 0x10 (0x38 - 0x28)
// Class Icarus.IcarusActorUIDLibrary
class UIcarusActorUIDLibrary : public UObject
{
public:
	uint8                                        Pad_7E7D[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusActorUIDLibrary* GetDefaultObj();

	bool FreeUniqueID(int32 IDToRemove);
	int32 ClaimUniqueID(int32 SuggestedID);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAIBlueprintFunctionLibrary
class UIcarusAIBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusAIBlueprintFunctionLibrary* GetDefaultObj();

	class AActor* SpawnNewAI(class UObject* WorldContextObject, struct FAISetupRowHandle& AISetup, struct FEpicCreaturesRowHandle& EpicCreatureSetup, const struct FTransform& SpawnTransform, int32 BaseLevel, enum class ESpawnActorCollisionHandlingMethod CollisionHandlingMethod, class AActor* Owner, class APawn* Instigator, int32 ForcedUID);
	bool SetBaseLevel(class AActor* AI, int32 Level);
	bool IsTargetHidden(class UObject* TargetObject);
	bool IsTargetAlive(class UObject* TargetObject);
	bool IsLocationWithinSpawnBlockerRadius(class UObject* WorldContextObject, const struct FVector& Location);
	bool IsAIStimulusOfType(struct FAIStimulus& Stimulus, TSubclassOf<class UAISense> Type);
	bool InitGrowthStats(class AActor* AI);
	bool InitAISetup(class AActor* AI, struct FAISetupRowHandle& AISetup, struct FEpicCreaturesRowHandle& EpicCreatureSetup);
	bool GetProspectSpawnConfig(class UObject* WorldContextObject, struct FAISpawnConfigData* SpawnConfig);
	int32 GetNPCStatWithDefaultValue(class AActor* SpawnableAI, const struct FStatsEnum& Stat, int32 DefaultValue);
	bool GetNearbyTargetableActors(class AActor* SelfTargetable, enum class ERelationshipType RelationshipType, TArray<class AActor*>* NearbyTargetableActors, bool bFilterByRelationship, float MaxDistance);
	void GetNearbyActorsOfAITypeWithContext(class UObject* WorldContextObject, TArray<class AActor*>* FoundActors, const struct FAISetupRowHandle& NPCType, const struct FVector& WorldLocation, float NearbyDistance);
	void GetNearbyActorsOfAIType(class UObject* WorldContextObject, TArray<class AActor*>* FoundActors, const struct FAISetupRowHandle& NPCType, const struct FVector& WorldLocation, float NearbyDistance);
	bool GetLastPerceivedTargetLocation(class AAIController* Controller, class AActor* Target, struct FVector* LastSensedLocation, struct FAIStimulus* LastSensedStimulus, bool bUseExactStimulusLocation, bool bProjectResult, enum class ETraceTypeQuery TraceChannel, const struct FVector& ProjectionExtent);
	class AActor* GetClosestValidEnemyTarget(class AIcarusNPCGOAPController* Controller);
	bool GetBlockBiomeDynamicSpawn(class UObject* WorldContext, struct FBiomesRowHandle& Biome);
	class AActor* GetBestValidEnemyTarget(class AIcarusNPCGOAPController* Controller);
	class UObject* GetBestTargetableObject(class UObject* TargetObject);
	struct FNavAgentProperties GetBestNavPropertiesForAgent(struct FNavAgentProperties& InAgentProperties);
	void BlockBiomeDynamicSpawn(class UObject* WorldContext, struct FBiomesRowHandle& Biome, bool bBlock);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAISpawnFilter
class UIcarusAISpawnFilter : public UObject
{
public:

	static class UClass* StaticClass();
	static class UIcarusAISpawnFilter* GetDefaultObj();

	bool IsSpawnLocationValid(class AActor* WorldContext, struct FVector& InLocation, TMap<class FString, int32>& FilterParams);
};

// 0x28 (0x248 - 0x220)
// Class Icarus.IcarusAmbientSound
class AIcarusAmbientSound : public AActor
{
public:
	class UFMODEvent*                            Event;                                             // 0x220(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseRadiusOverride;                                // 0x228(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E96[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        RadiusOverride;                                    // 0x22C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CurrentRadius;                                     // 0x230(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E97[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x238(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                      Collider;                                          // 0x240(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AIcarusAmbientSound* GetDefaultObj();

	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAnimBPFunctionLibrary
class UIcarusAnimBPFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusAnimBPFunctionLibrary* GetDefaultObj();

	float GetMontageSlotWeight(class UAnimInstance* AnimInstance, class FName SlotName, bool bLocalWeight);
	bool GetMontageSectionLength(class UAnimMontage* AnimMontage, class FName SectionName, float* Length);
};

// 0x18 (0x2D0 - 0x2B8)
// Class Icarus.IcarusAnimInstance
class UIcarusAnimInstance : public UAnimInstance
{
public:
	class AIcarusActor*                          OwningIcarusActor;                                 // 0x2B8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E9B[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusAnimInstance* GetDefaultObj();

	bool DoesCurveExist(class FName CurveName);
};

// 0x8 (0x30 - 0x28)
// Class Icarus.IcarusAnimMetaData
class UIcarusAnimMetaData : public UAnimMetaData
{
public:
	float                                        SectionWeight;                                     // 0x28(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E9C[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusAnimMetaData* GetDefaultObj();

};

// 0x20 (0x58 - 0x38)
// Class Icarus.IcarusAnimNotify
class UIcarusAnimNotify : public UAnimNotify
{
public:
	TSubclassOf<class UTraitComponent>           TargetComponent;                                   // 0x38(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                NotifyName;                                        // 0x40(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         TriggerWhenMontageReversed;                        // 0x50(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E9D[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusAnimNotify* GetDefaultObj();

};

// 0x8 (0x40 - 0x38)
// Class Icarus.IcarusAnimNotify_UpdateNPCStance
class UIcarusAnimNotify_UpdateNPCStance : public UAnimNotify
{
public:
	enum class EGOAPCharacterStance              NewStance;                                         // 0x38(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7E9E[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusAnimNotify_UpdateNPCStance* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAttachmentsLibrary
class UIcarusAttachmentsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusAttachmentsLibrary* GetDefaultObj();

	struct FIcarusAttachmentsRowHandle StructToRowHandle(const struct FIcarusAttachmentsEnum& EnumValue);
	class FName StructToName(const struct FIcarusAttachmentsEnum& EnumValue);
	int32 StructToInt(const struct FIcarusAttachmentsEnum& EnumValue);
	struct FIcarusAttachmentsEnum RowHandleToStruct(const struct FIcarusAttachmentsRowHandle& RowHandle);
	void RemoveRowFromIcarusAttachmentsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FIcarusAttachmentsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FIcarusAttachmentsEnum& A, const struct FIcarusAttachmentsEnum& B);
	struct FIcarusAttachmentsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FIcarusAttachmentsRowHandle MakeLiteralIcarusAttachments(const struct FIcarusAttachmentsRowHandle& RowHandle);
	struct FIcarusAttachmentsRowHandle MakeIcarusAttachmentsFromIndex(int32 Index);
	struct FIcarusAttachmentsEnum MakeIcarusAttachmentsEnum(const struct FIcarusAttachmentsEnum& Enum);
	struct FIcarusAttachmentsRowHandle MakeIcarusAttachments(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FIcarusAttachmentsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetIcarusAttachmentsStruct(const struct FIcarusAttachmentsRowHandle& RowHandle, struct FIcarusAttachment* IcarusAttachments, enum class EValid* Paths);
	bool EqualEqual_FIcarusAttachmentsRowHandleFIcarusAttachmentsRowHandle(const struct FIcarusAttachmentsRowHandle& RowHandleA, const struct FIcarusAttachmentsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FIcarusAttachmentsEnum& A, const struct FIcarusAttachmentsEnum& B);
	struct FIcarusAttachmentsRowHandle CastToIcarusAttachmentsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakIcarusAttachmentsEnum(const struct FIcarusAttachmentsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToIcarusAttachmentsTable(class FName Name, const struct FIcarusAttachment& Data, struct FIcarusAttachmentsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.IcarusAttachmentsTable
class UIcarusAttachmentsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UIcarusAttachmentsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusAudioFunctionLibrary
class UIcarusAudioFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusAudioFunctionLibrary* GetDefaultObj();

	void StopAllEvents();
	void SetEventAudioContextParameters(class AActor* ContextActor, const struct FFMODEventInstance& EventInstance, bool bUseOcclusion, class FName TracePoint, bool bUseWaterImmersion);
	void SetComponentAudioContextParameters(class AActor* ContextActor, class UFMODAudioComponent* AudioComponent, bool bUseOcclusion, class FName TracePoint, bool bUseWaterImmersion);
	void SetAudioComponentPlayState(class UFMODAudioComponent* AudioComponent, bool bShouldPlay);
	void RegisterEventInstanceToUseListenerRotation(const struct FFMODEventInstance& Instance);
	void PlayReplicatedOneShot(class UObject* WorldContext, class UFMODEvent* Event, const struct FTransform& Transform, bool bUseListenerRotation, bool bUseOcclusion);
	bool LocationIsInAudibleRangeOfEvent(const struct FVector& Location, class UFMODEvent* Event);
	TMap<int32, float> GetSubtitleTimes(class UFMODEvent* Event, int32 NumSubtitles);
	float GetSimpleOcclusionOnce(class UObject* WorldContextObject, const struct FVector& Location, class AActor* IgnoreActor);
	struct FTransform GetNearestListenerTransform(const struct FVector& TargetLocation);
	class UAudioContextComponent* GetLocalPlayerAudioContext(class UObject* WorldContextObject);
	struct FVector GetListenerLocation(class UObject* WorldContextObject);
	float GetEventMaxDistance(class UFMODEvent* Event);
	float GetEventLengthInSeconds(class UFMODEvent* Event);
	bool EventInstanceIsInAudibleRange(const struct FFMODEventInstance& EventInstance);
};

// 0x850 (0xB20 - 0x2D0)
// Class Icarus.IcarusFirearmAnimInstance
class UIcarusFirearmAnimInstance : public UIcarusAnimInstance
{
public:
	class UActionableBehaviour*                  ActionableBehaviour;                               // 0x2D0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAnimDataLoaded;                                   // 0x2D8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EBA[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FFirearmData                          FirearmData;                                       // 0x2E0(0x6F8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FFirearmAnimData                      AnimData;                                          // 0x9D8(0x130)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	float                                        CurrentCharge;                                     // 0xB08(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsADS;                                            // 0xB0C(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EBB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CurrentAimAlpha;                                   // 0xB10(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EBC[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusFirearmAnimInstance* GetDefaultObj();

};

// 0x0 (0xB20 - 0xB20)
// Class Icarus.IcarusBowAnimInstance
class UIcarusBowAnimInstance : public UIcarusFirearmAnimInstance
{
public:

	static class UClass* StaticClass();
	static class UIcarusBowAnimInstance* GetDefaultObj();

	bool IsHandConnectedToString();
};

// 0x30 (0x2B0 - 0x280)
// Class Icarus.IcarusCameraSpringArm
class UIcarusCameraSpringArm : public USpringArmComponent
{
public:
	bool                                         bThirdPerson;                                      // 0x280(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7EBD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               ThirdPersonOffset;                                 // 0x284(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               FirstPersonOffset;                                 // 0x290(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7EBE[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AController*                           DesiredRotationController;                         // 0x2A0(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EBF[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusCameraSpringArm* GetDefaultObj();

	void UpdateArmPosition();
	void ToggleCameraMode();
	void StopRecording();
	void StartRecording();
	void SetRotationLock(bool Locked);
	void ReadRecording();
};

// 0x300 (0x330 - 0x30)
// Class Icarus.IcarusSessionBase
class UIcarusSessionBase : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EC1[0x298];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	class UConfirmationPopupBase*                ConfirmationPopup;                                 // 0x2E8(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJoinSessionCallbackProxyAdvanced*     JoinSessionCallbackProxy;                          // 0x2F0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestroySessionCallbackProxy*          DestroySessionCallbackProxy;                       // 0x2F8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SessionNodeTime;                                   // 0x300(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SessionNodeMaxTime;                                // 0x304(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7EC2[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UResetCharacterProspectStateCallbackProxyGen* ResetCharacterProspectStateCallback;               // 0x328(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UIcarusSessionBase* GetDefaultObj();

	bool SessionTick(float DeltaSeconds);
	void ResetCharacterProspectStateCallbackSuccess(struct FResResetCharacterProspectState& Response);
	void ResetCharacterProspectStateCallbackFailure(struct FResResetCharacterProspectState& Response);
	void OnPackagedLoadoutUpdated();
	void OnPackagedLoadoutSuccess();
	void OnPackagedLoadoutFailure();
	void OnJoinedSessionSuccess();
	void OnJoinedSessionFailure();
	void OnDestroyedSessionSuccess();
	void OnDestroyedSessionFailure();
};

// 0x8 (0x338 - 0x330)
// Class Icarus.IcarusCanJoinSession
class UIcarusCanJoinSession : public UIcarusSessionBase
{
public:
	class UCanJoinProspectCallbackProxyGen*      CanJoinProspectCallbackProxy;                      // 0x330(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusCanJoinSession* GetDefaultObj();

	void OnCanJoinProspectSuccess(struct FResCanJoinProspect& Result);
	void OnCanJoinProspectFailure(struct FResCanJoinProspect& Result);
	class UIcarusCanJoinSession* IcarusCanJoinSession(class UObject* WorldContextObject, struct FProspectInfo& ProspectInfo, class APlayerController* PlayerController);
};

// 0x60 (0x320 - 0x2C0)
// Class Icarus.IcarusCaveAISpawner
class AIcarusCaveAISpawner : public AIcarusActor
{
public:
	TMap<TSubclassOf<class AActor>, struct FCaveSpawnConfig> CaveActorSpawnMap;                                 // 0x2C0(0x50)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EC3[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusCaveAISpawner* GetDefaultObj();

	void WorldStatsSet();
	void OnRestoredFromDatabase();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusChanceLibrary
class UIcarusChanceLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusChanceLibrary* GetDefaultObj();

	int32 SeededRoll(struct FRandomStream& Stream, int32 MinimumInclusive, int32 MaximumInclusive);
	int32 RollMax(int32 Maximum);
	int32 Roll(int32 MinimumInclusive, int32 MaximumInclusive);
	void BP_SeededRollChance(struct FRandomStream& Stream, int32 Threshold, enum class ERollResult* Paths);
	void BP_RollCustom(int32 MinimumInclusive, int32 MaximumInclusive, int32 Threshold, enum class ERollResult* Paths);
	void BP_RollChance(int32 Threshold, enum class ERollResult* Paths);
};

// 0x260 (0x718 - 0x4B8)
// Class Icarus.IcarusCharacter
class AIcarusCharacter : public ACharacter
{
public:
	uint8                                        Pad_7ECF[0xB0];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UIcarusStateRecorderComponent> RecorderClass;                                     // 0x568(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSaveModifiersToDatabase;                          // 0x570(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7ED0[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusStateRecorderComponent*         Recorder;                                          // 0x578(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnSprintingUpdated;                                // 0x580(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnHitEffectsSpawned;                               // 0x590(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UIcarusStatContainer*                  StatContainer;                                     // 0x5A0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterState*                       ActorState;                                        // 0x5A8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIRelationshipsRowHandle             AIRelationshipTableRowNew;                         // 0x5B0(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MinFallTime;                                       // 0x5C8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7ED1[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UCurveFloat*                           FallDamageCurve;                                   // 0x5D0(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PlayerNoiseInterpSpeed;                            // 0x5D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PlayerNoiseInterpDelay;                            // 0x5DC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ReferenceLoudnessRange;                            // 0x5E0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PlayerNoise;                                       // 0x5E4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7ED2[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x5F8(0x20)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	uint8                                        bIsSprinting : 1;                                  // Mask: 0x1, PropSize: 0x10x618(0x1)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        bIsAiming : 1;                                     // Mask: 0x2, PropSize: 0x10x618(0x1)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        bIsReloading : 1;                                  // Mask: 0x4, PropSize: 0x10x618(0x1)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        BitPad_1E5 : 5;                                    // Fixing Bit-Field Size  [ Dumper-7 ]
	uint8                                        Pad_7ED3[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class ULadderComponent*                      LadderReference;                                   // 0x620(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        TickMovementStaminaUpdateHz;                       // 0x628(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStaminaActionCostsRowHandle          SprintAction;                                      // 0x62C(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStaminaActionCostsRowHandle          SprintJumpAction;                                  // 0x644(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStaminaActionCostsRowHandle          JumpAction;                                        // 0x65C(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStaminaActionCostsRowHandle          CrouchAction;                                      // 0x674(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStaminaActionCostsRowHandle          WalkAction;                                        // 0x68C(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BlockDetectionDistance;                            // 0x6A4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BlockDetectionInterval;                            // 0x6A8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        BlockDetectionSampleCount;                         // 0x6AC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PreciseReachRadiusMultiplier;                      // 0x6B0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PreciseReachHeightMultiplier;                      // 0x6B4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7ED4[0x60];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusCharacter* GetDefaultObj();

	void TryApplyFallDamage(enum class EMovementMode PreviousMoveMode);
	bool TickMovementStaminaCost(float DeltaTime);
	void StopSprint(bool bClientSimulation);
	void StopReloading();
	void StopAim(bool bClientSimulation);
	void StartReloading();
	void StaminaMovementTickFunction();
	void Sprint(bool bClientSimulation);
	void SpawnHitEffects(const struct FTransform& SpawnTransform, enum class EPhysicalSurface HitSurface, class AActor* HitActor);
	bool ShouldApplyMovementCost();
	void SetIcarusUID(int32 ForcedUID);
	void ReportCharacterNoiseEvent(const struct FVector& NoiseLocation, float Loudness, class AActor* InstigatingActor, float MaxRange, class FName Tag);
	void RaiseTheCurtain();
	void OnTakeCollisionDamage(float Damage, class AController* DamageInstigator, class AActor* DamageCauser, const struct FHitResult& Hit);
	void OnStatContainerUpdated_Internal();
	void OnRep_IsSprinting();
	void OnRep_IsReloading();
	void OnRep_IsAiming();
	void OnFallDamageApplied(float DamageApplied, float FallSpeed, float FallStrength);
	void OnCharacterDamaged(const struct FIcarusDamagePacket& DamagePacket);
	void Multicast_StopReplicatedMontage(class UAnimMontage* Montage);
	void Multicast_SpawnHitEffects(const struct FTransform& SpawnTransform, enum class EPhysicalSurface HitSurface, class AActor* HitActor);
	void Multicast_PlayReplicatedMontage(class UAnimMontage* Montage, class FName StartingSection, float PlayRate, bool bSkipServer);
	void Multicast_JumpToMontageSection(class UAnimMontage* Montage, class FName Section);
	void ItemRemovedDelegate(class UInventory* Inventory, int32 Slot);
	void ItemAddedDelegate(class UInventory* Inventory, int32 Slot);
	bool IsSprinting();
	bool IsReloading();
	bool IsAiming();
	void IcarusBeginPlay();
	bool HasRecorder();
	class UInventoryComponent* GetInventoryComponent();
	int32 GetIcarusUID();
	struct FVector GetDamageSourceLocation();
	float GetAdjustedMovementActionStaminaCost(const struct FStatsEnum& Stat, float CostPerSecond);
	void ClaimUniqueIcarusUIDFromLibrary(int32 SuggestedUID);
	void Aim(bool bClientSimulation);
};

// 0x10 (0x2E0 - 0x2D0)
// Class Icarus.IcarusCharacterAnimInstance
class UIcarusCharacterAnimInstance : public UIcarusAnimInstance
{
public:
	class AIcarusItem*                           FocusedItem;                                       // 0x2D0(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusPlayerCharacter*                OwningCharacter;                                   // 0x2D8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UIcarusCharacterAnimInstance* GetDefaultObj();

	void SetFocusedItem(class AIcarusItem* Item);
	void OnFocusedItemUpdated(class AIcarusItem* Item);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusCharacterFunctionLibrary
class UIcarusCharacterFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusCharacterFunctionLibrary* GetDefaultObj();

	int32 CalculatePlayerLevel(int32 ExperiencePoints, const struct FCharacterGrowthRowHandle& GrowthRowHandle);
};

// 0x8 (0x1B0 - 0x1A8)
// Class Icarus.IcarusCharacterRecorderComponent
class UIcarusCharacterRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FIcarusCharacterRecord                CharacterRecord;                                   // 0x1A8(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7ED5[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusCharacterRecorderComponent* GetDefaultObj();

};

// 0x0 (0x88 - 0x88)
// Class Icarus.IcarusCheatManager
class UIcarusCheatManager : public UCheatManager
{
public:

	static class UClass* StaticClass();
	static class UIcarusCheatManager* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusCheatsFunctionLibrary
class UIcarusCheatsFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusCheatsFunctionLibrary* GetDefaultObj();

	void QueueAutomationScript(class UObject* WorldContextObject, class FName& ScriptName, const struct FLatentActionInfo& LatentInfo);
	bool IsCheatsEnabled();
	void IfCheatsEnabled(enum class ECheatsEnabled* Paths);
	class ACheatController* GetCheatController(class UObject* WorldContextObject, int32 PlayerIndex, enum class EValid* Paths);
	void EvaluateCheatScript(class UObject* WorldContextObject, TArray<class FString>& ScriptLines, const struct FLatentActionInfo& LatentInfo);
	void EvaluateAutomationScript(class UObject* WorldContextObject, TArray<class FString>& ScriptLines, const struct FLatentActionInfo& LatentInfo);
};

// 0x50 (0x380 - 0x330)
// Class Icarus.IcarusClaimLaunchSession
class UIcarusClaimLaunchSession : public UIcarusSessionBase
{
public:
	TMap<enum class EIcarusClaimLaunchConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups;                                // 0x330(0x50)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusClaimLaunchSession* GetDefaultObj();

	class UIcarusClaimLaunchSession* IcarusClaimLaunchSession(class UObject* WorldContextObject, struct FProspectInfo& ProspectInfo, class APlayerController* PlayerController, const struct FOnlineProfileCharacter& OnlineProfileCharacter, class UConfirmationPopupBase* InConfirmationPopup, TMap<enum class EIcarusClaimLaunchConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups);
	void ClaimProspectResult(bool Success, struct FProspectInfo& ProspectInfo);
};

// 0xA8 (0x308 - 0x260)
// Class Icarus.IcarusCompassIcon
class UIcarusCompassIcon : public UUserWidget
{
public:
	class UIcarusMapIconComponent*               LinkedMapIcon;                                     // 0x260(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        FadeOutOverDistance;                               // 0x268(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7ED8[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FMapIconsData                         CachedMapIconData;                                 // 0x270(0x98)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UIcarusCompassIcon* GetDefaultObj();

};

// 0x78 (0x2D8 - 0x260)
// Class Icarus.IcarusCompassWidget
class UIcarusCompassWidget : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*              DynamicMat;                                        // 0x260(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  DynamicMatParamName;                               // 0x268(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UIcarusCompassIcon*>            CompassIcons;                                      // 0x270(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<class UIcarusMapIconComponent*>         CompassIconComponents;                             // 0x280(0x50)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EDA[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusCompassWidget* GetDefaultObj();

	void RemoveWaypointWidget(class UIcarusCompassIcon* CompassIcon);
	void RemoveWaypointComponent(class UIcarusMapIconComponent* MapIconComponent);
	void OnMapIconVisibilityChanged(class UUserWidget* Widget, class UIcarusMapIconComponent* Component, bool bNewVisibility);
	void OnMapIconsUpdated();
	void AddWaypointComponent(class UIcarusMapIconComponent* MapIconComponent);
};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.IcarusContainerManagerRecorderComponent
class UIcarusContainerManagerRecorderComponent : public UActorStateRecorderComponent
{
public:
	int32                                        NumInventories;                                    // 0x1A8(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7EDB[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FSavedInventoryContainerData>  SavedInventoryContainers;                          // 0x1B0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusContainerManagerRecorderComponent* GetDefaultObj();

};

// 0x8 (0x598 - 0x590)
// Class Icarus.IcarusController
class AIcarusController : public APlayerController
{
public:
	FMulticastSparseDelegateProperty_            OnItemGained;                                      // 0x590(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EE7[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusController* GetDefaultObj();

	void TriggerQuickMoveType(class UInventory* Inventory, int32 Slot);
	void TriggerQuickMove(class UInventory* Inventory, int32 Slot);
	void ShiftItem(class UInventory* SourceInventory, int32 SourceLocation, class UInventory* DestinationInventory, int32 DestinationLocation, int32 Amount);
	bool PickupAll(class UInventory* Inventory);
	void OnServer_UseItemAuto(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use);
	void OnServer_UseItem(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use);
	void OnServer_TransferLike(class UInventory* FromInventory, class UInventory* ToInventory);
	void OnServer_TransferAllOfType(class UInventory* FromInventory, class UInventory* ToInventory, const struct FItemsStaticRowHandle& Type);
	void OnServer_TransferAll(class UInventory* FromInventory, class UInventory* ToInventory);
	void OnServer_TakeAll(class UInventory* Inventory, bool bSkipBags);
	void OnServer_ShiftItemAuto(class UInventory* SourceInventory, int32 SourceLocation, class UInventory* DestinationInventory);
	void OnServer_ShiftItem(class UInventory* SourceInventory, int32 SourceLocation, class UInventory* DestinationInventory, int32 DestinationLocation, int32 Amount);
	void OnServer_QuickMoveType(class UInventory* Inventory, int32 Slot, TArray<class UInventory*>& LinkedActorInventories);
	void OnServer_QuickMoveItem(class UInventory* Inventory, int32 Slot, TArray<class UInventory*>& LinkedActorInventories);
	void OnServer_BounceItem(const struct FItemData& Item);
	void OnServer_AddItemCheat(class UInventory* SourceInventory, const struct FItemData& ItemData);
	void OnServer_AddItem(const struct FItemData& ItemTemplate);
	bool IsOnProspect();
	TArray<class UInventory*> GetDynamicWidgetInventories();
};

// 0x50 (0x320 - 0x2D0)
// Class Icarus.IcarusCorpseAnimInstance
class UIcarusCorpseAnimInstance : public UIcarusAnimInstance
{
public:
	class AIcarusCorpse*                         OwningCorpse;                                      // 0x2D0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                         CarryAnim;                                         // 0x2D8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPoseSnapshot                         RagdollPose;                                       // 0x2E0(0x38)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                         bIsThirdPerson;                                    // 0x318(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsCarried;                                        // 0x319(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7EE8[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusCorpseAnimInstance* GetDefaultObj();

};

// 0xC0 (0x390 - 0x2D0)
// Class Icarus.IcarusCreatureAnimInstance
class UIcarusCreatureAnimInstance : public UIcarusAnimInstance
{
public:
	bool                                         bIsSwimming;                                       // 0x2D0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EE9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        PawnVelocity;                                      // 0x2D4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PawnDirection;                                     // 0x2D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                              PawnAngularVelocity;                               // 0x2DC(0xC)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                        PawnTurnRate;                                      // 0x2E8(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TurnRateNormalisationValue;                        // 0x2EC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        IKStrength;                                        // 0x2F0(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIKEnabled;                                        // 0x2F4(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EEA[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  DisableIKCurveName;                                // 0x2F8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ELookAtType                       LookAtType;                                        // 0x300(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EEB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LookYaw;                                           // 0x304(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LookPitch;                                         // 0x308(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               LookLocation;                                      // 0x30C(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bWithinViewAngle;                                  // 0x318(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EEC[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ViewAngleDotLimit;                                 // 0x31C(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ExistingTargetDotLimitBuffer;                      // 0x320(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  DisableLookAtCurveName;                            // 0x324(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LookAtStrength;                                    // 0x32C(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bShouldRagdoll;                                    // 0x330(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EED[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPoseSnapshot                         RagdollPose;                                       // 0x338(0x38)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	enum class EMovementState                    CurrentMovementState;                              // 0x370(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EEE[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                CurrentTarget;                                     // 0x378(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7EEF[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusCreatureAnimInstance* GetDefaultObj();

	void UpdateLookAtValues(float DeltaSeconds);
	float UpdateIKStrength(float DeltaSeconds);
	void OnIKSettingsUpdated(bool bNewIKEnabled);
	float GetLeanAmount();
};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.IcarusCriticalHitComponent
class UIcarusCriticalHitComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UIcarusCriticalHitComponent* GetDefaultObj();

	void SetLuckyBuffer(float NewLuckyBuffer);
	void SetIgnoreDamage(bool bIgnore);
	void SetDebug(bool bDebug);
	void SetCriticalHitConfig(class FName& Name);
	float GetLuckyBuffer();
	bool GetIgnoreDamage();
	bool GetDebug();
	void BP_SetLuckyBuffer(float NewLuckyBuffer);
	void BP_SetIgnoreDamage(bool bIgnore);
	void BP_SetDebug(bool bDebug);
};

// 0x8 (0x48 - 0x40)
// Class Icarus.IcarusDamageType
class UIcarusDamageType : public UDamageType
{
public:
	uint8                                        Pad_7EF0[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusDamageType* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.PureDamage
class UPureDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UPureDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.MeleeDamage
class UMeleeDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UMeleeDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ProjectileDamage
class UProjectileDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UProjectileDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.FireDamage
class UFireDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UFireDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.FallDamage
class UFallDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UFallDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.CollisionDamage
class UCollisionDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UCollisionDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.PoisonDamage
class UPoisonDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UPoisonDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.WindDamage
class UWindDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UWindDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ShieldDamage
class UShieldDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UShieldDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ReturnedDamage
class UReturnedDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UReturnedDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.FrostDamage
class UFrostDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UFrostDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ElectricDamage
class UElectricDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UElectricDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ExplosiveDamage
class UExplosiveDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UExplosiveDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.ShatterDamage
class UShatterDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UShatterDamage* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.FellingDamage
class UFellingDamage : public UIcarusDamageType
{
public:

	static class UClass* StaticClass();
	static class UFellingDamage* GetDefaultObj();

};

// 0x0 (0x118 - 0x118)
// Class Icarus.IcarusDataTableGenerationLibrary
class UIcarusDataTableGenerationLibrary : public UDataTableValidationLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusDataTableGenerationLibrary* GetDefaultObj();

};

// 0x30 (0x2B0 - 0x280)
// Class Icarus.IcarusDropShipSpawnLocator
class AIcarusDropShipSpawnLocator : public APawn
{
public:
	uint8                                        Pad_7EF1[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusDropShipSpawnLocator* GetDefaultObj();

};

// 0x10 (0x560 - 0x550)
// Class Icarus.IcarusEQSTestingPawn
class AIcarusEQSTestingPawn : public AEQSTestingPawn
{
public:
	FMulticastInlineDelegateProperty_            OnEQSQueryComplete;                                // 0x550(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusEQSTestingPawn* GetDefaultObj();

	void SetEQS(class UEnvQuery* Template);
	void RunEQSQueryTest();
	bool GetEQSResultsAsLocations(TArray<struct FVector>* OutLocations);
};

// 0x10 (0x40 - 0x30)
// Class Icarus.IcarusErrorSubsystem
class UIcarusErrorSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                        Pad_7EF4[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusErrorSubsystem* GetDefaultObj();

	void RequestErrorsForAction(enum class EErrorAction Action);
	void PushError(const struct FErrorCodesEnum& ErrorCode, enum class EErrorTarget Target, enum class EErrorAction ErrorAction);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusFunctionLibrary
class UIcarusFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusFunctionLibrary* GetDefaultObj();

	struct FVector2D WorldLocationToHeatmapUV(class UObject* WorldContext, struct FVector& Location);
	bool TriggerExperienceEvent(class AActor* Target, enum class EExperienceSource Type, class AActor* Source);
	int32 TriggerAfflictionChance(class AActor* Parent, const struct FAfflictionChanceRowHandle& Affliction, class AActor* Causer, class AController* Instigator);
	void SetWidgetNavigation(bool AllowAnalog, bool AllowKey, bool AllowTab);
	void SetPrimitveNeverDistanceCull(class UPrimitiveComponent* PrimitveComponent, bool NewState);
	void SetLandscapeCollisionProfile(class ALandscapeProxy* Landscape, class FName ProfileName);
	void SetItemOwnerInfo(class UObject* WorldContextObject, struct FItemData& Item, class AIcarusPlayerController* NewOwner);
	bool SetGameplayTagContainer(class UObject* InAsset, struct FGameplayTagContainer& InContainer);
	bool SetFarShadowsForComponent(class UPrimitiveComponent* Component, bool bFarShadowsEnabled);
	bool SetContactShadowsForComponent(class UPrimitiveComponent* Component, bool bContactShadowsEnabled);
	int32 SampleTerrainTemperatureColorAtLocation(class UObject* WorldContext, struct FVector& Location);
	int32 SampleTemperatureMapWithLocation(class UGameplayTexture* Texture, class UObject* WorldContext, struct FVector& Location, struct FVector2D& Scalar);
	bool SampleLocationOutOfBounds(class UObject* WorldContext, struct FVector& Location, bool bIncludeTerrainDataMask);
	struct FColor SampleHeatmapWithUV(class UGameplayTexture* Texture, struct FVector2D& UV);
	struct FColor SampleHeatmapWithLocation(class UGameplayTexture* Texture, class UObject* WorldContext, struct FVector& Location);
	int32 SampleEnvironmentalTemperature(class UObject* WorldContextObject, struct FBoxSphereBounds& Bounds, class AActor* Caller, const struct FBiomesRowHandle& Biome, bool bExcludeFire);
	struct FColor SampleBoundsColorAtLocation(class UObject* WorldContext, struct FVector& Location, bool bIncludeTerrainDataMask);
	struct FColor SampleBiomeColorAtLocation(class UObject* WorldContext, struct FVector& Location);
	struct FBiomesRowHandle SampleBiomeAtLocation(class UObject* WorldContext, struct FVector& Location);
	uint8 RowHandleToEnum(const struct FRowHandle& InRowHandle, class UEnum* InEnum);
	bool RemoveModifierState(class AActor* Parent, const struct FModifierStatesRowHandle& InModifierFilter, int32 UID);
	struct FQuat MakeQuatFromAxisAngle(struct FVector& Axis, float AngleRadians);
	bool IsUsingControllerInput();
	bool IsMouseNavigation(struct FFocusEvent& InFocusEvent);
	bool IsLocationLoaded(class UObject* WorldContextObject, struct FVector& Location, TSoftObjectPtr<class UWorld>* Heightmap);
	bool IsFLODMesh(class UStaticMeshComponent* Mesh);
	bool IsEditorOnlyActor(class AActor* Actor);
	bool IsConstraining(class UPhysicsConstraintComponent* PhysicsConstraint);
	bool HasModifierState(class AActor* Parent, const struct FModifierStatesRowHandle& InModifierFilter);
	bool GrantSharedExperience(class AActor* Source, int32 Experience);
	bool GrantExperienceToActorWithMultiplier(class AActor* Target, struct FExperienceEventsRowHandle& Event, float Multiplier, class AActor* Source);
	bool GrantExperienceToActor(class AActor* Target, const struct FExperienceEventsRowHandle& Event, class AActor* Source);
	bool GrantExactExperienceToActor(class AActor* Target, struct FExperienceEventsRowHandle& Event, int32 ExperienceGranted, class AActor* Source);
	class AWorldSettings* GetWorldSettings(class UObject* WorldContextObject);
	bool GetWorldData(class UObject* WorldContextObject, struct FWorldDataRowHandle* WorldData);
	class AWorldBossManager* GetWorldBossManager(class UObject* WorldContextObject);
	class UWeatherManagerComponent* GetWeatherManager(class UObject* WorldContextObject);
	class AWeatherForecastManager* GetWeatherForecastManager(class UObject* WorldContextObject);
	class AWeatherController* GetWeatherController(class UObject* WorldContextObject);
	class FString GetVoxelCacheFilePath(TSubclassOf<class AVoxelResource> VoxelBlueprint);
	bool GetTerrainData(class UObject* WorldContextObject, struct FTerrainsRowHandle* TerrainData);
	class ULevelStreamingDynamic* GetStreamedLevelAtLocation(class UObject* WorldContextObject, struct FVector& Location);
	class UStaticMesh* GetStaticMeshFromFoliageISM(class UObject* FoliageType);
	TArray<struct FStaticMeshCapsuleCollider> GetStaticMeshCapsuleGeo(class UStaticMesh* StaticMesh);
	int32 GetSecondsPerGameDay(class UObject* WorldContextObject);
	class FName GetRootBoneName(class USkeletalMesh* Mesh);
	int32 GetRemainingProspectTime(int32 ElapsedTimeSeconds, const struct FProspectListRowHandle& Prospect);
	class AQuestManager* GetQuestManager(class UObject* WorldContextObject);
	class APlayerHistoryTracker* GetPlayerHistoryTracker(class UObject* WorldContextObject);
	void GetPlayerCharacterState(class UObject* WorldContextObject, int32 PlayerIndex, class UPlayerCharacterState** PlayerCharacterState, bool* bSuccess);
	struct FWeatherBiomeGroupsRowHandle GetParentBiomeGroup(struct FBiomesRowHandle& SearchBiome);
	void GetObjectInteraction(class AActor* Source, class AActor* Target, struct FValidInteractQueriesRowHandle* RowHandle, bool* bValidInteract);
	int32 GetNearestTileIndex(class UObject* WorldContextObject, struct FVector& Location);
	TArray<class FName> GetMontageSections(class UAnimMontage* Montage);
	class UAnimMetaData* GetMontageSectionMetaDataByClass(TSubclassOf<class UAnimMetaData> Class, class UAnimMontage* Montage, bool* Success, class FName MontageSection);
	class UModifierStateComponent* GetModifierStateByUID(class AActor* Parent, int32 UID);
	bool GetMapVersions(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld>& LevelAsset, int32* MapVersion, int32* GeneratedVersion);
	void GetLinearDriveParams(class UPhysicsConstraintComponent* PhysicsConstraint, float* PositionStrength, float* VelocityStrength);
	int32 GetLevelTimeElapsedSec(class UObject* WorldContextObject);
	int32 GetLevelIndexAtLocation(class UObject* WorldContextObject, struct FVector& Location);
	bool GetItemOwnerInfo(class UObject* WorldContextObject, struct FItemData& Item, struct FPlayerHistoryEntry* OwningPlayerInfo);
	class AInventoryContainerManager* GetInventoryContainerManager(class UObject* WorldContextObject);
	class AIcarusPlayerController* GetIcarusPlayerController(class UObject* WorldContextObject, int32 PlayerIndex, enum class EValid* IsValid);
	class AIcarusPlayerCharacter* GetIcarusPlayerCharacter(class UObject* WorldContextObject, int32 PlayerIndex, enum class EValid* IsValid);
	class AIcarusGameStateSurvival* GetIcarusGameStateSurvival(class UObject* WorldContextObject, bool* bValid);
	class AIcarusGameStateSpace* GetIcarusGameStateSpace(class UObject* WorldContextObject, bool* bValid);
	bool GetGameplayTagContainer(class UObject* InAsset, struct FGameplayTagContainer* OutContainer);
	int32 GetExperienceGrantedFromRecipe(struct FProcessorRecipe& Recipe, struct FRecipeSet& RecipeSet);
	int32 GetExperienceGrantedFromEvent(class AActor* Target, struct FExperienceEventsRowHandle& Event, class AActor* Source);
	enum class EDynamicQuestDifficulty GetDynamicQuestDifficulty(class UObject* WorldContextObject);
	class ADisasterController* GetDisasterController(class UObject* WorldContextObject);
	class UDialogueSystem* GetDialogueSystem(class UObject* WorldContextObject);
	struct FVector4 GetCustomPrimitiveDataVector4(class UPrimitiveComponent* Primitive, int32 DataIndex);
	struct FVector GetCustomPrimitiveDataVector3(class UPrimitiveComponent* Primitive, int32 DataIndex);
	struct FVector2D GetCustomPrimitiveDataVector2(class UPrimitiveComponent* Primitive, int32 DataIndex);
	float GetCustomPrimitiveDataFloatISM(class UInstancedStaticMeshComponent* ISM, int32 InstanceIndex, int32 DataIndex);
	float GetCustomPrimitiveDataFloat(class UPrimitiveComponent* Primitive, int32 DataIndex);
	bool GetCurrentProspectDifficultySetup(class UObject* WorldContextObject, struct FDifficultySetup* DifficultySetup);
	enum class EMissionDifficulty GetCurrentProspectDifficulty(class UObject* WorldContextObject);
	class UPrimitiveComponent* GetConstrainedComponent(class UPhysicsConstraintComponent* PhysicsConstraint, enum class EConstraintFrame Frame);
	struct FTransform GetBoneTransform(class USkeletalMesh* Mesh, class FName BoneName);
	void GetBackendProxyComponent(class UObject* WorldContextObject, int32 PlayerIndex, class UBackendProxyComponent** BackendProxyComponent, bool* bSuccess);
	class UAuraManagerComponent* GetAuraManager(class UObject* WorldContextObject);
	void FlushLandscapeProxy(class ALandscapeProxy* Proxy);
	void FixModifierActivation(class AActor* Parent, struct FModifierStatesRowHandle& RowHandle);
	float FindPositionFromDistanceCurve(class UAnimSequenceBase* InAnimSequence, class FName AnimationCurveName, float Distance);
	bool FindModifierState(class AActor* Parent, const struct FModifierStatesRowHandle& InModifierFilter, class UModifierStateComponent** FoundComponent);
	TArray<class AActor*> FilterActorsByBiome(TArray<class AActor*>& Actors, const struct FBiomesRowHandle& Biome);
	class FName EnumToRowName(uint8 EnumValue, class UEnum* InEnum);
	bool DoesFoliageTypeHaveValidCollisionSetup(class UFoliageType_InstancedStaticMesh* InFoliageTypeISM, class FString* FailureReason);
	bool DoesBoneExist(class USkeletalMesh* Mesh, class FName BoneName);
	int32 ConvertToEpoch(const struct FDateTime& Time);
	struct FDateTime ConvertToDateTime(int32 EpochTime);
	struct FBiomesRowHandle ColorToBiome(struct FColor& Color);
	bool CheckDeathEvent(class AActor* Target, class AActor* Source, const struct FExperienceData& Data);
	bool CapsuleTraceSingleRotated(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, struct FRotator& Orientation, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	bool CapsuleTraceMultiRotated(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, struct FRotator& Orientation, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	void CanHitWithSuccessType(class AActor* Source, class AActor* Target, enum class ECanHitResult* Result, struct FValidHitTypesRowHandle* Out_ValidHitType);
	bool CanHit(class AActor* Source, class AActor* Target);
	struct FColor BiomeToColor(struct FBiomesRowHandle& BiomesRow);
	void AddTraitComponent(class AActor* Owner, TSubclassOf<class UTraitComponent> TraitComponentClass, const struct FRowHandle& TraitData, class UTraitComponent** OutComponent);
	int32 AddModifierState(class AActor* Parent, const struct FModifier& InModifier, class AActor* Causer, class AController* Instigator, int32 Effectiveness);
	int32 AddFireModifierState(class AActor* Parent, class AActor* Causer, class AController* Instigator);
};

// 0x0 (0xD70 - 0xD70)
// Class Icarus.IcarusGameEngine
class UIcarusGameEngine : public UGameEngine
{
public:

	static class UClass* StaticClass();
	static class UIcarusGameEngine* GetDefaultObj();

};

// 0x6A8 (0x850 - 0x1A8)
// Class Icarus.IcarusGameInstance
class UIcarusGameInstance : public UGameInstance
{
public:
	bool                                         bLoginAttempted;                                   // 0x1A8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F44[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        MapVersion;                                        // 0x1AC(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MapGeneratedVersion;                               // 0x1B0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F45[0x14];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class ULobbyMessageCallbackProxyGen*         LobbyMessageCallback;                              // 0x1C8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F46[0x48];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            LoadingScreenChanged;                              // 0x218(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UScopedViewportBlocker*                ProspectLoadViewportBlocker;                       // 0x228(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        ViewportBlockerCount;                              // 0x230(0x4)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F47[0x11C];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnWindowReceivedFocus;                             // 0x350(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnWindowLostFocus;                                 // 0x360(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                  PresenceHabitatLocationText;                       // 0x370(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                  PresenceProspectLocationText;                      // 0x388(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F48[0x48];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBlueprintSessionResult               SessionToJoin;                                     // 0x3E8(0x108)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F49[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TWeakObjectPtr<class UUserWidget>            InBetweenLoadingScreen;                            // 0x508(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F4A[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FMaintenanceStatus                    CurrentMaintenanceStatus;                          // 0x518(0x20)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            MaintenanceStatusUpdated;                          // 0x538(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            LobbyQueueLoginUpdated;                            // 0x548(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                        CurrentQueueSize;                                  // 0x558(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurrentQueueSecondsRemaining;                      // 0x55C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DedicatedServerSessionInitialized;                 // 0x560(0x1)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F4B[0x1F];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        MaxRejoinAttempts;                                 // 0x580(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F4C[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusJoinSession*                    RetryJoinSessionInstance;                          // 0x590(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIcarusSession                        LastJoinedSession;                                 // 0x598(0x1B0)(Protected, NativeAccessSpecifierProtected)
	struct FOnlineProfileCharacter               LastJoinedCharacter;                               // 0x748(0xA0)(Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UConfirmationPopupBase> LastJoinedPopup;                                   // 0x7E8(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<enum class EIcarusJoinConfirmationStep, struct FConfirmationPopupDetails> LastJoinedSetups;                                  // 0x7F0(0x50)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F4D[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGameInstance* GetDefaultObj();

	void UpdateSentryContext();
	void UpdatePresence(class APlayerController* PlayerController, class FText NewLocation, class FName SessionName);
	void TryRejoinServer();
	void SetLocalUserProfile(struct FOnlineProfileUser& NewLocalUserProfile);
	void SetLocalSelectedCharacter(struct FOnlineProfileCharacter& NewLocalSelectedCharacter);
	void ResetLocalSelectedCharacter();
	void OnSessionInviteAcceptedEvent(int32 ControllerId, struct FBlueprintSessionResult& InviteResult);
	void OnRetryJoinServerSuccess(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnRetryJoinServerFailed(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnLobbyMessageComplete(struct FResLobbyMessage& Response);
	void LoginIcarus();
	void Login();
	bool IsViewportBlockerActive();
	bool IsInBetweenLoadingScreenShowing();
	bool HasLocalUserProfile();
	bool HasLocalSelectedCharacter();
	void HandlePreLoadMap(const class FString& MapName);
	void HandlePostLoadMap(class UWorld* World);
	void HandleLevelStreamedOut(class ULevel* Level, class UWorld* World);
	struct FOnlineProfileUser GetLocalUserProfile();
	struct FOnlineProfileCharacter GetLocalSelectedCharacter();
	class FText GetLastPresenceLocation();
	void BackupGameData();
	void AutomaticallyUpdateSentryContext();
};

// 0x0 (0x308 - 0x308)
// Class Icarus.IcarusGameModeSpace
class AIcarusGameModeSpace : public AIcarusGameModeBase
{
public:

	static class UClass* StaticClass();
	static class AIcarusGameModeSpace* GetDefaultObj();

};

// 0x350 (0x658 - 0x308)
// Class Icarus.IcarusGameModeSurvival
class AIcarusGameModeSurvival : public AIcarusGameModeBase
{
public:
	uint8                                        Pad_7F57[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class FString>                          ApprovedPlayerIDs;                                 // 0x318(0x50)(Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            DropshipSpawnFound;                                // 0x368(0x10)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnPreEndProspectSession;                           // 0x378(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FProspectInfo                         TestProspectInfo;                                  // 0x388(0x90)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                         bDebugPlayerInitialisationDropships;               // 0x418(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EEndProspectSessionContext        EndProspectSessionContext;                         // 0x419(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bForceLastSaveProspectState;                       // 0x41A(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bForceUpdateUnrealSession;                         // 0x41B(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F58[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LastProspectSaveStateTime;                         // 0x420(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LastProspectHeartbeatTime;                         // 0x424(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        LastSessionUpdateTime;                             // 0x428(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        UpdateProspectStateFailedCounter;                  // 0x42C(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F59[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        UpdateUnrealSessionFailedCounter;                  // 0x438(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F5A[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusGameStateRecorder*              GameStateRecorder;                                 // 0x448(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUpdateProspectCallbackProxyGen*       UpdateProspectCallbackProxy;                       // 0x450(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F5B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bCurrentUpdateProspectIsSaving;                    // 0x460(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F5C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusHostSession*                    HostSessionCallbackProxy;                          // 0x468(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIcarusUpdateSession*                  UpdateSessionCallbackProxy;                        // 0x470(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F5D[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGameModeStateRecorderComponent*       GameModeRecorderComponent;                         // 0x480(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProspectExpiredCallbackProxyGen*      ProspectExpiredCallbackProxy;                      // 0x488(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ProspectExpiredShutdownDelayTime;                  // 0x490(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F5E[0x14];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AWeatherController*                    WeatherController;                                 // 0x4A8(0x8)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class AWeatherController>      WeatherControllerClass;                            // 0x4B0(0x28)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeatherForecastManager*               WeatherForecastManager;                            // 0x4D8(0x8)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class AWeatherForecastManager> WeatherForecastManagerClass;                       // 0x4E0(0x28)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMapManagerBase*                       MapManager;                                        // 0x508(0x8)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class AMapManagerBase>         MapManagerClass;                                   // 0x510(0x28)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWorldBossManager*                     WorldBossManager;                                  // 0x538(0x8)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class AWorldBossManager>       WorldBossManagerClass;                             // 0x540(0x28)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F5F[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AServerShutdownTimer*                  ShutdownTimer;                                     // 0x570(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7F60[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class APlayerState*                          DummyPauserPlayerState;                            // 0x580(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FStoredPlayerItems> StoredPlayerItems;                                 // 0x588(0x50)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FPlayerRewardSchedule> PlayerRewards;                                     // 0x5D8(0x50)(NativeAccessSpecifierPrivate)
	int32                                        TotalSentExotics;                                  // 0x628(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                        TotalSentRedExotics;                               // 0x62C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMissionStatus>                MissionHistory;                                    // 0x630(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7F61[0x9];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bSpawnedExoticPlants;                              // 0x649(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F62[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        NextMeteorShowerTime;                              // 0x64C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SecondsBetweenMeteorShowers;                       // 0x650(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F63[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusGameModeSurvival* GetDefaultObj();

	void UpdateLockedMissions();
	void UpdateAllPlayerRewards();
	bool TryResolveRecorderForOwner(class AActor* SpawnedActor, bool bActorSpawned, bool bOnlyUseFastPath);
	bool StartFindingRocketSpawnForPlayer(int32 SelectedGroupIndex, class AIcarusPlayerControllerSurvival* Player);
	class AActor* SpawnSplineActorFromSavedState(struct FTransform& Transform, int32 SplineTypeEnum);
	void ShutdownServer();
	void ShutdownAfterProspectExpired();
	bool ShouldRestoreFoliageEntity(class AActor* FoliageActor, const struct FVector& FoliageLocation, float FoliageRadius);
	bool SetupTestProspectInfo();
	void SaveDeveloperProspect(const class FString& ProspectFileName);
	void SaveBackupProspect();
	void ReturnToLobbyWhenEmpty(class APawn* Executor);
	void ReturnToLobby(class APawn* Executor);
	void ResolveBlockers();
	void RaiseTheCurtain();
	void OnUpdateUnrealSessionSuccess(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnUpdateUnrealSessionFailure(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnServerStartedEmpty();
	void OnPlayerLeftByDropship(class AIcarusPlayerControllerSurvival* Player);
	void OnPlayerInitialisationFailed(class AIcarusPlayerController* Player);
	void OnMissionStarted(const struct FFactionMissionsRowHandle& Mission);
	void OnMissionFailed(class AQuest* Quest, const struct FFactionMissionsRowHandle& Mission);
	void OnMissionComplete(class AQuest* Quest, const struct FFactionMissionsRowHandle& Mission);
	void OnMissionAbandoned(const struct FFactionMissionsRowHandle& Mission);
	void OnHostUnrealSessionSuccess(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnHostUnrealSessionFailure(const struct FErrorCodesEnum& Result, const class FString& ExtraErrorInfo);
	void OnConnectedPlayerInitialisationComplete(struct FConnectedPlayer& ConnectedPlayer);
	void OnActorSpawned(class AActor* SpawnedActor);
	void NativeRaiseTheCurtain();
	void LaunchRedExotics(int32 Amount);
	void LaunchExotics(int32 Amount);
	void LaunchEquipment(const TArray<struct FItemData>& Items);
	bool IsExoticReplenishEnabled();
	void IcarusBeginPlay();
	bool HasProspectSessionEnded();
	class AIcarusRocketSpawnBase* GetRandomAvailableDropshipSpawnForIndex(int32 GroupIndex);
	float GetProspectGameTime();
	TArray<struct FMissionStatus> GetMissionHistory();
	int32 GetLevelTimeElapsedSec();
	class UIcarusGameStateRecorder* GetGameStateRecorder();
	void GetDropshipSpawnsInGroup(int32 GroupIndex, TArray<class AIcarusRocketSpawnBase*>* DropshipSpawns, bool bIncludeAssigned);
	int32 GetBestSpawnGroupIndex();
	struct FMissionReport GenerateMissionReportForPlayer(class AIcarusPlayerController* Player);
	void FoundRocketSpawn(class AIcarusRocketSpawnBase* FoundRocketSpawn, class AIcarusPlayerControllerSurvival* Player);
	void FinishManagerInit();
	void EndProspectSession(enum class EEndProspectSessionContext Context);
	void DumpVoxelTarget(class APawn* Executor);
	void DumpVoxelStates(class APawn* Executor);
	bool DoTryReplenishExhaustedExotics();
	void DatabaseReloadComplete();
	void DatabaseReloadBegin();
	void CreateAndFillOverflowBag(struct FTransform& Transform, TArray<struct FItemData>& ItemData, bool bIsGravestone, TSubclassOf<class AIcarusActor> ActorOverride);
	void CompleteRocketSpawnInitialisation(class AIcarusRocketSpawnBase* FoundRocketSpawn, class AIcarusPlayerControllerSurvival* Player);
	void Cheat_SetLevelTimeElapsedSec(int32 NewTimeElapsed);
};

// 0x0 (0x308 - 0x308)
// Class Icarus.IcarusGameModeTitlescreen
class AIcarusGameModeTitlescreen : public AIcarusGameModeBase
{
public:

	static class UClass* StaticClass();
	static class AIcarusGameModeTitlescreen* GetDefaultObj();

	class FString CheckIfDriversAreUpToDate();
};

// 0xB8 (0x2F0 - 0x238)
// Class Icarus.IcarusGameSession
class AIcarusGameSession : public AGameSession
{
public:
	uint8                                        Pad_7F64[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class FString>                          AdminIds;                                          // 0x240(0x50)(NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class FText>   BanLookup;                                         // 0x290(0x50)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FBanInfo>                      BanInfos;                                          // 0x2E0(0x10)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AIcarusGameSession* GetDefaultObj();

	void SendServerMessage(const class FString& Message);
};

// 0x20 (0x2B0 - 0x290)
// Class Icarus.IcarusGameStateBase
class AIcarusGameStateBase : public AGameState
{
public:
	class UConnectedPlayers*                     ConnectedPlayers;                                  // 0x290(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueSystem*                       DialogueSystem;                                    // 0x298(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                RichPresenceGUID;                                  // 0x2A0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusGameStateBase* GetDefaultObj();

	void OnConnectedPlayerInitialised(struct FConnectedPlayer& ConnectedPlayer);
};

// 0x100 (0x128 - 0x28)
// Class Icarus.IcarusGameStateRecorder
class UIcarusGameStateRecorder : public UObject
{
public:
	TArray<class UIcarusStateRecorderComponent*> RecorderComponents;                                // 0x28(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                           GUIDFastLookup;                                    // 0x38(0x50)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, int32>                   ActorPathNameFastLookup;                           // 0x88(0x50)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FVector_NetQuantize, int32>      ActorLocationFastLookup;                           // 0xD8(0x50)(Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusGameStateRecorder* GetDefaultObj();

};

// 0x0 (0x2B0 - 0x2B0)
// Class Icarus.IcarusGameStateSpace
class AIcarusGameStateSpace : public AIcarusGameStateBase
{
public:

	static class UClass* StaticClass();
	static class AIcarusGameStateSpace* GetDefaultObj();

};

// 0x2D0 (0x580 - 0x2B0)
// Class Icarus.IcarusGameStateSurvival
class AIcarusGameStateSurvival : public AIcarusGameStateBase
{
public:
	class UWeatherManagerComponent*              WeatherManager;                                    // 0x2B0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAuraManagerComponent*                 AuraManager;                                       // 0x2B8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQuestManager>             QuestManagerClass;                                 // 0x2C0(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQuestManager*                         QuestManager;                                      // 0x2C8(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInventoryContainerManager*            InventoryContainerManager;                         // 0x2D0(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerHistoryTracker*                 PlayerHistoryTracker;                              // 0x2D8(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                           TimeOfDayEnumCurve;                                // 0x2E0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQuestManagerSet;                                 // 0x2E8(0x10)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F6A[0x19];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         DebugLogging;                                      // 0x311(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         GOAPDebugging;                                     // 0x312(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bThermalComponentDebugging;                        // 0x313(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        GlobalEnvTempModifier;                             // 0x314(0x4)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F6B[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnSeedInitialised;                                 // 0x328(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        Seed;                                              // 0x338(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSeedInitialised;                                  // 0x33C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F6C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AFLOD*                                 FLOD;                                              // 0x340(0x8)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADisasterController*                   DisasterController;                                // 0x348(0x8)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TimeOfDay;                                         // 0x350(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        SecondsPerGameDay;                                 // 0x354(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ProspectDurationSec;                               // 0x358(0x4)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        DynamicQuestSeed;                                  // 0x35C(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnUITimeUpdated;                                   // 0x360(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGlobalCheatData                      GlobalCheatData;                                   // 0x370(0x2)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F6D[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class FString, int32>                   PreviouslyAssignedPlayerColors;                    // 0x378(0x50)(Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F6E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGameplayTexture*                      TemperatureMap;                                    // 0x3D0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                             TemperatureMapRange;                               // 0x3D8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTexture*                      BiomeMap;                                          // 0x3E0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTexture*                      BoundsMap;                                         // 0x3E8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTexture*                      BoundsOverrideMap;                                 // 0x3F0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                  UITimeText;                                        // 0x3F8(0x18)(Protected, NativeAccessSpecifierProtected)
	TArray<class UThermalComponent*>             ThermalComponents;                                 // 0x410(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                        LevelTimeElapsedSec;                               // 0x420(0x4)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7F6F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FSessionFlagsRowHandle>        SessionFlags;                                      // 0x428(0x10)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                         bIsOpenWorldProspect;                              // 0x438(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsOutpostProspect;                                // 0x439(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F70[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnRepopulateDynamicQuests;                         // 0x440(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTimeLockedMissionInfo>        LockedMissions;                                    // 0x450(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLockedMissionsUpdated;                           // 0x460(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FProspectInfo                         ReplicatedActiveProspect;                          // 0x470(0x90)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                        Pad_7F71[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FNetworkingStatus                     NetworkingStatus;                                  // 0x508(0x60)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, NativeAccessSpecifierPublic)
	struct FVector2D                             MeteorDirection;                                   // 0x568(0x8)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnMeteorsIncoming;                                 // 0x570(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusGameStateSurvival* GetDefaultObj();

	void UpdateIsOpenWorldProspect();
	void UpdateDynamicQuestSeed(int32 NewSeed);
	void SpawnFloatingDamageNumbers(class AActor* Actor, struct FIcarusDamagePacket& DamagePacket);
	void SetSessionFlag(struct FSessionFlagsRowHandle& Flag, bool State);
	void SetSeed(int32 NewSeed);
	void SetMeteorsIncoming(struct FVector& Direction);
	void ServerUpdateActiveProspect(struct FProspectInfo& InProspectInfo);
	void RequestRepopulateDynamicQuests();
	void RegisterThermalComponent(class UThermalComponent* NewComponent);
	void QuestCleanup();
	void OnRep_TimeOfDay();
	void OnRep_SessionFlags();
	void OnRep_Seed();
	void OnRep_ReplicatedActiveProspect();
	void OnRep_MeteorDirection();
	void OnRep_LockedMissions(const TArray<struct FTimeLockedMissionInfo>& OldValues);
	bool IsInLastMomentsOfSession();
	bool HasSessionFlag(struct FSessionFlagsRowHandle& Flag);
	class FText GetUITimeOfDay();
	int32 GetTemperatureEffectAtLocation(const struct FVector& WorldLocation, class AActor* Querier);
	int32 GetSessionRemainingSec();
	int32 GetProspectDurationSec();
	int32 GetPlayerColorForPlayerID(const class FString& PlayerID);
	int32 GetNewPlayerColor();
	int32 GetLevelTimeElapsedSec();
	void GenerateResourceTypeForVoxelActor(class AVoxelResource* VoxelResourceActor);
	void DeregisterThermalComponent(class UThermalComponent* Component);
};

// 0x30 (0x150 - 0x120)
// Class Icarus.IcarusGameUserSettingsPreGen
class UIcarusGameUserSettingsPreGen : public UGameUserSettings
{
public:
	FMulticastSparseDelegateProperty_            OnRestartRequested;                                // 0x120(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7F72[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UGameUserSettingsSubsystem*            Subsystem;                                         // 0x138(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7F73[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UStringTable*                          StringTable;                                       // 0x148(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UIcarusGameUserSettingsPreGen* GetDefaultObj();

	void PushLock_BP();
	void PopLock_BP(bool bApplyOnRelease);
	bool GPUSupportsRTX();
	class FText FindText(const class FString& Key);
};

// 0xF0 (0x240 - 0x150)
// Class Icarus.IcarusGameUserSettingsGen
class UIcarusGameUserSettingsGen : public UIcarusGameUserSettingsPreGen
{
public:
	FMulticastSparseDelegateProperty_            OnVSyncApplied;                                    // 0x150(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFrameLimitApplied;                               // 0x151(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnResolutionScaleApplied;                          // 0x152(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFieldOfViewApplied;                              // 0x153(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMotionBlurApplied;                               // 0x154(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnGammaApplied;                                    // 0x155(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnOverallApplied;                                  // 0x156(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnViewDistanceApplied;                             // 0x157(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLODBiasApplied;                                  // 0x158(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPostProcessingApplied;                           // 0x159(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShadowsApplied;                                  // 0x15A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMaxShadowCascadesApplied;                        // 0x15B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnContactShadowsApplied;                           // 0x15C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLightShadowsApplied;                             // 0x15D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnUseSimpleBuildingShadowsApplied;                 // 0x15E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShadowFilterMethodApplied;                       // 0x15F(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTexturesApplied;                                 // 0x160(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTextureStreamingPoolsizeApplied;                 // 0x161(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLimitPoolsizeToVRAMApplied;                      // 0x162(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnEffectsApplied;                                  // 0x163(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFoliageApplied;                                  // 0x164(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShadingApplied;                                  // 0x165(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAntiAliasingApplied;                             // 0x166(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTessellationApplied;                             // 0x167(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTerrainDeformationExperimentalApplied;           // 0x168(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnVolumetricCloudsApplied;                         // 0x169(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSkyboxQualityApplied;                            // 0x16A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFrameGenerationApplied;                          // 0x16B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSuperResolutionApplied;                          // 0x16C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSharpnessApplied;                                // 0x16D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnNVIDIAReflexLowLatencyApplied;                   // 0x16E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFSRModeApplied;                                  // 0x16F(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFSRSharpnessApplied;                             // 0x170(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnRTXEnabledApplied;                               // 0x171(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnGlobalIlluminationApplied;                       // 0x172(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMasterVolumeApplied;                             // 0x173(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAmbientVolumeApplied;                            // 0x174(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMusicVolumeApplied;                              // 0x175(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSFXVolumeApplied;                                // 0x176(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDialogueVolumeApplied;                           // 0x177(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnCharacterVoiceVolumeApplied;                     // 0x178(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLanguageApplied;                                 // 0x179(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnKillcamApplied;                                  // 0x17A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPlayerMarkerApplied;                             // 0x17B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnClothSimulationApplied;                          // 0x17C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnCreatureIKApplied;                               // 0x17D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowAimCrosshairApplied;                         // 0x17E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowDamageNumbersApplied;                        // 0x17F(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowBloodEffectsApplied;                         // 0x180(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowLightningEffectsApplied;                     // 0x181(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMultiplayerGhostBuildingApplied;                 // 0x182(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowTutorialProspectApplied;                     // 0x183(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowItemHighlightsApplied;                       // 0x184(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowDeployableShelterWarningApplied;             // 0x185(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDisableDeployableCameraRotationApplied;          // 0x186(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnScreenHitEffectsStrengthApplied;                 // 0x187(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnShowScreenshakeApplied;                          // 0x188(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnBlueprintTooltipOpenAnimationsApplied;           // 0x189(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnWorkshopTooltipOpenAnimationsApplied;            // 0x18A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSkipStartupMoviesApplied;                        // 0x18B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDisplayTemperatureApplied;                       // 0x18C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDisableMapSelectionWarningApplied;               // 0x18D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInputTypeApplied;                                // 0x18E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnControllerIconsApplied;                          // 0x18F(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMouseSensitivityXApplied;                        // 0x190(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnMouseSensitivityYApplied;                        // 0x191(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnToggleCrouchApplied;                             // 0x192(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnCrouchLedgeSafetyApplied;                        // 0x193(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnToggleSprintApplied;                             // 0x194(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnToggleAimApplied;                                // 0x195(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnSprintCancelReloadApplied;                       // 0x196(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInvertYAxisApplied;                              // 0x197(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAimSensitivityApplied;                           // 0x198(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bVSync;                                            // 0x199(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FD6[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FrameLimit;                                        // 0x19C(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ResolutionScale;                                   // 0x1A0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        FieldOfView;                                       // 0x1A4(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MotionBlur;                                        // 0x1A8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        Gamma;                                             // 0x1AC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EOverallSetting                   Overall;                                           // 0x1B0(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EViewDistanceSetting              ViewDistance;                                      // 0x1B1(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FD7[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LODBias;                                           // 0x1B4(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EPostProcessingSetting            PostProcessing;                                    // 0x1B8(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EShadowsSetting                   Shadows;                                           // 0x1B9(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FD8[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MaxShadowCascades;                                 // 0x1BC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bContactShadows;                                   // 0x1C0(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bLightShadows;                                     // 0x1C1(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bUseSimpleBuildingShadows;                         // 0x1C2(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EShadowFilterMethodSetting        ShadowFilterMethod;                                // 0x1C3(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ETexturesSetting                  Textures;                                          // 0x1C4(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FD9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TextureStreamingPoolsize;                          // 0x1C8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bLimitPoolsizeToVRAM;                              // 0x1CC(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EEffectsSetting                   Effects;                                           // 0x1CD(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EFoliageSetting                   Foliage;                                           // 0x1CE(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EShadingSetting                   Shading;                                           // 0x1CF(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EAntiAliasingSetting              AntiAliasing;                                      // 0x1D0(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bTessellation;                                     // 0x1D1(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bTerrainDeformationExperimental;                   // 0x1D2(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bVolumetricClouds;                                 // 0x1D3(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ESkyboxQualitySetting             SkyboxQuality;                                     // 0x1D4(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bFrameGeneration;                                  // 0x1D5(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ESuperResolutionSetting           SuperResolution;                                   // 0x1D6(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FDA[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        Sharpness;                                         // 0x1D8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ENVIDIAReflexLowLatencySetting    NVIDIAReflexLowLatency;                            // 0x1DC(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EFSRModeSetting                   FSRMode;                                           // 0x1DD(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FDB[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FSRSharpness;                                      // 0x1E0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bRTXEnabled;                                       // 0x1E4(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bGlobalIllumination;                               // 0x1E5(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FDC[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MasterVolume;                                      // 0x1E8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        AmbientVolume;                                     // 0x1EC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MusicVolume;                                       // 0x1F0(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SFXVolume;                                         // 0x1F4(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        DialogueVolume;                                    // 0x1F8(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CharacterVoiceVolume;                              // 0x1FC(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                Language;                                          // 0x200(0x10)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bKillCam;                                          // 0x210(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bPlayerMarker;                                     // 0x211(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bClothSimulation;                                  // 0x212(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bCreatureIK;                                       // 0x213(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowAimCrosshair;                                 // 0x214(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowDamageNumbers;                                // 0x215(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowBloodEffects;                                 // 0x216(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowLightningEffects;                             // 0x217(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bMultiplayerGhostBuilding;                         // 0x218(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowTutorialProspect;                             // 0x219(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowItemHighlights;                               // 0x21A(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowDeployableShelterWarning;                     // 0x21B(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDisableDeployableCameraRotation;                  // 0x21C(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FDD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ScreenHitEffectsStrength;                          // 0x220(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bShowScreenshake;                                  // 0x224(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bBlueprintTooltipOpenAnimations;                   // 0x225(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bWorkshopTooltipOpenAnimations;                    // 0x226(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bSkipStartupMovies;                                // 0x227(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EDisplayTemperatureSetting        DisplayTemperature;                                // 0x228(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDisableMapSelectionWarning;                       // 0x229(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EInputTypeSetting                 InputType;                                         // 0x22A(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EControllerIconsSetting           ControllerIcons;                                   // 0x22B(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MouseSensitivityX;                                 // 0x22C(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MouseSensitivityY;                                 // 0x230(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bToggleCrouch;                                     // 0x234(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bCrouchLedgeSafety;                                // 0x235(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bToggleSprint;                                     // 0x236(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bToggleAim;                                        // 0x237(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bSprintCancelReload;                               // 0x238(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bInvertYAxis;                                      // 0x239(0x1)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FDE[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AimSensitivity;                                    // 0x23C(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusGameUserSettingsGen* GetDefaultObj();

	void SetWorkshopTooltipOpenAnimations(bool bInWorkshopTooltipOpenAnimations);
	void SetVSync(bool bInVSync);
	void SetVolumetricClouds(bool bInVolumetricClouds);
	void SetViewDistance(enum class EViewDistanceSetting InViewDistance);
	void SetUseSimpleBuildingShadows(bool bInUseSimpleBuildingShadows);
	void SetToggleSprint(bool bInToggleSprint);
	void SetToggleCrouch(bool bInToggleCrouch);
	void SetToggleAim(bool bInToggleAim);
	bool SettingRequiresRestart(class FName SettingName);
	void SetTextureStreamingPoolsize(float InTextureStreamingPoolsize);
	void SetTextures(enum class ETexturesSetting InTextures);
	void SetTessellation(bool bInTessellation);
	void SetTerrainDeformationExperimental(bool bInTerrainDeformationExperimental);
	void SetSuperResolution(enum class ESuperResolutionSetting InSuperResolution);
	void SetSprintCancelReload(bool bInSprintCancelReload);
	void SetSkyboxQuality(enum class ESkyboxQualitySetting InSkyboxQuality);
	void SetSkipStartupMovies(bool bInSkipStartupMovies);
	void SetShowTutorialProspect(bool bInShowTutorialProspect);
	void SetShowScreenshake(bool bInShowScreenshake);
	void SetShowLightningEffects(bool bInShowLightningEffects);
	void SetShowItemHighlights(bool bInShowItemHighlights);
	void SetShowDeployableShelterWarning(bool bInShowDeployableShelterWarning);
	void SetShowDamageNumbers(bool bInShowDamageNumbers);
	void SetShowBloodEffects(bool bInShowBloodEffects);
	void SetShowAimCrosshair(bool bInShowAimCrosshair);
	void SetSharpness(float InSharpness);
	void SetShadows(enum class EShadowsSetting InShadows);
	void SetShadowFilterMethod(enum class EShadowFilterMethodSetting InShadowFilterMethod);
	void SetShading(enum class EShadingSetting InShading);
	void SetSFXVolume(float InSFXVolume);
	void SetSettingValue_String(class FName SettingName, const class FString& NewValue);
	void SetSettingValue_Index(class FName SettingName, int32 NewValue);
	void SetSettingValue_Float(class FName SettingName, float NewValue);
	void SetSettingValue_Bool(class FName SettingName, bool bNewValue);
	void SetScreenHitEffectsStrength(float InScreenHitEffectsStrength);
	void SetRTXEnabled(bool bInRTXEnabled);
	void SetResolutionScale(float InResolutionScale);
	void SetPostProcessing(enum class EPostProcessingSetting InPostProcessing);
	void SetPlayerMarker(bool bInPlayerMarker);
	void SetOverall(enum class EOverallSetting InOverall);
	void SetNVIDIAReflexLowLatency(enum class ENVIDIAReflexLowLatencySetting InNVIDIAReflexLowLatency);
	void SetMusicVolume(float InMusicVolume);
	void SetMultiplayerGhostBuilding(bool bInMultiplayerGhostBuilding);
	void SetMouseSensitivityY(float InMouseSensitivityY);
	void SetMouseSensitivityX(float InMouseSensitivityX);
	void SetMotionBlur(float InMotionBlur);
	void SetMaxShadowCascades(float InMaxShadowCascades);
	void SetMasterVolume(float InMasterVolume);
	void SetLODBias(float InLODBias);
	void SetLimitPoolsizeToVRAM(bool bInLimitPoolsizeToVRAM);
	void SetLightShadows(bool bInLightShadows);
	void SetLanguage(const class FString& InLanguage);
	void SetKillcam(bool bInKillcam);
	void SetInvertYAxis(bool bInInvertYAxis);
	void SetInputType(enum class EInputTypeSetting InInputType);
	void SetGlobalIllumination(bool bInGlobalIllumination);
	void SetGamma(float InGamma);
	void SetFSRSharpness(float InFSRSharpness);
	void SetFSRMode(enum class EFSRModeSetting InFSRMode);
	void SetFrameLimit(float InFrameLimit);
	void SetFrameGeneration(bool bInFrameGeneration);
	void SetFoliage(enum class EFoliageSetting InFoliage);
	void SetFieldOfView(float InFieldOfView);
	void SetEffects(enum class EEffectsSetting InEffects);
	void SetDisplayTemperature(enum class EDisplayTemperatureSetting InDisplayTemperature);
	void SetDisableMapSelectionWarning(bool bInDisableMapSelectionWarning);
	void SetDisableDeployableCameraRotation(bool bInDisableDeployableCameraRotation);
	void SetDialogueVolume(float InDialogueVolume);
	void SetCrouchLedgeSafety(bool bInCrouchLedgeSafety);
	void SetCreatureIK(bool bInCreatureIK);
	void SetControllerIcons(enum class EControllerIconsSetting InControllerIcons);
	void SetContactShadows(bool bInContactShadows);
	void SetClothSimulation(bool bInClothSimulation);
	void SetCharacterVoiceVolume(float InCharacterVoiceVolume);
	void SetBlueprintTooltipOpenAnimations(bool bInBlueprintTooltipOpenAnimations);
	void SetAntiAliasing(enum class EAntiAliasingSetting InAntiAliasing);
	void SetAmbientVolume(float InAmbientVolume);
	void SetAimSensitivity(float InAimSensitivity);
	void RevertSetting(class FName SettingName);
	void RevertDisplayMode();
	void ResetSettingsForSection(class FName CategoryName, class FName SectionName);
	void ResetSettingsForCategory(class FName CategoryName);
	void ResetGameplaySettings();
	void ResetDisplaySettings();
	void ResetControlsSettings();
	void ResetAudioSettings();
	bool IsSettingEnabledForEdit(class FName SettingName);
	bool IsSectionUsingDefaultValues(class FName CategoryName, class FName SectionName);
	bool IsSectionEnabledForEdit(class FName CategoryName, class FName SectionName);
	bool IsCategoryUsingDefaultValues(class FName CategoryName);
	bool GetWorkshopTooltipOpenAnimations();
	bool GetVSync();
	bool GetVolumetricClouds();
	enum class EViewDistanceSetting GetViewDistance();
	bool GetUseSimpleBuildingShadows();
	bool GetToggleSprint();
	bool GetToggleCrouch();
	bool GetToggleAim();
	float GetTextureStreamingPoolsize();
	enum class ETexturesSetting GetTextures();
	bool GetTessellation();
	bool GetTerrainDeformationExperimental();
	enum class ESuperResolutionSetting GetSuperResolution();
	bool GetSprintCancelReload();
	enum class ESkyboxQualitySetting GetSkyboxQuality();
	bool GetSkipStartupMovies();
	bool GetShowTutorialProspect();
	bool GetShowScreenshake();
	bool GetShowLightningEffects();
	bool GetShowItemHighlights();
	bool GetShowDeployableShelterWarning();
	bool GetShowDamageNumbers();
	bool GetShowBloodEffects();
	bool GetShowAimCrosshair();
	float GetSharpness();
	enum class EShadowsSetting GetShadows();
	enum class EShadowFilterMethodSetting GetShadowFilterMethod();
	enum class EShadingSetting GetShading();
	float GetSFXVolume();
	class FString GetSettingValue_String(class FName SettingName);
	int32 GetSettingValue_Index(class FName SettingName);
	float GetSettingValue_Float(class FName SettingName);
	bool GetSettingValue_Bool(class FName SettingName);
	enum class ESettingType GetSettingType(class FName SettingName);
	float GetScreenHitEffectsStrength();
	bool GetRTXEnabled();
	float GetResolutionScale();
	enum class EPostProcessingSetting GetPostProcessing();
	bool GetPlayerMarker();
	enum class EOverallSetting GetOverall();
	enum class ENVIDIAReflexLowLatencySetting GetNVIDIAReflexLowLatency();
	float GetMusicVolume();
	bool GetMultiplayerGhostBuilding();
	float GetMouseSensitivityY();
	float GetMouseSensitivityX();
	float GetMotionBlur();
	float GetMinTextureStreamingPoolsizeValue();
	float GetMinSharpnessValue();
	float GetMinSFXVolumeValue();
	float GetMinScreenHitEffectsStrengthValue();
	float GetMinResolutionScaleValue();
	float GetMinMusicVolumeValue();
	float GetMinMouseSensitivityYValue();
	float GetMinMouseSensitivityXValue();
	float GetMinMotionBlurValue();
	float GetMinMaxShadowCascadesValue();
	float GetMinMasterVolumeValue();
	float GetMinLODBiasValue();
	float GetMinGammaValue();
	float GetMinFSRSharpnessValue();
	float GetMinFrameLimitValue();
	float GetMinFieldOfViewValue();
	float GetMinDialogueVolumeValue();
	float GetMinCharacterVoiceVolumeValue();
	float GetMinAmbientVolumeValue();
	float GetMinAimSensitivityValue();
	float GetMaxTextureStreamingPoolsizeValue();
	float GetMaxSharpnessValue();
	float GetMaxShadowCascades();
	float GetMaxSFXVolumeValue();
	float GetMaxScreenHitEffectsStrengthValue();
	float GetMaxResolutionScaleValue();
	float GetMaxMusicVolumeValue();
	float GetMaxMouseSensitivityYValue();
	float GetMaxMouseSensitivityXValue();
	float GetMaxMotionBlurValue();
	float GetMaxMaxShadowCascadesValue();
	float GetMaxMasterVolumeValue();
	float GetMaxLODBiasValue();
	float GetMaxGammaValue();
	float GetMaxFSRSharpnessValue();
	float GetMaxFrameLimitValue();
	float GetMaxFieldOfViewValue();
	float GetMaxDialogueVolumeValue();
	float GetMaxCharacterVoiceVolumeValue();
	float GetMaxAmbientVolumeValue();
	float GetMaxAimSensitivityValue();
	float GetMasterVolume();
	float GetLODBias();
	bool GetLimitPoolsizeToVRAM();
	bool GetLightShadows();
	class FString GetLanguage();
	bool GetKillcam();
	bool GetInvertYAxis();
	enum class EInputTypeSetting GetInputType();
	bool GetGlobalIllumination();
	float GetGamma();
	float GetFSRSharpness();
	enum class EFSRModeSetting GetFSRMode();
	float GetFrameLimit();
	bool GetFrameGeneration();
	enum class EFoliageSetting GetFoliage();
	float GetFieldOfView();
	enum class EEffectsSetting GetEffects();
	enum class EDisplayTemperatureSetting GetDisplayTemperature();
	TArray<class FText> GetDisplayModeList();
	bool GetDisableMapSelectionWarning();
	bool GetDisableDeployableCameraRotation();
	float GetDialogueVolume();
	bool GetCrouchLedgeSafety();
	bool GetCreatureIK();
	enum class EControllerIconsSetting GetControllerIcons();
	bool GetContactShadows();
	bool GetClothSimulation();
	float GetCharacterVoiceVolume();
	bool GetBlueprintTooltipOpenAnimations();
	enum class EAntiAliasingSetting GetAntiAliasing();
	float GetAmbientVolume();
	float GetAimSensitivity();
	void ConfirmSetting(class FName SettingName);
	void ConfirmDisplayMode();
	bool CheckWorkshopTooltipOpenAnimationsCondition(int32 Index);
	bool CheckVSyncCondition(int32 Index);
	bool CheckVolumetricCloudsCondition(int32 Index);
	bool CheckViewDistanceCondition(int32 Index);
	bool CheckUseSimpleBuildingShadowsCondition(int32 Index);
	bool CheckToggleSprintCondition(int32 Index);
	bool CheckToggleCrouchCondition(int32 Index);
	bool CheckToggleAimCondition(int32 Index);
	bool CheckTextureStreamingPoolsizeCondition(int32 Index);
	bool CheckTexturesCondition(int32 Index);
	bool CheckTessellationCondition(int32 Index);
	bool CheckTerrainDeformationExperimentalCondition(int32 Index);
	bool CheckSuperResolutionCondition(int32 Index);
	bool CheckSprintCancelReloadCondition(int32 Index);
	bool CheckSkyboxQualityCondition(int32 Index);
	bool CheckSkipStartupMoviesCondition(int32 Index);
	bool CheckShowTutorialProspectCondition(int32 Index);
	bool CheckShowScreenshakeCondition(int32 Index);
	bool CheckShowLightningEffectsCondition(int32 Index);
	bool CheckShowItemHighlightsCondition(int32 Index);
	bool CheckShowDeployableShelterWarningCondition(int32 Index);
	bool CheckShowDamageNumbersCondition(int32 Index);
	bool CheckShowBloodEffectsCondition(int32 Index);
	bool CheckShowAimCrosshairCondition(int32 Index);
	bool CheckSharpnessCondition(int32 Index);
	bool CheckShadowsCondition(int32 Index);
	bool CheckShadowFilterMethodCondition(int32 Index);
	bool CheckShadingCondition(int32 Index);
	bool CheckSFXVolumeCondition(int32 Index);
	bool CheckSettingCondition(class FName SettingName, int32 Index);
	bool CheckSectionCondition(class FName CategoryName, class FName SectionName, int32 Index);
	bool CheckScreenHitEffectsStrengthCondition(int32 Index);
	bool CheckRTXEnabledCondition(int32 Index);
	bool CheckResolutionScaleCondition(int32 Index);
	bool CheckPostProcessingCondition(int32 Index);
	bool CheckPlayerMarkerCondition(int32 Index);
	bool CheckOverallCondition(int32 Index);
	bool CheckNVIDIAReflexLowLatencyCondition(int32 Index);
	bool CheckMusicVolumeCondition(int32 Index);
	bool CheckMultiplayerGhostBuildingCondition(int32 Index);
	bool CheckMouseSensitivityYCondition(int32 Index);
	bool CheckMouseSensitivityXCondition(int32 Index);
	bool CheckMotionBlurCondition(int32 Index);
	bool CheckMaxShadowCascadesCondition(int32 Index);
	bool CheckMasterVolumeCondition(int32 Index);
	bool CheckLODBiasCondition(int32 Index);
	bool CheckLimitPoolsizeToVRAMCondition(int32 Index);
	bool CheckLightShadowsCondition(int32 Index);
	bool CheckLanguageCondition(int32 Index);
	bool CheckKillcamCondition(int32 Index);
	bool CheckInvertYAxisCondition(int32 Index);
	bool CheckInputTypeCondition(int32 Index);
	bool CheckGlobalIlluminationCondition(int32 Index);
	bool CheckGammaCondition(int32 Index);
	bool CheckGameplayUserInterfaceCondition(int32 Index);
	bool CheckGameplayLanguageCondition(int32 Index);
	bool CheckGameplayGeneralCondition(int32 Index);
	bool CheckFSRSharpnessCondition(int32 Index);
	bool CheckFSRModeCondition(int32 Index);
	bool CheckFrameLimitCondition(int32 Index);
	bool CheckFrameGenerationCondition(int32 Index);
	bool CheckFoliageCondition(int32 Index);
	bool CheckFieldOfViewCondition(int32 Index);
	bool CheckEffectsCondition(int32 Index);
	bool CheckDisplayWindowCondition(int32 Index);
	bool CheckDisplayVideoCondition(int32 Index);
	bool CheckDisplayTemperatureCondition(int32 Index);
	bool CheckDisplayRayTracingCondition(int32 Index);
	bool CheckDisplayQualityCondition(int32 Index);
	bool CheckDisplayNVIDIAReflexCondition(int32 Index);
	bool CheckDisplayNVIDIADLSSCondition(int32 Index);
	bool CheckDisplayModeCondition(int32 Index);
	bool CheckDisplayAMDFidelityFXCondition(int32 Index);
	bool CheckDisableMapSelectionWarningCondition(int32 Index);
	bool CheckDisableDeployableCameraRotationCondition(int32 Index);
	bool CheckDialogueVolumeCondition(int32 Index);
	bool CheckCrouchLedgeSafetyCondition(int32 Index);
	bool CheckCreatureIKCondition(int32 Index);
	bool CheckControlsKeybindingsCondition(int32 Index);
	bool CheckControlsGeneralCondition(int32 Index);
	bool CheckControllerIconsCondition(int32 Index);
	bool CheckContactShadowsCondition(int32 Index);
	bool CheckClothSimulationCondition(int32 Index);
	bool CheckCharacterVoiceVolumeCondition(int32 Index);
	bool CheckBlueprintTooltipOpenAnimationsCondition(int32 Index);
	bool CheckAudioVolumeCondition(int32 Index);
	bool CheckAntiAliasingCondition(int32 Index);
	bool CheckAmbientVolumeCondition(int32 Index);
	bool CheckAimSensitivityCondition(int32 Index);
	bool CheckActionsCondition(int32 Index);
	void ApplySettingsForSection(class FName CategoryName, class FName SectionName);
	void ApplyGameplaySettings(bool bSaveSettings);
	void ApplyDisplaySettings(bool bSaveSettings);
	void ApplyControlsSettings(bool bSaveSettings);
	void ApplyAudioSettings(bool bSaveSettings);
};

// 0x78 (0x2B8 - 0x240)
// Class Icarus.IcarusGameUserSettings
class UIcarusGameUserSettings : public UIcarusGameUserSettingsGen
{
public:
	FMulticastSparseDelegateProperty_            OnMouseSensitivityChanged;                         // 0x240(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7FE0[0x1B];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	uint32                                       PatchVersion;                                      // 0x25C(0x4)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FE1[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class FName, class USettingWidget*>     SettingWidgets;                                    // 0x268(0x50)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusGameUserSettings* GetDefaultObj();

	void RevertChangesFromUI(class USettingsSection* Section);
	void OnDirty();
	bool IsPlayerUsingControllerStatic();
	void GetMouseSensitivityParameters(float* Yaw, float* Pitch, float* AimYaw, float* AimPitch);
	class UIcarusGameUserSettings* GetIcarusGameUserSettings();
	bool GetCanSprintCancelReload();
	void DisableDeployableCameraRotationChanged(bool bEnabled);
	class USettingsView* CreateWidgetsForCategory(class UUserWidget* OwningWidget, class UClass* SettingsViewClass, enum class ESettingsCategory Category);
	void ConfirmChangesFromUI(class USettingsSection* Section);
	void AutoTuneGraphicsSettings();
	void ApplyChangesFromUI(class USettingsSection* Section);
};

// 0x10 (0x370 - 0x360)
// Class Icarus.IcarusGameViewportClient
class UIcarusGameViewportClient : public UGameViewportClient
{
public:
	uint8                                        Pad_7FE2[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGameViewportClient* GetDefaultObj();

};

// 0x58 (0x80 - 0x28)
// Class Icarus.IcarusGOAPAction
class UIcarusGOAPAction : public UObject
{
public:
	uint8                                        Pad_7FED[0x28];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                Target;                                            // 0x50(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusNPCGOAPController*              CachedController;                                  // 0x58(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_7FEE[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGOAPAction* GetDefaultObj();

	bool UpdateCost(class AIcarusNPCGOAPController* Controller);
	bool PlanAction(class AIcarusNPCGOAPController* Controller);
	bool IsInRange(class AIcarusNPCGOAPController* Controller);
	bool GOAPAnimNotify(const class FString& NotifyName, class AIcarusNPCGOAPController* Controller);
	bool GetActionStats(TMap<struct FBaseStatsEnum, int32>* ActionStats);
	struct FGOAPAction GetActionData();
	bool ExecutionComplete(class AIcarusNPCGOAPController* Controller);
	bool Execute(class AIcarusNPCGOAPController* Controller, float Delta);
	bool CheckContextualPreconditions(class AIcarusNPCGOAPController* Controller);
	bool ArePreconditionsSatisfied(class AIcarusNPCGOAPController* Controller);
	bool AreEffectsSatisfied(class AIcarusNPCGOAPController* Controller);
	bool ActionReset(bool Interrupted);
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.IcarusGOAPAIMemory
class UIcarusGOAPAIMemory : public UActorComponent
{
public:
	TArray<struct FIcarusGOAPAIFact>             InteractableObjectMemories;                        // 0xB0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class AIcarusNPCGOAPController*              CurrentController;                                 // 0xC0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7FF5[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGOAPAIMemory* GetDefaultObj();

	void UpdateObject(enum class EGOAPObjectType ObjectType, class AActor* Object, const struct FAIStimulus& NewAIStimulus, enum class EGOAPFactSource FactSource);
	TArray<struct FIcarusGOAPAIFact> GetKnownIteractablesOfType(enum class EGOAPObjectType ObjectType, bool bOnlyCurrentlyPerceived);
	bool GetFactForObject(class AActor* Object, struct FIcarusGOAPAIFact* FoundFact);
	TArray<struct FIcarusGOAPAIFact> GetDistanceSortedKnownInteractables(class AActor* Actor, enum class EGOAPObjectType ObjectType, bool bOnlyCurrentlyPerceived);
	struct FIcarusGOAPAIFact GetClosestKnownInteractable(class AActor* Actor, enum class EGOAPObjectType ObjectType, bool bOnlyCurrentlyPerceived);
};

// 0x10 (0xC0 - 0xB0)
// Class Icarus.IcarusGOAPAIState
class UIcarusGOAPAIState : public UActorComponent
{
public:
	class AActor*                                CurrentTarget;                                     // 0xB0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EGOAPObjectType                   SearchingInteractableType;                         // 0xB8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7FF6[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGOAPAIState* GetDefaultObj();

	bool ClearAIState();
};

// 0x0 (0x5B0 - 0x5B0)
// Class Icarus.IcarusGOAPCorpseBase
class AIcarusGOAPCorpseBase : public AIcarusCorpse
{
public:

	static class UClass* StaticClass();
	static class AIcarusGOAPCorpseBase* GetDefaultObj();

	void SetupCorpseSettleTime(float NewMaxCorpseSettleTime);
};

// 0x18 (0x40 - 0x28)
// Class Icarus.IcarusGOAPGoal
class UIcarusGOAPGoal : public UObject
{
public:
	struct FGOAPGoalsRowHandle                   CachedRowHandle;                                   // 0x28(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UIcarusGOAPGoal* GetDefaultObj();

	bool SetWorkingData(class AIcarusNPCGOAPController* Controller);
	bool SetInitialState(class AIcarusNPCGOAPController* Controller);
	struct FGOAPGoal GetGoalData();
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.IcarusGOAPInteractableComponent
class UIcarusGOAPInteractableComponent : public UActorComponent
{
public:
	enum class EGOAPObjectType                   Type;                                              // 0xB0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         InUse;                                             // 0xB1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_7FFA[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        InteractTime;                                      // 0xB4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIcarusGOAPAction*                     CurrentAction;                                     // 0xB8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusNPCGOAPController*              CurrentInteractionController;                      // 0xC0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInteraction;                                     // 0xC8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAbort;                                           // 0xC9(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInteractionComplete;                             // 0xCA(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_7FFB[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGOAPInteractableComponent* GetDefaultObj();

	bool Interact(class UIcarusGOAPAction* Action, class AIcarusNPCGOAPController* Controller);
	bool CompleteInteraction();
	bool Abort();
};

// 0x0 (0x220 - 0x220)
// Class Icarus.IcarusGOAPInteractableObject
class AIcarusGOAPInteractableObject : public AActor
{
public:

	static class UClass* StaticClass();
	static class AIcarusGOAPInteractableObject* GetDefaultObj();

};

// 0x38 (0x60 - 0x28)
// Class Icarus.IcarusGOAPMotivation
class UIcarusGOAPMotivation : public UObject
{
public:
	struct FGOAPMotivationsRowHandle             CachedRowHandle;                                   // 0x28(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CurrentValue;                                      // 0x40(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8002[0x1C];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusGOAPMotivation* GetDefaultObj();

	bool UpdateCost(float Delta, class AIcarusNPCGOAPController* Controller);
	bool Update(float Delta, class AIcarusNPCGOAPController* Controller);
	bool SetMotivation(int32 NewValue);
	void OnMotivationTriggerEvent(class AIcarusNPCGOAPController* Controller, struct FGOAPMotivationTrigger& TriggeredEvent, bool bWasTriggered);
	struct FGOAPMotivation GetMotivationData();
};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.IcarusGOAPPlanner
class UIcarusGOAPPlanner : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UIcarusGOAPPlanner* GetDefaultObj();

};

// 0x18 (0x348 - 0x330)
// Class Icarus.IcarusUpdateSession
class UIcarusUpdateSession : public UIcarusSessionBase
{
public:
	class UGetProspectCallbackProxyGen*          GetProspectCallbackProxy;                          // 0x330(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUpdateSessionCallbackProxyAdvanced*   UpdateSessionCallbackProxy;                        // 0x338(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bForceUpdate;                                      // 0x340(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8003[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusUpdateSession* GetDefaultObj();

	void OnUpdateSessionSuccess();
	void OnUpdateSessionFailure(const class FString& ErrorReason);
	class UIcarusUpdateSession* IcarusUpdateSession(class UObject* WorldContextObject, class APlayerController* PlayerController);
	void GetProspectInfoSuccess(struct FResGetProspect& Response);
	void GetProspectInfoFailure(struct FResGetProspect& Response);
};

// 0x20 (0x368 - 0x348)
// Class Icarus.IcarusHostSession
class UIcarusHostSession : public UIcarusUpdateSession
{
public:
	bool                                         bHostSessionRetry;                                 // 0x348(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8004[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        HostSessionRetryAttempts;                          // 0x34C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        HostSessionRetryAttemptsMax;                       // 0x350(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        HostSessionRetryTime;                              // 0x354(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        HostSessionRetryTimeMax;                           // 0x358(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8005[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UCreateSessionCallbackProxyAdvanced*   CreateSessionCallbackProxy;                        // 0x360(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusHostSession* GetDefaultObj();

	void OnCreateSessionSuccess();
	void OnCreateSessionFailure(const class FString& FailureReason);
	class UIcarusHostSession* IcarusHostSession(class UObject* WorldContextObject, class APlayerController* PlayerController);
};

// 0xA0 (0x3B0 - 0x310)
// Class Icarus.IcarusHUD
class AIcarusHUD : public AHUD
{
public:
	uint8                                        Pad_8007[0xA0];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusHUD* GetDefaultObj();

	void UnregisterInventoryChangeListener(class UObject* Listener, class UInventory* Inventory);
	void ToggleDrawWeather();
	void SetBiomeWeatherData(TMap<struct FWeatherBiomeGroupsEnum, struct FWeatherBiomeGroupForecast>& BiomeGroupForecast);
	void RegisterInventoryChangeListener(class UObject* Listener, class UInventory* Inventory);
	void InventoryUpdated(class UInventory* Inventory, int32 Slot);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusItemFactory
class UIcarusItemFactory : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusItemFactory* GetDefaultObj();

	class AIcarusItem* SpawnItemActor(class UObject* WorldContextObject, struct FItemData& ItemData, enum class EIcarusItemContext ItemContext, struct FTransform& SpawnTransform, struct FIcarusItemSpawnParameters& SpawnParameters, bool bAllowSpawningByClient);
	bool GetItemDataContextParams(struct FItemData& ItemData, enum class EIcarusItemContext ItemContext, TSubclassOf<class AIcarusItem>* OutActorClass, TSoftObjectPtr<class UStreamableRenderAsset>* OutMeshPtr);
	class AIcarusItem* FinishSpawningItemActor(class AIcarusItem* SpawnedItem, struct FTransform& SpawnTransform);
};

// 0x60 (0x390 - 0x330)
// Class Icarus.IcarusJoinSession
class UIcarusJoinSession : public UIcarusSessionBase
{
public:
	class UJoinProspectCallbackProxyGen*         JoinProspectCallbackProxy;                         // 0x330(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<enum class EIcarusJoinConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups;                                // 0x338(0x50)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         bJoinCancelled;                                    // 0x388(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bJoiningDedicated;                                 // 0x389(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_800E[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusJoinSession* GetDefaultObj();

	void OnJoinProspectSuccess(struct FResJoinProspect& Result);
	void OnJoinProspectFailure(struct FResJoinProspect& Result);
	void OnConfirmationCancel();
	class UIcarusJoinSession* IcarusJoinSession(class UObject* WorldContextObject, struct FIcarusSession& IcarusSession, class APlayerController* PlayerController, const struct FOnlineProfileCharacter& OnlineProfileCharacter, class UConfirmationPopupBase* InConfirmationPopup, TMap<enum class EIcarusJoinConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups, const class FString& Options);
};

// 0x18 (0x1C8 - 0x1B0)
// Class Icarus.IcarusNPCRecorderComponent
class UIcarusNPCRecorderComponent : public UIcarusCharacterRecorderComponent
{
public:
	int32                                        FoodLevel;                                         // 0x1B0(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        WaterLevel;                                        // 0x1B4(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        OxygenLevel;                                       // 0x1B8(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        Stamina;                                           // 0x1BC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  AISetupRowName;                                    // 0x1C0(0x8)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusNPCRecorderComponent* GetDefaultObj();

};

// 0x28 (0x1F0 - 0x1C8)
// Class Icarus.IcarusJuvenileRecorderComponent
class UIcarusJuvenileRecorderComponent : public UIcarusNPCRecorderComponent
{
public:
	enum class ETamedState                       TamedState;                                        // 0x1C8(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_800F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TamingProgress;                                    // 0x1CC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  TamesRowName;                                      // 0x1D0(0x8)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerCharacterID                    LastPlayerLeaderID;                                // 0x1D8(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusJuvenileRecorderComponent* GetDefaultObj();

};

// 0x68 (0x118 - 0xB0)
// Class Icarus.IcarusLargeScaleDestroyComponent
class UIcarusLargeScaleDestroyComponent : public UActorComponent
{
public:
	uint8                                        Pad_8010[0x68];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusLargeScaleDestroyComponent* GetDefaultObj();

};

// 0x0 (0x260 - 0x260)
// Class Icarus.IcarusLinkedActorPanelBase
class UIcarusLinkedActorPanelBase : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UIcarusLinkedActorPanelBase* GetDefaultObj();

};

// 0x20 (0x50 - 0x30)
// Class Icarus.IcarusLogSubsystem
class UIcarusLogSubsystem : public UGameInstanceSubsystem
{
public:
	TArray<struct FIcarusLogEntry>               LogList;                                           // 0x30(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLogEntryAdded;                                   // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UIcarusLogSubsystem* GetDefaultObj();

	void Warn(const struct FLogCategoriesEnum& Category, const class FString& Message);
	void Log(const struct FLogCategoriesEnum& Category, const class FString& Message);
	void Error(const struct FLogCategoriesEnum& Category, const class FString& Message);
	void AddEntry(const struct FLogCategoriesEnum& Category, enum class ELevel Level, const class FString& Message);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.LogOverlayFunctionLibrary
class ULogOverlayFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class ULogOverlayFunctionLibrary* GetDefaultObj();

	class FString LogTimestampToString(struct FDateTime& Timestamp);
	bool IsLogValid(struct FIcarusLogEntry& Log);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MapIconWidgetInterface
class IMapIconWidgetInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IMapIconWidgetInterface* GetDefaultObj();

	bool ShouldOverrideWidgetLocation(struct FVector* Location);
	bool ShouldOverrideVisibility(enum class ESlateVisibility* ForcedVisibility);
	bool ShouldDrawPathToLinkedActor(class AActor** LinkedActor);
	void InitialiseIconWidget(const struct FMapIconsRowHandle& MapIconData, class AActor* OwningActor);
};

// 0x140 (0x1F0 - 0xB0)
// Class Icarus.IcarusMapIconComponent
class UIcarusMapIconComponent : public UActorComponent
{
public:
	struct FMapIconsRowHandle                    MapIconData;                                       // 0xB0(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                IconParentActor;                                   // 0xC8(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                           GeneratedIconWidget;                               // 0xD0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIconIsVisible;                                    // 0xD8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8015[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnIconVisibilityChanged;                           // 0xE0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         bSetupIconAutomatically;                           // 0xF0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8016[0xFF];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusMapIconComponent* GetDefaultObj();

	void TrySetupMapIcon();
	void SetupMapIcon();
	void SetSetupIconAutomatically(bool bAutomaticSetup);
	bool HasWidgetBeenConstructed();
	bool GetSetupIconAutomatically();
};

// 0x0 (0x260 - 0x260)
// Class Icarus.IcarusMapScreenBase
class UIcarusMapScreenBase : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UIcarusMapScreenBase* GetDefaultObj();

};

// 0x180 (0x898 - 0x718)
// Class Icarus.IcarusNPCCharacter
class AIcarusNPCCharacter : public AIcarusCharacter
{
public:
	TSubclassOf<class UCharacterState>           ActorStateClass;                                   // 0x718(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainAnchorComponent*               NPCTerrainAnchor;                                  // 0x720(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ImplementsVisionSense;                             // 0x728(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ImplementsSoundSense;                              // 0x729(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         ImplementsDamageSense;                             // 0x72A(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         PerceptionLogging;                                 // 0x72B(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  EyeSocket;                                         // 0x72C(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  RootBoneName;                                      // 0x734(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8018[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<enum class EMovementState, struct FMovementStateData> MoveSpeedMapping;                                  // 0x740(0x50)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	enum class EMovementState                    MovementStateSet;                                  // 0x790(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8019[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UBehaviorTree*                         NpcBehaviourTree;                                  // 0x798(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bForceMaxLODWhenNotRendered;                       // 0x7A0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDrownNPCIfStuckInWater;                           // 0x7A1(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801A[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        DrownDelayInSeconds;                               // 0x7A4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFreezeNPCIfTerrainAnchorInvalid;                  // 0x7A8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDisableSurvivalTickOnFreeze;                      // 0x7A9(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsNPCFrozen;                                      // 0x7AA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801B[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            FrozenStateUpdated;                                // 0x7B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         bCleanupNPCIfFallingOutOfBounds;                   // 0x7C0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        OutOfBoundsCleanupDelayInSeconds;                  // 0x7C4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        OutOfBoundsMinimumFallDistance;                    // 0x7C8(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        OutOfBoundsMaximumZHeight;                         // 0x7CC(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseMeshBoundsAsSelfGoalRadius;                    // 0x7D0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseMeshBoundsAsTargetGoalRadius;                  // 0x7D1(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseMeshBoundsAsGoalHeight;                        // 0x7D2(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801D[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MeshBoundsScaleMultiplier;                         // 0x7D4(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDebugGoalRadius;                                  // 0x7D8(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bBeginDeathRagdoll;                                // 0x7D9(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801E[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPoseSnapshot                         DeathRagdollPose;                                  // 0x7E0(0x38)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                               DeathVelocity;                                     // 0x818(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_801F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            RagdollSettled;                                    // 0x828(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                FollowTargetActor;                                 // 0x838(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  FollowTargetActorKey;                              // 0x840(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8020[0x28];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UCreatureAudioThreatComponent*         AudioThreatComponent;                              // 0x870(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8021[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusNPCCharacter* GetDefaultObj();

	void UpdateVisibilityBasedAnimTickOption();
	void UpdateReplicatedBlackboardProperties();
	void UpdateRagdoll();
	void UpdateCharacterMoveSpeed(float Walk_speed);
	bool UnfreezeNPC();
	bool ShouldCreateTerrainAnchorComponent();
	void SetRagdollEnabled(bool bShouldRagdoll);
	void SetIsDrowning(bool NewIsDrowning);
	void ScheduleNextAnimTickOptionUpdate(float DistSqrToPlayer);
	bool ReplaceSelfWithDeadItem(class AIcarusActor** ReplacementActor);
	void OnTerrainAnchorStateChanged();
	void OnActorDeath(class UActorState* ActorStateIn);
	void HandleFallingOutOfWorld();
	void GetSightPerceptionOrigin(struct FVector* OutLocation, struct FRotator* OutRotation);
	class AActor* GetCurrentAnimationTarget();
	bool FreezeNPC();
};

// 0x130 (0x9C8 - 0x898)
// Class Icarus.IcarusNPCGOAPCharacter
class AIcarusNPCGOAPCharacter : public AIcarusNPCCharacter
{
public:
	struct FAISetupRowHandle                     AISetup;                                           // 0x898(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEpicCreaturesRowHandle               EpicCreature;                                      // 0x8B0(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                  EpicCreatureName;                                  // 0x8C8(0x18)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UIcarusGOAPAction>, struct FActionAnimData> ActionAnimMapping;                                 // 0x8E0(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            CharacterStanceUpdated;                            // 0x930(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AIcarusNPCGOAPCharacter*>       NPCChildren;                                       // 0x940(0x10)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                          JumpMontage;                                       // 0x950(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxJumpDistance;                                   // 0x958(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        JumpArc;                                           // 0x95C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CurrentLevel;                                      // 0x960(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8023[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnObstacleJumpStarted;                             // 0x968(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnObstacleJumpFinished;                            // 0x978(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class AActor*                                CurrentTarget;                                     // 0x988(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            GOAPMovementBlocked;                               // 0x990(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            CreatureLevelUpdated;                              // 0x9A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                LastDamageCauser;                                  // 0x9B0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                LastDamageInstigator;                              // 0x9B8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8024[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	enum class EGOAPCharacterStance              CurrentStance;                                     // 0x9C4(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8025[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusNPCGOAPCharacter* GetDefaultObj();

	void WorldStatsSet();
	bool UpdateMovementState(enum class EMovementState NewState);
	bool TryJumpOverObstacle();
	void StatContainerUpdated();
	void SetHitEventsEnabled(bool bEnabled);
	bool SetCurrentStance(enum class EGOAPCharacterStance NewStance);
	void OnRep_Level();
	void OnCharacterStanceUpdated(enum class EGOAPCharacterStance PreviousStance, enum class EGOAPCharacterStance NewStance);
	class FName GetNextAttackMontageSection(class AActor* AttackTarget);
	bool GetMontageForAction(TSoftClassPtr<class UIcarusGOAPAction>& Action, TSoftObjectPtr<class UAnimMontage>* ActionMontage, class FName* MontageSection, class FName* MontageNotify);
};

// 0x168 (0xB30 - 0x9C8)
// Class Icarus.IcarusMountCharacter
class AIcarusMountCharacter : public AIcarusNPCGOAPCharacter
{
public:
	struct FSurvivalTriggersRowHandle            SurvivalTriggersRowHandle;                         // 0x9C8(0x18)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        CachedWeightValue;                                 // 0x9E0(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_802C[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnMountWeightUpdated;                              // 0x9E8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_802D[0x40];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusMapIconComponent*               MapIconComponent;                                  // 0xA38(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                MountName;                                         // 0xA40(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCharacterID                    OwnerCharacterID;                                  // 0xA50(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                OwnerName;                                         // 0xA68(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMountsRowHandle                      MountData;                                         // 0xA78(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMounted;                                         // 0xA90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDismounted;                                      // 0xAA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         bWasPlayerFirstPerson;                             // 0xAB0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EMountCombatBehaviourState        CombatBehaviourState;                              // 0xAB1(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EMountMovementBehaviourState      MovementBehaviourState;                            // 0xAB2(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_802E[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UAnimMontage*>                  LoadedAnimations;                                  // 0xAB8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_802F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<int32, class UAnimMontage*>             ActiveTemporaryStats;                              // 0xAD8(0x50)(NativeAccessSpecifierPrivate)
	uint8                                        Pad_8030[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusMountCharacter* GetDefaultObj();

	bool TryJump();
	bool TryAttack();
	bool TryAlternateAttack();
	void SetOwningPlayerID(const struct FPlayerCharacterID& PlayerID);
	bool SetMountOwner(class AIcarusPlayerState* InPlayerState, bool bForceOwnership);
	bool SetMountName(const class FString& Name);
	void SetDesiredMovementState(enum class EMountMovementBehaviourState DesiredState);
	void SetDesiredCombatState(enum class EMountCombatBehaviourState DesiredState);
	void PerformPlayerOwnerStatConversion();
	void OwnerCharacterUpdated();
	void OnWeightUpdated();
	void OnWaterLevelUpdated(int32 WaterLevel);
	void OnRep_OwnerCharacterID();
	void OnRep_CachedWeightValue();
	void OnMountStatContainerUpdated();
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnFoodLevelUpdated(int32 FoodLevel);
	void Mounted(class AIcarusPlayerCharacter* Player);
	void MarkConvertedStatsRequireUpdate();
	bool IsMountOwner(class AIcarusPlayerState* InPlayerState);
	bool IsBeingRidden();
	class USurvivalCharacterState* GetSurvivalCharacterState();
	bool GetSeatActor(class ASeatBase** Seat);
	bool GetRidingPlayer(class AIcarusPlayerCharacter** RidingPlayer);
	class UAnimMontage* GetMontageForGameplayTag(struct FGameplayTag& Tag);
	struct FVector GetHandsTargetLocation();
	bool DoesMountSupportMovementState(enum class EMountMovementBehaviourState State);
	bool DoesMountSupportCombatState(enum class EMountCombatBehaviourState State);
	void Dismounted(class AIcarusPlayerCharacter* Player);
	void AddTemporaryStatsForMontage(TMap<struct FBaseStatsEnum, int32> TemporaryStats, class UAnimMontage* Montage);
};

// 0x58 (0x220 - 0x1C8)
// Class Icarus.IcarusMountCharacterRecorderComponent
class UIcarusMountCharacterRecorderComponent : public UIcarusNPCRecorderComponent
{
public:
	TArray<struct FStomachContent>               StomachContents;                                   // 0x1C8(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	class FString                                MountName;                                         // 0x1D8(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerCharacterID                    OwnerCharacterID;                                  // 0x1E8(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                OwnerName;                                         // 0x200(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EMountCombatBehaviourState        CombatBehaviourState;                              // 0x210(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EMountMovementBehaviourState      MovementBehaviourState;                            // 0x211(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8031[0xE];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusMountCharacterRecorderComponent* GetDefaultObj();

};

// 0x40 (0xF0 - 0xB0)
// Class Icarus.IcarusNavigationDirtier
class UIcarusNavigationDirtier : public UActorComponent
{
public:
	bool                                         bTryDirtyOnTick;                                   // 0xB0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRegenerateOnDirty;                                // 0xB1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EDirtierMode                      DirtierMode;                                       // 0xB2(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasDirtied;                                       // 0xB3(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8032[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UObject*>                       AffectedObjects;                                   // 0xB8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPreDirtyNavmesh;                                 // 0xC8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPostDirtyNavmesh;                                // 0xD8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AIcarusActor*                          IcarusActorOwner;                                  // 0xE8(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusNavigationDirtier* GetDefaultObj();

	bool TryDirtyNavmesh();
	void SetTryDirtyOnTick(bool bNewTryDirty);
	void RemoveAffectedObject(class UObject* Object);
	class AIcarusActor* GetOwningIcarusActor();
	void ClearAffectedObjects();
	void AddAffectedObject(class UObject* Object);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusNavigationFunctionLibrary
class UIcarusNavigationFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusNavigationFunctionLibrary* GetDefaultObj();

	void SpawnIcarusNavLink(class AActor* WorldContextObject, const struct FTransform& SpawnTransform, const struct FVector& LeftLinkLocation, const struct FVector& RightLinkLocation, class AActor** OutNavLink, enum class ENavLinkDirection LinkDirection, TSubclassOf<class AIcarusNavLink> LinkClass, TSubclassOf<class UNavArea> AreaClass, bool bDirtyNavigationOnBeginPlay);
};

// 0x18 (0x40 - 0x28)
// Class Icarus.LevelStreamingDelegateManager
class ULevelStreamingDelegateManager : public UObject
{
public:
	class ULevelStreaming*                       StreamingLevel;                                    // 0x28(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLevelStreamingStateUpdated;                      // 0x30(0x10)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ULevelStreamingDelegateManager* GetDefaultObj();

	void OnStreamingLevelStateUpdated();
	void OnLevelUnloaded();
	void OnLevelShown();
	void OnLevelLoaded();
	void OnLevelHidden();
};

// 0xB0 (0x1690 - 0x15E0)
// Class Icarus.IcarusNavigationSystem
class UIcarusNavigationSystem : public UNavigationSystemV1
{
public:
	TSet<class ULevelStreaming*>                 CompositionStreamingLevels;                        // 0x15E0(0x50)(Protected, NativeAccessSpecifierProtected)
	TSet<class ULevelStreaming*>                 BlockingStreamingLevels;                           // 0x1630(0x50)(Protected, NativeAccessSpecifierProtected)
	TArray<class ULevelStreamingDelegateManager*> LevelStreamingManagers;                            // 0x1680(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusNavigationSystem* GetDefaultObj();

	void UpdateNavOctreeBounds_BP(class AActor* Actor);
	void UpdateComponentInNavOctree_BP(class UActorComponent* Comp);
	void UpdateActorInNavOctree_BP(class AActor* Actor);
	void UnregisterActorAndComponentsInOctree(class AActor* Actor);
	void OnStreamingLevelStateUpdated(class ULevelStreaming* UpdatedStreamingLevel, bool bIsVisible);
	class UIcarusNavigationSystem* GetIcarusNavigationSystem(class UObject* WorldContextObject);
	void AddDirtyArea_BP(struct FVector& Origin, struct FVector& Extent, bool bIsIcarusNavigationDirtier);
};

// 0x0 (0x58 - 0x58)
// Class Icarus.IcarusNavigationSystemConfig
class UIcarusNavigationSystemConfig : public UNavigationSystemModuleConfig
{
public:

	static class UClass* StaticClass();
	static class UIcarusNavigationSystemConfig* GetDefaultObj();

};

// 0x30 (0x2A0 - 0x270)
// Class Icarus.IcarusNavLink
class AIcarusNavLink : public ANavLinkProxy
{
public:
	struct FVector                               LeftLinkLocation;                                  // 0x270(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               RightLinkLocation;                                 // 0x27C(0xC)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ENavLinkDirection                 LinkDirection;                                     // 0x288(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8038[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UNavArea>                  AreaClass;                                         // 0x290(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDirtyNavigationOnBeginPlay;                       // 0x298(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8039[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusNavLink* GetDefaultObj();

	void InitialiseNavLink();
};

// 0x8 (0x50 - 0x48)
// Class Icarus.IcarusNavQueryFilter
class UIcarusNavQueryFilter : public UNavigationQueryFilter
{
public:
	int32                                        MaxNavPathSearchNodes;                             // 0x48(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_803A[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusNavQueryFilter* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.IcarusNotfiyState
class UIcarusNotfiyState : public UAnimNotifyState
{
public:

	static class UClass* StaticClass();
	static class UIcarusNotfiyState* GetDefaultObj();

};

// 0xB8 (0x3E0 - 0x328)
// Class Icarus.IcarusNPCController
class AIcarusNPCController : public AAIController
{
public:
	uint8                                        Pad_803C[0x30];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UBlackboardComponent*                  AiBlackboardComponent;                             // 0x358(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                AiBehaviourTreeComponent;                          // 0x360(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_803D[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bTrackBlockedPathLocations;                        // 0x370(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_803E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TimeToRememberBlockedPaths;                        // 0x374(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoSmoothPathFollowing;                          // 0x378(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_803F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MinCurvePawnVelocity;                              // 0x37C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxCurvePawnVelocity;                              // 0x380(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxFirstPointDistance;                             // 0x384(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        PathInterpolationFactor;                           // 0x388(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8040[0x54];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusNPCController* GetDefaultObj();

	void UpdateCurrentGoalLocation(struct FVector& NewTargetLocation);
	bool ShouldAddCurveToNavigationPath();
	bool SetNewBehaviourTree(class UBehaviorTree* NewBehaviourTree);
	void OnStimulusDetected(TArray<class AActor*>& Detected);
	void GetBlockedPathLocations(TArray<struct FVector>* BlockedLocations);
	void CustomizeSenses();
};

// 0x160 (0x540 - 0x3E0)
// Class Icarus.IcarusNPCGOAPController
class AIcarusNPCGOAPController : public AIcarusNPCController
{
public:
	bool                                         bCurrentActionComplete;                            // 0x3E0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_804C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UIcarusGOAPInteractableComponent*      CurrentInteractable;                               // 0x3E8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                       DefaultBlackboard;                                 // 0x3F0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnGOAPStateUpdated;                                // 0x3F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnNewActionSet;                                    // 0x408(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	enum class EGOAPControllerState              CurrentControllerState;                            // 0x418(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_804D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRandomStream                         SeededRandomStream;                                // 0x41C(0x8)(BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_804E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnRandomStreamUpdated;                             // 0x428(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGOAPState                            CurrentState;                                      // 0x438(0x10)(NativeAccessSpecifierPrivate)
	class UIcarusGOAPGoal*                       CurrentGoal;                                       // 0x448(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIcarusGOAPAction*                     CurrentAction;                                     // 0x450(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIcarusGOAPGoal*>               PotentialGoals;                                    // 0x458(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UIcarusGOAPAction*>             PotentialActions;                                  // 0x468(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UIcarusGOAPMotivation*>         Motivations;                                       // 0x478(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UIcarusGOAPPlanner*                    Planner;                                           // 0x488(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AIcarusNPCGOAPCharacter*               NpcCharacter;                                      // 0x490(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIcarusGOAPAIState*                    AIState;                                           // 0x498(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIcarusGOAPAIMemory*                   AIMemory;                                          // 0x4A0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIcarusGOAPGoal*                       DefaultGoal;                                       // 0x4A8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_804F[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<TSoftClassPtr<class UIcarusGOAPGoal>, float> LastGoalExecutionTimes;                            // 0x4C0(0x50)(NativeAccessSpecifierPrivate)
	uint8                                        Pad_8050[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusNPCGOAPController* GetDefaultObj();

	bool UpdateMotivationValue(const struct FGOAPMotivationsRowHandle& Motivation, int32 NewValue);
	bool UpdateCurrentState(const struct FGOAPPropertiesRowHandle& Property, bool Value);
	bool TryCompleteCurrentAction();
	void SeedRandomStream(int32 NewSeed);
	void RecordAIMemory(enum class EGOAPObjectType ObjectType, class AActor* Object, const struct FAIStimulus& NewAIStimulus, enum class EGOAPFactSource FactSource);
	bool RecalculateGOAPState();
	bool RecalculateGoal(bool bForceNewGoal);
	bool OnProcessedNoise(class AActor* PerceivedActor, const struct FAIStimulus& EventStimulus);
	bool OnProcessedDamage(class AActor* PerceivedActor, const struct FAIStimulus& EventStimulus);
	bool MoveToAction(class UIcarusGOAPAction* Action);
	class AIcarusNPCGOAPCharacter* GetNPCCharacter();
	float GetMotivationValue(const struct FGOAPMotivationsRowHandle& Motivation);
	TArray<class UIcarusGOAPMotivation*> GetMotivations();
	bool GetMotivationObject(const struct FGOAPMotivationsRowHandle& Motivation, class UIcarusGOAPMotivation** ObjectReference);
	struct FGOAPState GetGOAPState();
	TArray<class UIcarusGOAPGoal*> GetGoals();
	void GetDynamicSubtreesToInject(TMap<struct FGameplayTag, class UBehaviorTree*>* DynamicSubtrees);
	bool GetCurrentPropertyState(const struct FGOAPPropertiesRowHandle& Property);
	class FString GetCurrentPlanDebug();
	class FString GetCurrentGoalDebug();
	class FString GetCurrentActionName();
	class UIcarusGOAPAction* GetCurrentAction();
	TArray<class FString> GetAvaliableGoals();
	TArray<class FString> GetAvaliableActions();
	class UIcarusGOAPAIState* GetAIState();
	class UIcarusGOAPAIMemory* GetAIMemory();
	float GetActorThreat(class AActor* PerceivedActor, bool bIgnoreRelationships);
	TArray<class UIcarusGOAPAction*> GetActions();
	bool CompleteCurrentAction(bool Succeeded);
	bool AddTemporaryStatsForAction(TMap<struct FBaseStatsEnum, int32> TemporaryStats);
};

// 0x0 (0x3E0 - 0x3E0)
// Class Icarus.IcarusNPCPredatorController
class AIcarusNPCPredatorController : public AIcarusNPCController
{
public:

	static class UClass* StaticClass();
	static class AIcarusNPCPredatorController* GetDefaultObj();

};

// 0x0 (0x3E0 - 0x3E0)
// Class Icarus.IcarusNPCPreyController
class AIcarusNPCPreyController : public AIcarusNPCController
{
public:

	static class UClass* StaticClass();
	static class AIcarusNPCPreyController* GetDefaultObj();

};

// 0xB0 (0xD8 - 0x28)
// Class Icarus.OrchestrationEvent
class UOrchestrationEvent : public UObject
{
public:
	uint8                                        Pad_8051[0xB0];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UOrchestrationEvent* GetDefaultObj();

};

// 0x98 (0xC8 - 0x30)
// Class Icarus.IcarusOrchestrationSubsystem
class UIcarusOrchestrationSubsystem : public UWorldSubsystem
{
public:
	TArray<class UOrchestrationEvent*>           OrchestrationEvents;                               // 0x30(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8054[0x28];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<TWeakObjectPtr<class AActor>>         AllActors;                                         // 0x68(0x10)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8055[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusOrchestrationSubsystem* GetDefaultObj();

	void MarkOrchestrationFlag(const struct FOrchestrationStateFlagsEnum& OrchestrationFlagEnum);
	class UOrchestrationEvent* GetOrchestrationEvent(const struct FOrchestrationEventsEnum& EventToGet);
	bool CheckOrchestrationFlag(const struct FOrchestrationStateFlagsEnum& OrchestrationFlag);
	bool CheckEvent(struct FOrchestrationEventsEnum& EventToCheck);
	void BindToOrchestrationEvent(FDelegateProperty_ Delegate, const struct FOrchestrationEventsEnum& EventToBind);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusPakMeta
class UIcarusPakMeta : public UObject
{
public:

	static class UClass* StaticClass();
	static class UIcarusPakMeta* GetDefaultObj();

	bool ShouldShowPopup();
	bool IsPakResultMatch(int32 Bitmask, enum class EMetaHashResult Variable);
	class FString FileDetailsToString(struct FPakFileDetails& Details);
	struct FPakMetaDetail CheckGameContentHash(class UGameInstance* GameInstance);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusParticleSystemFunctionLibrary
class UIcarusParticleSystemFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusParticleSystemFunctionLibrary* GetDefaultObj();

	class UNiagaraComponent* SpawnReplicatedNiagaraSystemAtLocation(class UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, class USceneComponent* TargetComponent, class FName TargetSocket, bool bAutoDestroy, bool bAutoActivate, enum class ENCPoolMethod PoolingMethod, bool bPreCullCheck);
};

// 0x1C0 (0x440 - 0x280)
// Class Icarus.IcarusPawn
class AIcarusPawn : public APawn
{
public:
	uint8                                        Pad_805B[0xA8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bCriticalHitDisabled;                              // 0x328(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_805C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FAISetupRowHandle                     AISetup;                                           // 0x32C(0x18)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEpicCreaturesRowHandle               EpicCreature;                                      // 0x344(0x18)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_805D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FText                                  EpicCreatureName;                                  // 0x360(0x18)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UIcarusStatContainer*                  StatContainer;                                     // 0x378(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorState*                           ActorState;                                        // 0x380(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIRelationshipsRowHandle             AIRelationshipTableRowNew;                         // 0x388(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bReplicateControlRotation;                         // 0x3A0(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_805E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRotator                              ReplicatedControlRotation;                         // 0x3A4(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                        CurrentLevel;                                      // 0x3B0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_805F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            PawnLevelUpdated;                                  // 0x3B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_8060[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x3D0(0x20)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	uint8                                        Pad_8061[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPawn* GetDefaultObj();

	void SetDamageEnabled(bool bEnabled);
	void OnStatContainerUpdated_Internal();
	void OnRep_Level();
	void OnActorDeath(class UActorState* ActorStateIn);
	void Multicast_PlayReplicatedMontage(class UAnimMontage* Montage, class FName StartingSection, float PlayRate, float StartPosition, bool bSkipServer);
	struct FVector GetDamageSourceLocation();
	class USkeletalMeshComponent* GetAnimatedMeshComponent();
	bool CanHitDamageTarget(class AActor* TargetActor, const struct FHitResult& InHit);
	TArray<class AIcarusPlayerCharacter*> BP_GetAllDamagingPlayerCharacters();
};

// 0x1C8 (0x3E8 - 0x220)
// Class Icarus.IcarusPayload
class AIcarusPayload : public AActor
{
public:
	class AController*                           PayloadInstigator;                                 // 0x220(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                Causer;                                            // 0x228(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                HitActor;                                          // 0x230(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                            HitResult;                                         // 0x238(0x88)(Edit, BlueprintVisible, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                         WasBounce;                                         // 0x2C0(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8063[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBallisticRowHandle                   BallisticRowHandle;                                // 0x2C4(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8064[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FStatContainer                        DamageStatContainer;                               // 0x2E0(0x108)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusPayload* GetDefaultObj();

	void SpawningComplete();
	int32 GetDamageStat(const struct FStatsEnum& Stat);
	void FinishSpawning(class UBallisticComponent* BallisticComponent);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusPlatformHelpers
class UIcarusPlatformHelpers : public UObject
{
public:

	static class UClass* StaticClass();
	static class UIcarusPlatformHelpers* GetDefaultObj();

	bool IsRunningLocalAdmin();
};

// 0x10 (0x2820 - 0x2810)
// Class Icarus.IcarusPlayerCameraManager
class AIcarusPlayerCameraManager : public APlayerCameraManager
{
public:
	class UAudioListenerCollider*                AudioListenerCollider;                             // 0x2810(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8065[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPlayerCameraManager* GetDefaultObj();

	void UpdateRotationLimits();
	void SetScreenShakeEnabled(bool bEnabled);
};

// 0x460 (0xB78 - 0x718)
// Class Icarus.IcarusPlayerCharacter
class AIcarusPlayerCharacter : public AIcarusCharacter
{
public:
	float                                        NextAllowedInteractTime;                           // 0x718(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFocusedItemUpdated;                              // 0x71C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_807B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UInventoryComponent*                   InventoryComponent;                                // 0x720(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            EquipmentInventory;                                // 0x728(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASeatBase*                             AttachedToSeat;                                    // 0x730(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APawn>                  PossessedPhotoCamera;                              // 0x738(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         BlockInputActions;                                 // 0x740(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_807C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRotator                              ReplicatedControlRotation;                         // 0x744(0xC)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bDisableActiveInteractable;                        // 0x750(0x1)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_807D[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FHitResult                            CachedActiveInteractableHit;                       // 0x754(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                            CachedActiveHighlightableHit;                      // 0x7DC(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                            CachedContextImageHit;                             // 0x864(0x88)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_807E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FInteractableHitLookup                CachedInteractableHitLookup;                       // 0x8F0(0xA0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                        InteractionTraceDistance;                          // 0x990(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterStartingStatsRowHandle      CharacterSetup;                                    // 0x994(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_807F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<int32, struct FArmourComponentData>     EquippedArmourData;                                // 0x9B0(0x50)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnArmourEquipmentUpdated;                          // 0xA00(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         IsMale;                                            // 0xA10(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8080[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FFocusedItemData                      FocusedItemData;                                   // 0xA18(0x10)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioContextPlayerComponent*          AudioContext;                                      // 0xA28(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerVocalisationComponent*          VocalisationComponent;                             // 0xA30(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerModifierAudioComponent*         ModifierAudioComponent;                            // 0xA38(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerFeedbackAudioComponent*         PlayerFeedbackAudioComponent;                      // 0xA40(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterVoicesRowHandle             Voice;                                             // 0xA48(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        RespawnCount;                                      // 0xA60(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         HasGrantedLoadout;                                 // 0xA64(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8081[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            PlayerCrouchUpdated;                               // 0xA68(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ADeployable*                           CurrentlyInteractingWithDeployable;                // 0xA78(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIcarusMapIconComponent*               PlayerMapIcon;                                     // 0xA80(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8082[0xEB];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bPlayerUIHidden;                                   // 0xB73(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8083[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPlayerCharacter* GetDefaultObj();

	void WorldStatsSet();
	enum class EViewTraceResultPriority ViewTraceActiveInteractableResultPredicate(struct FViewTraceResult& Result);
	enum class EViewTraceResultPriority ViewTraceActiveHighlightableResultPredicate(struct FViewTraceResult& Result);
	void UpdateHeldItem(struct FItemData& Item);
	bool UpdateEquipmentForSlot(int32 SlotNum, struct FArmourRowHandle& DataRow, struct FItemData& Item);
	void UpdateCameraPerspective();
	void UpdateCachedActiveInteractableHit(struct FHitResult& NewHit);
	void UpdateAllEquipment();
	void StopInteractingWithDeployable();
	void SetVoice(const struct FCharacterVoicesRowHandle& VoiceRowHandle);
	void SetupCharacterCosmetics();
	void SetPlayerMovementLocked(bool bLocked);
	void SetMontagePlayRate(float PlayRate);
	void SetInteractingWithDeployable(class ADeployable* Deployable);
	void Server_SetCachedInteractableHitLookup(const struct FInteractableHitLookup& LookUp);
	void Server_SetCachedActiveInteractableHit(const struct FHitResult& Hit);
	void Server_OnInteract(enum class EInteractType InteractType);
	void RequestSwapGender();
	void RecalculateArmourSetBonus(class UInventory* Inventory);
	void PlayMontage(class UAnimMontage* Montage, class UAnimMontage* FP_Montage, bool LockMotion, class FName StartingSection, class FName FP_StartingSection, float PlaySpeed);
	bool PickupItem(class AIcarusItem* Item);
	void OnViewTraceResultsUpdated(class AIcarusPlayerController* RegisteredController);
	bool OnUnFocusItem(int32 ItemLocation);
	void OnServer_UnFocusItem(int32 ItemLocation);
	void OnServer_SetStartingStats(const struct FCharacterStartingStatsRowHandle& CharacterStartingStatsRowHandle);
	void OnServer_FocusItem(class UInventory* Inventory, int32 Location);
	void OnServer_DropItem(class UInventory* Inventory, int32 Location, int32 Count);
	void OnRep_Gender();
	void OnRep_FocusedItemDataUpdated();
	void OnRep_CharacterVoice();
	void OnPlayerStateSet(class APlayerState* NewPlayerState);
	void OnOwner_ItemUseFailed(const struct FItemsStaticRowHandle& ItemData, const struct FUsesRowHandle& Use);
	void OnOwner_ItemUsed(const struct FItemsStaticRowHandle& ItemData, const struct FUsesRowHandle& Use);
	void OnOwner_ConsumableExpired(const struct FItemsStaticRowHandle& ItemData);
	void OnItemUseFailed(const struct FItemsStaticRowHandle& ItemData, const struct FUsesRowHandle& Use);
	void OnItemUsed(const struct FItemsStaticRowHandle& ItemData, const struct FUsesRowHandle& Use);
	bool OnInteractableLineTraceHit(struct FHitResult& HitResult);
	void OnInteract(enum class EInteractType InteractType);
	bool OnFocusItem(struct FItemData& InventoryItem);
	void OnEquipmentInventoryUpdated(int32 UpdatedSlot);
	void OnControllerThirdPersonToggled(bool bIsThirdPerson);
	void OnConsumableExpired(const struct FItemsStaticRowHandle& ItemData);
	void OnConnectedPlayersConnectedPlayerInitialised(struct FConnectedPlayer& ConnectedPlayer);
	void OnConnectedPlayerInitialised();
	void OnAttachedToSeatChanged(class ASeatBase* PreviousSeat);
	void OnActorHiddenStateUpdated(bool bIsHidden);
	void MarkNeedsCosmeticArmourUpdate();
	void MarkEquipmentInventoryUpdated();
	void MarkEquipmentInventorySlotUpdated(class UInventory* Inventory, int32 UpdatedSlotNum);
	void JumpToMontageSection(class UAnimMontage* TPMontage, class UAnimMontage* FPMontage, class FName NewTPSection, class FName NewFPSection);
	bool IsSeated();
	bool IsLocallyControlledWithMountResolve();
	bool IsHabCharacter();
	bool IsClothSimEnabled();
	bool InitialisationComplete();
	class USkeletalMeshComponent* GetVisibleCharacterMesh();
	class USkeletalMeshComponent* GetThirdPersonMesh();
	class UPlayerCharacterState* GetPlayerCharacterState();
	class AIcarusItem* GetLightSlotItemActor();
	class UItemManipulationComponent* GetItemManipulationComponent();
	struct FItemData GetItem(int32 InventoryID, int32 InventorySlot);
	float GetInteractCooldown();
	class AIcarusPlayerState* GetIcarusPlayerState();
	class AIcarusPlayerController* GetIcarusPlayerController();
	void GetHoldTimer(const struct FKeybindingsRowHandle& KeyBind, struct FTimerHandle* TimerHandle, bool* bValid);
	void GetFocusedItemInventoryAndSlot(class UInventory** FocusedItemInventory, int32* FocusedItemSlot, enum class EDataValidity* Validity);
	struct FItemData GetFocusedItemData(enum class EDataValidity* Validity);
	class AIcarusItem* GetFocusedItemActor();
	class USkeletalMeshComponent* GetFirstPersonMesh();
	class UCameraComponent* GetFirstPersonCamera();
	class USkeletalMeshComponent* GetFirstPersonBodyMesh();
	int32 GetEquippedArmourSet(const struct FArmourSetsRowHandle& ArmourSet);
	class AIcarusItem* GetCurrentUtilitySlotActor();
	class AIcarusItem* GetCurrentSecondarySlotActor();
	class ASeatBase* GetAttachedToSeat();
	bool GetArmourDataForGFurComponent(class UGFurComponent* Component, struct FArmourData* OutArmourData);
	void FocusAndUseItemFromMenu(class UInventory* Inventory, int32 Slot, const struct FUsesEnum& Use);
	TArray<class USkeletalMeshComponent*> FindOrCreateEquipmentComponent(int32 ForSlot);
	void EndMontage(class UAnimMontage* Montage, class UAnimMontage* FP_Montage, float BleedOutTime);
	bool DropItem(struct FItemData& InventoryItem);
	bool DoesCurrentSeatPreventOutOfBoundsCheck();
	bool ConsumeFocusedItem(int32 Amount);
	void ClearEquipmentInventory();
	void CheckShouldRefreshEquipmentInventory(class UInventory* Inventory, int32 UpdatedSlotNum);
};

// 0x8 (0xB80 - 0xB78)
// Class Icarus.IcarusPlayerCharacterServer
class AIcarusPlayerCharacterServer : public AIcarusPlayerCharacter
{
public:
	uint8                                        Pad_8084[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPlayerCharacterServer* GetDefaultObj();

};

// 0x8 (0xB80 - 0xB78)
// Class Icarus.IcarusPlayerCharacterSpace
class AIcarusPlayerCharacterSpace : public AIcarusPlayerCharacter
{
public:
	class UInventory*                            MainInventory;                                     // 0xB78(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusPlayerCharacterSpace* GetDefaultObj();

};

// 0x198 (0xD10 - 0xB78)
// Class Icarus.IcarusPlayerCharacterSurvival
class AIcarusPlayerCharacterSurvival : public AIcarusPlayerCharacter
{
public:
	bool                                         bIsHoldingJump;                                    // 0xB78(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bWantsAutoRun;                                     // 0xB79(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasMovementInputBeenReleased;                     // 0xB7A(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_808A[0x4D];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bClientFrozenMovement;                             // 0xBC8(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bServerFrozenMovement;                             // 0xBC9(0x1)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bActualFrozenMovement;                             // 0xBCA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_808B[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UScopedViewportBlocker*                FrozenMovementViewportBlocker;                     // 0xBD0(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsSpectateTarget;                                 // 0xBD8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_808C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        base_turn_rate;                                    // 0xBDC(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        base_look_up_rate;                                 // 0xBE0(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PlayerPitch;                                       // 0xBE4(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PlayerYaw;                                         // 0xBE8(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_808D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UInventory*                            EnvirosuitInventory;                               // 0xBF0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            BackpackInventory;                                 // 0xBF8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            QuickbarInventory;                                 // 0xC00(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            UpgradeInventory;                                  // 0xC08(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            VisionInventory;                                   // 0xC10(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        FocusedQuickbarSlot;                               // 0xC18(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSmoothMouseInput;                                 // 0xC1C(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_808E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        InputSmoothSpeed;                                  // 0xC20(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_808F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFLODInfluencePlayer*                  FLODInfluence;                                     // 0xC28(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStomachComponent*                     StomachComponent;                                  // 0xC30(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerTerrainAnchorComponent*         TerrainAnchor;                                     // 0xC38(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8090[0x58];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class ADDGIVolume*>                   RTXGIVolumes;                                      // 0xC98(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAttachedSeatChanged;                             // 0xCA8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayersSlept;                                    // 0xCB8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnInventoryWeightChanged;                          // 0xCC8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPerspectiveUpdated;                              // 0xCD8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_8091[0x28];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPlayerCharacterSurvival* GetDefaultObj();

	void UpdateMetaResources();
	void UpdateFrozenMovement();
	void ToggleWantsAutoRun();
	void StopJump();
	void StartJump();
	void StartCrouch();
	void SetWantsAutoRun(bool bNewAutoRun);
	void SetThermalVisionActive(bool bActive);
	void SetSpectateTarget(bool bState);
	void SetIsTravellingInDropship(bool bIsInDropship);
	void SetAimVignetteIntensity(float NewIntensityTarget, float InterpSpeed);
	void SetAimSpaceValues(float Pitch, float Yaw);
	void SetADSOffset(struct FTransform& NewOffset);
	void ServerUpdateClientFrozenMovement(bool bFreezeMovement);
	void ServerPlayerLeftByDropship();
	void Respawn();
	void RequestMoveForward(float Value);
	void OnWaterLevelUpdated(int32 WaterLevel);
	void OnWaterConsumed();
	void OnTerrainAnchorStateChanged();
	void OnTemperatureUpdated(int32 Temperature);
	void OnServer_ExitLadder();
	void OnPlayerDeath(class UActorState* ActorStateIn);
	void OnOxygenLevelUpdated(int32 OxygenLevel);
	void OnOxygenConsumed();
	void OnLongMovementFreeze();
	void OnJumpFailed();
	void OnInventoryBouncedItem(struct FItemData& Item);
	void OnFrozenMovementChanged();
	void OnFoodLevelUpdated(int32 FoodLevel);
	void OnFoodConsumed();
	void OnBiomeUpdated();
	void OnActorDeathBestiary(class UActorState* ActorStateIn);
	void OnActorDamagedBestiary(const struct FIcarusDamagePacket& DamagePacket);
	void NotifyPlayersSlept();
	void NotifyPerspectiveUpdated();
	void NotifyInventoryWeightChanged(int32 NewWeight);
	void NotifyAttachedSeatChanged();
	void NotifyAddedMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce);
	void MoveRight(float Value);
	void MoveForward(float Value);
	bool IsAlive();
	void InventoryUpdated(class UInventory* Inventory, int32 Location);
	bool HasCraftingRequirements(const struct FTalentsRowHandle& Talent);
	bool GetWantsAutoRun();
	bool GetThermalVisionActive();
	int32 GetSecondaryFocusedItemSlot();
	bool GetPlayerBestViewResultInteraction(struct FValidInteractQueriesRowHandle* FoundInteraction, bool* bValidInteraction);
	TArray<struct FItemData> GetLoadout();
	bool GetIsInCave();
	void GetFPCameraOrientation(struct FVector* OutPosition, struct FVector* OutForward);
	class AIcarusItem* GetFocusedItem();
	enum class EProspectLocation GetCurrentProspectLocation();
	int32 GetCurrentInventoryWeight();
	enum class EViewTraceResultPriority GetBestViewTraceInteractionHandler(struct FViewTraceResult& Result);
	void EndCrouch();
	void Debug_SetGOAPWorldStatsActive(bool bActive);
	bool Debug_GetGOAPWorldStatsActive();
	void Debug_DrawArmourComponent();
	void AddYaw(float Value);
	void AddPitch(float Value);
};

// 0x1F8 (0x790 - 0x598)
// Class Icarus.IcarusPlayerController
class AIcarusPlayerController : public AIcarusController
{
public:
	uint8                                        Pad_80A1[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusPlayerCharacter*                IcarusPlayerCharacter;                             // 0x5A0(0x8)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AContextMenuFactory>       ContextMenuFactoryClass;                           // 0x5A8(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80A2[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        InputAimYawScale;                                  // 0x5B4(0x4)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InputAimPitchScale;                                // 0x5B8(0x4)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFreeLook;                                         // 0x5BC(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80A3[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRotator                              FreeLookInput;                                     // 0x5C0(0xC)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80A4[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnToggleThirdPerson;                               // 0x5D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         bIsThirdPerson;                                    // 0x5E0(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_80A5[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnChatMessageReceived;                             // 0x5E8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnServerMessageReceived;                           // 0x5F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLocalMessageReceived;                            // 0x608(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnViewTraceResultsUpdated;                         // 0x618(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                         bCaptureViewTraces;                                // 0x628(0x1)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80A6[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class UObject*, struct FViewTraceRegistration> ViewTraceRegistrations;                            // 0x630(0x50)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FViewTraceResult>              ViewTraceResults;                                  // 0x680(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                        ViewTraceCapsuleRadius;                            // 0x690(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        ViewTraceIterationCount;                           // 0x694(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDebugCaptureViewTraceResultsStats;                // 0x698(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80A7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  DebugCaptureViewTraceResultsTag;                   // 0x69C(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80A8[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UBackendProxyComponent*                BackendProxyComponent;                             // 0x6A8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerDataComponent*                  PlayerDataComponent;                               // 0x6B0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBestiaryManagerComponent*             BestiaryManagerComponent;                          // 0x6B8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            OnServerFriendsUpdated;                            // 0x6C0(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UGetFriendsCallbackProxy*              GetFriendsListCallBackProxy;                       // 0x6D0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBPFriendInfo>                 ClientFriendsList;                                 // 0x6D8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                        FriendIds;                                         // 0x6E8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                         bClientFriendsListReady;                           // 0x6F8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bServerFriendsReady;                               // 0x6F9(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bClientIsInitialisingPlayerProfile;                // 0x6FA(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80A9[0x11];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SyncBackendStateCooldown;                          // 0x70C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnCharacterProgressionSynced;                      // 0x710(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80AA[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            OnCharacterTalentsSynced;                          // 0x728(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80AB[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            OnAccountTalentsSynced;                            // 0x740(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80AC[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            OnAccountFlagsSynced;                              // 0x758(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80AD[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x770(0x20)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusPlayerController* GetDefaultObj();

	bool ViewTraceByChannel(struct FViewTraceResult* Result, enum class ECollisionChannel TraceChannel, struct FViewTraceParams& ViewTraceParams);
	void ToggleThirdPerson();
	void SetUIVisibility(bool bHide, bool bHideDebug);
	void ServerUpdateCharacterTalents(bool bSkipDelay);
	void ServerUpdateCharacterProgression(bool bSkipDelay);
	void ServerUpdateAccountTalents(bool bSkipDelay);
	void ServerUpdateAccountFlags(bool bSkipDelay);
	void ServerSyncCharacterTalents();
	void ServerSyncCharacterProgression();
	void ServerSyncAccountTalents();
	void ServerSyncAccountFlags();
	void ServerSendChatMessage(const class FString& Message);
	void ServerFriendsListUpdated(TArray<class FString>& NewFriendIds);
	void Server_ToggleThirdPerson(bool bThirdPerson);
	void Server_BeginPlayerInitialisation(int32 ChrSlot);
	bool RetrieveViewTraceResults(class UObject* Registrant, TArray<struct FViewTraceResult>* OutFilteredResults);
	void RegisterForViewTraces(class UObject* Registrant, float MaxDistance);
	void PushUIInput(class UWidget* WidgetToFocus, bool bAllowGameInput, bool bShowMouse);
	struct FIcarusPlayerChatMessage ProcessChatMessage(class AIcarusPlayerState* FromPlayer, const class FString& Message);
	void PopUIInput();
	void OwningClientDisplayDynamicWidget(TSubclassOf<class UIcarusLinkedActorPanelBase> WidgetClass, class AActor* LinkedActorForWidget);
	void OutputProgressState(float Duration);
	void OpenBagWidgetUI(struct FItemData& SourceItem);
	void OnServerUpdateCharacterTalents(bool bSuccess, TArray<struct FBackendTalent>& BackendTalents);
	void OnServerUpdateCharacterProgression(bool bSuccess);
	void OnServerUpdateAccountTalents(bool bSuccess, TArray<struct FBackendTalent>& BackendTalents);
	void OnServerUpdateAccountFLags(bool bSuccess, TArray<int32>& Flags);
	void OnServerInitialise_GetPlayerUserProfileResult(bool bSuccess, struct FOnlineProfileUser& InUserProfile);
	void OnServerInitialise_GetPlayerCharacterProfileResult(bool bSuccess, struct FOnlineProfileCharacter& InCharacterProfile);
	void OnServer_PlayerDeath();
	void OnRep_IcarusPlayerCharacter();
	bool OnPlayerDeath();
	void OnPawnLeavingGame();
	void OnGetFriendsListSuccess(TArray<struct FBPFriendInfo>& Results);
	void OnGetFriendsListFailure(TArray<struct FBPFriendInfo>& Results);
	void OnConnectedPlayerInitialised();
	void NotifyOfCheater(const class FString& CharacterName);
	bool IsThirdPersonToggleDisabled();
	bool IsSyncingUpdateCharacterTalents();
	bool IsSyncingUpdateCharacterProgression();
	bool IsSyncingUpdateAccountTalents();
	bool IsSyncingUpdateAccountFlags();
	bool IsAiming();
	void InitialiseLocalSelectedPlayerProfile();
	void HandleLivingItemChallengeProgressUpdated(struct FItemData& ItemData, int32 ProgressAmount);
	void HandleLivingItemChallengeCompleted(struct FItemData& ItemData);
	void GetViewTraceStartEndPoints(float TraceDistance, struct FVector* OutStart, struct FVector* OutEnd);
	class UUserInterfaceBase* GetUserInterfaceInternal();
	struct FRotator GetRotationInput();
	class UPlayerDataComponent* GetPlayerDataComponent();
	struct FPlayerCharacterID GetPlayerCharacterID();
	class UNetworkProxyComponent* GetNetworkProxyComponent();
	bool GetIsThirdPerson();
	class AIcarusPlayerState* GetIcarusPlayerState();
	class AIcarusPlayerCharacter* GetIcarusPlayerCharacter();
	enum class EViewTraceResultPriority GetGenericViewTraceResultPriority(struct FViewTraceResult& Result, bool bResultIsRelevant, bool bMeleeAttackTrace);
	class UCheatOverlayBase* GetCheatOverlay(class UObject* WorldContextObject);
	class UBestiaryManagerComponent* GetBestiaryManagerComponent();
	class UBackendProxyComponent* GetBackendProxyComponent();
	struct FTransform GetAudioListenerTransform();
	bool FindBestViewTraceResult(class UObject* Registrant, FDelegateProperty_& ResultPriorityCallback, struct FViewTraceResult* OutBestResult, float DebugDrawDuration);
	void FinaliseConnectedPlayerInitialisation(struct FConnectedPlayer& ConnectedPlayer);
	bool External_CanPerformInputAction(bool bBlockedByUI, bool bIgnoreAnimLock);
	class UIcarusLinkedActorPanelBase* DisplayDynamicWidget(TSubclassOf<class UIcarusLinkedActorPanelBase> WidgetClass, class AActor* LinkedActorForWidget);
	class AContextMenuFactory* CreateContextMenu();
	void ClientReceiveServerMessage(const class FString& Message);
	void ClientReceiveChatMessage(class AIcarusPlayerState* FromPlayer, const class FString& Message);
	void ClientQueryForFriendsList();
	void ClientOpenBagWidget(class UInventory* SourceInventory, int32 SlotIndex);
	void ClientNotifyLivingItemChallengeProgressUpdated(struct FItemData& ItemData, int32 ProgressAmount);
	void ClientNotifyLivingItemChallengeCompleted(struct FItemData& ItemData);
	void ClientNotifyBecomeAdmin();
	void ClientConnectedPlayerInitialiseComplete(const struct FErrorCodesEnum& FailureError);
	void Client_TryCompleteOneOffAccolade(const struct FAccoladesRowHandle& Accolade);
	void Client_SetPlayerTracker(const struct FPlayerTrackersRowHandle& PlayerTracker, int32 NewAmount);
	void Client_IncrementPlayerTracker(const struct FPlayerTrackersRowHandle& PlayerTracker, int32 AmountToAdd);
	void Client_CheckOffPlayerTrackerTask(const struct FAccoladesRowHandle& Accolade, const struct FRowHandle& TaskRow);
	void Client_CheckEntireTalentTreeUnlockedTrackerTask(const struct FAccoladesRowHandle& Accolade);
	void ClearUIInput();
	void Cheat(const class FString& InputString);
	void ChatMessageHook(const class FString& InputString);
	void CaptureViewTraceResults(float DeltaTime);
	void BP_ClientReceiveServerMessage(const class FString& Message);
	void BP_ClientReceiveChatMessage(class AIcarusPlayerState* FromPlayer, const class FString& Message);
	void Bookmark(const class FString& InputString);
	void AddLocalMessage(const class FString& Message);
	void AddForcedYawInput(float Val);
	void AddForcedPitchInput(float Val);
};

// 0x60 (0x7F0 - 0x790)
// Class Icarus.IcarusPlayerControllerServer
class AIcarusPlayerControllerServer : public AIcarusPlayerController
{
public:
	uint8                                        Pad_80AF[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnServerProspectListChanged;                       // 0x798(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPrepareProspect;                                 // 0x7A8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLaunchPermissionChanged;                         // 0x7B8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDeletePermissionChanged;                         // 0x7C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            RequestProspectListCallback;                       // 0x7D8(0x10)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_80B0[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bHasLaunchPermission;                              // 0x7EA(0x1)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bHasDeletePermission;                              // 0x7EB(0x1)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_80B1[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPlayerControllerServer* GetDefaultObj();

	void ServerRequestDeleteProspect(const struct FProspectInfo& ProspectInfo);
	void ServerRequestAvailableProspects();
	void ServerLoadProspect(const struct FProspectInfo& Prospect);
	void ServerConfirmLoadoutReady(bool bHasLoadout);
	void ServerClaimAndLaunchProspect(const struct FProspectInfo& Prospect);
	void RequestServerAvailableProspects(FDelegateProperty_ ProspectListCallback);
	void NotifyLaunchPermissionChanged();
	void NotifyDeletePermissionChanged();
	void InitMetaInventory();
	bool HasProspectLaunchPermission();
	bool HasProspectDeletePermission();
	void ClientReceiveServerAvailableProspects(TArray<struct FProspectInfo>& Prospects);
	void ClientProspectListUpdated();
	void ClientPrepareProspect(const struct FProspectInfo& Prospect, bool bIsResuming);
	void ClaimAndLaunchProspect(const struct FProspectInfo& Prospect);
};

// 0x28 (0x7B8 - 0x790)
// Class Icarus.IcarusPlayerControllerSpace
class AIcarusPlayerControllerSpace : public AIcarusPlayerController
{
public:
	struct FVector                               CustomUp;                                          // 0x790(0xC)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CustomUpSlerp;                                     // 0x79C(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CustomUpPitchMax;                                  // 0x7A0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CustomUpPitchMin;                                  // 0x7A4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SessionInfoUpdated;                                // 0x7A8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusPlayerControllerSpace* GetDefaultObj();

	void SyncInventorySlot(class UInventory* Inventory, const class FString& DatabaseGUID, struct FMetaItem& MetaItem);
	void SyncInventory(class UInventory* Inventory, TArray<struct FMetaItem>* MetaItems);
	void ReturnToCharacterSelect();
	void OnAvailableSessionsUpdated();
	void OnActiveCharacterSet();
	void MetaInventoryUpdatedEventHandler();
	void MetaInventorySlotUpdatedEventHandler(const class FString& DatabaseGUID, struct FMetaItem& MetaItem);
	void LoadoutInventoryUpdatedEventHandler();
	void LoadoutInventorySlotUpdatedEventHandler(const class FString& DatabaseGUID, struct FMetaItem& MetaItem);
	void InitMetaInventory();
	bool FindLoadoutScreenQuickMoveTarget(class UInventory* SourceInventory, int32 SourceSlot, class UInventory** DestinationInventory, int32* DestinationSlot, int32* AmountCanMove);
	void AcceptSessionInvite(const struct FIcarusSession& SessionToJoin);
};

// 0x1C8 (0x958 - 0x790)
// Class Icarus.IcarusPlayerControllerSurvival
class AIcarusPlayerControllerSurvival : public AIcarusPlayerController
{
public:
	TArray<struct FItemPriority>                 ItemPriorities;                                    // 0x790(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemBounced;                                     // 0x7A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<struct FInventoryIDEnum>                AccessibleInventoriesBlacklist;                    // 0x7B0(0x50)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLivingItemChallengeUpdated;                      // 0x800(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLivingItemChallengeCompleted;                    // 0x810(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UProspectAudioComponent*               ProspectAudio;                                     // 0x820(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScopedViewportBlocker*                InitialisationViewportBlocker;                     // 0x828(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bServerHasCharacterLoadout;                        // 0x830(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bServerHasCharacterBestiary;                       // 0x831(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80BF[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FOnlineProfileCharacter               TestProspectCharacter;                             // 0x838(0xA0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_            OnLeaveProspectSessionComplete;                    // 0x8D8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	enum class ELeaveProspectSessionType         ServerPendingLeaveProspectSession;                 // 0x8D9(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bServerCancelPendingLeaveProspectSession;          // 0x8DA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ELeaveProspectSessionType         ReplicatedLeftProspectSession;                     // 0x8DB(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bServerReturnToHabComplete;                        // 0x8DC(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80C0[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UScopedViewportBlocker*                LeaveProspectViewportBlocker;                      // 0x8E0(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80C1[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusRocketSpawnBase*                AssignedDropshipSpawn;                             // 0x8F0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusRocket*                         AssignedDropship;                                  // 0x8F8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGravestoneBase*                       AssignedGravestone;                                // 0x900(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerRecorderComponent*              Recorder;                                          // 0x908(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                  ForceRemovePlayerDebugCommandText;                 // 0x910(0x18)(Edit, NativeAccessSpecifierPublic)
	class UResetCharacterProspectStateCallbackProxyGen* ResetCharacterProspectStateCallback;               // 0x928(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	enum class EForceRemovePlayerReason          ForceRemovePlayerReason;                           // 0x930(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bClientWasKicked;                                  // 0x931(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_80C2[0x16];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bDebugCameraLocationChanges;                       // 0x948(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPlayerBestiaryProgressed;                        // 0x949(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPlayerBestiaryUnlocked;                          // 0x94A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPlayerFishUnlocked;                              // 0x94B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80C3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class URemoteUserSettings*                   RemoteUserSettings;                                // 0x950(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AIcarusPlayerControllerSurvival* GetDefaultObj();

	void TriggerLoadShip(class AIcarusRocket* Rocket);
	void ShowDelayedLeavingPrompt(struct FConfirmationPopupDetails& ConfirmationPopupDetails);
	bool ShouldRotateCameraOnDeployableInteract();
	void SetAssignedGravestone(class AGravestoneBase* Gravestone);
	void SetAssignedDropship(class AIcarusRocket* Dropship);
	void ServerUpdateCharacterProspectLocation(bool bSkipDelay);
	void ServerTryCompleteLeaveProspectSession();
	void ServerSyncCharacterProspectLocation();
	void ServerPushClientDynamicWidget(TSubclassOf<class UIcarusLinkedActorPanelBase> WidgetClass, class AActor* LinkedActor, bool bFocusCameraOnActor);
	void ServerLeftByDropship();
	void ServerLeaveProspectSessionWithoutSave();
	void ServerLeaveProspectSession(enum class ELeaveProspectSessionType LeaveProspectSessionType);
	void ServerFinaliseLeaveProspectSession(enum class ELeaveProspectSessionType LeaveProspectSessionType);
	void ServerCancelLeaveProspectSession();
	void ServerAttemptRevive(class AGravestoneBase* Gravestone);
	void Server_Unstuck();
	void Server_CorpseUnstuck();
	void PostTrackerInit();
	void PlayProspectMissionIntroDialogue();
	void OnServerUpdateCharacterProspectLocation(bool bSuccess);
	void OnServerInitialise_IcarusBeginPlay();
	void OnServerInitialise_GetPlayerBestiary();
	void OnServerInitialise_GetCharacterLoadout(struct FPlayerLoadoutData& Loadout);
	void OnRep_ReplicatedLeftProspectSession();
	void OnProspectLocationChanged(enum class EProspectLocation ProspectLocation);
	void OnLeaveProspectSessionStatisticsUpdated(bool bSuccess);
	void OnLeaveProspectSessionCompleteImpl();
	void OnLeaveProspectSessionBackToHab(bool bSuccess, class APlayerController* Controller);
	void NotifyQuestCompleted(class AQuest* Quest, struct FFactionMissionsRowHandle& MissionRowHandle, bool bIsCurrentQuest, TArray<struct FMetaResource>& ReceivedResources);
	void NotifyItemBounced(struct FItemData& Item);
	void NotifyFishUnlock(struct FFishTypeTracking& Tracking, enum class EFishUnlockPopup& PopType);
	void NotifyExoticsBanked(int32 Amount, const struct FMetaCurrencyRowHandle& Type);
	void NotifyDynamicQuestCompleted(int32 NumCredits, int32 NumExperience);
	void NotifyBestiaryUnlock(struct FBestiaryDataRowHandle& Group, enum class EBestiaryUnlockPopup PopType);
	void NotifyBestiaryProgress(struct FBestiaryDataRowHandle& Group, int32 NowPoints, int32 MaxPoints);
	void MapTravelBackToHab();
	bool IsTryingToUnstuck();
	bool IsSyncingUpdateCharacterProspectLocation();
	bool HasLeftProspectSession();
	class UIcarusCriticalHitComponent* GetCriticalHitComponent();
	TArray<class UInventory*> GetAllInventories(bool bIncludeInaccessible);
	void GatherMetaItems(TArray<struct FItemData>* OutMetaItems, TArray<struct FMetaResource>* OutMetaResources);
	void ForceRemoveFromProspectResetCallbackSuccess(struct FResResetCharacterProspectState& Response);
	void ForceRemoveFromProspectResetCallbackFailure(struct FResResetCharacterProspectState& Response);
	void ForceRemoveFromProspect(enum class EForceRemovePlayerReason ForceRemovePlayerReason);
	void EmptyInventories();
	void DelayedShowSavingDialog();
	void ClientOpenContainer(class UInventory* Inventory, bool bShowStoreAll, bool bShowTakeAll);
	void ClientHandleProspectExpired(struct FProspectInfo& Prospect);
	void Client_NotifyQuestCompleted(class AQuest* Quest, struct FFactionMissionsRowHandle& MissionsRowHandle, bool bIsCurrentQuest, TArray<struct FMetaResource>& ReceivedResources);
	void Client_NotifyExoticsBanked(int32 Amount, const struct FMetaCurrencyRowHandle& Type);
	void Client_NotifyDynamicQuestCompleted(int32 NumCredits, int32 NumExperience);
	void CalculateQuickItemMove(class UInventory* Inventory, int32 Slot);
	void BP_ServerCorpseUnstuck_Implementation();
	void BP_ServerAttemptRevive_Implementation(class AGravestoneBase* Gravestone);
	void BP_Server_Unstuck_Implementation();
	void BP_ClientOpenContainer(class UInventory* Inventory, bool bShowStoreAll, bool bShowTakeAll);
	void ActivateHotbarSlot(int32 NewSelection, bool bForce, bool bQuickCraft, bool bDelayedActivate);
};

// 0xA8 (0x450 - 0x3A8)
// Class Icarus.IcarusPlayerInput
class UIcarusPlayerInput : public UPlayerInput
{
public:
	TMap<struct FKeybindContextsRowHandle, struct FPerInputUserBindings> SavedBindings;                                     // 0x3A8(0x50)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_80C4[0x58];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusPlayerInput* GetDefaultObj();

};

// 0x150 (0xC40 - 0xAF0)
// Class Icarus.IcarusPlayerMovementComponent
class UIcarusPlayerMovementComponent : public UCharacterMovementComponent
{
public:
	bool                                         bSwimming;                                         // 0xAF0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80C5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        FluidFriction;                                     // 0xAF4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                          LadderExitMontage;                                 // 0xAF8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LadderExitTolerance;                               // 0xB00(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LadderAngleOffset;                                 // 0xB04(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bMaxOutLadderVelocity;                             // 0xB08(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80C6[0x17];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FTransform                            LadderStart;                                       // 0xB20(0x30)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                            LadderEnd;                                         // 0xB50(0x30)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                        CurrentWaterDepth;                                 // 0xB80(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        TimeSpentSliding;                                  // 0xB84(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsSliding;                                        // 0xB88(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80C7[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FHitResult                            LastSlideHit;                                      // 0xB8C(0x88)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                        SlidingDurationThreshold;                          // 0xC14(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnCharacterSlidingUpdated;                         // 0xC18(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_80C8[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bCanEverSprint;                                    // 0xC2C(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        bWantsToSprint : 1;                                // Mask: 0x1, PropSize: 0x10xC2D(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        bWantsToAim : 1;                                   // Mask: 0x2, PropSize: 0x10xC2D(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        bWantsToReloadWeapon : 1;                          // Mask: 0x4, PropSize: 0x10xC2D(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        BitPad_1E6 : 5;                                    // Fixing Bit-Field Size  [ Dumper-7 ]
	uint8                                        Pad_80C9[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        BackwardsMovementSpeedMultiplier;                  // 0xC34(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80CA[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusPlayerMovementComponent* GetDefaultObj();

	void UpdateWaterDepth();
	void SetIsSliding(bool IsSliding);
	bool IsSprinting();
	bool IsReloadingWeapon();
	bool IsClimbingLadder();
	bool IsAiming();
	struct FVector GetNormalizedLadderInput();
	float GetLadderPosition();
	float GetCurrentWaterDepth();
	void ExitWater();
	void ExitLadder();
	void EnterWater();
	void EnterLadder(class ULadderComponent* Ladder);
};

// 0x168 (0x488 - 0x320)
// Class Icarus.IcarusPlayerState
class AIcarusPlayerState : public APlayerState
{
public:
	FMulticastSparseDelegateProperty_            OnCharacterFlagsChanged;                           // 0x320(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAccountFlagsChanged;                             // 0x321(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80CE[0x16];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FOnlineProfileUser                    ActiveUserProfile;                                 // 0x338(0x48)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FOnlineProfileCharacter               ActiveCharacter;                                   // 0x380(0xA0)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UPlayerCharacterState*                 ActivePlayerCharacterState;                        // 0x420(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerCharacterID                    PlayerCharacterID;                                 // 0x428(0x18)(Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsHost;                                           // 0x440(0x1)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80CF[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class ACheatController*                      CheatController;                                   // 0x448(0x8)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnCharacterTalentsChanged;                         // 0x450(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnAccountTalentsChanged;                           // 0x451(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80D0[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UPlayerTalentControllerComponent*      PlayerTalentController;                            // 0x458(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlueprintTalentControllerComponent*   BlueprintTalentController;                         // 0x460(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorkshopTalentControllerComponent*    WorkshopTalentController;                          // 0x468(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProspectTalentControllerComponent*    ProspectTalentController;                          // 0x470(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOutpostTalentControllerComponent*     OutpostTalentControllerComponent;                  // 0x478(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoloTalentControllerComponent*        SoloTalentControllerComponent;                     // 0x480(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AIcarusPlayerState* GetDefaultObj();

	void SetCharacterFlags(TMap<struct FCharacterFlagsRowHandle, bool>& FlagMap);
	void SetCharacterFlag(struct FCharacterFlagsRowHandle& Flag, bool State);
	void SetActiveUserProfile(struct FOnlineProfileUser& InProfileUser);
	void SetActiveCharacter(struct FOnlineProfileCharacter& InActiveCharacter);
	void SetAccountFlags(TMap<struct FAccountFlagsRowHandle, bool>& FlagMap);
	void SetAccountFlag(struct FAccountFlagsRowHandle& Flag, bool State);
	void ServerSyncCharacterTalent(struct FTalentsRowHandle& Talent, struct FTalentModelData& TalentData);
	void ServerSyncAccountTalent(struct FTalentsRowHandle& Talent, struct FTalentModelData& TalentData);
	void ServerSetUnlockedAccountTalents(TArray<struct FBackendTalent>& BackendTalents);
	void OnUnlockedCharacterTalent(class UTalentModelInterface_Const* Model, struct FTalentsRowHandle& Talent, struct FTalentModelData& TalentData);
	void OnUnlockedAccountTalent(class UTalentModelInterface_Const* Model, struct FTalentsRowHandle& Talent, struct FTalentModelData& TalentData);
	void OnTalentControllerModelViewChanged(class UTalentControllerComponent* Controller);
	void OnRep_ActiveUserProfile(struct FOnlineProfileUser& PreviousUserProfile);
	void OnRep_ActiveCharacter(struct FOnlineProfileCharacter& PreviousCharacter);
	void OnActiveCharacterExperienceDebtChanged();
	void OnActiveCharacterExperienceChanged();
	void OnActiveCharacterAliveStateChanged(class UActorState* ActorState);
	bool HaveTalentControllersBeenSetup();
	bool HasValidUserID();
	bool HasValidPlayerCharacterID();
	bool HasCharacterFlag(struct FCharacterFlagsRowHandle& Flag);
	bool HasActiveUserProfile();
	bool HasActiveCharacter();
	class FString GetUserID();
	TArray<class UTalentControllerComponent*> GetTalentControllers();
	class UTalentControllerComponent* GetTalentControllerForTalent(struct FTalentsRowHandle& Talent);
	int32 GetPlayerVisualIdentity();
	struct FPlayerCharacterID GetPlayerCharacterID();
	struct FOnlineProfileUser GetActiveUserProfile();
	class UPlayerCharacterState* GetActivePlayerCharacterState();
	struct FOnlineProfileCharacter GetActiveCharacter();
};

// 0x158 (0x610 - 0x4B8)
// Class Icarus.IcarusPreviewCharacter
class AIcarusPreviewCharacter : public ACharacter
{
public:
	uint8                                        Pad_80D5[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UInventoryComponent*                   InventoryComponent;                                // 0x4C8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            EnvirosuitInventory;                               // 0x4D0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            BackpackInventory;                                 // 0x4D8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            QuickbarInventory;                                 // 0x4E0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                            EquipmentInventory;                                // 0x4E8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>        ArmourComponents;                                  // 0x4F0(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                         IsMale;                                            // 0x500(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80D6[0x10F];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusPreviewCharacter* GetDefaultObj();

	bool UpdateEquipmentForSlot(int32 SlotNum, struct FArmourData& Data);
	void UpdateAllEquipment();
	void SetupCharacterCosmetics();
	void OnEquipmentInventoryUpdated(class UInventory* Inventory, int32 UpdatedSlot);
	class USkeletalMeshComponent* FindOrCreateEquipmentComponent(int32 ForSlot, struct FArmourData& WithData);
};

// 0x50 (0x220 - 0x1D0)
// Class Icarus.IcarusProjectileComponent
class UIcarusProjectileComponent : public UProjectileMovementComponent
{
public:
	struct FRotator                              VelocityRotationOffset;                            // 0x1D0(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                              AngularRotation;                                   // 0x1DC(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                  HomingTargetBoneName;                              // 0x1E8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bDisableHomingOncePassedTarget;                    // 0x1F0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPreventHomingAccelerationBeforeApex;              // 0x1F1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bScaleHomingMagnitudeByDistanceToTarget;           // 0x1F2(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80D7[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UCurveFloat*                           HomingScaleCurve;                                  // 0x1F8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                           HomingGravityScale;                                // 0x200(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        HomingNegativeZAccelerationMultiplier;             // 0x208(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80D8[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusProjectileComponent* GetDefaultObj();

	bool HasReachedApex();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusQuestFunctionLibrary
class UIcarusQuestFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusQuestFunctionLibrary* GetDefaultObj();

	bool IsSpecificItem(class AIcarusActor* Actor, const struct FItemsStaticRowHandle& ItemStatic);
	TArray<class AQuestMarker*> GetQuestMarkersFromTags(class UObject* WorldContextObject, const TArray<struct FQuestQueriesRowHandle>& TagQueriesRowHandles);
	TArray<class AQuestMarker*> GetQuestMarkers(class UObject* WorldContextObject, const struct FQuestQueriesRowHandle& QuestQueriesRowHandle);
	class AQuestMarker* GetQuestMarkerFromTags(class AActor* StartingLocation, const TArray<struct FQuestQueriesRowHandle>& TagQueriesRowHandles);
	class AQuestMarker* GetQuestMarker(class AActor* StartingLocation, const struct FQuestQueriesRowHandle& TagQueriesRowHandle);
	TArray<class AIcarusPlayerCharacter*> GetNearbyPlayersAtLocation(class UObject* WorldContextObject, struct FVector& Location, float MaxDistance, bool bIgnoreZ);
	int32 GetCurrentPlayerCount(class UObject* WorldContextObject);
	bool DistanceCheckFromLocation(class AActor* Actor, struct FVector& Location, float Distance);
};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.IcarusQuestManagerRecorderComponent
class UIcarusQuestManagerRecorderComponent : public UActorStateRecorderComponent
{
public:
	class FName                                  FactionMissionName;                                // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInitialQuestRecord                   InitialQuestRecord;                                // 0x1B0(0x18)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                         bMissionComplete;                                  // 0x1C8(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bRunQuests;                                        // 0x1C9(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80DD[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        DynamicQuestDifficulty;                            // 0x1CC(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        DynamicQuestDelay;                                 // 0x1D0(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  DynamicMissionProspectName;                        // 0x1D4(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80DE[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusQuestManagerRecorderComponent* GetDefaultObj();

};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.IcarusQuestRecorderComponent
class UIcarusQuestRecorderComponent : public UActorStateRecorderComponent
{
public:
	class FName                                  QuestName;                                         // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRelevantQuestActorRecord>     RelevantActorRecords;                              // 0x1B0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSubQuestRecord>               SubQuestRecords;                                   // 0x1C0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQuestVariableRecord>          VariableRecords;                                   // 0x1D0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UIcarusQuestRecorderComponent* GetDefaultObj();

};

// 0x148 (0x5F0 - 0x4A8)
// Class Icarus.IcarusReplicationGraph
class UIcarusReplicationGraph : public UReplicationGraph
{
public:
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x4A8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*       AlwaysRelevantNode;                                // 0x4B0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80E1[0x138];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusReplicationGraph* GetDefaultObj();

	void OnPlayerCharacterItemFocusedChanged(class AIcarusPlayerCharacter* PlayerCharacter, class AIcarusItem* Item, bool bRemoved);
	void OnFLODTileBehaviourHarnessChanged(class AFLODTile* Tile, bool bRemoved);
};

// 0x0 (0x330 - 0x330)
// Class Icarus.IcarusResetCharacterFromSession
class UIcarusResetCharacterFromSession : public UIcarusSessionBase
{
public:

	static class UClass* StaticClass();
	static class UIcarusResetCharacterFromSession* GetDefaultObj();

	class UIcarusResetCharacterFromSession* IcarusResetCharacterFromSession(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FOnlineProfileCharacter& OnlineProfileCharacter);
};

// 0x68 (0x398 - 0x330)
// Class Icarus.IcarusResumeSession
class UIcarusResumeSession : public UIcarusSessionBase
{
public:
	class UResumeProspectCallbackProxyGen*       ResumeProspectCallbackProxy;                       // 0x330(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<enum class EIcarusResumeConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups;                                // 0x338(0x50)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_80E3[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bAttemptHostMigration;                             // 0x390(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80E4[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bResumeCancelled;                                  // 0x392(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80E5[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusResumeSession* GetDefaultObj();

	void ResumeContinue();
	void ResumeCancel();
	void OnResumeProspectSuccess(struct FResResumeProspect& Result);
	void OnResumeProspectFailure(struct FResResumeProspect& Result);
	class UIcarusResumeSession* IcarusResumeSession(class UObject* WorldContextObject, struct FProspectInfo& ProspectInfo, class APlayerController* PlayerController, const struct FOnlineProfileCharacter& OnlineProfileCharacter, class UConfirmationPopupBase* InConfirmationPopup, TMap<enum class EIcarusResumeConfirmationStep, struct FConfirmationPopupDetails> ConfirmationSetups, bool bAttemptHostMigration);
};

// 0x58 (0x318 - 0x2C0)
// Class Icarus.IcarusRocket
class AIcarusRocket : public AIcarusActor
{
public:
	FMulticastSparseDelegateProperty_            RocketAssembled;                                   // 0x2C0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80E9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVector                               SpawnLocation;                                     // 0x2C4(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                               DescentOrigin;                                     // 0x2D0(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InitialPositionOffset;                             // 0x2DC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DropshipPositionsSet;                              // 0x2E0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         PlayerHasLeft;                                     // 0x2E1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bStoredLoadout;                                    // 0x2E2(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80EA[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPlayerCharacterID                    AssignedPlayerCharacterID;                         // 0x2E8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ERocketState                      RocketState;                                       // 0x300(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80EB[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AIcarusRocketPart*>             RocketParts;                                       // 0x308(0x10)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AIcarusRocket* GetDefaultObj();

	void TriggerLeaveProspectLaunch();
	void SetRocketState(enum class ERocketState InRocketState);
	bool RemovePart(class AIcarusRocketPart* PartToRemove);
	void OnRep_RocketState();
	void OnRep_AssignedPlayerCharacterID();
	void OnDropshipSpawnPlayerInit();
	void OnDatabaseReload();
	bool InstallPart(class AIcarusRocketPart* NewPart);
	bool GrantLoadoutToInventory(class UInventory* DestinationInventory);
	TArray<class AIcarusRocketPart*> GetParts();
	class AIcarusPlayerControllerSurvival* GetAssignedPlayer();
	void DefaultInstallPart(class AIcarusItem* NewPart);
	void DebugLogRocket(const class FString& Message);
	void AssignPlayer(struct FPlayerCharacterID& PlayerCharacterID);
};

// 0x20 (0x590 - 0x570)
// Class Icarus.IcarusRocketPart
class AIcarusRocketPart : public AIcarusItem
{
public:
	uint8                                        Pad_80ED[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        PartIdentifier;                                    // 0x580(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_80EE[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusRocketPart* GetDefaultObj();

	void SetPartIdentifier(int32 ID);
	void SetEditorInteractable(bool Interactable);
	void SetEditorHighlight(bool Highlight);
	bool IsConnected();
	int32 GetPartIdentifier();
	int32 GetConnectionCount();
	void GetClosestConnection(const struct FVector& HitLocation, class AIcarusRocketPartConnector** ClosestConnection);
	class FName GetChildSocketName(class AIcarusRocketPartConnector* Connector);
	void FindConnectableConnector(class AIcarusRocketPartConnector* OtherConnector, class AIcarusRocketPartConnector** Connector);
	void DestroyAllConnections();
};

// 0x20 (0x590 - 0x570)
// Class Icarus.IcarusRocketPartConnector
class AIcarusRocketPartConnector : public AIcarusItem
{
public:
	enum class ERocketPartConnectionType         ConnectionType;                                    // 0x570(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F1[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusRocketPartConnector*            AttachedConnector;                                 // 0x578(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ConnectionUpdated;                                 // 0x580(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F2[0xF];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusRocketPartConnector* GetDefaultObj();

	bool IsConnected();
	bool EstablishConnection(class AIcarusRocketPartConnector* OtherConnector);
	bool DestroyConnection();
	bool CanEstablishConnection(class AIcarusRocketPartConnector* OtherConnector);
};

// 0x8 (0x720 - 0x718)
// Class Icarus.IcarusShipEditorCharacter
class AIcarusShipEditorCharacter : public AIcarusCharacter
{
public:
	uint8                                        Pad_80F3[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusShipEditorCharacter* GetDefaultObj();

};

// 0x10 (0x280 - 0x270)
// Class Icarus.IcarusSmartNavLink
class AIcarusSmartNavLink : public ANavLinkProxy
{
public:
	enum class ENavigationType                   NavigationType;                                    // 0x270(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F5[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        NavigationDuration;                                // 0x274(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         AllowBasicTraversal;                               // 0x278(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F6[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusSmartNavLink* GetDefaultObj();

	void ReachedSmartLink(class AActor* Actor, struct FVector& Destination);
};

// 0x18 (0x238 - 0x220)
// Class Icarus.IcarusSpawn
class AIcarusSpawn : public AActor
{
public:
	class UCapsuleComponent*                     SpawnCapsule;                                      // 0x220(0x8)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_80F7[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusSpawn* GetDefaultObj();

	void ActorEndOverlaps(class AActor* FirstActor, class AActor* OtherActor);
	void ActorBeginOverlaps(class AActor* FirstActor, class AActor* OtherActor);
};

// 0x38 (0x2E0 - 0x2A8)
// Class Icarus.IcarusSpectatorPawn
class AIcarusSpectatorPawn : public ASpectatorPawn
{
public:
	float                                        InitialMaxSpeed;                                   // 0x2A8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InitialAcceleration;                               // 0x2AC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InitialDeceleration;                               // 0x2B0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bSmoothMouseInput;                                 // 0x2B4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F8[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        InputSmoothSpeed;                                  // 0x2B8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LookUpRate;                                        // 0x2BC(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TurnRate;                                          // 0x2C0(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bFreeLook;                                         // 0x2C4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_80F9[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRotator                              FreelookRotation;                                  // 0x2C8(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_80FA[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusSpectatorPawn* GetDefaultObj();

	void SetSpeedScale(float SpeedScale);
	void AddYaw(float Value);
	void AddPitch(float Value);
};

// 0x0 (0x4E0 - 0x4E0)
// Class Icarus.IcarusSplinePoint
class UIcarusSplinePoint : public UStaticMeshComponent
{
public:

	static class UClass* StaticClass();
	static class UIcarusSplinePoint* GetDefaultObj();

};

// 0x8 (0x200 - 0x1F8)
// Class Icarus.IcarusSplineSegment
class UIcarusSplineSegment : public USceneComponent
{
public:
	uint8                                        Pad_80FB[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusSplineSegment* GetDefaultObj();

};

// 0x228 (0x2D8 - 0xB0)
// Class Icarus.IcarusStatContainer
class UIcarusStatContainer : public UActorComponent
{
public:
	uint8                                        Pad_8102[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            OnStatContainerUpdated;                            // 0xB1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnStatContainerUpdateComplete;                     // 0xB2(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnPreStatContainerUpdateComplete;                  // 0xB3(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnStatContainerCategoryUpdated;                    // 0xB4(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8103[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FStatsRepArray                        ReplicatedStatArray;                               // 0xB8(0x118)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8104[0x108];                                   // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusStatContainer* GetDefaultObj();

	bool RemoveStats_BP(enum class EStatSources Source, int32 UID);
	void RemoveBackingStatContainer(class UIcarusStatContainer* BackingContainer, const class FString& Context);
	void OnServer_SerialiseStats();
	void OnRep_StatChanges();
	TMap<struct FStatsEnum, int32> GetStatsSlowBP(bool bIncludeVirtual);
	int32 GetStatByRowHandle(const struct FStatsRowHandle& StatRowHandle);
	int32 GetStat(const struct FStatsEnum& Stat);
	struct FStatContainer GetInternalContainer();
	bool AddStats_BP(enum class EStatSources Source, int32 UID, TMap<struct FStatsEnum, int32>& InStats);
	void AddBackingStatContainer(class UIcarusStatContainer* BackingContainer, const class FString& Context);
};

// 0x0 (0x4E0 - 0x4E0)
// Class Icarus.IcarusStaticMeshComponent
class UIcarusStaticMeshComponent : public UStaticMeshComponent
{
public:

	static class UClass* StaticClass();
	static class UIcarusStaticMeshComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusTameFunctionLibrary
class UIcarusTameFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusTameFunctionLibrary* GetDefaultObj();

	bool IsCharacterBeingTamed(class AIcarusNPCCharacter* Character);
	bool InitialiseTamableCharacter(class AIcarusNPCCharacter* Character, const struct FTamesRowHandle& TameData);
	void AbortTamingCharacter(class AIcarusNPCCharacter* Character);
};

// 0x58 (0x108 - 0xB0)
// Class Icarus.IcarusTamingComponent
class UIcarusTamingComponent : public UActorComponent
{
public:
	enum class ETamedState                       TamedState;                                        // 0xB0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8107[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TamingProgress;                                    // 0xB4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTamesRowHandle                       TamesRow;                                          // 0xB8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                CurrentLeader;                                     // 0xD0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCharacterID                    LastPlayerLeaderID;                                // 0xD8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIcarusNPCCharacter*                   OwnerNPC;                                          // 0xF0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8108[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusTamingComponent* GetDefaultObj();

	void UpdateTamingProgress(float DeltaTime);
	void UpdateTamingModifiers();
	void UpdateReplicatedVariables();
	void UpdateCreatureRelationship();
	void SetTamingProgress(float NewProgress);
	void SetTamedState(enum class ETamedState NewState);
	void SetPlayerLeaderID(const struct FPlayerCharacterID& LeaderID);
	void PerformPlayerOwnerStatConversion();
	void OnTamedStateUpdated(enum class ETamedState NewState);
	void OnRep_TamedState();
	void MarkConvertedStatsRequireUpdate();
	void InitialiseTamingComponent(const struct FTamesRowHandle& TamesRowHandle);
	float GetRemainingTamingTimeInSeconds();
	float GetPerSecondTamingProgressIncrease();
	bool DoesMeetTemperatureRequirement(enum class ETamingTemperatureState* TemperatureState);
	bool DoesMeetShelterRequirement();
	bool DoesMeetNutritionRequirement();
	bool DoesMeetModifierRequirement();
	bool CanTameCreature();
};

// 0x78 (0x2D8 - 0x260)
// Class Icarus.IcarusTemperatureBar
class UIcarusTemperatureBar : public UUserWidget
{
public:
	struct FLinearColor                          ColdColour;                                        // 0x260(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                          HotColour;                                         // 0x270(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                          NeutralColour;                                     // 0x280(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        BlendDegrees;                                      // 0x290(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SafeRegionMin;                                     // 0x294(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        SafeRegionMax;                                     // 0x298(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InternalMin;                                       // 0x29C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        InternalMax;                                       // 0x2A0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        Insulation;                                        // 0x2A4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        HeatInsulation;                                    // 0x2A8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ColdInsulation;                                    // 0x2AC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ExternalTemp;                                      // 0x2B0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CurrentTemp;                                       // 0x2B4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        PreviousTemp;                                      // 0x2B8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_810A[0x1C];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusTemperatureBar* GetDefaultObj();

	void UpdateTempIndicators(class UWidget* InternalTempIndicator, class UWidget* ExternalTempIndicator, float TemperatureBarWidth);
	void UpdateTemperatureColour(const struct FLinearColor& NewColour);
	void UpdatePercentageBars(class UProgressBar* ColdBar, class UProgressBar* HotBar, class UProgressBar* ColdInsulationBar, class UProgressBar* HotInsulationBar);
	struct FLinearColor GetCurrentTemperatureColour();
	void CheckAnimations();
};

// 0x98 (0x2D8 - 0x240)
// Class Icarus.IcarusTestRail
class AIcarusTestRail : public ACameraRig_Rail
{
public:
	FMulticastInlineDelegateProperty_            OnTestComplete;                                    // 0x240(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSetupComplete;                                   // 0x250(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	enum class ETestRailState                    CurrentState;                                      // 0x260(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_810B[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        TimeoutDuration;                                   // 0x264(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestProfileData                      ProfileData;                                       // 0x268(0x60)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class ACharacter*                            TestCharacter;                                     // 0x2C8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_810C[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusTestRail* GetDefaultObj();

	void TickTest(float DeltaTime);
	void TestComplete();
	void SetupTest(class ACharacter* InTestCharacter);
	void SetupComplete();
	void BeginTest();
};

// 0x0 (0x590 - 0x590)
// Class Icarus.IcarusTitlePlayerController
class AIcarusTitlePlayerController : public APlayerController
{
public:

	static class UClass* StaticClass();
	static class AIcarusTitlePlayerController* GetDefaultObj();

	void OnEndRetryJoinServer();
	void OnBeginRetryJoinServer(int32 JoinAttempt, int32 MaxAttempts);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusUIFunctionLibrary
class UIcarusUIFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UIcarusUIFunctionLibrary* GetDefaultObj();

	float LevenshteinFuzzyStringMatch(const class FString& SearchString, const class FString& TargetString);
	void HighlightTalents(class UTalentTreeWidget* TalentTree, const class FString& FilterQuery);
	bool GetMapIconsNeedingUpdate(TArray<class UIcarusMapIconComponent*>& CurrentMapIcons, TArray<class UIcarusCompassIcon*>& CurrentCompassIcons, TArray<class UIcarusMapIconComponent*>* NewComponents, TArray<class UIcarusCompassIcon*>* CompassIconsPendingCleanup);
	bool FilterSearchSignIcons(TArray<class USignIconListItem*>& AllIcons, const class FString& FilterQuery, TArray<class USignIconListItem*>* MatchingListItems, bool bUseFuzzySearch);
};

// 0x0 (0x220 - 0x220)
// Class Icarus.IcarusWaypointActor
class AIcarusWaypointActor : public AActor
{
public:

	static class UClass* StaticClass();
	static class AIcarusWaypointActor* GetDefaultObj();

	void InitForPlayer(class AIcarusPlayerState* OwningPlayerState);
	class AIcarusPlayerState* GetOwningPlayerState();
};

// 0x5D0 (0x680 - 0xB0)
// Class Icarus.IcarusWeatherAction
class UIcarusWeatherAction : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_            WeatherActionComplete;                             // 0xB0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8113[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FWeatherEventsRowHandle               ParentWeatherEvent;                                // 0xB4(0x18)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeatherActionsRowHandle              WeatherActionData;                                 // 0xCC(0x18)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8114[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FIcarusWeatherActionData              CachedActionData;                                  // 0xE8(0x570)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ActionRowUpdated;                                  // 0x658(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8115[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TotalLifeTime;                                     // 0x65C(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CurrentLifeTime;                                   // 0x660(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBiomesRowHandle                      BiomeAssigned;                                     // 0x664(0x18)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsRunning;                                        // 0x67C(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8116[0x3];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusWeatherAction* GetDefaultObj();

	void WeatherEventUpdated(struct FWeatherEventsRowHandle* Event);
	void WeatherActionVisualTick(float Delta, class AWeatherController* WeatherController);
	void WeatherActionTick(float Delta, class AWeatherController* WeatherController);
	void WeatherActionStarted(class AWeatherController* WeatherController);
	void WeatherActionEnded(class AWeatherController* WeatherController);
	void OnRep_WeatherActionData();
	void OnRep_ParentWeatherEvent();
	void Initialise(float ExpectedLifeTime, const struct FBiomesRowHandle& Biome, const struct FWeatherEventsRowHandle& ParentWeatherEvent, const struct FWeatherActionsRowHandle& ActionData);
	float GetStormTier();
	struct FBiomesRowHandle GetBiomeAssigned();
	void ActionTick_External(float Delta, class AWeatherController* WeatherController);
};

// 0x38 (0x298 - 0x260)
// Class Icarus.IcarusWidget
class UIcarusWidget : public UUserWidget
{
public:
	struct FFeatureLevelsRowHandle               RequiredFeatureLevel;                              // 0x260(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlagsMultiRowHandle                  RequiredFlag;                                      // 0x278(0x18)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bOverrideVisibilityIfFeatureLevelDisabled;         // 0x290(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ESlateVisibility                  FeatureLevelVisibilityOverride;                    // 0x291(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8119[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusWidget* GetDefaultObj();

	bool IsWidgetFocusable();
	enum class EFeatureLevelCheckResult IsFeatureLevelMet();
	void GetFocusWidget(bool* bValid, class UWidget** Widget, bool* bThis);
	void ForceSetEnabled(bool bInIsEnabled);
	void FocusUpdated(bool bNewFocus);
	void FocusIcarusWidget();
	void CheckMeetsFeatureLevelRequirements();
};

// 0x40 (0x3E0 - 0x3A0)
// Class Icarus.IcarusWorldSettings
class AIcarusWorldSettings : public AWorldSettings
{
public:
	TArray<struct FTransform>                    ExoticVoxelSpawnLocations;                         // 0x3A0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                    DeepMiningOreDepositSpawnLocations;                // 0x3B0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCaveLocation>                 CaveLocations;                                     // 0x3C0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPlayerTrackerListener*                PlayerTrackerListener;                             // 0x3D0(0x8)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_811A[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AIcarusWorldSettings* GetDefaultObj();

	void AddExoticVoxelSpawnLocation(struct FTransform& SpawnLocation);
	void AddDeepMiningOreDepositSpawnLocation(struct FTransform& SpawnLocation);
};

// 0x0 (0x38 - 0x38)
// Class Icarus.IcausAnimNotify_GOAPInteraction
class UIcausAnimNotify_GOAPInteraction : public UAnimNotify
{
public:

	static class UClass* StaticClass();
	static class UIcausAnimNotify_GOAPInteraction* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.IcarusDeployableRepairInterface
class IIcarusDeployableRepairInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IIcarusDeployableRepairInterface* GetDefaultObj();

	bool RepairHasShelter(class AIcarusPlayerCharacter* CraftingPlayer);
	bool CanRepairItem(struct FItemData& Item);
};

// 0x28 (0xE8 - 0xC0)
// Class Icarus.InteractableBehaviour
class UInteractableBehaviour : public UTraitBehaviour
{
public:
	enum class EInteractType                     InteractType;                                      // 0xC0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_811F[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        InteractIndex;                                     // 0xC4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  RequiredInteractTag;                               // 0xC8(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionsRowHandle                InteractionsRowHandle;                             // 0xD0(0x18)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UInteractableBehaviour* GetDefaultObj();

	void Interact(class AActor* Instigator, struct FHitResult& HitResult);
	class FText GetInteractionText();
	bool GetInteractData(struct FInteractData* OutData);
	class UInteractableComponent* GetInteractableComponent();
	bool CanInteract(class AActor* Instigator, const struct FHitResult& HitResult);
};

// 0x50 (0x138 - 0xE8)
// Class Icarus.InteractableComponent
class UInteractableComponent : public UTraitBehaviours
{
public:
	TMap<enum class EInteractType, struct FInteractStack> WorldInteracts;                                    // 0xE8(0x50)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UInteractableComponent* GetDefaultObj();

	void WorldInteract(class AActor* Instigator, struct FHitResult* HitResult);
	void WorldHeldInteract(class AActor* Instigator, struct FHitResult* HitResult);
	void WorldAltHeldInteract(class AActor* Instigator, struct FHitResult* HitResult);
	bool GetInteractData(const struct FInteractionsRowHandle& InteractionsRowHandle, struct FInteractData* OutData);
	bool GetInteractableData(struct FInteractableData* OutData);
	class UInteractableBehaviour* GetCurrentInteractForType(enum class EInteractType InteractType, class AActor* Instigator, const struct FHitResult& HitResult);
	bool CanInteract();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.InteractableLibrary
class UInteractableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInteractableLibrary* GetDefaultObj();

	struct FInteractableRowHandle StructToRowHandle(const struct FInteractableEnum& EnumValue);
	class FName StructToName(const struct FInteractableEnum& EnumValue);
	int32 StructToInt(const struct FInteractableEnum& EnumValue);
	struct FInteractableEnum RowHandleToStruct(const struct FInteractableRowHandle& RowHandle);
	void RemoveRowFromInteractableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInteractableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInteractableEnum& A, const struct FInteractableEnum& B);
	struct FInteractableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInteractableRowHandle MakeLiteralInteractable(const struct FInteractableRowHandle& RowHandle);
	struct FInteractableRowHandle MakeInteractableFromIndex(int32 Index);
	struct FInteractableEnum MakeInteractableEnum(const struct FInteractableEnum& Enum);
	struct FInteractableRowHandle MakeInteractable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInteractableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInteractableStruct(const struct FInteractableRowHandle& RowHandle, struct FInteractableData* Interactable, enum class EValid* Paths);
	bool EqualEqual_FInteractableRowHandleFInteractableRowHandle(const struct FInteractableRowHandle& RowHandleA, const struct FInteractableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInteractableEnum& A, const struct FInteractableEnum& B);
	struct FInteractableRowHandle CastToInteractableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInteractableEnum(const struct FInteractableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInteractableTable(class FName Name, const struct FInteractableData& Data, struct FInteractableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InteractableTable
class UInteractableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInteractableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.InteractionsLibrary
class UInteractionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInteractionsLibrary* GetDefaultObj();

	struct FInteractionsRowHandle StructToRowHandle(const struct FInteractionsEnum& EnumValue);
	class FName StructToName(const struct FInteractionsEnum& EnumValue);
	int32 StructToInt(const struct FInteractionsEnum& EnumValue);
	struct FInteractionsEnum RowHandleToStruct(const struct FInteractionsRowHandle& RowHandle);
	void RemoveRowFromInteractionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInteractionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInteractionsEnum& A, const struct FInteractionsEnum& B);
	struct FInteractionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInteractionsRowHandle MakeLiteralInteractions(const struct FInteractionsRowHandle& RowHandle);
	struct FInteractionsRowHandle MakeInteractionsFromIndex(int32 Index);
	struct FInteractionsEnum MakeInteractionsEnum(const struct FInteractionsEnum& Enum);
	struct FInteractionsRowHandle MakeInteractions(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInteractionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInteractionsStruct(const struct FInteractionsRowHandle& RowHandle, struct FInteractData* Interactions, enum class EValid* Paths);
	bool EqualEqual_FInteractionsRowHandleFInteractionsRowHandle(const struct FInteractionsRowHandle& RowHandleA, const struct FInteractionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInteractionsEnum& A, const struct FInteractionsEnum& B);
	struct FInteractionsRowHandle CastToInteractionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInteractionsEnum(const struct FInteractionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInteractionsTable(class FName Name, const struct FInteractData& Data, struct FInteractionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InteractionsTable
class UInteractionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInteractionsTable* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.InteractSubsystem
class UInteractSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnWaterSourceInteractNotify;                       // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UInteractSubsystem* GetDefaultObj();

	void BroadcastWaterSourceInteractDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* WaterSource);
};

// 0x300 (0x3C0 - 0xC0)
// Class Icarus.Inventory
class UInventory : public UTraitBehaviour
{
public:
	uint8                                        Pad_8163[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnInventoryItemChanged;                            // 0xC8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAllInventoryItemsChanged;                        // 0xD8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        CurrentWeight;                                     // 0xE8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8164[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FInventorySlotsFastArray              Slots;                                             // 0xF0(0x158)(Edit, BlueprintVisible, Net, DisableEditOnTemplate, EditConst, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_8165[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FTransform                            OverflowSpawnTransform;                            // 0x250(0x30)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bOverflowSpawnCanStack;                            // 0x280(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8166[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FItemData>                     InitialItems;                                      // 0x288(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnItemAdded;                                       // 0x298(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnItemRemoved;                                     // 0x299(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnItemRemovedVerbose;                              // 0x29A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            Client_OnItemsUpdated;                             // 0x29B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnWeightUpdated;                                   // 0x29C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SlotCountChange;                                   // 0x29D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            SlotsUpdated;                                      // 0x29E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnDroppingOverflowItem;                            // 0x29F(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnItemBroke;                                       // 0x2A0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8167[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FEquippableRowHandle, struct FEquippableModifierList> CurrentlyEquippedModifiers;                        // 0x2A8(0x50)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReplicatedStackMultipliersUpdated;               // 0x2F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<float>                                ReplicatedModifierStackMultipliers;                // 0x308(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	struct FInventoryInfoRowHandle               InventoryInfoRowHandle;                            // 0x318(0x18)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8168[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        SpoilTickRate;                                     // 0x338(0x4)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8169[0x64];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TWeakObjectPtr<class UInventory>             ParentInventory;                                   // 0x3A0(0x8)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_816A[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UInventory* GetDefaultObj();

	void TryRegisterHUDUpdates();
	bool TransferInventory(class UInventory* Other);
	TArray<struct FItemData> SortRestackInventory();
	void SortByWeight();
	void SortByTag();
	void SortByStackCount();
	void SortByAlphanumeric();
	void Sort(enum class EInventorySortType SortType);
	void SlottableSetup(TArray<struct FSlotWrapper>& SlotableSetup);
	bool SetItemDynamicProperty(int32 Location, enum class EDynamicItemProperties Property, int32 Value);
	bool SetItem(int32 Location, const struct FItemData& NewItem);
	void RemoveSlots(int32 SlotsToRemove);
	struct FItemData RemoveItem(int32 Location, int32 Amount, bool ClearItemSave);
	void RemoveEquippableModifier(class UEquippableModifier* Modifier);
	void OverrideQuery(int32 Index, struct FTagQueriesRowHandle* Query);
	void OnStatContainerUpdated();
	void OnRep_Slots();
	void OnRep_ReplicatedModifierStackMultipliers();
	void OnOwnedInventorySlotRemoved(struct FInventorySlot& Slot, int32 Index);
	void OnOwnedInventorySlotChanged(struct FInventorySlot& Slot, int32 Index);
	void OnOwnedInventorySlotAdded(struct FInventorySlot& Slot, int32 Index);
	void OnOwnedInventoryAllSlotsChanged();
	void OnContainerManagerUpdated();
	void MarkSlotIndexDirty(int32 SlotIndex, bool bSkipUpdates);
	void MarkSlotAsDirty(int32 Location);
	bool ManuallyPlaceItem(const struct FItemData& Item, int32 Location, bool AllowStacking);
	bool ManuallyForcePlaceItem(const struct FItemData& Item, int32 Location, bool AllowStacking);
	bool IsRemoveOnly();
	bool IsClientSideOnlyInventory();
	void InitialiseDefaultStats();
	bool HasValidItemInSlot(int32 Location);
	bool HasItems();
	int32 HasFillableResource(enum class EIcarusResourceType Type, int32 AmountRequired);
	TArray<struct FFindItemSlotInfo> GetItems(const struct FGameplayTagQuery& Query);
	struct FItemData GetItemRef(int32 Location, bool* bIsValid);
	int32 GetItemCount();
	struct FItemData GetItem(int32 Location);
	float GetInventorySpoilTickRate();
	float GetInventorySpoilTickAccumulator();
	struct FInventoryIDEnum GetInventoryID();
	bool GetInventoryData(struct FInventoryInfo* OutData);
	int32 GetFillableResourceCount(enum class EIcarusResourceType Type);
	void GetEquippableModifiers(TArray<class UEquippableModifier*>* EquippedModifiers);
	TArray<struct FItemData> GetAllItems();
	void ForceAddItems(TArray<struct FItemData>& Items, TArray<struct FItemData>* RemainingItems);
	bool FindValidItemPlacementLocation(const struct FItemData& Item, int32* ValidLocation, bool AllowStacking);
	int32 FindStaticStackTotal(const struct FItemsStaticRowHandle& ItemToFind, bool bIncludeBags);
	int32 FindStatic(const struct FItemsStaticRowHandle& ItemToFind, int32 Amount);
	int32 FindStackTotalWithMatchingData(struct FItemData& ItemData, bool bIncludeBags);
	int32 FindStackableLocation(const struct FItemData& Item);
	TArray<struct FFindItemSlotInfo> FindItemsWithTag(const struct FTagQueriesRowHandle& Query);
	TArray<struct FFindItemSlotInfo> FindItems(const struct FItemsStaticRowHandle& ItemStaticRow, int32 RequiredAmount);
	int32 FindFirstItem(const struct FGameplayTagQuery& Query);
	int32 FindEmptyLocation(const struct FItemData& Item);
	int32 FindContainerToFill(enum class EIcarusResourceType Type);
	TArray<struct FFindItemSlotInfo> FindContainers(enum class EIcarusResourceType ResourceType);
	TArray<struct FFindAllStacksResult> FindAllUniqueStacks(const struct FItemsStaticRowHandle& ItemStaticRow);
	int32 Find(const struct FItemData& ItemToFind, int32 Amount);
	void Empty();
	bool DoesInventorySupportEquippable(int32 SlotIndex);
	bool ConsumeItem(int32 Location, int32 Amount, bool ClearItemSave);
	bool ConsumeFillableResource(int32 Location, enum class EIcarusResourceType Type, int32 Units);
	void ClearLastItemInfo(int32 Location);
	bool CheckSlotValidity(const struct FItemData& Item, int32 Location);
	bool CheckPlacement(const struct FItemData& Item, int32 Location, bool AllowStacking, int32 Amount);
	bool CheckAutoPlacement(const struct FItemData& Item);
	bool CanTransferInventory(class UInventory* Other);
	bool CanStack(const struct FItemData& Item, int32 Location, int32 Amount);
	bool CanPlaceItems(const TArray<struct FItemData>& Items, bool AllowStacking);
	bool CanPlace(const struct FItemData& Item, int32 Location, bool AllowStacking, int32 Amount);
	bool CanInventorySpoil();
	bool CanAdd(const struct FItemData& Item, int32 Location);
	bool AutomaticallyPlaceItem(const struct FItemData& Item, int32* PlacedLocation, bool DropItemAtOverFlow, bool AllowStacking);
	int32 AttemptPartialStackPlacement(const struct FItemData& Item, int32 Count);
	void AddSlots(int32 SlotsToAdd, const struct FTagQueriesRowHandle& QueryOverride);
	void AddEquippableModifier(class UEquippableModifier* Modifier);
};

// 0xA8 (0x190 - 0xE8)
// Class Icarus.InventoryComponent
class UInventoryComponent : public UTraitBehaviours
{
public:
	TMap<struct FInventoryIDEnum, class UInventory*> Inventories;                                       // 0xE8(0x50)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FInventoryIDEnum, struct FManuallyAddedInventoryItems> ManuallyAddedItems;                                // 0x138(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInventoryItemAdded;                              // 0x188(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInventoryItemRemoved;                            // 0x189(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInventoryItemRemovedVerbose;                     // 0x18A(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnInventoryItemChanged;                            // 0x18B(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnBounceItem;                                      // 0x18C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bRequiresUpdate;                                   // 0x18D(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnWeightUpdated;                                   // 0x18E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8176[0x1];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UInventoryComponent* GetDefaultObj();

	void WeightUpdatedDelagate(int32 NewWeight);
	void UpdateInventorySlotCount(class UInventory* Inventory, int32 DesiredSlotCount);
	bool TransferInventories(class UInventoryComponent* Other);
	void StatsUpdated();
	void ItemRemovedVerboseDelagate(class UInventory* Inventory, int32 Slot, struct FItemData& ItemData);
	void ItemRemovedDelagate(class UInventory* Inventory, int32 Slot);
	void ItemChangedDelegate(class UInventory* Inventory, int32 Slot);
	void ItemAddedDelagate(class UInventory* Inventory, int32 Slot);
	int32 GetTotalWeight();
	bool GetInventoryInfoData(const struct FInventoryInfoRowHandle& InventoryInfoRowHandle, struct FInventoryInfo* OutData);
	TArray<struct FInventoryIDEnum> GetInventoryIds();
	bool GetInventoryData(struct FInventoryData* OutData);
	class UInventory* GetInventory(const struct FInventoryIDEnum& InventoryID);
	TArray<struct FFindItemSlotInfo> FindItemsWithTag(const struct FTagQueriesRowHandle& Query);
	int32 FindItemsTotal(const struct FItemsStaticRowHandle& ItemsStaticRowHandle, const TArray<struct FStatsEnum>& RequiredStats);
	TArray<struct FFindItemSlotInfo> FindItems(const struct FItemsStaticRowHandle& ItemsStaticRowHandle, int32 Count);
	TArray<struct FFindItemSlotInfo> FindContainers(enum class EIcarusResourceType ResourceType);
	TArray<struct FFindItemSlotInfo> FindAllItems(const struct FItemsStaticRowHandle& ItemsStaticRowHandle, const TArray<struct FStatsEnum>& RequiredStats);
	void DoInventoryUpdate();
	void CheckInventorySlotStats();
};

// 0x18 (0xE8 - 0xD0)
// Class Icarus.InventoryContainerComponent
class UInventoryContainerComponent : public UTraitComponent
{
public:
	FMulticastInlineDelegateProperty_            OnInventoryAvailable;                              // 0xD0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        InventoryInstanceId;                               // 0xE0(0x4)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8179[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UInventoryContainerComponent* GetDefaultObj();

	void OnInventoryManagerUpdated();
	void OnInventoryIdReplicated();
	bool HasLinkedInventory_Fast();
	bool GetInventoryContainerData(struct FInventoryContainerData* OutData);
	bool GetInventory(class UInventory** Inventory);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryContainerLibrary
class UInventoryContainerLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInventoryContainerLibrary* GetDefaultObj();

	struct FInventoryContainerRowHandle StructToRowHandle(const struct FInventoryContainerEnum& EnumValue);
	class FName StructToName(const struct FInventoryContainerEnum& EnumValue);
	int32 StructToInt(const struct FInventoryContainerEnum& EnumValue);
	struct FInventoryContainerEnum RowHandleToStruct(const struct FInventoryContainerRowHandle& RowHandle);
	void RemoveRowFromInventoryContainerTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInventoryContainerEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInventoryContainerEnum& A, const struct FInventoryContainerEnum& B);
	struct FInventoryContainerEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInventoryContainerRowHandle MakeLiteralInventoryContainer(const struct FInventoryContainerRowHandle& RowHandle);
	struct FInventoryContainerRowHandle MakeInventoryContainerFromIndex(int32 Index);
	struct FInventoryContainerEnum MakeInventoryContainerEnum(const struct FInventoryContainerEnum& Enum);
	struct FInventoryContainerRowHandle MakeInventoryContainer(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInventoryContainerEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInventoryContainerStruct(const struct FInventoryContainerRowHandle& RowHandle, struct FInventoryContainerData* InventoryContainer, enum class EValid* Paths);
	bool EqualEqual_FInventoryContainerRowHandleFInventoryContainerRowHandle(const struct FInventoryContainerRowHandle& RowHandleA, const struct FInventoryContainerRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInventoryContainerEnum& A, const struct FInventoryContainerEnum& B);
	struct FInventoryContainerRowHandle CastToInventoryContainerRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInventoryContainerEnum(const struct FInventoryContainerEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInventoryContainerTable(class FName Name, const struct FInventoryContainerData& Data, struct FInventoryContainerRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x20 (0x2E0 - 0x2C0)
// Class Icarus.InventoryContainerManager
class AInventoryContainerManager : public AIcarusActor
{
public:
	TArray<class UInventory*>                    Inventories;                                       // 0x2C0(0x10)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8186[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AInventoryContainerManager* GetDefaultObj();

	void OnInventoriesReplicated();
	class UInventory* GetInventory(int32 InventoryIndex);
	int32 AddInventory();
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InventoryContainerTable
class UInventoryContainerTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInventoryContainerTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryIDLibrary
class UInventoryIDLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInventoryIDLibrary* GetDefaultObj();

	struct FInventoryIDRowHandle StructToRowHandle(const struct FInventoryIDEnum& EnumValue);
	class FName StructToName(const struct FInventoryIDEnum& EnumValue);
	int32 StructToInt(const struct FInventoryIDEnum& EnumValue);
	struct FInventoryIDEnum RowHandleToStruct(const struct FInventoryIDRowHandle& RowHandle);
	void RemoveRowFromInventoryIDTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInventoryIDEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInventoryIDEnum& A, const struct FInventoryIDEnum& B);
	struct FInventoryIDEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInventoryIDRowHandle MakeLiteralInventoryID(const struct FInventoryIDRowHandle& RowHandle);
	struct FInventoryIDRowHandle MakeInventoryIDFromIndex(int32 Index);
	struct FInventoryIDEnum MakeInventoryIDEnum(const struct FInventoryIDEnum& Enum);
	struct FInventoryIDRowHandle MakeInventoryID(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInventoryIDEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInventoryIDStruct(const struct FInventoryIDRowHandle& RowHandle, struct FInventoryID* InventoryID, enum class EValid* Paths);
	bool EqualEqual_FInventoryIDRowHandleFInventoryIDRowHandle(const struct FInventoryIDRowHandle& RowHandleA, const struct FInventoryIDRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInventoryIDEnum& A, const struct FInventoryIDEnum& B);
	struct FInventoryIDRowHandle CastToInventoryIDRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInventoryIDEnum(const struct FInventoryIDEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInventoryIDTable(class FName Name, const struct FInventoryID& Data, struct FInventoryIDRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InventoryIDTable
class UInventoryIDTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInventoryIDTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryInfoLibrary
class UInventoryInfoLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInventoryInfoLibrary* GetDefaultObj();

	struct FInventoryInfoRowHandle StructToRowHandle(const struct FInventoryInfoEnum& EnumValue);
	class FName StructToName(const struct FInventoryInfoEnum& EnumValue);
	int32 StructToInt(const struct FInventoryInfoEnum& EnumValue);
	struct FInventoryInfoEnum RowHandleToStruct(const struct FInventoryInfoRowHandle& RowHandle);
	void RemoveRowFromInventoryInfoTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInventoryInfoEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInventoryInfoEnum& A, const struct FInventoryInfoEnum& B);
	struct FInventoryInfoEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInventoryInfoRowHandle MakeLiteralInventoryInfo(const struct FInventoryInfoRowHandle& RowHandle);
	struct FInventoryInfoRowHandle MakeInventoryInfoFromIndex(int32 Index);
	struct FInventoryInfoEnum MakeInventoryInfoEnum(const struct FInventoryInfoEnum& Enum);
	struct FInventoryInfoRowHandle MakeInventoryInfo(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInventoryInfoEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInventoryInfoStruct(const struct FInventoryInfoRowHandle& RowHandle, struct FInventoryInfo* InventoryInfo, enum class EValid* Paths);
	bool EqualEqual_FInventoryInfoRowHandleFInventoryInfoRowHandle(const struct FInventoryInfoRowHandle& RowHandleA, const struct FInventoryInfoRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInventoryInfoEnum& A, const struct FInventoryInfoEnum& B);
	struct FInventoryInfoRowHandle CastToInventoryInfoRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInventoryInfoEnum(const struct FInventoryInfoEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInventoryInfoTable(class FName Name, const struct FInventoryInfo& Data, struct FInventoryInfoRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InventoryInfoTable
class UInventoryInfoTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInventoryInfoTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryItemLibrary
class UInventoryItemLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UInventoryItemLibrary* GetDefaultObj();

	struct FItemData VerifyItem(const struct FItemData& ItemData, class UObject* WorldContextObject);
	void SplitInventoryItemStack(class UInventory* Inventory, int32 ItemLocation, class AIcarusPlayerCharacter* FromPlayer);
	void SetItemPropertyValue(enum class EDynamicItemProperties Property, int32 NewValue, struct FItemData& Item, enum class ESetDataSuccess* Paths);
	void ReplenishItemFillable(struct FItemData* Item);
	bool RemoveItemProperty(enum class EDynamicItemProperties Property, struct FItemData& Item);
	bool ItemMatchesQuery(struct FItemData& Item, const struct FTagQueriesRowHandle& Query);
	void ItemDataValid(struct FItemData& Item, enum class EDataValid* Paths);
	bool IsSameItem(struct FItemData& Item1, struct FItemData& Item2, class UObject* WorldContextObject);
	bool IsCustomItem(struct FItemData& Item, class UObject* WorldContextObject);
	bool HasSecondaryItemType(struct FItemData& Item, enum class ESecondaryItemTypes ItemType);
	bool HasPrimaryItemType(struct FItemData& Item, enum class EPrimaryItemTypes ItemType);
	void GetWeightData(struct FItemData& Item, struct FWeightData* WeightData, enum class EDataValid* Paths);
	void GetUsableData(struct FItemData& Item, struct FUsableData* UsableData, enum class EDataValid* Paths);
	void GetTurretData(struct FItemData& Item, struct FTurretData* Turret, enum class EDataValid* Paths);
	void GetTransmutableData(struct FItemData& Item, struct FTransmutableData* Transmutable, enum class EDataValid* Paths);
	void GetToolDamage(struct FItemData& Item, struct FToolDamage* ToolDamageData, enum class EDataValid* Paths);
	void GetStaticItemData(struct FItemData& Item, struct FItemStaticData* StaticData, enum class EDataValid* Paths);
	int32 GetStat(class UObject* WorldContextObject, struct FItemData& Item, const struct FStatsEnum& Stat);
	void GetSlotableData(struct FItemData& Item, struct FSlotableData* Slotable, enum class EDataValid* Paths);
	void GetRocketableData(struct FItemData& Item, struct FRocketableData* Rocketable, enum class EDataValid* Paths);
	struct FRefundResult GetRefundResult(struct FItemsStaticRowHandle& ItemType, int32 StackSize);
	void GetRecipesAndFiltersForRecipeSet(const struct FRecipeSetsRowHandle& RecipeSetRowHandle, TArray<struct FProcessorRecipeResult>* Recipes, TArray<struct FItemClassificationsIconsRowHandle>* ItemFilters);
	void GetRangedWeaponData(struct FItemData& Item, struct FRangedWeaponData* RangedWeaponData, enum class EDataValid* Paths);
	void GetProjectileDamage(class UObject* WorldContextObject, struct FItemData& Item, class AIcarusPlayerCharacter* Player, int32* ProjectileDamage);
	void GetProcessingData(struct FItemData& Item, struct FProcessingData* ProcessingData, enum class EDataValid* Paths);
	void GetOrCreateInventoryContainer(class UObject* WorldContextObject, struct FItemData& ItemData, class UInventory** Inventory, enum class EDataValid* Paths);
	int32 GetModifiedTransmutableUnits(const struct FItemData& ItemData, class UObject* WorldContextObject);
	void GetMeshableData(struct FItemData& Item, struct FMeshableData* MeshableData, enum class EDataValid* Paths);
	void GetLivingItemData(struct FItemData& Item, struct FLivingItemData* LivingItem, enum class EDataValid* Paths);
	int32 GetItemWeight(struct FItemData& ItemData, class AActor* ItemOwner);
	void GetItemTypes(struct FItemData& Item, TArray<enum class EPrimaryItemTypes>* PrimaryTypes, TArray<enum class ESecondaryItemTypes>* SecondaryTypes);
	struct FGameplayTagContainer GetItemTags(struct FItemData& Item);
	void GetItemStats(class UObject* WorldContextObject, struct FItemData& Item, TMap<struct FStatsEnum, int32>* Stats, bool GetVirtual);
	int32 GetItemStackCount(struct FItemData& ItemData);
	void GetItemPropertyValue(enum class EDynamicItemProperties Property, struct FItemData& Item, int32* IntValue, enum class EDataValid* Paths);
	void GetItemProperty(enum class EDynamicItemProperties Property, struct FItemData& Item, struct FItemDynamicData* DynamicData, enum class EDataValid* Paths);
	void GetItemPopupStats(class UObject* WorldContextObject, struct FItemData& Item, TMap<struct FStatsEnum, int32>* Stats);
	class FString GetItemID(struct FItemData& Item);
	void GetItemAttachmentData(struct FItemData& Item, struct FIcarusAttachment* Attachment, enum class EDataValid* Paths);
	void GetItemAttachmentActor(class AActor* Item, struct FItemData* Attachment, enum class EDataValid* Paths);
	void GetItemAttachment(class UObject* WorldContextObject, struct FItemData& ItemData, struct FItemData* Attachment, enum class EDataValid* Paths);
	void GetItemAlterations(class UObject* WorldContextObject, struct FItemData& Item, TArray<struct FAlterationsEnum>* Alterations);
	void GetItemableData(struct FItemData& Item, struct FItemableData* ItemableData, enum class EDataValid* Paths);
	void GetInventoryInfoData(struct FItemData& Item, TArray<struct FInventoryInfo>* InventoryInfos, enum class EDataValid* Paths);
	void GetInventoryData(struct FItemData& Item, struct FInventoryData* Inventory, enum class EDataValid* Paths);
	void GetInventoryContainerData(struct FItemData& Item, struct FInventoryContainerData* InventoryContainerData, enum class EDataValid* Paths);
	void GetInventoryContainerActor(class AActor* Item, class UInventory** Inventory, enum class EDataValid* Paths);
	void GetInventoryContainer(class UObject* WorldContextObject, struct FItemData& ItemData, class UInventory** Inventory, enum class EDataValid* Paths);
	void GetInteractableData(struct FItemData& Item, struct FInteractableData* IntectableData, enum class EDataValid* Paths);
	void GetHighlightableData(struct FItemData& Item, struct FHighlightableData* HighlightableData, enum class EDataValid* Paths);
	void GetHeldItemGrantedStats(class UObject* WorldContextObject, struct FItemData& Item, TMap<struct FStatsEnum, int32>* Stats);
	void GetFocusableData(struct FItemData& Item, struct FFocusableData* FocusableData, enum class EDataValid* Paths);
	void GetFocusableAttachmentData(struct FItemData& Item, struct FItemAttachmentData* AttachmentData, enum class EDataValid* Paths);
	void GetFocusableAnimationData(struct FItemData& Item, struct FItemAnimationData* AnimationData, enum class EDataValid* Paths);
	void GetFloatableData(struct FItemData& Item, struct FFloatableData* FloatableData, enum class EDataValid* Paths);
	void GetFirearmData(struct FItemData& Item, struct FFirearmData* FirearmData, enum class EDataValid* Paths);
	void GetFillableData(struct FItemData& Item, struct FFillableData* FillableData, enum class EDataValid* Paths);
	void GetFarmableData(struct FItemData& Item, struct FFarmableData* Farmable, enum class EDataValid* Paths);
	void GetEquippableData(struct FItemData& Item, struct FEquippableData* EquippableData, enum class EDataValid* Paths);
	void GetEnergyData(struct FItemData& Item, struct FEnergyData* EnergyData, enum class EDataValid* Paths);
	void GetDurableData(struct FItemData& Item, struct FDurableData* DurableData, enum class EDataValid* Paths);
	void GetDeployableData(struct FItemData& Item, struct FDeployableData* DeployableData, enum class EDataValid* Paths);
	void GetDecayableData(struct FItemData& Item, struct FDecayableData* Decayable, enum class EDataValid* Paths);
	TArray<struct FAlterationsEnum> GetCraftingModificationAlterations(class AActor* CraftingActor, class AActor* CraftingDevice, struct FItemData& Item);
	void GetConsumableData(struct FItemData& Item, struct FConsumableData* ConsumableData, enum class EDataValid* Paths);
	void GetCombustibleData(struct FItemData& Item, struct FCombustibleData* CombustibleData, enum class EDataValid* Paths);
	void GetBuildingTypePopupStats(struct FBuildingTypesRowHandle& BuildingTypeRow, TMap<struct FStatsEnum, int32>* Stats);
	void GetBuildableData(struct FItemData& Item, struct FBuildableData* BuildableData, enum class EDataValid* Paths);
	void GetBallisticData(struct FItemData& Item, struct FBallisticData* BallisiticData, enum class EDataValid* Paths);
	void GetAttachmentSlotActor(class AActor* Item, class UInventory** Inventory, int32* Slot, enum class EDataValid* Paths);
	void GetAttachmentSlot(class UObject* WorldContextObject, struct FItemData& ItemData, class UInventory** Inventory, int32* Slot, enum class EDataValid* Paths);
	struct FArmourSetsEnum GetArmourSet(struct FItemData& Item);
	void GetArmourData(struct FItemData& Item, struct FArmourData* ArmourData, enum class EDataValid* Paths);
	void GetAnyCookingModifications(class AIcarusPlayerCharacter* CraftingActor, struct FItemData& Item, TArray<struct FIcarusStatReplicated>& AdditionalStats);
	void GetAmmoTypeData(struct FItemData& Item, struct FAmmoTypeData* AmmoTypeData, enum class EDataValid* Paths);
	void GetAmmoItem(class UObject* WorldContextObject, struct FItemData& ItemData, struct FItemData* Ammo, enum class EDataValid* Paths);
	void GetActionableData(struct FItemData& Item, struct FActionableData* ActionableData, enum class EDataValid* Paths);
	int32 GenerateRewardStackSize(class AIcarusPlayerCharacter* PlayerCharacter, struct FItemRewardEntry& ItemReward, float AdditionalMultiplier);
	struct FItemData GenerateItemisedRocket(const class FString& Name);
	struct FProcessorRecipesRowHandle FindCraftingRecipe(struct FItemsStaticRowHandle& ItemsStaticRowHandle, enum class EDataValid* Paths);
	TArray<class AIcarusItem*> FilterItems(const TArray<class AIcarusItem*>& Items, const struct FTagQueriesRowHandle& Query, bool bInvertQuery, const struct FVector& Origin, float MinDistance, float MaxDistance);
	bool EstablishInventoryLink(class AIcarusItem* Item, class UInventory* Inventory, int32 Location);
	bool Equals(struct FItemData& Item1, struct FItemData& Item2);
	void DropInventoryItemStack(class UInventory* Inventory, int32 ItemLocation, class AIcarusPlayerCharacter* FromPlayer);
	void DestroyInventoryItemStack(class UInventory* Inventory, int32 ItemLocation, class AIcarusPlayerController* Player, bool bRefundPartCost);
	bool CreateLinkedInventoryFromItemData(class UObject* WorldContextObject, struct FItemData* ItemData);
	bool CreateLinkedInventoryFromInventoryItem(class UObject* WorldContextObject, class UInventory* Inventory, int32 Slot);
	struct FItemData CreateItem(struct FItemData& ItemData, class UObject* WorldContextObject);
	struct FItemData CreateCustomItem(struct FItemData& ItemData, const TArray<struct FAlterationsEnum>& Alterations, const TArray<struct FIcarusStatReplicated>& AdditionalStats, class UObject* WorldContextObject);
	struct FMetaItem ConvertToMetaItem(struct FItemData& Item);
	struct FItemData ConvertToItem(struct FMetaItem& MetaItem, class UObject* WorldContextObject);
	bool ContainerItemLeak(class UInventory* Inventory, int32 InventoryLocation);
	bool ContainerCurrentlyAcceptsType(class AIcarusActor* Actor, enum class EIcarusResourceType Type);
	bool ContainerActorLeak(class AIcarusActor* Actor);
	TArray<struct FFindAllStacksResult> CombineFindAllStackResults(TArray<struct FFindAllStacksResult>& ResultsA, TArray<struct FFindAllStacksResult>& ResultsB, class UObject* WorldContextObject);
	void CleanupDestroyedItem(struct FItemData& ItemData, enum class EItemDestructionContext DestructionContext, class AActor* ItemDestructionSource, class UObject* WorldContextObject);
	bool CanHaveAttachment(struct FItemData& ItemData);
	bool CanGetReward(class AIcarusPlayerCharacter* PlayerCharacter, struct FItemRewardEntry& ItemReward);
	bool CanDropItemFromInventory(class UInventory* Inventory, int32 ItemLocation);
	bool CanDropItem(struct FItemData& ItemData);
	bool CanCombineItems(struct FItemData& Item1, struct FItemData& Item2, class UObject* WorldContextObject);
	int32 AttemptToFillItemsInInventory(class UInventory* Inventory, enum class EIcarusResourceType Type, int32 Units);
	int32 AddContainerItemCapacity(class UInventory* Inventory, int32 InventoryLocation, enum class EIcarusResourceType Resource, int32 Units);
	int32 AddContainerActorCapacity(class AIcarusActor* Actor, enum class EIcarusResourceType Resource, int32 Units);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryLibrary
class UInventoryLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UInventoryLibrary* GetDefaultObj();

	struct FInventoryRowHandle StructToRowHandle(const struct FInventoryEnum& EnumValue);
	class FName StructToName(const struct FInventoryEnum& EnumValue);
	int32 StructToInt(const struct FInventoryEnum& EnumValue);
	struct FInventoryEnum RowHandleToStruct(const struct FInventoryRowHandle& RowHandle);
	void RemoveRowFromInventoryTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FInventoryEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FInventoryEnum& A, const struct FInventoryEnum& B);
	struct FInventoryEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FInventoryRowHandle MakeLiteralInventory(const struct FInventoryRowHandle& RowHandle);
	struct FInventoryRowHandle MakeInventoryFromIndex(int32 Index);
	struct FInventoryEnum MakeInventoryEnum(const struct FInventoryEnum& Enum);
	struct FInventoryRowHandle MakeInventory(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FInventoryEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetInventoryStruct(const struct FInventoryRowHandle& RowHandle, struct FInventoryData* Inventory, enum class EValid* Paths);
	bool EqualEqual_FInventoryRowHandleFInventoryRowHandle(const struct FInventoryRowHandle& RowHandleA, const struct FInventoryRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FInventoryEnum& A, const struct FInventoryEnum& B);
	struct FInventoryRowHandle CastToInventoryRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakInventoryEnum(const struct FInventoryEnum& Enum, class FName* Name, int32* Index);
	void AddRowToInventoryTable(class FName Name, const struct FInventoryData& Data, struct FInventoryRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventoryModerator
class IInventoryModerator : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IInventoryModerator* GetDefaultObj();

	bool IsSlotValidForItem(class UInventoryComponent* Inventory, const struct FInventoryIDEnum& InventoryID, const struct FItemData& Item, int32 SlotIndex);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.InventorySlotChangeListener
class IInventorySlotChangeListener : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IInventorySlotChangeListener* GetDefaultObj();

	void HandleChangedSlots(class UInventory* Inventory, TSet<int32>& ChangedSlotIndices);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.InventoryTable
class UInventoryTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UInventoryTable* GetDefaultObj();

};

// 0x240 (0x290 - 0x50)
// Class Icarus.IRGN_AlwaysRelevant_ForConnection
class UIRGN_AlwaysRelevant_ForConnection : public UReplicationGraphNode
{
public:
	uint8                                        Pad_8204[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FAlwaysRelevantActorInfo>      PastRelevantActors;                                // 0x60(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_8205[0x210];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                LastPawn;                                          // 0x280(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8206[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIRGN_AlwaysRelevant_ForConnection* GetDefaultObj();

};

// 0x28 (0x78 - 0x50)
// Class Icarus.IRGN_PlayerState_FrequencyLimited
class UIRGN_PlayerState_FrequencyLimited : public UReplicationGraphNode
{
public:
	uint8                                        Pad_8207[0x28];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIRGN_PlayerState_FrequencyLimited* GetDefaultObj();

};

// 0x8 (0xD8 - 0xD0)
// Class Icarus.ItemableComponent
class UItemableComponent : public UTraitComponent
{
public:
	FMulticastSparseDelegateProperty_            OnWorldPickup;                                     // 0xD0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8209[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        Stack;                                             // 0xD4(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UItemableComponent* GetDefaultObj();

	void SetStack(int32 NewStack);
	bool GetItemableData(struct FItemableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemableLibrary
class UItemableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemableLibrary* GetDefaultObj();

	struct FItemableRowHandle StructToRowHandle(const struct FItemableEnum& EnumValue);
	class FName StructToName(const struct FItemableEnum& EnumValue);
	int32 StructToInt(const struct FItemableEnum& EnumValue);
	struct FItemableEnum RowHandleToStruct(const struct FItemableRowHandle& RowHandle);
	void RemoveRowFromItemableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemableEnum& A, const struct FItemableEnum& B);
	struct FItemableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemableRowHandle MakeLiteralItemable(const struct FItemableRowHandle& RowHandle);
	struct FItemableRowHandle MakeItemableFromIndex(int32 Index);
	struct FItemableEnum MakeItemableEnum(const struct FItemableEnum& Enum);
	struct FItemableRowHandle MakeItemable(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemableStruct(const struct FItemableRowHandle& RowHandle, struct FItemableData* Itemable, enum class EValid* Paths);
	bool EqualEqual_FItemableRowHandleFItemableRowHandle(const struct FItemableRowHandle& RowHandleA, const struct FItemableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemableEnum& A, const struct FItemableEnum& B);
	struct FItemableRowHandle CastToItemableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemableEnum(const struct FItemableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemableTable(class FName Name, const struct FItemableData& Data, struct FItemableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemableTable
class UItemableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemAnimationsLibrary
class UItemAnimationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemAnimationsLibrary* GetDefaultObj();

	struct FItemAnimationsRowHandle StructToRowHandle(const struct FItemAnimationsEnum& EnumValue);
	class FName StructToName(const struct FItemAnimationsEnum& EnumValue);
	int32 StructToInt(const struct FItemAnimationsEnum& EnumValue);
	struct FItemAnimationsEnum RowHandleToStruct(const struct FItemAnimationsRowHandle& RowHandle);
	void RemoveRowFromItemAnimationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemAnimationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemAnimationsEnum& A, const struct FItemAnimationsEnum& B);
	struct FItemAnimationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemAnimationsRowHandle MakeLiteralItemAnimations(const struct FItemAnimationsRowHandle& RowHandle);
	struct FItemAnimationsRowHandle MakeItemAnimationsFromIndex(int32 Index);
	struct FItemAnimationsEnum MakeItemAnimationsEnum(const struct FItemAnimationsEnum& Enum);
	struct FItemAnimationsRowHandle MakeItemAnimations(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemAnimationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemAnimationsStruct(const struct FItemAnimationsRowHandle& RowHandle, struct FItemAnimationData* ItemAnimations, enum class EValid* Paths);
	bool EqualEqual_FItemAnimationsRowHandleFItemAnimationsRowHandle(const struct FItemAnimationsRowHandle& RowHandleA, const struct FItemAnimationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemAnimationsEnum& A, const struct FItemAnimationsEnum& B);
	struct FItemAnimationsRowHandle CastToItemAnimationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemAnimationsEnum(const struct FItemAnimationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemAnimationsTable(class FName Name, const struct FItemAnimationData& Data, struct FItemAnimationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemAnimationsTable
class UItemAnimationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemAnimationsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemAttachmentLibrary
class UItemAttachmentLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemAttachmentLibrary* GetDefaultObj();

	struct FItemAttachmentRowHandle StructToRowHandle(const struct FItemAttachmentEnum& EnumValue);
	class FName StructToName(const struct FItemAttachmentEnum& EnumValue);
	int32 StructToInt(const struct FItemAttachmentEnum& EnumValue);
	struct FItemAttachmentEnum RowHandleToStruct(const struct FItemAttachmentRowHandle& RowHandle);
	void RemoveRowFromItemAttachmentTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemAttachmentEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemAttachmentEnum& A, const struct FItemAttachmentEnum& B);
	struct FItemAttachmentEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemAttachmentRowHandle MakeLiteralItemAttachment(const struct FItemAttachmentRowHandle& RowHandle);
	struct FItemAttachmentRowHandle MakeItemAttachmentFromIndex(int32 Index);
	struct FItemAttachmentEnum MakeItemAttachmentEnum(const struct FItemAttachmentEnum& Enum);
	struct FItemAttachmentRowHandle MakeItemAttachment(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemAttachmentEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemAttachmentStruct(const struct FItemAttachmentRowHandle& RowHandle, struct FItemAttachmentData* ItemAttachment, enum class EValid* Paths);
	bool EqualEqual_FItemAttachmentRowHandleFItemAttachmentRowHandle(const struct FItemAttachmentRowHandle& RowHandleA, const struct FItemAttachmentRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemAttachmentEnum& A, const struct FItemAttachmentEnum& B);
	struct FItemAttachmentRowHandle CastToItemAttachmentRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemAttachmentEnum(const struct FItemAttachmentEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemAttachmentTable(class FName Name, const struct FItemAttachmentData& Data, struct FItemAttachmentRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemAttachmentTable
class UItemAttachmentTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemAttachmentTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemAudioDataLibrary
class UItemAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemAudioDataLibrary* GetDefaultObj();

	struct FItemAudioDataRowHandle StructToRowHandle(const struct FItemAudioDataEnum& EnumValue);
	class FName StructToName(const struct FItemAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FItemAudioDataEnum& EnumValue);
	struct FItemAudioDataEnum RowHandleToStruct(const struct FItemAudioDataRowHandle& RowHandle);
	void RemoveRowFromItemAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemAudioDataEnum& A, const struct FItemAudioDataEnum& B);
	struct FItemAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemAudioDataRowHandle MakeLiteralItemAudioData(const struct FItemAudioDataRowHandle& RowHandle);
	struct FItemAudioDataRowHandle MakeItemAudioDataFromIndex(int32 Index);
	struct FItemAudioDataEnum MakeItemAudioDataEnum(const struct FItemAudioDataEnum& Enum);
	struct FItemAudioDataRowHandle MakeItemAudioData(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemAudioDataStruct(const struct FItemAudioDataRowHandle& RowHandle, struct FItemAudioData* ItemAudioData, enum class EValid* Paths);
	bool EqualEqual_FItemAudioDataRowHandleFItemAudioDataRowHandle(const struct FItemAudioDataRowHandle& RowHandleA, const struct FItemAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemAudioDataEnum& A, const struct FItemAudioDataEnum& B);
	struct FItemAudioDataRowHandle CastToItemAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemAudioDataEnum(const struct FItemAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemAudioDataTable(class FName Name, const struct FItemAudioData& Data, struct FItemAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemAudioDataTable
class UItemAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemAudioDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemClassificationsIconsLibrary
class UItemClassificationsIconsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemClassificationsIconsLibrary* GetDefaultObj();

	struct FItemClassificationsIconsRowHandle StructToRowHandle(const struct FItemClassificationsIconsEnum& EnumValue);
	class FName StructToName(const struct FItemClassificationsIconsEnum& EnumValue);
	int32 StructToInt(const struct FItemClassificationsIconsEnum& EnumValue);
	struct FItemClassificationsIconsEnum RowHandleToStruct(const struct FItemClassificationsIconsRowHandle& RowHandle);
	void RemoveRowFromItemClassificationsIconsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemClassificationsIconsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemClassificationsIconsEnum& A, const struct FItemClassificationsIconsEnum& B);
	struct FItemClassificationsIconsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemClassificationsIconsRowHandle MakeLiteralItemClassificationsIcons(const struct FItemClassificationsIconsRowHandle& RowHandle);
	struct FItemClassificationsIconsRowHandle MakeItemClassificationsIconsFromIndex(int32 Index);
	struct FItemClassificationsIconsEnum MakeItemClassificationsIconsEnum(const struct FItemClassificationsIconsEnum& Enum);
	struct FItemClassificationsIconsRowHandle MakeItemClassificationsIcons(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemClassificationsIconsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemClassificationsIconsStruct(const struct FItemClassificationsIconsRowHandle& RowHandle, struct FItemClassificationsIconsData* ItemClassificationsIcons, enum class EValid* Paths);
	bool EqualEqual_FItemClassificationsIconsRowHandleFItemClassificationsIconsRowHandle(const struct FItemClassificationsIconsRowHandle& RowHandleA, const struct FItemClassificationsIconsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemClassificationsIconsEnum& A, const struct FItemClassificationsIconsEnum& B);
	struct FItemClassificationsIconsRowHandle CastToItemClassificationsIconsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemClassificationsIconsEnum(const struct FItemClassificationsIconsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemClassificationsIconsTable(class FName Name, const struct FItemClassificationsIconsData& Data, struct FItemClassificationsIconsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemClassificationsIconsTable
class UItemClassificationsIconsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemClassificationsIconsTable* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.ItemManipulationComponent
class UItemManipulationComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UItemManipulationComponent* GetDefaultObj();

	bool UseItem(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use, class AIcarusPlayerCharacter* Target, struct FItemData* ItemConsumed);
	bool RepairItem(class UInventory* SourceInventory, int32 SourceLocation, class AIcarusPlayerCharacter* Target);
	bool PlaceItem(class UInventory* SourceInventory, int32 SourceLocation, class AIcarusPlayerCharacter* Target);
	int32 GetTotalFoodRecovery(class UPlayerCharacterState* TargetPlayer, struct FItemData* ItemData);
	TArray<struct FQueueItem> FindItemsRequiredForRepair(struct FItemData& ItemData, const TArray<class UInventory*>& Inventories);
	bool ConsumeItem(class UInventory* SourceInventory, int32 SourceLocation, class AIcarusPlayerCharacter* Target, struct FItemData* ItemConsumed);
	enum class ECanUseItemResult CanUseItem(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use, const struct FUseCondition& UseCondition, class AIcarusPlayerCharacter* Target);
	bool CanRepairItem(class UInventory* SourceInventory, int32 SourceLocation, class AIcarusPlayerCharacter* Target);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemRanksLibrary
class UItemRanksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemRanksLibrary* GetDefaultObj();

	struct FItemRanksRowHandle StructToRowHandle(const struct FItemRanksEnum& EnumValue);
	class FName StructToName(const struct FItemRanksEnum& EnumValue);
	int32 StructToInt(const struct FItemRanksEnum& EnumValue);
	struct FItemRanksEnum RowHandleToStruct(const struct FItemRanksRowHandle& RowHandle);
	void RemoveRowFromItemRanksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemRanksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemRanksEnum& A, const struct FItemRanksEnum& B);
	struct FItemRanksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemRanksRowHandle MakeLiteralItemRanks(const struct FItemRanksRowHandle& RowHandle);
	struct FItemRanksRowHandle MakeItemRanksFromIndex(int32 Index);
	struct FItemRanksEnum MakeItemRanksEnum(const struct FItemRanksEnum& Enum);
	struct FItemRanksRowHandle MakeItemRanks(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemRanksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemRanksStruct(const struct FItemRanksRowHandle& RowHandle, struct FItemRank* ItemRanks, enum class EValid* Paths);
	bool EqualEqual_FItemRanksRowHandleFItemRanksRowHandle(const struct FItemRanksRowHandle& RowHandleA, const struct FItemRanksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemRanksEnum& A, const struct FItemRanksEnum& B);
	struct FItemRanksRowHandle CastToItemRanksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemRanksEnum(const struct FItemRanksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemRanksTable(class FName Name, const struct FItemRank& Data, struct FItemRanksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemRanksTable
class UItemRanksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemRanksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemRewardFactory
class UItemRewardFactory : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemRewardFactory* GetDefaultObj();

	struct FItemData GenerateItemFromReward(struct FItemRewardEntry& ItemReward, class UObject* WorldContextObject);
	struct FItemData GenerateItemData(struct FItemReward& ItemReward, class UObject* WorldContextObject);
	TArray<struct FItemData> GenerateHarvestedItemRewards(TArray<struct FItemRewardEntry>& ItemRewards, float RewardMultiplier, class UIcarusStatContainer* StatCheckSource, class UObject* WorldContextObject);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemRewardsLibrary
class UItemRewardsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemRewardsLibrary* GetDefaultObj();

	struct FItemRewardsRowHandle StructToRowHandle(const struct FItemRewardsEnum& EnumValue);
	class FName StructToName(const struct FItemRewardsEnum& EnumValue);
	int32 StructToInt(const struct FItemRewardsEnum& EnumValue);
	struct FItemRewardsEnum RowHandleToStruct(const struct FItemRewardsRowHandle& RowHandle);
	void RemoveRowFromItemRewardsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemRewardsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemRewardsEnum& A, const struct FItemRewardsEnum& B);
	struct FItemRewardsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemRewardsRowHandle MakeLiteralItemRewards(const struct FItemRewardsRowHandle& RowHandle);
	struct FItemRewardsRowHandle MakeItemRewardsFromIndex(int32 Index);
	struct FItemRewardsEnum MakeItemRewardsEnum(const struct FItemRewardsEnum& Enum);
	struct FItemRewardsRowHandle MakeItemRewards(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemRewardsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemRewardsStruct(const struct FItemRewardsRowHandle& RowHandle, struct FItemRewards* ItemRewards, enum class EValid* Paths);
	bool EqualEqual_FItemRewardsRowHandleFItemRewardsRowHandle(const struct FItemRewardsRowHandle& RowHandleA, const struct FItemRewardsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemRewardsEnum& A, const struct FItemRewardsEnum& B);
	struct FItemRewardsRowHandle CastToItemRewardsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemRewardsEnum(const struct FItemRewardsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemRewardsTable(class FName Name, const struct FItemRewards& Data, struct FItemRewardsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemRewardsTable
class UItemRewardsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemRewardsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemsStaticLibrary
class UItemsStaticLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemsStaticLibrary* GetDefaultObj();

	struct FItemsStaticRowHandle StructToRowHandle(const struct FItemsStaticEnum& EnumValue);
	class FName StructToName(const struct FItemsStaticEnum& EnumValue);
	int32 StructToInt(const struct FItemsStaticEnum& EnumValue);
	struct FItemsStaticEnum RowHandleToStruct(const struct FItemsStaticRowHandle& RowHandle);
	void RemoveRowFromItemsStaticTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemsStaticEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemsStaticEnum& A, const struct FItemsStaticEnum& B);
	struct FItemsStaticEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemsStaticRowHandle MakeLiteralItemsStatic(const struct FItemsStaticRowHandle& RowHandle);
	struct FItemsStaticRowHandle MakeItemsStaticFromIndex(int32 Index);
	struct FItemsStaticEnum MakeItemsStaticEnum(const struct FItemsStaticEnum& Enum);
	struct FItemsStaticRowHandle MakeItemsStatic(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemsStaticEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemsStaticStruct(const struct FItemsStaticRowHandle& RowHandle, struct FItemStaticData* ItemsStatic, enum class EValid* Paths);
	bool EqualEqual_FItemsStaticRowHandleFItemsStaticRowHandle(const struct FItemsStaticRowHandle& RowHandleA, const struct FItemsStaticRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemsStaticEnum& A, const struct FItemsStaticEnum& B);
	struct FItemsStaticRowHandle CastToItemsStaticRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemsStaticEnum(const struct FItemsStaticEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemsStaticTable(class FName Name, const struct FItemStaticData& Data, struct FItemsStaticRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemsStaticTable
class UItemsStaticTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemsStaticTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemTemplateLibrary
class UItemTemplateLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemTemplateLibrary* GetDefaultObj();

	struct FItemTemplateRowHandle StructToRowHandle(const struct FItemTemplateEnum& EnumValue);
	class FName StructToName(const struct FItemTemplateEnum& EnumValue);
	int32 StructToInt(const struct FItemTemplateEnum& EnumValue);
	struct FItemTemplateEnum RowHandleToStruct(const struct FItemTemplateRowHandle& RowHandle);
	void RemoveRowFromItemTemplateTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemTemplateEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemTemplateEnum& A, const struct FItemTemplateEnum& B);
	struct FItemTemplateEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemTemplateRowHandle MakeLiteralItemTemplate(const struct FItemTemplateRowHandle& RowHandle);
	struct FItemTemplateRowHandle MakeItemTemplateFromIndex(int32 Index);
	struct FItemTemplateEnum MakeItemTemplateEnum(const struct FItemTemplateEnum& Enum);
	struct FItemTemplateRowHandle MakeItemTemplate(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemTemplateEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemTemplateStruct(const struct FItemTemplateRowHandle& RowHandle, struct FItemData* ItemTemplate, enum class EValid* Paths);
	bool EqualEqual_FItemTemplateRowHandleFItemTemplateRowHandle(const struct FItemTemplateRowHandle& RowHandleA, const struct FItemTemplateRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemTemplateEnum& A, const struct FItemTemplateEnum& B);
	struct FItemTemplateRowHandle CastToItemTemplateRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemTemplateEnum(const struct FItemTemplateEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemTemplateTable(class FName Name, const struct FItemData& Data, struct FItemTemplateRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemTemplateTable
class UItemTemplateTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemTemplateTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemTraitMasksLibrary
class UItemTraitMasksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemTraitMasksLibrary* GetDefaultObj();

	struct FItemTraitMasksRowHandle StructToRowHandle(const struct FItemTraitMasksEnum& EnumValue);
	class FName StructToName(const struct FItemTraitMasksEnum& EnumValue);
	int32 StructToInt(const struct FItemTraitMasksEnum& EnumValue);
	struct FItemTraitMasksEnum RowHandleToStruct(const struct FItemTraitMasksRowHandle& RowHandle);
	void RemoveRowFromItemTraitMasksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemTraitMasksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemTraitMasksEnum& A, const struct FItemTraitMasksEnum& B);
	struct FItemTraitMasksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemTraitMasksRowHandle MakeLiteralItemTraitMasks(const struct FItemTraitMasksRowHandle& RowHandle);
	struct FItemTraitMasksRowHandle MakeItemTraitMasksFromIndex(int32 Index);
	struct FItemTraitMasksEnum MakeItemTraitMasksEnum(const struct FItemTraitMasksEnum& Enum);
	struct FItemTraitMasksRowHandle MakeItemTraitMasks(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemTraitMasksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemTraitMasksStruct(const struct FItemTraitMasksRowHandle& RowHandle, struct FItemTraitMask* ItemTraitMasks, enum class EValid* Paths);
	bool EqualEqual_FItemTraitMasksRowHandleFItemTraitMasksRowHandle(const struct FItemTraitMasksRowHandle& RowHandleA, const struct FItemTraitMasksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemTraitMasksEnum& A, const struct FItemTraitMasksEnum& B);
	struct FItemTraitMasksRowHandle CastToItemTraitMasksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemTraitMasksEnum(const struct FItemTraitMasksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemTraitMasksTable(class FName Name, const struct FItemTraitMask& Data, struct FItemTraitMasksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemTraitMasksTable
class UItemTraitMasksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemTraitMasksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ItemWeightStatQueriesLibrary
class UItemWeightStatQueriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UItemWeightStatQueriesLibrary* GetDefaultObj();

	struct FItemWeightStatQueriesRowHandle StructToRowHandle(const struct FItemWeightStatQueriesEnum& EnumValue);
	class FName StructToName(const struct FItemWeightStatQueriesEnum& EnumValue);
	int32 StructToInt(const struct FItemWeightStatQueriesEnum& EnumValue);
	struct FItemWeightStatQueriesEnum RowHandleToStruct(const struct FItemWeightStatQueriesRowHandle& RowHandle);
	void RemoveRowFromItemWeightStatQueriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FItemWeightStatQueriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FItemWeightStatQueriesEnum& A, const struct FItemWeightStatQueriesEnum& B);
	struct FItemWeightStatQueriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FItemWeightStatQueriesRowHandle MakeLiteralItemWeightStatQueries(const struct FItemWeightStatQueriesRowHandle& RowHandle);
	struct FItemWeightStatQueriesRowHandle MakeItemWeightStatQueriesFromIndex(int32 Index);
	struct FItemWeightStatQueriesEnum MakeItemWeightStatQueriesEnum(const struct FItemWeightStatQueriesEnum& Enum);
	struct FItemWeightStatQueriesRowHandle MakeItemWeightStatQueries(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FItemWeightStatQueriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetItemWeightStatQueriesStruct(const struct FItemWeightStatQueriesRowHandle& RowHandle, struct FItemWeightStatQueries* ItemWeightStatQueries, enum class EValid* Paths);
	bool EqualEqual_FItemWeightStatQueriesRowHandleFItemWeightStatQueriesRowHandle(const struct FItemWeightStatQueriesRowHandle& RowHandleA, const struct FItemWeightStatQueriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FItemWeightStatQueriesEnum& A, const struct FItemWeightStatQueriesEnum& B);
	struct FItemWeightStatQueriesRowHandle CastToItemWeightStatQueriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakItemWeightStatQueriesEnum(const struct FItemWeightStatQueriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToItemWeightStatQueriesTable(class FName Name, const struct FItemWeightStatQueries& Data, struct FItemWeightStatQueriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ItemWeightStatQueriesTable
class UItemWeightStatQueriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UItemWeightStatQueriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeybindContextsLibrary
class UKeybindContextsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeybindContextsLibrary* GetDefaultObj();

	struct FKeybindContextsRowHandle StructToRowHandle(const struct FKeybindContextsEnum& EnumValue);
	class FName StructToName(const struct FKeybindContextsEnum& EnumValue);
	int32 StructToInt(const struct FKeybindContextsEnum& EnumValue);
	struct FKeybindContextsEnum RowHandleToStruct(const struct FKeybindContextsRowHandle& RowHandle);
	void RemoveRowFromKeybindContextsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FKeybindContextsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FKeybindContextsEnum& A, const struct FKeybindContextsEnum& B);
	struct FKeybindContextsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FKeybindContextsRowHandle MakeLiteralKeybindContexts(const struct FKeybindContextsRowHandle& RowHandle);
	struct FKeybindContextsRowHandle MakeKeybindContextsFromIndex(int32 Index);
	struct FKeybindContextsEnum MakeKeybindContextsEnum(const struct FKeybindContextsEnum& Enum);
	struct FKeybindContextsRowHandle MakeKeybindContexts(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FKeybindContextsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetKeybindContextsStruct(const struct FKeybindContextsRowHandle& RowHandle, struct FKeybindContext* KeybindContexts, enum class EValid* Paths);
	bool EqualEqual_FKeybindContextsRowHandleFKeybindContextsRowHandle(const struct FKeybindContextsRowHandle& RowHandleA, const struct FKeybindContextsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FKeybindContextsEnum& A, const struct FKeybindContextsEnum& B);
	struct FKeybindContextsRowHandle CastToKeybindContextsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakKeybindContextsEnum(const struct FKeybindContextsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToKeybindContextsTable(class FName Name, const struct FKeybindContext& Data, struct FKeybindContextsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.KeybindContextsTable
class UKeybindContextsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UKeybindContextsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeybindingsLibrary
class UKeybindingsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeybindingsLibrary* GetDefaultObj();

	struct FKeybindingsRowHandle StructToRowHandle(const struct FKeybindingsEnum& EnumValue);
	class FName StructToName(const struct FKeybindingsEnum& EnumValue);
	int32 StructToInt(const struct FKeybindingsEnum& EnumValue);
	struct FKeybindingsEnum RowHandleToStruct(const struct FKeybindingsRowHandle& RowHandle);
	void RemoveRowFromKeybindingsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FKeybindingsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FKeybindingsEnum& A, const struct FKeybindingsEnum& B);
	struct FKeybindingsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FKeybindingsRowHandle MakeLiteralKeybindings(const struct FKeybindingsRowHandle& RowHandle);
	TArray<struct FKeybindingsRowHandle> MakeKeybindingsRowFromActionName(class FName& InActionName);
	struct FKeybindingsRowHandle MakeKeybindingsFromIndex(int32 Index);
	struct FKeybindingsEnum MakeKeybindingsEnum(const struct FKeybindingsEnum& Enum);
	struct FKeybindingsRowHandle MakeKeybindings(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FKeybindingsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetKeybindingsStruct(const struct FKeybindingsRowHandle& RowHandle, struct FKeybindData* Keybindings, enum class EValid* Paths);
	bool EqualEqual_FKeybindingsRowHandleFKeybindingsRowHandle(const struct FKeybindingsRowHandle& RowHandleA, const struct FKeybindingsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FKeybindingsEnum& A, const struct FKeybindingsEnum& B);
	struct FKeybindingsRowHandle CastToKeybindingsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakKeybindingsEnum(const struct FKeybindingsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToKeybindingsTable(class FName Name, const struct FKeybindData& Data, struct FKeybindingsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.KeybindingsTable
class UKeybindingsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UKeybindingsTable* GetDefaultObj();

};

// 0x18 (0x2B0 - 0x298)
// Class Icarus.KeybindingWidget
class UKeybindingWidget : public UIcarusWidget
{
public:
	struct FKeybindingsRowHandle                 KeybindRow;                                        // 0x298(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UKeybindingWidget* GetDefaultObj();

	void PostSetup();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeyDataFunctionLibrary
class UKeyDataFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeyDataFunctionLibrary* GetDefaultObj();

	class FText GetDisplayNameForKey(struct FKey& Key, bool bLongDisplay);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeyIconDataFunctionLibrary
class UKeyIconDataFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeyIconDataFunctionLibrary* GetDefaultObj();

	void GetIconsForKey(struct FKey& Key, enum class EControllerIconSet IconSet, struct FKeyIconData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeyIconsLibrary
class UKeyIconsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeyIconsLibrary* GetDefaultObj();

	struct FKeyIconsRowHandle StructToRowHandle(const struct FKeyIconsEnum& EnumValue);
	class FName StructToName(const struct FKeyIconsEnum& EnumValue);
	int32 StructToInt(const struct FKeyIconsEnum& EnumValue);
	struct FKeyIconsEnum RowHandleToStruct(const struct FKeyIconsRowHandle& RowHandle);
	void RemoveRowFromKeyIconsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FKeyIconsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FKeyIconsEnum& A, const struct FKeyIconsEnum& B);
	struct FKeyIconsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FKeyIconsRowHandle MakeLiteralKeyIcons(const struct FKeyIconsRowHandle& RowHandle);
	TArray<struct FKeyIconsRowHandle> MakeKeyIconsRowFromIconSet(enum class EControllerIconSet& InIconSet);
	struct FKeyIconsRowHandle MakeKeyIconsFromIndex(int32 Index);
	struct FKeyIconsEnum MakeKeyIconsEnum(const struct FKeyIconsEnum& Enum);
	struct FKeyIconsRowHandle MakeKeyIcons(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FKeyIconsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetKeyIconsStruct(const struct FKeyIconsRowHandle& RowHandle, struct FKeyIconData* KeyIcons, enum class EValid* Paths);
	bool EqualEqual_FKeyIconsRowHandleFKeyIconsRowHandle(const struct FKeyIconsRowHandle& RowHandleA, const struct FKeyIconsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FKeyIconsEnum& A, const struct FKeyIconsEnum& B);
	struct FKeyIconsRowHandle CastToKeyIconsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakKeyIconsEnum(const struct FKeyIconsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToKeyIconsTable(class FName Name, const struct FKeyIconData& Data, struct FKeyIconsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.KeyIconsTable
class UKeyIconsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UKeyIconsTable* GetDefaultObj();

};

// 0x8 (0x268 - 0x260)
// Class Icarus.KeyRebindableWidget
class UKeyRebindableWidget : public UUserWidget
{
public:
	bool                                         bListening;                                        // 0x260(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_82B7[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UKeyRebindableWidget* GetDefaultObj();

	void OnStartRebind();
	bool OnKeySet(const struct FKey& NewKey);
	void OnEndRebind();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.KeysLibrary
class UKeysLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UKeysLibrary* GetDefaultObj();

	struct FKeysRowHandle StructToRowHandle(const struct FKeysEnum& EnumValue);
	class FName StructToName(const struct FKeysEnum& EnumValue);
	int32 StructToInt(const struct FKeysEnum& EnumValue);
	struct FKeysEnum RowHandleToStruct(const struct FKeysRowHandle& RowHandle);
	void RemoveRowFromKeysTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FKeysEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FKeysEnum& A, const struct FKeysEnum& B);
	struct FKeysEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FKeysRowHandle MakeLiteralKeys(const struct FKeysRowHandle& RowHandle);
	struct FKeysRowHandle MakeKeysRowFromKey(struct FKey& InKey);
	struct FKeysRowHandle MakeKeysFromIndex(int32 Index);
	struct FKeysEnum MakeKeysEnum(const struct FKeysEnum& Enum);
	struct FKeysRowHandle MakeKeys(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FKeysEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetKeysStruct(const struct FKeysRowHandle& RowHandle, struct FKeyData* Keys, enum class EValid* Paths);
	bool EqualEqual_FKeysRowHandleFKeysRowHandle(const struct FKeysRowHandle& RowHandleA, const struct FKeysRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FKeysEnum& A, const struct FKeysEnum& B);
	struct FKeysRowHandle CastToKeysRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakKeysEnum(const struct FKeysEnum& Enum, class FName* Name, int32* Index);
	void AddRowToKeysTable(class FName Name, const struct FKeyData& Data, struct FKeysRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.KeysTable
class UKeysTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UKeysTable* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.LadderComponent
class ULadderComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class ULadderComponent* GetDefaultObj();

	class ULadderComponent* GetOutermostLadder();
	struct FTransform GetLadderStart();
	struct FTransform GetLadderEnd();
};

// 0x78 (0x338 - 0x2C0)
// Class Icarus.WaterBody
class AWaterBody : public AIcarusActor
{
public:
	struct FWaterSetupRowHandle                  WaterSetup;                                        // 0x2C0(0x18)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxFish;                                           // 0x2D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_82C3[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UFloatableComponent*>           OverlappedFloatables;                              // 0x2E0(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        OverlappedBuildings;                               // 0x2F0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                         bWaterBodyIsLava;                                  // 0x300(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_82C4[0x37];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AWaterBody* GetDefaultObj();

	void TryStopBurnOnEndOverlap(class AActor* Actor, class UActorComponent* Component);
	void TryBurnOnBeginOverlap(class AActor* Actor, class UActorComponent* Component);
	void RemoveFloatableOverlap(class UFloatableComponent* Component);
	TArray<class UPrimitiveComponent*> GetNavAffectingComponents();
	void AddFloatableOverlap(class UFloatableComponent* Component);
};

// 0x30 (0x368 - 0x338)
// Class Icarus.Lake
class ALake : public AWaterBody
{
public:
	struct FVector                               LakeScale;                                         // 0x338(0xC)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_82C5[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FWaterPoint>                   WaterPoints;                                       // 0x348(0x10)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class UFishManager*                          FishManager;                                       // 0x358(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsFishVolume;                                     // 0x360(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_82C6[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ALake* GetDefaultObj();

};

// 0x0 (0x560 - 0x560)
// Class Icarus.LakeSplineComponent
class ULakeSplineComponent : public UEdgeSplineComponent
{
public:

	static class UClass* StaticClass();
	static class ULakeSplineComponent* GetDefaultObj();

	TMap<struct FIntPoint, struct FVector> GetLakePoints(class AActor* Target, const struct FTransform& Transform, TArray<struct FVector>& TraceLocations, float Density);
	struct FVector GetEditorViewportCameraLocation();
	TArray<struct FVector> GetEdgePointsFromLakePoints(TMap<struct FIntPoint, struct FVector>& LakePoints);
	void ConstructFromTransformArray(TArray<struct FTransform>& Transforms, enum class ESplineLoopDirection LoopDirection);
	void ConstructFromPrefabTemplate(struct FPrefabLake& PrefabLake);
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.LandingPadComponent
class ULandingPadComponent : public UActorComponent
{
public:
	int32                                        TimeBuilt;                                         // 0xB0(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_82CB[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FPlayerCharacterID                    PlayerID;                                          // 0xB8(0x18)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class ULandingPadComponent* GetDefaultObj();

	void InitTimeBuilt(int32 InTimeBuilt);
	bool HasPlayer();
	int32 GetTimeBuilt();
	class FString GetPlayerName();
	struct FPlayerCharacterID GetPlayerID();
	void ClearAssignedPlayer();
	void AssignPlayer(struct FPlayerCharacterID& InPlayerID);
};

// 0x28 (0x280 - 0x258)
// Class Icarus.LandingPadRecorderComponent
class ULandingPadRecorderComponent : public UDeployableRecorderComponent
{
public:
	struct FLandingPadRecord                     LandingPadRecord;                                  // 0x258(0x20)(SaveGame, NativeAccessSpecifierPublic)
	uint8                                        Pad_82CC[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ULandingPadRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.LanguagesLibrary
class ULanguagesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULanguagesLibrary* GetDefaultObj();

	struct FLanguagesRowHandle StructToRowHandle(const struct FLanguagesEnum& EnumValue);
	class FName StructToName(const struct FLanguagesEnum& EnumValue);
	int32 StructToInt(const struct FLanguagesEnum& EnumValue);
	struct FLanguagesEnum RowHandleToStruct(const struct FLanguagesRowHandle& RowHandle);
	void RemoveRowFromLanguagesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLanguagesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLanguagesEnum& A, const struct FLanguagesEnum& B);
	struct FLanguagesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLanguagesRowHandle MakeLiteralLanguages(const struct FLanguagesRowHandle& RowHandle);
	struct FLanguagesRowHandle MakeLanguagesFromIndex(int32 Index);
	struct FLanguagesEnum MakeLanguagesEnum(const struct FLanguagesEnum& Enum);
	struct FLanguagesRowHandle MakeLanguages(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FLanguagesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLanguagesStruct(const struct FLanguagesRowHandle& RowHandle, struct FLanguagesData* Languages, enum class EValid* Paths);
	bool EqualEqual_FLanguagesRowHandleFLanguagesRowHandle(const struct FLanguagesRowHandle& RowHandleA, const struct FLanguagesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLanguagesEnum& A, const struct FLanguagesEnum& B);
	struct FLanguagesRowHandle CastToLanguagesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLanguagesEnum(const struct FLanguagesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLanguagesTable(class FName Name, const struct FLanguagesData& Data, struct FLanguagesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LanguagesTable
class ULanguagesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULanguagesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.LevelSequencesLibrary
class ULevelSequencesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULevelSequencesLibrary* GetDefaultObj();

	struct FLevelSequencesRowHandle StructToRowHandle(const struct FLevelSequencesEnum& EnumValue);
	class FName StructToName(const struct FLevelSequencesEnum& EnumValue);
	int32 StructToInt(const struct FLevelSequencesEnum& EnumValue);
	struct FLevelSequencesEnum RowHandleToStruct(const struct FLevelSequencesRowHandle& RowHandle);
	void RemoveRowFromLevelSequencesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLevelSequencesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLevelSequencesEnum& A, const struct FLevelSequencesEnum& B);
	struct FLevelSequencesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLevelSequencesRowHandle MakeLiteralLevelSequences(const struct FLevelSequencesRowHandle& RowHandle);
	struct FLevelSequencesRowHandle MakeLevelSequencesFromIndex(int32 Index);
	struct FLevelSequencesEnum MakeLevelSequencesEnum(const struct FLevelSequencesEnum& Enum);
	struct FLevelSequencesRowHandle MakeLevelSequences(class FName RowName);
	bool IsValidName(class FName NameValue);
	struct FLevelSequencesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLevelSequencesStruct(const struct FLevelSequencesRowHandle& RowHandle, struct FLevelSequencesData* LevelSequences, enum class EValid* Paths);
	bool EqualEqual_FLevelSequencesRowHandleFLevelSequencesRowHandle(const struct FLevelSequencesRowHandle& RowHandleA, const struct FLevelSequencesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLevelSequencesEnum& A, const struct FLevelSequencesEnum& B);
	struct FLevelSequencesRowHandle CastToLevelSequencesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLevelSequencesEnum(const struct FLevelSequencesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLevelSequencesTable(class FName Name, const struct FLevelSequencesData& Data, struct FLevelSequencesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LevelSequencesTable
class ULevelSequencesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULevelSequencesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.LivingItemBlueprintFunctionLibrary
class ULivingItemBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class ULivingItemBlueprintFunctionLibrary* GetDefaultObj();

	void UpdateLivingItemChallengeProgress(class AIcarusPlayerCharacter* OwningCharacter, struct FItemData& Item, const struct FChallengesRowHandle& Challenge, int32 ProgressIncrease);
	bool SetLivingItemUpgrade(struct FItemData& Item, int32 Slot, const struct FLivingItemUpgradesRowHandle& Upgrade);
	bool GetLivingItemSlotStates(struct FItemData& Item, TArray<struct FLivingItemSlotState>* Slots);
	bool GetLivingItemActiveChallengeSlotState(struct FItemData& Item, struct FLivingItemSlotState* ActiveQuestSlot);
	bool GetEquippedItemUpgrades(struct FItemData& Item, TArray<struct FLivingItemUpgradeData>* Upgrades);
};

// 0xA8 (0x178 - 0xD0)
// Class Icarus.LivingItemComponent
class ULivingItemComponent : public UTraitComponent
{
public:
	uint8                                        Pad_82EA[0x98];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UStaticMeshComponent*>          AttachedStaticMeshes;                              // 0x168(0x10)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class ULivingItemComponent* GetDefaultObj();

	void RebuildMesh();
	void OnVoxelResourceMinedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnVoxelCompletedNotify(class AIcarusPlayerCharacter* Player, class AVoxelResource* Voxel);
	void OnTreeResourceCollectedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnTreeFelledNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerPerformedStealthAttackNotify(class AIcarusPlayerCharacter* Player);
	void OnPlayerPerformedCriticalHitNotify(class AIcarusPlayerCharacter* Player, const struct FVector& HitLocation, const struct FCriticalHitAreasEnum& CriticalHitArea);
	void OnItemHarvestedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void OnCreatureSkinnedNotify(class AIcarusPlayerCharacter* Player, class AIcarusCorpse* Corpse);
	void OnCreatureKilledNotify(class AIcarusPlayerCharacter* Player, class AIcarusActor* Causer, class AActor* Creature, class AIcarusPlayerCharacter* KillingBlowFromPlayer);
	void OnCorpseItemRemovedNotify(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	bool HasActiveChallenge();
	bool GetLivingItemData(struct FLivingItemData* OutData);
	struct FChallenge GetActiveChallengeData();
	void FinaliseMeshCustomisations();
	void Cheat_SetUpgradeInSlot(int32 SlotIndex, const struct FLivingItemUpgradesRowHandle& Upgrade);
	void Cheat_CompleteAllChallenges();
	void Cheat_CompleteActiveChallenge();
	void Cheat_AddChallengeProgress(int32 Amount);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.LivingItemLibrary
class ULivingItemLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULivingItemLibrary* GetDefaultObj();

	struct FLivingItemRowHandle StructToRowHandle(const struct FLivingItemEnum& EnumValue);
	class FName StructToName(const struct FLivingItemEnum& EnumValue);
	int32 StructToInt(const struct FLivingItemEnum& EnumValue);
	struct FLivingItemEnum RowHandleToStruct(const struct FLivingItemRowHandle& RowHandle);
	void RemoveRowFromLivingItemTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLivingItemEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLivingItemEnum& A, const struct FLivingItemEnum& B);
	struct FLivingItemEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLivingItemRowHandle MakeLivingItemFromIndex(int32 Index);
	struct FLivingItemEnum MakeLivingItemEnum(const struct FLivingItemEnum& Enum);
	struct FLivingItemRowHandle MakeLivingItem(class FName RowName);
	struct FLivingItemRowHandle MakeLiteralLivingItem(const struct FLivingItemRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FLivingItemEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLivingItemStruct(const struct FLivingItemRowHandle& RowHandle, struct FLivingItemData* LivingItem, enum class EValid* Paths);
	bool EqualEqual_FLivingItemRowHandleFLivingItemRowHandle(const struct FLivingItemRowHandle& RowHandleA, const struct FLivingItemRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLivingItemEnum& A, const struct FLivingItemEnum& B);
	struct FLivingItemRowHandle CastToLivingItemRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLivingItemEnum(const struct FLivingItemEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLivingItemTable(class FName Name, const struct FLivingItemData& Data, struct FLivingItemRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.LivingItemShopItemsLibrary
class ULivingItemShopItemsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULivingItemShopItemsLibrary* GetDefaultObj();

	struct FLivingItemShopItemsRowHandle StructToRowHandle(const struct FLivingItemShopItemsEnum& EnumValue);
	class FName StructToName(const struct FLivingItemShopItemsEnum& EnumValue);
	int32 StructToInt(const struct FLivingItemShopItemsEnum& EnumValue);
	struct FLivingItemShopItemsEnum RowHandleToStruct(const struct FLivingItemShopItemsRowHandle& RowHandle);
	void RemoveRowFromLivingItemShopItemsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLivingItemShopItemsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLivingItemShopItemsEnum& A, const struct FLivingItemShopItemsEnum& B);
	struct FLivingItemShopItemsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLivingItemShopItemsRowHandle MakeLivingItemShopItemsFromIndex(int32 Index);
	struct FLivingItemShopItemsEnum MakeLivingItemShopItemsEnum(const struct FLivingItemShopItemsEnum& Enum);
	struct FLivingItemShopItemsRowHandle MakeLivingItemShopItems(class FName RowName);
	struct FLivingItemShopItemsRowHandle MakeLiteralLivingItemShopItems(const struct FLivingItemShopItemsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FLivingItemShopItemsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLivingItemShopItemsStruct(const struct FLivingItemShopItemsRowHandle& RowHandle, struct FLivingItemShopItemData* LivingItemShopItems, enum class EValid* Paths);
	bool EqualEqual_FLivingItemShopItemsRowHandleFLivingItemShopItemsRowHandle(const struct FLivingItemShopItemsRowHandle& RowHandleA, const struct FLivingItemShopItemsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLivingItemShopItemsEnum& A, const struct FLivingItemShopItemsEnum& B);
	struct FLivingItemShopItemsRowHandle CastToLivingItemShopItemsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLivingItemShopItemsEnum(const struct FLivingItemShopItemsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLivingItemShopItemsTable(class FName Name, const struct FLivingItemShopItemData& Data, struct FLivingItemShopItemsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LivingItemShopItemsTable
class ULivingItemShopItemsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULivingItemShopItemsTable* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LivingItemTable
class ULivingItemTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULivingItemTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.LivingItemUpgradesLibrary
class ULivingItemUpgradesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULivingItemUpgradesLibrary* GetDefaultObj();

	struct FLivingItemUpgradesRowHandle StructToRowHandle(const struct FLivingItemUpgradesEnum& EnumValue);
	class FName StructToName(const struct FLivingItemUpgradesEnum& EnumValue);
	int32 StructToInt(const struct FLivingItemUpgradesEnum& EnumValue);
	struct FLivingItemUpgradesEnum RowHandleToStruct(const struct FLivingItemUpgradesRowHandle& RowHandle);
	void RemoveRowFromLivingItemUpgradesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLivingItemUpgradesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLivingItemUpgradesEnum& A, const struct FLivingItemUpgradesEnum& B);
	struct FLivingItemUpgradesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLivingItemUpgradesRowHandle MakeLivingItemUpgradesFromIndex(int32 Index);
	struct FLivingItemUpgradesEnum MakeLivingItemUpgradesEnum(const struct FLivingItemUpgradesEnum& Enum);
	struct FLivingItemUpgradesRowHandle MakeLivingItemUpgrades(class FName RowName);
	struct FLivingItemUpgradesRowHandle MakeLiteralLivingItemUpgrades(const struct FLivingItemUpgradesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FLivingItemUpgradesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLivingItemUpgradesStruct(const struct FLivingItemUpgradesRowHandle& RowHandle, struct FLivingItemUpgradeData* LivingItemUpgrades, enum class EValid* Paths);
	bool EqualEqual_FLivingItemUpgradesRowHandleFLivingItemUpgradesRowHandle(const struct FLivingItemUpgradesRowHandle& RowHandleA, const struct FLivingItemUpgradesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLivingItemUpgradesEnum& A, const struct FLivingItemUpgradesEnum& B);
	struct FLivingItemUpgradesRowHandle CastToLivingItemUpgradesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLivingItemUpgradesEnum(const struct FLivingItemUpgradesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLivingItemUpgradesTable(class FName Name, const struct FLivingItemUpgradeData& Data, struct FLivingItemUpgradesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LivingItemUpgradesTable
class ULivingItemUpgradesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULivingItemUpgradesTable* GetDefaultObj();

};

// 0xB8 (0xF0 - 0x38)
// Class Icarus.LoadingScreenSettings
class ULoadingScreenSettings : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UUserWidget>             DefaultLoadingScreenWidget;                        // 0x38(0x28)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UUserWidget>             InBetweenLoadingScreenWidget;                      // 0x60(0x28)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftClassPtr<class UUserWidget>> PerLevelLoadingScreens;                            // 0x88(0x50)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                        MinimumLoadingScreenDisplayTime;                   // 0xD8(0x4)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        PostLoadFadeInDuration;                            // 0xDC(0x4)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                        InBetweenLoadingVideos;                            // 0xE0(0x10)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ULoadingScreenSettings* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.LoadingScreenInterface
class ILoadingScreenInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ILoadingScreenInterface* GetDefaultObj();

	void InitLoadingScreen(const class FString& LevelName);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.LogCategoriesLibrary
class ULogCategoriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class ULogCategoriesLibrary* GetDefaultObj();

	struct FLogCategoriesRowHandle StructToRowHandle(const struct FLogCategoriesEnum& EnumValue);
	class FName StructToName(const struct FLogCategoriesEnum& EnumValue);
	int32 StructToInt(const struct FLogCategoriesEnum& EnumValue);
	struct FLogCategoriesEnum RowHandleToStruct(const struct FLogCategoriesRowHandle& RowHandle);
	void RemoveRowFromLogCategoriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FLogCategoriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FLogCategoriesEnum& A, const struct FLogCategoriesEnum& B);
	struct FLogCategoriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FLogCategoriesRowHandle MakeLogCategoriesFromIndex(int32 Index);
	struct FLogCategoriesEnum MakeLogCategoriesEnum(const struct FLogCategoriesEnum& Enum);
	struct FLogCategoriesRowHandle MakeLogCategories(class FName RowName);
	struct FLogCategoriesRowHandle MakeLiteralLogCategories(const struct FLogCategoriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FLogCategoriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetLogCategoriesStruct(const struct FLogCategoriesRowHandle& RowHandle, struct FIcarusLogCategory* LogCategories, enum class EValid* Paths);
	bool EqualEqual_FLogCategoriesRowHandleFLogCategoriesRowHandle(const struct FLogCategoriesRowHandle& RowHandleA, const struct FLogCategoriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FLogCategoriesEnum& A, const struct FLogCategoriesEnum& B);
	struct FLogCategoriesRowHandle CastToLogCategoriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakLogCategoriesEnum(const struct FLogCategoriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToLogCategoriesTable(class FName Name, const struct FIcarusLogCategory& Data, struct FLogCategoriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.LogCategoriesTable
class ULogCategoriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class ULogCategoriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MapIconsLibrary
class UMapIconsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMapIconsLibrary* GetDefaultObj();

	struct FMapIconsRowHandle StructToRowHandle(const struct FMapIconsEnum& EnumValue);
	class FName StructToName(const struct FMapIconsEnum& EnumValue);
	int32 StructToInt(const struct FMapIconsEnum& EnumValue);
	struct FMapIconsEnum RowHandleToStruct(const struct FMapIconsRowHandle& RowHandle);
	void RemoveRowFromMapIconsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMapIconsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMapIconsEnum& A, const struct FMapIconsEnum& B);
	struct FMapIconsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMapIconsRowHandle MakeMapIconsFromIndex(int32 Index);
	struct FMapIconsEnum MakeMapIconsEnum(const struct FMapIconsEnum& Enum);
	struct FMapIconsRowHandle MakeMapIcons(class FName RowName);
	struct FMapIconsRowHandle MakeLiteralMapIcons(const struct FMapIconsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMapIconsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMapIconsStruct(const struct FMapIconsRowHandle& RowHandle, struct FMapIconsData* MapIcons, enum class EValid* Paths);
	bool EqualEqual_FMapIconsRowHandleFMapIconsRowHandle(const struct FMapIconsRowHandle& RowHandleA, const struct FMapIconsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMapIconsEnum& A, const struct FMapIconsEnum& B);
	struct FMapIconsRowHandle CastToMapIconsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMapIconsEnum(const struct FMapIconsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMapIconsTable(class FName Name, const struct FMapIconsData& Data, struct FMapIconsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MapIconsTable
class UMapIconsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMapIconsTable* GetDefaultObj();

};

// 0x90 (0x2B0 - 0x220)
// Class Icarus.MapManagerBase
class AMapManagerBase : public AActor
{
public:
	struct FTransform                            MapCorner;                                         // 0x220(0x30)(Edit, BlueprintVisible, Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                        TileSize;                                          // 0x250(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8323[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FRadarV3ScanData>              RadarV3Scans;                                      // 0x258(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMapRow>                       FogData;                                           // 0x268(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                        Pad_8324[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        UpdateFogTime;                                     // 0x290(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        SaveFogDataTime;                                   // 0x294(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8325[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UMapManagerRecorderComponent*          Recorder;                                          // 0x2A0(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8326[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AMapManagerBase* GetDefaultObj();

	void WorldSpaceToTile(const struct FVector& WorldSpaceLocation, int32* X, int32* Y);
	void UpdatePendingFOWDrawLocations(TArray<struct FVector>& LocationArrayToUpdate);
	void UpdateFog();
	void TryInitFogData();
	bool ShouldDrawFOWLocations(TArray<struct FVector>& NewLocations, TArray<struct FVector>& OldLocations);
	void SaveToDatabase(TMap<struct FIntPoint, int32>& TileFlags);
	void RestoreFromDatabase(TMap<struct FIntPoint, int32>& TileFlags, TArray<struct FRadarV3ScanData>& RadarScans);
	struct FVector RadarTileToWorldLocation(int32 X, int32 Y);
	void CheckSaveFogData();
};

// 0x60 (0x138 - 0xD8)
// Class Icarus.MapManagerRecorderComponent
class UMapManagerRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	struct FMapManagerRecord                     Record;                                            // 0xD8(0x60)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UMapManagerRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MapSearchAreaLibrary
class UMapSearchAreaLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMapSearchAreaLibrary* GetDefaultObj();

	struct FMapSearchAreaRowHandle StructToRowHandle(const struct FMapSearchAreaEnum& EnumValue);
	class FName StructToName(const struct FMapSearchAreaEnum& EnumValue);
	int32 StructToInt(const struct FMapSearchAreaEnum& EnumValue);
	struct FMapSearchAreaEnum RowHandleToStruct(const struct FMapSearchAreaRowHandle& RowHandle);
	void RemoveRowFromMapSearchAreaTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMapSearchAreaEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMapSearchAreaEnum& A, const struct FMapSearchAreaEnum& B);
	struct FMapSearchAreaEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMapSearchAreaRowHandle MakeMapSearchAreaFromIndex(int32 Index);
	struct FMapSearchAreaEnum MakeMapSearchAreaEnum(const struct FMapSearchAreaEnum& Enum);
	struct FMapSearchAreaRowHandle MakeMapSearchArea(class FName RowName);
	struct FMapSearchAreaRowHandle MakeLiteralMapSearchArea(const struct FMapSearchAreaRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMapSearchAreaEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMapSearchAreaStruct(const struct FMapSearchAreaRowHandle& RowHandle, struct FMapSearchArea* MapSearchArea, enum class EValid* Paths);
	bool EqualEqual_FMapSearchAreaRowHandleFMapSearchAreaRowHandle(const struct FMapSearchAreaRowHandle& RowHandleA, const struct FMapSearchAreaRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMapSearchAreaEnum& A, const struct FMapSearchAreaEnum& B);
	struct FMapSearchAreaRowHandle CastToMapSearchAreaRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMapSearchAreaEnum(const struct FMapSearchAreaEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMapSearchAreaTable(class FName Name, const struct FMapSearchArea& Data, struct FMapSearchAreaRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x20 (0x2E0 - 0x2C0)
// Class Icarus.MapSearchAreaProxy
class AMapSearchAreaProxy : public AIcarusActor
{
public:
	float                                        Radius;                                            // 0x2C0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapSearchAreaRowHandle               SearchArea;                                        // 0x2C4(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8332[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AMapSearchAreaProxy* GetDefaultObj();

};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.MapSearchAreaRecorder
class UMapSearchAreaRecorder : public UActorStateRecorderComponent
{
public:
	class FName                                  MapSearchAreaName;                                 // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        Radius;                                            // 0x1B0(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8333[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UMapSearchAreaRecorder* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MapSearchAreaTable
class UMapSearchAreaTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMapSearchAreaTable* GetDefaultObj();

};

// 0x70 (0xA0 - 0x30)
// Class Icarus.MapSubsystem
class UMapSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnMapIconsUpdated;                                 // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMapIconVisibilityChanged;                        // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UUserWidget*, class UIcarusMapIconComponent*> RegisteredMapIcons;                                // 0x50(0x50)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UMapSubsystem* GetDefaultObj();

	void UpdateWidgetVisibility();
	void UpdateSingleWidgetVisibility(class UUserWidget** MapWidget, class UIcarusMapIconComponent* IconComponent);
	bool ShouldMapIconBeVisible(class UIcarusMapIconComponent* MapIconComponent);
	void RegisterIcon(class UIcarusMapIconComponent* Component);
	void GetMapIconWidgets(TArray<class UUserWidget*>* OutMapIconWidgets);
	void DeregisterIcon(class UIcarusMapIconComponent* Component);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MasterAccolade
class UMasterAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UMasterAccolade* GetDefaultObj();

};

// 0x2F8 (0x328 - 0x30)
// Class Icarus.MatchmakingSubsystem
class UMatchmakingSubsystem : public UGameInstanceSubsystem
{
public:
	class UCancelFindSessionsCallbackProxy*      CancelFindSessionsCallbackProxy;                   // 0x30(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8339[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnFindFriendInstance;                              // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFriendSessionsUpdated;                           // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFriendSessionsCleared;                           // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_833A[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFindFriendSessionCallbackProxy*       FindFriendSessionCallbackProxy;                    // 0x78(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                FindFriendUserId;                                  // 0x80(0x10)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UIcarusSessionResult*> FriendSessions;                                    // 0x90(0x50)(NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_            OnFindServerInstance;                              // 0xE0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDedicatedSessionsUpdated;                        // 0xF0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDedicatedSessionsCleared;                        // 0x100(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_833B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFindSessionsCallbackProxyAdvanced*    FindSessionsCallbackProxy;                         // 0x118(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIcarusSessionResult*>          MultiplayerSessions;                               // 0x120(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_833C[0x28];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class AIcarusPlayerController*               PlayerController;                                  // 0x158(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AIcarusPlayerState*                    PlayerState;                                       // 0x160(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIcarusSession                        ActiveSession;                                     // 0x168(0x1B0)(NativeAccessSpecifierPrivate)
	TArray<class UProspectHistoryResult*>        ProspectHistory;                                   // 0x318(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UMatchmakingSubsystem* GetDefaultObj();

	void SetSteamSearchType(enum class ESteamSearchType SearchType);
	void SetDedicatedQueryFilters(TArray<struct FSessionsSearchSetting>& InFilters);
	void SetCurrentSearchType(enum class ESessionSearchType SearchType);
	bool RemoveFavoriteServer(class UIcarusSessionResult* Server, bool bIsHistory);
	void RefreshFriendSessions();
	void RefreshDedicatedSessions();
	void OnPlayerControllerFriendsUpdated(class AIcarusPlayerController* RegisteredController);
	void OnInstanceReturned(struct FBlueprintSessionResult& Result);
	void OnFindFriendSessionResult(TArray<struct FBlueprintSessionResult>& Result);
	void OnFindDedicatedSessionsSuccess(TArray<struct FBlueprintSessionResult>& Result);
	void OnFindDedicatedSessionsFailure(TArray<struct FBlueprintSessionResult>& Result);
	void OnCancelFindSessions();
	bool IsFindFriendSessionsRunning();
	bool IsFindDedicatedSessionsRunning();
	bool IsFavoriteServer(class UIcarusSessionResult* Server);
	TArray<class UIcarusSessionResult*> GetSessions(enum class ESessionSearchType SearchType, struct FSessionQuery& QuerySettings);
	TArray<class UProspectHistoryResult*> GetProspectHistory();
	enum class ESessionSearchType GetCurrentSearchType();
	struct FIcarusSession GetActiveSession();
	void CancelFindSessions(bool bClearResults, bool bSearchAfter);
	bool AddFavoriteServer(class UIcarusSessionResult* Server, bool bIsHistory);
};

// 0x10 (0x238 - 0x228)
// Class Icarus.MegaTreeAudioVolume
class AMegaTreeAudioVolume : public ATriggerBox
{
public:
	uint8                                        Pad_833F[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AMegaTreeAudioVolume* GetDefaultObj();

	void Update();
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
};

// 0x60 (0x90 - 0x30)
// Class Icarus.MegaTreePrefabAsset
class UMegaTreePrefabAsset : public UActorPrefabAsset
{
public:
	TArray<struct FPrefabStaticMesh>             StaticMeshes;                                      // 0x30(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrefabFoliage>                Foliage;                                           // 0x40(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrefabTriggerBox                     AudioVolume;                                       // 0x50(0x40)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UMegaTreePrefabAsset* GetDefaultObj();

};

// 0x8 (0x228 - 0x220)
// Class Icarus.MegaTreePrefab
class AMegaTreePrefab : public AActorPrefab
{
public:
	class UMegaTreePrefabAsset*                  PrefabAsset;                                       // 0x220(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AMegaTreePrefab* GetDefaultObj();

};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.MeshableComponent
class UMeshableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UMeshableComponent* GetDefaultObj();

	bool GetMeshableData(struct FMeshableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MeshableLibrary
class UMeshableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMeshableLibrary* GetDefaultObj();

	struct FMeshableRowHandle StructToRowHandle(const struct FMeshableEnum& EnumValue);
	class FName StructToName(const struct FMeshableEnum& EnumValue);
	int32 StructToInt(const struct FMeshableEnum& EnumValue);
	struct FMeshableEnum RowHandleToStruct(const struct FMeshableRowHandle& RowHandle);
	void RemoveRowFromMeshableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMeshableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMeshableEnum& A, const struct FMeshableEnum& B);
	struct FMeshableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMeshableRowHandle MakeMeshableFromIndex(int32 Index);
	struct FMeshableEnum MakeMeshableEnum(const struct FMeshableEnum& Enum);
	struct FMeshableRowHandle MakeMeshable(class FName RowName);
	struct FMeshableRowHandle MakeLiteralMeshable(const struct FMeshableRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMeshableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMeshableStruct(const struct FMeshableRowHandle& RowHandle, struct FMeshableData* Meshable, enum class EValid* Paths);
	bool EqualEqual_FMeshableRowHandleFMeshableRowHandle(const struct FMeshableRowHandle& RowHandleA, const struct FMeshableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMeshableEnum& A, const struct FMeshableEnum& B);
	struct FMeshableRowHandle CastToMeshableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMeshableEnum(const struct FMeshableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMeshableTable(class FName Name, const struct FMeshableData& Data, struct FMeshableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MeshableTable
class UMeshableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMeshableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MetaCurrencyLibrary
class UMetaCurrencyLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMetaCurrencyLibrary* GetDefaultObj();

	struct FMetaCurrencyRowHandle StructToRowHandle(const struct FMetaCurrencyEnum& EnumValue);
	class FName StructToName(const struct FMetaCurrencyEnum& EnumValue);
	int32 StructToInt(const struct FMetaCurrencyEnum& EnumValue);
	struct FMetaCurrencyEnum RowHandleToStruct(const struct FMetaCurrencyRowHandle& RowHandle);
	void RemoveRowFromMetaCurrencyTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMetaCurrencyEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMetaCurrencyEnum& A, const struct FMetaCurrencyEnum& B);
	struct FMetaCurrencyEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMetaCurrencyRowHandle MakeMetaCurrencyFromIndex(int32 Index);
	struct FMetaCurrencyEnum MakeMetaCurrencyEnum(const struct FMetaCurrencyEnum& Enum);
	struct FMetaCurrencyRowHandle MakeMetaCurrency(class FName RowName);
	struct FMetaCurrencyRowHandle MakeLiteralMetaCurrency(const struct FMetaCurrencyRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMetaCurrencyEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMetaCurrencyStruct(const struct FMetaCurrencyRowHandle& RowHandle, struct FMetaCurrency* MetaCurrency, enum class EValid* Paths);
	bool EqualEqual_FMetaCurrencyRowHandleFMetaCurrencyRowHandle(const struct FMetaCurrencyRowHandle& RowHandleA, const struct FMetaCurrencyRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMetaCurrencyEnum& A, const struct FMetaCurrencyEnum& B);
	struct FMetaCurrencyRowHandle CastToMetaCurrencyRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMetaCurrencyEnum(const struct FMetaCurrencyEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMetaCurrencyTable(class FName Name, const struct FMetaCurrency& Data, struct FMetaCurrencyRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MetaCurrencyTable
class UMetaCurrencyTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMetaCurrencyTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MetaResourceNodesLibrary
class UMetaResourceNodesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMetaResourceNodesLibrary* GetDefaultObj();

	struct FMetaResourceNodesRowHandle StructToRowHandle(const struct FMetaResourceNodesEnum& EnumValue);
	class FName StructToName(const struct FMetaResourceNodesEnum& EnumValue);
	int32 StructToInt(const struct FMetaResourceNodesEnum& EnumValue);
	struct FMetaResourceNodesEnum RowHandleToStruct(const struct FMetaResourceNodesRowHandle& RowHandle);
	void RemoveRowFromMetaResourceNodesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMetaResourceNodesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMetaResourceNodesEnum& A, const struct FMetaResourceNodesEnum& B);
	struct FMetaResourceNodesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMetaResourceNodesRowHandle MakeMetaResourceNodesFromIndex(int32 Index);
	struct FMetaResourceNodesEnum MakeMetaResourceNodesEnum(const struct FMetaResourceNodesEnum& Enum);
	struct FMetaResourceNodesRowHandle MakeMetaResourceNodes(class FName RowName);
	struct FMetaResourceNodesRowHandle MakeLiteralMetaResourceNodes(const struct FMetaResourceNodesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMetaResourceNodesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMetaResourceNodesStruct(const struct FMetaResourceNodesRowHandle& RowHandle, struct FMetaResourceNodeInfo* MetaResourceNodes, enum class EValid* Paths);
	bool EqualEqual_FMetaResourceNodesRowHandleFMetaResourceNodesRowHandle(const struct FMetaResourceNodesRowHandle& RowHandleA, const struct FMetaResourceNodesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMetaResourceNodesEnum& A, const struct FMetaResourceNodesEnum& B);
	struct FMetaResourceNodesRowHandle CastToMetaResourceNodesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMetaResourceNodesEnum(const struct FMetaResourceNodesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMetaResourceNodesTable(class FName Name, const struct FMetaResourceNodeInfo& Data, struct FMetaResourceNodesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MetaResourceNodesTable
class UMetaResourceNodesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMetaResourceNodesTable* GetDefaultObj();

};

// 0x0 (0x2C0 - 0x2C0)
// Class Icarus.MetaSpawnActor
class AMetaSpawnActor : public AIcarusActor
{
public:

	static class UClass* StaticClass();
	static class AMetaSpawnActor* GetDefaultObj();

};

// 0x38 (0x2F8 - 0x2C0)
// Class Icarus.MineableResource
class AMineableResource : public AIcarusActor
{
public:
	TArray<class UDestructibleComponent*>        DestructibleComponents;                            // 0x2C0(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FItemTemplateRowHandle                DestructionItemDropType;                           // 0x2D0(0x18)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                           DestructionItemMesh;                               // 0x2E8(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8362[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AMineableResource* GetDefaultObj();

	void OnClient_DestructibleComponentDestroyed(int32 ComponentIndex);
};

// 0x30 (0x60 - 0x30)
// Class Icarus.MiningSubsystem
class UMiningSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnVoxelHitNotify;                                  // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVoxelCompletedNotify;                            // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnVoxelResourceMinedNotify;                        // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UMiningSubsystem* GetDefaultObj();

	void BroadcastVoxelResourceMinedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastVoxelHitDelegate(class AIcarusPlayerCharacter* Player, class AVoxelResource* Voxel);
	void BroadcastVoxelCompletedDelegate(class AIcarusPlayerCharacter* Player, class AVoxelResource* Voxel);
};

// 0x40 (0x70 - 0x30)
// Class Icarus.MissionSubsystem
class UMissionSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnFactionItemRemovedNotify;                        // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFactionEnterAreaNotify;                          // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDefendLeftAreaNotify;                            // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnProspectMissionCompleteNotify;                   // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UMissionSubsystem* GetDefaultObj();

	void BroadcastProspectMissionCompleteDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastFactionItemRemovedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastFactionEnterAreaDelegate(class AIcarusPlayerCharacter* Player, class AIcarusActor* Actor);
	void BroadcastDefendLeftAreaDelegate(class AIcarusActor* Actor);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ModifiableInterface
class IModifiableInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IModifiableInterface* GetDefaultObj();

	void OnModifiersUpdated(class UModifierStateComponent* ModifiedComponent, bool Removed);
	int32 GetNextUID();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ModificationBehaviour
class UModificationBehaviour : public UObject
{
public:

	static class UClass* StaticClass();
	static class UModificationBehaviour* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ModifierStateAudioDataLibrary
class UModifierStateAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UModifierStateAudioDataLibrary* GetDefaultObj();

	struct FModifierStateAudioDataRowHandle StructToRowHandle(const struct FModifierStateAudioDataEnum& EnumValue);
	class FName StructToName(const struct FModifierStateAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FModifierStateAudioDataEnum& EnumValue);
	struct FModifierStateAudioDataEnum RowHandleToStruct(const struct FModifierStateAudioDataRowHandle& RowHandle);
	void RemoveRowFromModifierStateAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FModifierStateAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FModifierStateAudioDataEnum& A, const struct FModifierStateAudioDataEnum& B);
	struct FModifierStateAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FModifierStateAudioDataRowHandle MakeModifierStateAudioDataFromIndex(int32 Index);
	struct FModifierStateAudioDataEnum MakeModifierStateAudioDataEnum(const struct FModifierStateAudioDataEnum& Enum);
	struct FModifierStateAudioDataRowHandle MakeModifierStateAudioData(class FName RowName);
	struct FModifierStateAudioDataRowHandle MakeLiteralModifierStateAudioData(const struct FModifierStateAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FModifierStateAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetModifierStateAudioDataStruct(const struct FModifierStateAudioDataRowHandle& RowHandle, struct FModifierStateAudioData* ModifierStateAudioData, enum class EValid* Paths);
	bool EqualEqual_FModifierStateAudioDataRowHandleFModifierStateAudioDataRowHandle(const struct FModifierStateAudioDataRowHandle& RowHandleA, const struct FModifierStateAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FModifierStateAudioDataEnum& A, const struct FModifierStateAudioDataEnum& B);
	struct FModifierStateAudioDataRowHandle CastToModifierStateAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakModifierStateAudioDataEnum(const struct FModifierStateAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToModifierStateAudioDataTable(class FName Name, const struct FModifierStateAudioData& Data, struct FModifierStateAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ModifierStateAudioDataTable
class UModifierStateAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UModifierStateAudioDataTable* GetDefaultObj();

};

// 0x2E0 (0x390 - 0xB0)
// Class Icarus.ModifierStateComponent
class UModifierStateComponent : public UActorComponent
{
public:
	struct FModifierStatesRowHandle              DataRowHandleNew;                                  // 0xB0(0x18)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                           Instigator;                                        // 0xC8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                Causer;                                            // 0xD0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                ReplicatedOwner;                                   // 0xD8(0x8)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IModifiableInterface> OwningModifiableInterface;                         // 0xE0(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                        ModifierUID;                                       // 0xF0(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_836F[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USceneComponent*                       CosmeticComponent;                                 // 0xF8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ModifierLifetime;                                  // 0x100(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CachedModifierLifeTimeModifier;                    // 0x104(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        RemainingTime;                                     // 0x108(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        InitialEffectivenessModifier;                      // 0x10C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        CachedFinalEffectiveness;                          // 0x110(0x4)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnModifierUpdated;                                 // 0x114(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnModifierLifetimeUpdated;                         // 0x115(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8370[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnModifierEffectivenessUpdated;                    // 0x118(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FModifierStateData                    CachedModifierStateData;                           // 0x128(0x250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_8371[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UModifierStateComponent* GetDefaultObj();

	void SetModifierLifeTime(float LifeTime);
	void SetInitialModifierEffectiveness(int32 InitialEffectiveness);
	int32 ScaleStatByEffectiveness(const struct FStatsEnum& Stat, int32 Value);
	int32 ScaleByEffectiveness(int32 Value);
	void RefreshLifetime();
	void OnStatContainerUpdated();
	void OnRep_ReplicatedOwningActor();
	void OnRep_RemainingTime();
	void OnRep_DataRowHandle();
	void OnRep_CachedFinalEffectiveness();
	void ModifierTick(float DeltaTime);
	bool ModifierRemoved();
	bool ModifierApplied();
	void InitComponent();
	struct FModifierStateData GetModifierStateData();
	int32 GetCurrentModifierEffectiveness();
	float GetCurrentLifetimeMultiplier();
	bool DoesMatchTagQuery();
	bool CheckTickConditions();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ModifierStateCondition
class UModifierStateCondition : public UObject
{
public:

	static class UClass* StaticClass();
	static class UModifierStateCondition* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ModifierStatesLibrary
class UModifierStatesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UModifierStatesLibrary* GetDefaultObj();

	struct FModifierStatesRowHandle StructToRowHandle(const struct FModifierStatesEnum& EnumValue);
	class FName StructToName(const struct FModifierStatesEnum& EnumValue);
	int32 StructToInt(const struct FModifierStatesEnum& EnumValue);
	struct FModifierStatesEnum RowHandleToStruct(const struct FModifierStatesRowHandle& RowHandle);
	void RemoveRowFromModifierStatesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FModifierStatesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FModifierStatesEnum& A, const struct FModifierStatesEnum& B);
	struct FModifierStatesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FModifierStatesRowHandle MakeModifierStatesFromIndex(int32 Index);
	struct FModifierStatesEnum MakeModifierStatesEnum(const struct FModifierStatesEnum& Enum);
	struct FModifierStatesRowHandle MakeModifierStates(class FName RowName);
	struct FModifierStatesRowHandle MakeLiteralModifierStates(const struct FModifierStatesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FModifierStatesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetModifierStatesStruct(const struct FModifierStatesRowHandle& RowHandle, struct FModifierStateData* ModifierStates, enum class EValid* Paths);
	bool EqualEqual_FModifierStatesRowHandleFModifierStatesRowHandle(const struct FModifierStatesRowHandle& RowHandleA, const struct FModifierStatesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FModifierStatesEnum& A, const struct FModifierStatesEnum& B);
	struct FModifierStatesRowHandle CastToModifierStatesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakModifierStatesEnum(const struct FModifierStatesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToModifierStatesTable(class FName Name, const struct FModifierStateData& Data, struct FModifierStatesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ModifierStatesTable
class UModifierStatesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UModifierStatesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MountsLibrary
class UMountsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMountsLibrary* GetDefaultObj();

	struct FMountsRowHandle StructToRowHandle(const struct FMountsEnum& EnumValue);
	class FName StructToName(const struct FMountsEnum& EnumValue);
	int32 StructToInt(const struct FMountsEnum& EnumValue);
	struct FMountsEnum RowHandleToStruct(const struct FMountsRowHandle& RowHandle);
	void RemoveRowFromMountsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMountsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMountsEnum& A, const struct FMountsEnum& B);
	struct FMountsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMountsRowHandle MakeMountsFromIndex(int32 Index);
	struct FMountsEnum MakeMountsEnum(const struct FMountsEnum& Enum);
	struct FMountsRowHandle MakeMounts(class FName RowName);
	struct FMountsRowHandle MakeLiteralMounts(const struct FMountsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMountsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMountsStruct(const struct FMountsRowHandle& RowHandle, struct FIcarusMount* Mounts, enum class EValid* Paths);
	bool EqualEqual_FMountsRowHandleFMountsRowHandle(const struct FMountsRowHandle& RowHandleA, const struct FMountsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMountsEnum& A, const struct FMountsEnum& B);
	struct FMountsRowHandle CastToMountsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMountsEnum(const struct FMountsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMountsTable(class FName Name, const struct FIcarusMount& Data, struct FMountsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MountsTable
class UMountsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMountsTable* GetDefaultObj();

};

// 0xB8 (0x2B0 - 0x1F8)
// Class Icarus.MultiPointAudioEmitter
class UMultiPointAudioEmitter : public USceneComponent
{
public:
	uint8                                        Pad_838C[0x88];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x280(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_838D[0x28];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UMultiPointAudioEmitter* GetDefaultObj();

	void Stop();
	void SetNodeDefaultWeighting(class UObject* NodeObject, float Weighting);
	void SetDebugActive(bool bActive);
	void RemoveNode(class UObject* NodeObject);
	void Play();
	void Initialize(class UFMODEvent* Event, bool bUseAutomaticPlayback, float MinDistanceOverride, float MaxDistanceOverride, bool bNodesAreStatic);
	float GetTotalWeighting();
	class UFMODAudioComponent* GetAudioComponent();
	void AddNode(class UObject* NodeObject, bool bRemoveNodeOnZeroWeighting);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MultiPointAudioNodeInterface
class IMultiPointAudioNodeInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IMultiPointAudioNodeInterface* GetDefaultObj();

	float GetMultiPointAudioWeighting();
	struct FVector GetMultiPointAudioLocation();
};

// 0x10 (0x50 - 0x40)
// Class Icarus.MultiPointAudioSubsystem
class UMultiPointAudioSubsystem : public UTickableWorldSubsystem
{
public:
	uint8                                        Pad_838E[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UMultiPointAudioSubsystem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MultiTalentAccolade
class UMultiTalentAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UMultiTalentAccolade* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MusicLocationConditionsLibrary
class UMusicLocationConditionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMusicLocationConditionsLibrary* GetDefaultObj();

	struct FMusicLocationConditionsRowHandle StructToRowHandle(const struct FMusicLocationConditionsEnum& EnumValue);
	class FName StructToName(const struct FMusicLocationConditionsEnum& EnumValue);
	int32 StructToInt(const struct FMusicLocationConditionsEnum& EnumValue);
	struct FMusicLocationConditionsEnum RowHandleToStruct(const struct FMusicLocationConditionsRowHandle& RowHandle);
	void RemoveRowFromMusicLocationConditionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMusicLocationConditionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMusicLocationConditionsEnum& A, const struct FMusicLocationConditionsEnum& B);
	struct FMusicLocationConditionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMusicLocationConditionsRowHandle MakeMusicLocationConditionsFromIndex(int32 Index);
	struct FMusicLocationConditionsEnum MakeMusicLocationConditionsEnum(const struct FMusicLocationConditionsEnum& Enum);
	struct FMusicLocationConditionsRowHandle MakeMusicLocationConditions(class FName RowName);
	struct FMusicLocationConditionsRowHandle MakeLiteralMusicLocationConditions(const struct FMusicLocationConditionsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMusicLocationConditionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMusicLocationConditionsStruct(const struct FMusicLocationConditionsRowHandle& RowHandle, struct FMusicLocationCondition* MusicLocationConditions, enum class EValid* Paths);
	bool EqualEqual_FMusicLocationConditionsRowHandleFMusicLocationConditionsRowHandle(const struct FMusicLocationConditionsRowHandle& RowHandleA, const struct FMusicLocationConditionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMusicLocationConditionsEnum& A, const struct FMusicLocationConditionsEnum& B);
	struct FMusicLocationConditionsRowHandle CastToMusicLocationConditionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMusicLocationConditionsEnum(const struct FMusicLocationConditionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMusicLocationConditionsTable(class FName Name, const struct FMusicLocationCondition& Data, struct FMusicLocationConditionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MusicLocationConditionsTable
class UMusicLocationConditionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMusicLocationConditionsTable* GetDefaultObj();

};

// 0x88 (0xB0 - 0x28)
// Class Icarus.MusicPlayer
class UMusicPlayer : public UObject
{
public:
	uint8                                        Pad_839A[0x38];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UCurveFloat*                           FadeCurve;                                         // 0x60(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_839B[0x48];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UMusicPlayer* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MusicQuestConditionsLibrary
class UMusicQuestConditionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMusicQuestConditionsLibrary* GetDefaultObj();

	struct FMusicQuestConditionsRowHandle StructToRowHandle(const struct FMusicQuestConditionsEnum& EnumValue);
	class FName StructToName(const struct FMusicQuestConditionsEnum& EnumValue);
	int32 StructToInt(const struct FMusicQuestConditionsEnum& EnumValue);
	struct FMusicQuestConditionsEnum RowHandleToStruct(const struct FMusicQuestConditionsRowHandle& RowHandle);
	void RemoveRowFromMusicQuestConditionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMusicQuestConditionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMusicQuestConditionsEnum& A, const struct FMusicQuestConditionsEnum& B);
	struct FMusicQuestConditionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMusicQuestConditionsRowHandle MakeMusicQuestConditionsFromIndex(int32 Index);
	struct FMusicQuestConditionsEnum MakeMusicQuestConditionsEnum(const struct FMusicQuestConditionsEnum& Enum);
	struct FMusicQuestConditionsRowHandle MakeMusicQuestConditions(class FName RowName);
	struct FMusicQuestConditionsRowHandle MakeLiteralMusicQuestConditions(const struct FMusicQuestConditionsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMusicQuestConditionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMusicQuestConditionsStruct(const struct FMusicQuestConditionsRowHandle& RowHandle, struct FMusicQuestCondition* MusicQuestConditions, enum class EValid* Paths);
	bool EqualEqual_FMusicQuestConditionsRowHandleFMusicQuestConditionsRowHandle(const struct FMusicQuestConditionsRowHandle& RowHandleA, const struct FMusicQuestConditionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMusicQuestConditionsEnum& A, const struct FMusicQuestConditionsEnum& B);
	struct FMusicQuestConditionsRowHandle CastToMusicQuestConditionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMusicQuestConditionsEnum(const struct FMusicQuestConditionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMusicQuestConditionsTable(class FName Name, const struct FMusicQuestCondition& Data, struct FMusicQuestConditionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MusicQuestConditionsTable
class UMusicQuestConditionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMusicQuestConditionsTable* GetDefaultObj();

};

// 0xC0 (0xF0 - 0x30)
// Class Icarus.MusicSubsystem
class UMusicSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                        Pad_83A7[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UMusicPlayer*>                  MusicPlayers;                                      // 0x38(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83A8[0x58];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FMusicTrackStateGroupsRowHandle, int32> TrackStates;                                       // 0xA0(0x50)(NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UMusicSubsystem* GetDefaultObj();

	void StopMusic();
	void StartMusic();
	void SetTrackState(const struct FMusicTrackStateGroupsRowHandle& StateGroup, int32 StateIndex);
	void SetConfig(struct FMusicSubsystemConfig& Config);
	void SetConditionWeather(enum class EMusicConditionWeather NewWeather);
	void SetConditionTimeOfDay(enum class EMusicConditionTimeOfDay NewTimeOfDay);
	void SetConditionQuest(const struct FMusicQuestConditionsRowHandle& NewQuest);
	void SetConditionPlayerState(enum class EMusicConditionPlayerState NewPlayerState);
	void SetConditionLocation(const struct FMusicLocationConditionsRowHandle& NewLocation);
	void SetConditionGameplayEvent(enum class EMusicConditionGameplayEvent GameplayEvent);
	void SetConditionDropTime(enum class EMusicConditionDropTime NewDropTime);
	void SetConditionDropState(enum class EMusicConditionDropState NewDropState);
	void SetConditionDisaster(enum class EMusicConditionDisaster NewDisaster);
	void SetConditionCombatState(enum class EMusicConditionCombatState NewCombatState);
	void SetAutoTrackChangeEnabled(bool bEnabled);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MusicTracksLibrary
class UMusicTracksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMusicTracksLibrary* GetDefaultObj();

	struct FMusicTracksRowHandle StructToRowHandle(const struct FMusicTracksEnum& EnumValue);
	class FName StructToName(const struct FMusicTracksEnum& EnumValue);
	int32 StructToInt(const struct FMusicTracksEnum& EnumValue);
	struct FMusicTracksEnum RowHandleToStruct(const struct FMusicTracksRowHandle& RowHandle);
	void RemoveRowFromMusicTracksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMusicTracksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMusicTracksEnum& A, const struct FMusicTracksEnum& B);
	struct FMusicTracksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMusicTracksRowHandle MakeMusicTracksFromIndex(int32 Index);
	struct FMusicTracksEnum MakeMusicTracksEnum(const struct FMusicTracksEnum& Enum);
	struct FMusicTracksRowHandle MakeMusicTracks(class FName RowName);
	struct FMusicTracksRowHandle MakeLiteralMusicTracks(const struct FMusicTracksRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMusicTracksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMusicTracksStruct(const struct FMusicTracksRowHandle& RowHandle, struct FMusicTrack* MusicTracks, enum class EValid* Paths);
	bool EqualEqual_FMusicTracksRowHandleFMusicTracksRowHandle(const struct FMusicTracksRowHandle& RowHandleA, const struct FMusicTracksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMusicTracksEnum& A, const struct FMusicTracksEnum& B);
	struct FMusicTracksRowHandle CastToMusicTracksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMusicTracksEnum(const struct FMusicTracksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMusicTracksTable(class FName Name, const struct FMusicTrack& Data, struct FMusicTracksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MusicTracksTable
class UMusicTracksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMusicTracksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.MusicTrackStateGroupsLibrary
class UMusicTrackStateGroupsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UMusicTrackStateGroupsLibrary* GetDefaultObj();

	struct FMusicTrackStateGroupsRowHandle StructToRowHandle(const struct FMusicTrackStateGroupsEnum& EnumValue);
	class FName StructToName(const struct FMusicTrackStateGroupsEnum& EnumValue);
	int32 StructToInt(const struct FMusicTrackStateGroupsEnum& EnumValue);
	struct FMusicTrackStateGroupsEnum RowHandleToStruct(const struct FMusicTrackStateGroupsRowHandle& RowHandle);
	void RemoveRowFromMusicTrackStateGroupsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FMusicTrackStateGroupsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FMusicTrackStateGroupsEnum& A, const struct FMusicTrackStateGroupsEnum& B);
	struct FMusicTrackStateGroupsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FMusicTrackStateGroupsRowHandle MakeMusicTrackStateGroupsFromIndex(int32 Index);
	struct FMusicTrackStateGroupsEnum MakeMusicTrackStateGroupsEnum(const struct FMusicTrackStateGroupsEnum& Enum);
	struct FMusicTrackStateGroupsRowHandle MakeMusicTrackStateGroups(class FName RowName);
	struct FMusicTrackStateGroupsRowHandle MakeLiteralMusicTrackStateGroups(const struct FMusicTrackStateGroupsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FMusicTrackStateGroupsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetMusicTrackStateGroupsStruct(const struct FMusicTrackStateGroupsRowHandle& RowHandle, struct FMusicTrackStateGroup* MusicTrackStateGroups, enum class EValid* Paths);
	bool EqualEqual_FMusicTrackStateGroupsRowHandleFMusicTrackStateGroupsRowHandle(const struct FMusicTrackStateGroupsRowHandle& RowHandleA, const struct FMusicTrackStateGroupsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FMusicTrackStateGroupsEnum& A, const struct FMusicTrackStateGroupsEnum& B);
	struct FMusicTrackStateGroupsRowHandle CastToMusicTrackStateGroupsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakMusicTrackStateGroupsEnum(const struct FMusicTrackStateGroupsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToMusicTrackStateGroupsTable(class FName Name, const struct FMusicTrackStateGroup& Data, struct FMusicTrackStateGroupsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.MusicTrackStateGroupsTable
class UMusicTrackStateGroupsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UMusicTrackStateGroupsTable* GetDefaultObj();

};

// 0x28 (0x4A0 - 0x478)
// Class Icarus.MusicTrackStateTriggerComponent
class UMusicTrackStateTriggerComponent : public UBoxComponent
{
public:
	struct FMusicTrackStateGroupsRowHandle       TrackStateGroup;                                   // 0x478(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        StateValue;                                        // 0x490(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_83C0[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UMusicTrackStateTriggerComponent* GetDefaultObj();

	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.MutableGameplayTagInterface
class IMutableGameplayTagInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IMutableGameplayTagInterface* GetDefaultObj();

	void SetGameplayTags(struct FGameplayTagContainer& InGameplayTags);
	struct FGameplayTagContainer GetGameplayTags();
};

// 0x0 (0x4E0 - 0x4E0)
// Class Icarus.NavBlockingStaticMeshComponent
class UNavBlockingStaticMeshComponent : public UStaticMeshComponent
{
public:

	static class UClass* StaticClass();
	static class UNavBlockingStaticMeshComponent* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.NetworkProxyComponent
class UNetworkProxyComponent : public UActorComponent
{
public:
	uint8                                        Pad_83CD[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UNetworkProxyComponent* GetDefaultObj();

	void Proxy_SortInventory(class UInventory* Inventory, enum class EInventorySortType SortType);
	void CheatingNotification();
	void Cheat_UnlockCharacterAllFlags();
	void Cheat_SetWater(int32 Water, bool bPercent);
	void Cheat_SetStamina(int32 Stamina, bool bPercent);
	void Cheat_SetServerTimeDilation(float TimeDilation);
	void Cheat_SetOxygen(int32 Oxygen, bool bPercent);
	void Cheat_SetHealth(int32 Health, bool bPercent);
	void Cheat_SetFood(int32 Food, bool bPercent);
	void Cheat_SetBodyTemperature(float Value);
	void Cheat_ClearStats();
	void Cheat_ClearInventory();
	void Cheat_AddWater(int32 Water, bool bPercent);
	void Cheat_AddStat(const struct FStatsEnum& Stat, int32 Value);
	void Cheat_AddStamina(int32 Stamina, bool bPercent);
	void Cheat_AddOxygen(int32 Oxygen, bool bPercent);
	void Cheat_AddHealth(int32 Health, bool bPercent);
	void Cheat_AddFood(int32 Food, bool bPercent);
	void Cheat_AddExperienceDebt(int32 Value);
	void Cheat_AddExperience(int32 Value);
};

// 0x28 (0x58 - 0x30)
// Class Icarus.NotificationSubsystem
class UNotificationSubsystem : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnNotificationsUpdated;                            // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AIcarusPlayerController*               PlayerController;                                  // 0x40(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FNotification>                 Notifications;                                     // 0x48(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UNotificationSubsystem* GetDefaultObj();

	void RefreshNotifications();
	void NotificationsUpdated();
	TArray<struct FNotification> GetUnseenNotifications();
	TArray<struct FNotification> GetNotifications();
};

// 0x30 (0x2F0 - 0x2C0)
// Class Icarus.ObjectSlot
class AObjectSlot : public AIcarusActor
{
public:
	enum class EObjectSlotType                   SlotType;                                          // 0x2C0(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_83D0[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UHighlightableComponent*               HighlightableComponent;                            // 0x2C8(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                InteractableComponent;                             // 0x2D0(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADeployable*                           AttachedActor;                                     // 0x2D8(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AObjectSlot*                           LinkedSlot;                                        // 0x2E0(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLinkEstablished;                                 // 0x2E8(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnLinkDestroyed;                                   // 0x2E9(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_83D1[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AObjectSlot* GetDefaultObj();

	bool UpdateVisibility();
	void OnServer_UnlinkSlots();
	void OnServer_LinkSlots(class AObjectSlot* SlotToConnect);
	bool OnServer_Interact(class AActor* Interactor, struct FHitResult& HitResult);
	void OnInteraction(class AActor* Interactor, struct FHitResult& HitResult);
	class UInventoryComponent* GetSlotInventory();
	bool CanLink(class AObjectSlot* SlotToConnect);
};

// 0x2C0 (0x2E8 - 0x28)
// Class Icarus.OfflineAccountMigrator
class UOfflineAccountMigrator : public UObject
{
public:
	enum class EMigrationStep                    CurrentMigrationStep;                              // 0x28(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_83D2[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnMigrationSuccess;                                // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMigrationFailed;                                 // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_83D3[0x78];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetUserProfileCallbackProxyGen*       GetUserProfileCallbackProxy;                       // 0xC8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D4[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetCharactersCallbackProxyGen*        GetCharactersCallbackProxy;                        // 0xD8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D5[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetAllProspectsCallbackProxyGen*      GetProspectsCallbackProxy;                         // 0xE8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D6[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetProspectCallbackProxyGen*          GetProspectCallbackProxy;                          // 0xF8(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D7[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetCharacterLoadoutCallbackProxyGen*  GetCharacterLoadoutCallbackProxy;                  // 0x108(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D8[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetLoadoutInventoryCallbackProxyGen*  GetLoadoutInventoryCallbackProxy;                  // 0x118(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83D9[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetPreparedLoadoutCallbackProxyGen*   GetPreparedLoadoutCallbackProxy;                   // 0x128(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DA[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UGetMetaInventoryCallbackProxyGen*     GetMetaInventoryCallbackProxy;                     // 0x138(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DB[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USyncCharacterTalentsCallbackProxyGen* SyncCharacterTalentsCallbackProxy;                 // 0x148(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DC[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FOnlineProfileUser                    DownloadedAccountData;                             // 0x158(0x48)(NativeAccessSpecifierPrivate)
	struct FOnlineProfileUser                    OfflineAccountData;                                // 0x1A0(0x48)(NativeAccessSpecifierPrivate)
	TArray<struct FOnlineProfileCharacter>       DownloadedCharacters;                              // 0x1E8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FProspectInfo>                 DownloadedProspectInfos;                           // 0x1F8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DD[0x48];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FOnlineProfileCharacter>       OfflineCharacters;                                 // 0x250(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FProspectInfo>                 OfflineProspectInfos;                              // 0x260(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DE[0x38];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FOnlineProfileCharacter>       MergedCharacters;                                  // 0x2A8(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83DF[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UOfflineAccountMigrator* GetDefaultObj();

	void SkipMigration();
	bool HasAccountDataMigrationBeenPerformed();
	void GetUserProfileTimedout();
	void GetUserProfileSuccess(struct FResGetUserProfile& Response);
	void GetUserProfileFailed(struct FResGetUserProfile& Response);
	void GetProspectBlobSuccess(struct FResGetProspect& Response);
	void GetProspectBlobFailed(struct FResGetProspect& Response);
	void GetPreparedLoadoutSuccess(struct FResPreparedLoadout& Response);
	void GetPreparedLoadoutFailed(struct FResPreparedLoadout& Response);
	void GetMetaInventorySuccess(struct FResGetMetaInventory& Response);
	void GetMetaInventoryFailed(struct FResGetMetaInventory& Response);
	void GetLoadoutInventorySuccess(struct FResLoadoutInventory& Response);
	void GetLoadoutInventoryFailed(struct FResLoadoutInventory& Response);
	void GetCharacterLoadoutSuccess(struct FResGetCharacterLoadout& Response);
	void GetCharacterLoadoutFailed(struct FResGetCharacterLoadout& Response);
	void GetAllProspectInfosSuccess(struct FResGetAllProspects& Response);
	void GetAllProspectInfosFailed(struct FResGetAllProspects& Response);
	void GetAllCharactersSuccess(struct FResGetCharacters& Response);
	void GetAllCharactersFailed(struct FResGetCharacters& Response);
	void BeginMigration(bool bForceMigration);
};

// 0x18 (0x48 - 0x30)
// Class Icarus.OfflinePackageFlagsSubsystem
class UOfflinePackageFlagsSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                        Pad_83E4[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UOfflinePackageFlagsSubsystem* GetDefaultObj();

	bool SaveFlagsToFile(const class FString& PlayerID, const TArray<int32>& AccountFlags);
	bool LoadFlagsFromFile(const class FString& PlayerID, TArray<int32>* AccountFlags);
	bool HasPackageFlag(const class FString& PlayerID, struct FDLCPackageDataRowHandle& PackageFlag);
	bool FetchAndGrantPackageFlagsForCurrentUser(const class FString& PlayerID, TArray<int32>* PackageFlags, class FString* FailReason);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.OneOffAccolade
class UOneOffAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UOneOffAccolade* GetDefaultObj();

};

// 0x38 (0x258 - 0x220)
// Class Icarus.OneShotAudio
class AOneShotAudio : public AActor
{
public:
	struct FSoftObjectPath                       EventPath;                                         // 0x220(0x18)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bUseListenerRotation;                              // 0x238(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bUseOcclusion;                                     // 0x239(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_83E5[0xE];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UAudioContextComponent*                AudioContext;                                      // 0x248(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioOcclusionComponent*              OcclusionComponent;                                // 0x250(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class AOneShotAudio* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.OrchestrationEventsLibrary
class UOrchestrationEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UOrchestrationEventsLibrary* GetDefaultObj();

	struct FOrchestrationEventsRowHandle StructToRowHandle(const struct FOrchestrationEventsEnum& EnumValue);
	class FName StructToName(const struct FOrchestrationEventsEnum& EnumValue);
	int32 StructToInt(const struct FOrchestrationEventsEnum& EnumValue);
	struct FOrchestrationEventsEnum RowHandleToStruct(const struct FOrchestrationEventsRowHandle& RowHandle);
	void RemoveRowFromOrchestrationEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FOrchestrationEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FOrchestrationEventsEnum& A, const struct FOrchestrationEventsEnum& B);
	struct FOrchestrationEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FOrchestrationEventsRowHandle MakeOrchestrationEventsFromIndex(int32 Index);
	struct FOrchestrationEventsEnum MakeOrchestrationEventsEnum(const struct FOrchestrationEventsEnum& Enum);
	struct FOrchestrationEventsRowHandle MakeOrchestrationEvents(class FName RowName);
	struct FOrchestrationEventsRowHandle MakeLiteralOrchestrationEvents(const struct FOrchestrationEventsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FOrchestrationEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetOrchestrationEventsStruct(const struct FOrchestrationEventsRowHandle& RowHandle, struct FOrchestrationEventDescription* OrchestrationEvents, enum class EValid* Paths);
	bool EqualEqual_FOrchestrationEventsRowHandleFOrchestrationEventsRowHandle(const struct FOrchestrationEventsRowHandle& RowHandleA, const struct FOrchestrationEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FOrchestrationEventsEnum& A, const struct FOrchestrationEventsEnum& B);
	struct FOrchestrationEventsRowHandle CastToOrchestrationEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakOrchestrationEventsEnum(const struct FOrchestrationEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToOrchestrationEventsTable(class FName Name, const struct FOrchestrationEventDescription& Data, struct FOrchestrationEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.OrchestrationEventsTable
class UOrchestrationEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UOrchestrationEventsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.OrchestrationStateFlagsLibrary
class UOrchestrationStateFlagsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UOrchestrationStateFlagsLibrary* GetDefaultObj();

	struct FOrchestrationStateFlagsRowHandle StructToRowHandle(const struct FOrchestrationStateFlagsEnum& EnumValue);
	class FName StructToName(const struct FOrchestrationStateFlagsEnum& EnumValue);
	int32 StructToInt(const struct FOrchestrationStateFlagsEnum& EnumValue);
	struct FOrchestrationStateFlagsEnum RowHandleToStruct(const struct FOrchestrationStateFlagsRowHandle& RowHandle);
	void RemoveRowFromOrchestrationStateFlagsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FOrchestrationStateFlagsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FOrchestrationStateFlagsEnum& A, const struct FOrchestrationStateFlagsEnum& B);
	struct FOrchestrationStateFlagsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FOrchestrationStateFlagsRowHandle MakeOrchestrationStateFlagsFromIndex(int32 Index);
	struct FOrchestrationStateFlagsEnum MakeOrchestrationStateFlagsEnum(const struct FOrchestrationStateFlagsEnum& Enum);
	struct FOrchestrationStateFlagsRowHandle MakeOrchestrationStateFlags(class FName RowName);
	struct FOrchestrationStateFlagsRowHandle MakeLiteralOrchestrationStateFlags(const struct FOrchestrationStateFlagsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FOrchestrationStateFlagsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetOrchestrationStateFlagsStruct(const struct FOrchestrationStateFlagsRowHandle& RowHandle, struct FOrchestrationStateFlag* OrchestrationStateFlags, enum class EValid* Paths);
	bool EqualEqual_FOrchestrationStateFlagsRowHandleFOrchestrationStateFlagsRowHandle(const struct FOrchestrationStateFlagsRowHandle& RowHandleA, const struct FOrchestrationStateFlagsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FOrchestrationStateFlagsEnum& A, const struct FOrchestrationStateFlagsEnum& B);
	struct FOrchestrationStateFlagsRowHandle CastToOrchestrationStateFlagsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakOrchestrationStateFlagsEnum(const struct FOrchestrationStateFlagsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToOrchestrationStateFlagsTable(class FName Name, const struct FOrchestrationStateFlag& Data, struct FOrchestrationStateFlagsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.OrchestrationStateFlagsTable
class UOrchestrationStateFlagsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UOrchestrationStateFlagsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.OreDepositLibrary
class UOreDepositLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UOreDepositLibrary* GetDefaultObj();

	struct FOreDepositRowHandle StructToRowHandle(const struct FOreDepositEnum& EnumValue);
	class FName StructToName(const struct FOreDepositEnum& EnumValue);
	int32 StructToInt(const struct FOreDepositEnum& EnumValue);
	struct FOreDepositEnum RowHandleToStruct(const struct FOreDepositRowHandle& RowHandle);
	void RemoveRowFromOreDepositTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FOreDepositEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FOreDepositEnum& A, const struct FOreDepositEnum& B);
	struct FOreDepositEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FOreDepositRowHandle MakeOreDepositFromIndex(int32 Index);
	struct FOreDepositEnum MakeOreDepositEnum(const struct FOreDepositEnum& Enum);
	struct FOreDepositRowHandle MakeOreDeposit(class FName RowName);
	struct FOreDepositRowHandle MakeLiteralOreDeposit(const struct FOreDepositRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FOreDepositEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetOreDepositStruct(const struct FOreDepositRowHandle& RowHandle, struct FOreDeposit* OreDeposit, enum class EValid* Paths);
	bool EqualEqual_FOreDepositRowHandleFOreDepositRowHandle(const struct FOreDepositRowHandle& RowHandleA, const struct FOreDepositRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FOreDepositEnum& A, const struct FOreDepositEnum& B);
	struct FOreDepositRowHandle CastToOreDepositRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakOreDepositEnum(const struct FOreDepositEnum& Enum, class FName* Name, int32* Index);
	void AddRowToOreDepositTable(class FName Name, const struct FOreDeposit& Data, struct FOreDepositRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.OreDepositTable
class UOreDepositTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UOreDepositTable* GetDefaultObj();

};

// 0x60 (0x90 - 0x30)
// Class Icarus.OutOfBoundsSubsystem
class UOutOfBoundsSubsystem : public UWorldSubsystem
{
public:
	TMap<class AIcarusPlayerCharacter*, struct FOutOfBoundsArray> PlayerVolumeMap;                                   // 0x30(0x50)(NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnOutOfBoundsUpdate;                               // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UOutOfBoundsSubsystem* GetDefaultObj();

	void UnRegisterOutOfBoundsForPlayer(class AIcarusPlayerCharacter* Player, class AActor* Volume);
	void RegisterOutOfBoundsForPlayer(class AIcarusPlayerCharacter* Player, class AActor* Volume);
	bool IsPlayerOutOfBounds(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0x268 - 0x268)
// Class Icarus.OutOfBoundsVolume
class AOutOfBoundsVolume : public APhysicsVolume
{
public:

	static class UClass* StaticClass();
	static class AOutOfBoundsVolume* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.OutpostsLibrary
class UOutpostsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UOutpostsLibrary* GetDefaultObj();

	struct FOutpostsRowHandle StructToRowHandle(const struct FOutpostsEnum& EnumValue);
	class FName StructToName(const struct FOutpostsEnum& EnumValue);
	int32 StructToInt(const struct FOutpostsEnum& EnumValue);
	struct FOutpostsEnum RowHandleToStruct(const struct FOutpostsRowHandle& RowHandle);
	void RemoveRowFromOutpostsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FOutpostsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FOutpostsEnum& A, const struct FOutpostsEnum& B);
	struct FOutpostsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FOutpostsRowHandle MakeOutpostsFromIndex(int32 Index);
	struct FOutpostsEnum MakeOutpostsEnum(const struct FOutpostsEnum& Enum);
	struct FOutpostsRowHandle MakeOutposts(class FName RowName);
	struct FOutpostsRowHandle MakeLiteralOutposts(const struct FOutpostsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FOutpostsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetOutpostsStruct(const struct FOutpostsRowHandle& RowHandle, struct FOutpost* Outposts, enum class EValid* Paths);
	bool EqualEqual_FOutpostsRowHandleFOutpostsRowHandle(const struct FOutpostsRowHandle& RowHandleA, const struct FOutpostsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FOutpostsEnum& A, const struct FOutpostsEnum& B);
	struct FOutpostsRowHandle CastToOutpostsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakOutpostsEnum(const struct FOutpostsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToOutpostsTable(class FName Name, const struct FOutpost& Data, struct FOutpostsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.OutpostsTable
class UOutpostsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UOutpostsTable* GetDefaultObj();

};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.OutpostTalentControllerComponent
class UOutpostTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class UOutpostTalentControllerComponent* GetDefaultObj();

};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.OutpostTalentModel
class UOutpostTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class UOutpostTalentModel* GetDefaultObj();

};

// 0x38 (0x230 - 0x1F8)
// Class Icarus.OverlapAudioComponent
class UOverlapAudioComponent : public USceneComponent
{
public:
	class UFMODEvent*                            Event;                                             // 0x1F8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bInitializeManually;                               // 0x200(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoPlay;                                         // 0x201(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseAttenuationOverride;                           // 0x202(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8415[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MinDistance;                                       // 0x204(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxDistance;                                       // 0x208(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8416[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x210(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                      Collider;                                          // 0x218(0x8)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8417[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UOverlapAudioComponent* GetDefaultObj();

	void Stop();
	void Play();
	void Initialize();
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.OxygenComponent
class UOxygenComponent : public UResourceNetworkComponent
{
public:

	static class UClass* StaticClass();
	static class UOxygenComponent* GetDefaultObj();

	bool GetFuelData(struct FFuelData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.OxygenLibrary
class UOxygenLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UOxygenLibrary* GetDefaultObj();

	struct FOxygenRowHandle StructToRowHandle(const struct FOxygenEnum& EnumValue);
	class FName StructToName(const struct FOxygenEnum& EnumValue);
	int32 StructToInt(const struct FOxygenEnum& EnumValue);
	struct FOxygenEnum RowHandleToStruct(const struct FOxygenRowHandle& RowHandle);
	void RemoveRowFromOxygenTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FOxygenEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FOxygenEnum& A, const struct FOxygenEnum& B);
	struct FOxygenEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FOxygenRowHandle MakeOxygenFromIndex(int32 Index);
	struct FOxygenEnum MakeOxygenEnum(const struct FOxygenEnum& Enum);
	struct FOxygenRowHandle MakeOxygen(class FName RowName);
	struct FOxygenRowHandle MakeLiteralOxygen(const struct FOxygenRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FOxygenEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetOxygenStruct(const struct FOxygenRowHandle& RowHandle, struct FOxygenData* Oxygen, enum class EValid* Paths);
	bool EqualEqual_FOxygenRowHandleFOxygenRowHandle(const struct FOxygenRowHandle& RowHandleA, const struct FOxygenRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FOxygenEnum& A, const struct FOxygenEnum& B);
	struct FOxygenRowHandle CastToOxygenRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakOxygenEnum(const struct FOxygenEnum& Enum, class FName* Name, int32* Index);
	void AddRowToOxygenTable(class FName Name, const struct FOxygenData& Data, struct FOxygenRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.OxygenTable
class UOxygenTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UOxygenTable* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class Icarus.PaintingListItem
class UPaintingListItem : public UObject
{
public:
	struct FPaintingsRowHandle                   PaintingRowHandle;                                 // 0x28(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPaintingListItem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PaintingRecorderInterface
class IPaintingRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IPaintingRecorderInterface* GetDefaultObj();

	void SetPaintingImage(struct FPaintingsRowHandle& PaintingRow);
	struct FPaintingsRowHandle GetPaintingImageRow();
};

// 0x8 (0x260 - 0x258)
// Class Icarus.PaintingRecorderComponent
class UPaintingRecorderComponent : public UDeployableRecorderComponent
{
public:
	class FName                                  PaintingImageRecord;                               // 0x258(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPaintingRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PaintingsLibrary
class UPaintingsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPaintingsLibrary* GetDefaultObj();

	struct FPaintingsRowHandle StructToRowHandle(const struct FPaintingsEnum& EnumValue);
	class FName StructToName(const struct FPaintingsEnum& EnumValue);
	int32 StructToInt(const struct FPaintingsEnum& EnumValue);
	struct FPaintingsEnum RowHandleToStruct(const struct FPaintingsRowHandle& RowHandle);
	void RemoveRowFromPaintingsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPaintingsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPaintingsEnum& A, const struct FPaintingsEnum& B);
	struct FPaintingsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPaintingsRowHandle MakePaintingsFromIndex(int32 Index);
	struct FPaintingsEnum MakePaintingsEnum(const struct FPaintingsEnum& Enum);
	struct FPaintingsRowHandle MakePaintings(class FName RowName);
	struct FPaintingsRowHandle MakeLiteralPaintings(const struct FPaintingsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPaintingsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPaintingsStruct(const struct FPaintingsRowHandle& RowHandle, struct FPaintingData* Paintings, enum class EValid* Paths);
	bool EqualEqual_FPaintingsRowHandleFPaintingsRowHandle(const struct FPaintingsRowHandle& RowHandleA, const struct FPaintingsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPaintingsEnum& A, const struct FPaintingsEnum& B);
	struct FPaintingsRowHandle CastToPaintingsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPaintingsEnum(const struct FPaintingsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPaintingsTable(class FName Name, const struct FPaintingData& Data, struct FPaintingsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PaintingsTable
class UPaintingsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPaintingsTable* GetDefaultObj();

};

// 0x48 (0x240 - 0x1F8)
// Class Icarus.ParticleAudioComponent
class UParticleAudioComponent : public USceneComponent
{
public:
	uint8                                        Pad_842F[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  NiagaraVariableName;                               // 0x200(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        ParticleCountThreshold;                            // 0x208(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ParticleAgeThreshold;                              // 0x20C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            OneShotSound;                                      // 0x210(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            PersistentSound;                                   // 0x218(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseCountParameter;                                // 0x220(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bUseListenerRotation;                              // 0x221(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8430[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UFMODAudioComponent*                   AudioComponent;                                    // 0x228(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8431[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UParticleAudioComponent* GetDefaultObj();

};

// 0x10 (0x2D0 - 0x2C0)
// Class Icarus.PersistentBlocker
class APersistentBlocker : public AIcarusActor
{
public:
	class UIcarusNavigationDirtier*              NavigationDirtier;                                 // 0x2C0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasUpdatedDestroyedState;                         // 0x2C8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8432[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class APersistentBlocker* GetDefaultObj();

	void UpdateDestroyedState();
	void TriggerBlockerDestroy();
	void OnStatContainerUpdated_Internal();
};

// 0x48 (0x308 - 0x2C0)
// Class Icarus.PersistentBlockerSpawner
class APersistentBlockerSpawner : public AIcarusActor
{
public:
	TSubclassOf<class APersistentBlocker>        BlockerClass;                                      // 0x2C0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTalentsRowHandle                     UnlockTalent;                                      // 0x2C8(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFactionMissionsRowHandle             LinkedFactionMission;                              // 0x2E0(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasSpawned;                                       // 0x2F8(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8433[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class APersistentBlocker*                    SpawnedBlocker;                                    // 0x300(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class APersistentBlockerSpawner* GetDefaultObj();

	void SetBlocker(class APersistentBlocker* Blocker);
	bool HasSpawned();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerAccoladeCategoriesLibrary
class UPlayerAccoladeCategoriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerAccoladeCategoriesLibrary* GetDefaultObj();

	struct FPlayerAccoladeCategoriesRowHandle StructToRowHandle(const struct FPlayerAccoladeCategoriesEnum& EnumValue);
	class FName StructToName(const struct FPlayerAccoladeCategoriesEnum& EnumValue);
	int32 StructToInt(const struct FPlayerAccoladeCategoriesEnum& EnumValue);
	struct FPlayerAccoladeCategoriesEnum RowHandleToStruct(const struct FPlayerAccoladeCategoriesRowHandle& RowHandle);
	void RemoveRowFromPlayerAccoladeCategoriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPlayerAccoladeCategoriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPlayerAccoladeCategoriesEnum& A, const struct FPlayerAccoladeCategoriesEnum& B);
	struct FPlayerAccoladeCategoriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPlayerAccoladeCategoriesRowHandle MakePlayerAccoladeCategoriesFromIndex(int32 Index);
	struct FPlayerAccoladeCategoriesEnum MakePlayerAccoladeCategoriesEnum(const struct FPlayerAccoladeCategoriesEnum& Enum);
	struct FPlayerAccoladeCategoriesRowHandle MakePlayerAccoladeCategories(class FName RowName);
	struct FPlayerAccoladeCategoriesRowHandle MakeLiteralPlayerAccoladeCategories(const struct FPlayerAccoladeCategoriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPlayerAccoladeCategoriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPlayerAccoladeCategoriesStruct(const struct FPlayerAccoladeCategoriesRowHandle& RowHandle, struct FPlayerAccoladeCategory* PlayerAccoladeCategories, enum class EValid* Paths);
	bool EqualEqual_FPlayerAccoladeCategoriesRowHandleFPlayerAccoladeCategoriesRowHandle(const struct FPlayerAccoladeCategoriesRowHandle& RowHandleA, const struct FPlayerAccoladeCategoriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPlayerAccoladeCategoriesEnum& A, const struct FPlayerAccoladeCategoriesEnum& B);
	struct FPlayerAccoladeCategoriesRowHandle CastToPlayerAccoladeCategoriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPlayerAccoladeCategoriesEnum(const struct FPlayerAccoladeCategoriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPlayerAccoladeCategoriesTable(class FName Name, const struct FPlayerAccoladeCategory& Data, struct FPlayerAccoladeCategoriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerAccoladeCategoriesTable
class UPlayerAccoladeCategoriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPlayerAccoladeCategoriesTable* GetDefaultObj();

};

// 0x28 (0x50 - 0x28)
// Class Icarus.PlayerAudioFoliageRecord
class UPlayerAudioFoliageRecord : public UObject
{
public:
	class UFLODRecord*                           FLODRecord;                                        // 0x28(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_843F[0x20];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerAudioFoliageRecord* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerCharacterIDFunctionLibrary
class UPlayerCharacterIDFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerCharacterIDFunctionLibrary* GetDefaultObj();

	class FString ToString_PlayerCharacterID(struct FPlayerCharacterID& PlayerCharacterID);
	bool NotEqual_PlayerCharacterIDPlayerCharacterID(struct FPlayerCharacterID& A, struct FPlayerCharacterID& B);
	bool IsValid_PlayerCharacterID(struct FPlayerCharacterID& PlayerCharacterID);
	bool EqualEqual_PlayerCharacterIDPlayerCharacterID(struct FPlayerCharacterID& A, struct FPlayerCharacterID& B);
};

// 0x70 (0x380 - 0x310)
// Class Icarus.SurvivalCharacterState
class USurvivalCharacterState : public UCharacterState
{
public:
	FMulticastSparseDelegateProperty_            OnConsumedFood;                                    // 0x310(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnConsumedWater;                                   // 0x311(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnConsumedOxygen;                                  // 0x312(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnOxygenUpdated;                                   // 0x313(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnFoodUpdated;                                     // 0x314(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnWaterUpdated;                                    // 0x315(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnTemperatureUpdated;                              // 0x316(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnExternalTemperatureUpdated;                      // 0x317(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	int32                                        OxygenLevel;                                       // 0x318(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        WaterLevel;                                        // 0x31C(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        FoodLevel;                                         // 0x320(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MinOxygen;                                         // 0x324(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxOxygen;                                         // 0x328(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MinWater;                                          // 0x32C(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxWater;                                          // 0x330(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MinFood;                                           // 0x334(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        MaxFood;                                           // 0x338(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                        InternalTemperature;                               // 0x33C(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8443[0x38];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UTemperatureSingleton*                 TemperatureSingleton;                              // 0x378(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class USurvivalCharacterState* GetDefaultObj();

	void TemperatureTick(float DeltaTime);
	void SetWater(int32 Amount);
	void SetSurvivalTickEnabled(bool bEnabled);
	void SetOxygen(int32 Amount);
	void SetInternalTemperature(int32 NewTemperature);
	void SetFood(int32 Amount);
	void RecalculateSurvivalVariables();
	void RecalculateSurvivalConsumeRate();
	void OnRep_Water();
	void OnRep_Oxygen();
	void OnRep_Food();
	bool IsSurvivalTickEnabled();
	int32 GetWater();
	int32 GetOxygen();
	int32 GetMaxWater();
	int32 GetMaxOxygen();
	int32 GetMaxFood();
	int32 GetInternalTemperature();
	int32 GetFood();
	void AddWater(int32 Amount);
	void AddTemperature(int32 Amount);
	void AddOxygen(int32 Amount);
	void AddFood(int32 Amount);
};

// 0x100 (0x480 - 0x380)
// Class Icarus.PlayerCharacterState
class UPlayerCharacterState : public USurvivalCharacterState
{
public:
	FMulticastSparseDelegateProperty_            OnProspectLocationChanged;                         // 0x380(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	enum class EProspectLocation                 CurrentProspectLocation;                           // 0x381(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8444[0xC6];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FWeatherEventsRowHandle               LocalWeatherEvent;                                 // 0x448(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            LocalWeatherEventUpdated;                          // 0x460(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                        AIDetectionPercentage;                             // 0x470(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bWasDeadOnReload;                                  // 0x474(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8445[0xB];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerCharacterState* GetDefaultObj();

	void UpdateAIDetection();
	void OnRep_LocalWeatherEvent();
	void OnLocalWeatherEventUpdated();
	void CheckForNewWeatherEvent();
};

// 0x498 (0x548 - 0xB0)
// Class Icarus.PlayerDataComponent
class UPlayerDataComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_            OnMetaCurrencyChanged;                             // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_845F[0x28];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnMetaInventoryChanged;                            // 0xE8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReceivedPlayerLoadout;                           // 0xF8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReceivedPlayerLoadoutExtension;                  // 0x108(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReceivedReturnedItems;                           // 0x118(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnResearchWorkshopItemComplete;                    // 0x128(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnReplicateWorkshopItemComplete;                   // 0x138(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_8460[0x3F0];                                   // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FTalentsRowHandle>             PendingAccountTalents;                             // 0x538(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UPlayerDataComponent* GetDefaultObj();

	void SetPendingLoadoutExtensionItems(const TArray<struct FItemData>& PendingItems, bool bAddInsurance);
	void SetPendingLoadout(struct FPlayerLoadoutData& PendingLoadoutData);
	void ServerReceivePendingLoadoutExtensionItems(TArray<struct FItemData>& RequestedItems, bool bAddInsurance);
	void ServerReceiveLoadout(const struct FPlayerLoadoutData& ClientsLoadout);
	void ServerAckReceivedReturnedItems(TArray<struct FItemData>& Items);
	void ServerAcknowledgeMissionRewardsReceived(int32 MissionIndex);
	void RetryGrantMissionRewards();
	bool RepairWorkshopItem(class UInventory* SourceInventory, int32 Location);
	void RemoveAssociatedProspect(const class FString& ProspectID);
	void OnTalentControllersReady();
	void OnOfflineMetaInventoryChanged();
	void OnBackendMetaResourcesUpdated();
	bool IsInsuranceClaimable(struct FPlayerLoadoutData& Loadout);
	bool IsCurrentLoadoutEmpty();
	bool HasPendingLoadoutExtentionRequest();
	bool HasPendingLoadout();
	bool HasLoadoutForProspect(struct FProspectInfo& Prospect);
	bool HasLoadout();
	void HandleProspectExpired(struct FProspectInfo& Prospect);
	int32 GetTimeUntilInsuranceClaimable(struct FPlayerLoadoutData& Loadout);
	TArray<struct FItemData> GetPendingLoadoutExtensionItems();
	bool GetPendingLoadout(struct FPlayerLoadoutData* OutPendingLoadoutData, int32 ChrSlot);
	TArray<struct FItemData> GetMetaInventoryItems();
	TArray<struct FPlayerLoadoutData> GetLoadoutRecords();
	bool GetLoadoutForProspect(struct FProspectInfo& Prospect, struct FPlayerLoadoutData* Loadout);
	bool GetLastProspect(struct FAssociatedProspectInfo* AssociatedProspectInfo);
	int32 GetInsuranceClaimTime();
	struct FPlayerLoadoutData GetCurrentLoadout();
	bool GetCharacterProfile(int32 ChrSlot, struct FOnlineProfileCharacter* CharacterProfile);
	int32 GetAvailableMetaResource(const struct FMetaCurrencyRowHandle& MetaCurrencyRow);
	void GetAllLocalProspectInfos(TArray<struct FProspectInfo>* ProspectInfos);
	bool GetAllLoadableProspects(TArray<struct FAssociatedProspectInfo>* AssociatedProspectInfos);
	bool GetAllAssociatedProspects(TArray<struct FAssociatedProspectInfo>* AssociatedProspectInfos, bool bIncludeOutpostsAndOpenWorld);
	void DeleteLoadout(struct FPlayerLoadoutData& Loadout);
	bool ConvertCurrency(const struct FCurrencyConversionsRowHandle& Conversion, int32 Iterations);
	void ClientUpdateMetaItem(const struct FItemData& Item);
	void ClientSetLastProspect(const class FString& ProspectID);
	void ClientRemoveMetaItem(const struct FItemData& Item);
	void ClientReceiveReturnedItems(TArray<struct FItemData>& Items);
	void ClientPrepareLoadout(int32 ChrSlot, const struct FLastProspectHostInfo& HostInfo);
	bool ClientOnly_PurchaseMetaItem(struct FItemTemplateRowHandle& Item, const TArray<struct FWorkshopCost>& Costs);
	bool ClientOnly_PurchaseItemUpdate(struct FItemData& Item, const TArray<struct FWorkshopCost>& Costs);
	bool ClientOnly_CanAffordWorkshopCosts(const TArray<struct FWorkshopCost>& Costs);
	bool ClientOnly_CanAffordWorkshopCost(struct FWorkshopCost& Cost);
	bool ClientOnly_CanAffordMetaResource(struct FMetaResource& MetaResource);
	void ClientGrantMissionScaledMetaResource(struct FMetaResource& MetaResource);
	void ClientGrantMissionRewards(struct FFactionMissionsRowHandle& Mission, int32 MissionIndex, bool bIsCurrentMission, class AQuest* InitialQuest);
	void ClientGrantMetaResource(struct FMetaResource& MetaResource);
	void ClientGrantMetaItemTemplate(struct FItemTemplateRowHandle& ItemTemplateRowHandle);
	void ClientGrantMetaItem(struct FItemData& ItemTemplate);
	void ClientGrantDynamicMissionRewards(int32 Credits, int32 Experience);
	void ClientGrantCharacterFlagsByRow(TArray<struct FCharacterFlagsRowHandle>& CharacterFlags);
	void ClientGrantAccountTalents(TArray<struct FTalentsRowHandle>& Talents);
	void ClientConsumeMetaResource(struct FMetaResource& MetaResource);
	void ClientCommitPendingLoadoutExtension();
	void ClientAddMetaItem(const struct FItemData& Item);
	void Client_ResearchWorkshopItem(struct FTalentsRowHandle& WorkshopTalent);
	void Client_PurchaseWorkshopItem(struct FWorkshopItemsRowHandle& WorkshopItem);
	void ClearPendingLoadout();
	void ClaimInsurance(struct FPlayerLoadoutData& Loadout);
	TArray<struct FItemData> CheckInLoadout(const TArray<struct FItemData>& MetaItems, bool bProspectWasExpired, bool bSettleLoadout);
	bool CanPerformCurrencyConversion(const struct FCurrencyConversionsRowHandle& Conversion, int32 Iterations);
	bool CanInsureLoadout(struct FPlayerLoadoutData& Loadout);
	void AddAssociatedProspect(int32 ChrSlot, const struct FAssociatedProspectInfo& AssociatedProspectInfo);
	void AbandonLoadout(const class FString& ProspectID);
};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.PlayerEffectsComponent
class UPlayerEffectsComponent : public UActorComponent
{
public:
	class USceneComponent*                       OwnerOverrideComponent;                            // 0xB0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UPlayerEffectsComponent* GetDefaultObj();

	void SetOwnerOverride(class USceneComponent* OwnerOverride);
};

// 0xC8 (0x178 - 0xB0)
// Class Icarus.PlayerEnvironmentalAudioComponent
class UPlayerEnvironmentalAudioComponent : public UActorComponent
{
public:
	class AFLOD*                                 FLOD;                                              // 0xB0(0x8)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        FoliageCountTraceRadius;                           // 0xB8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        FoliageCloseCountTraceRadius;                      // 0xBC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPlayerAudioFoliageRecord*>     FoliageRecords;                                    // 0xC0(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFLODRecord*>                   PendingFoliageRecords;                             // 0xD0(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class AFLODTile*>                       LoadedFLODTiles;                                   // 0xE0(0x50)(NativeAccessSpecifierPrivate)
	uint8                                        Pad_8462[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        CurrentShelter;                                    // 0x134(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8463[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FVector>                       ShelterTraceDirections;                            // 0x140(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                         bDebugShelter;                                     // 0x150(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8464[0x1F];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UGameplayTexture*                      TerrainZoneMap;                                    // 0x170(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UPlayerEnvironmentalAudioComponent* GetDefaultObj();

	void UpdateTerrainParameters();
	void InitialiseTerrainZoneMap();
	void GetShelterValues(float* OutShelter, float* OutAverageDistance, float* OutClosestDistance, enum class EPhysicalSurface* OutPrimarySurface, float* OutAverageReflectionMultiplier, float* OutAverageReflectionHighFreq, float* OutAverageReflectionLowFreq);
	struct FVector GetShelterTraceLocation();
	struct FVector GetFoliageTraceLocation();
	void GetCurrentTreeCount(int32* OutCount, int32* OutCloseCount, float* OutCoverDepth, float* OutCloseCountGroupOverlap);
	int32 GetCurrentBushCount();
};

// 0x38 (0xE8 - 0xB0)
// Class Icarus.PlayerFeedbackAudioComponent
class UPlayerFeedbackAudioComponent : public UActorComponent
{
public:
	class UFMODEvent*                            NegativeFeedbackSound;                             // 0xB0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            StatRollSuccessFeedbackSound;                      // 0xB8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            CausedAfflictionsFeedbackSound;                    // 0xC0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            MissionUpdatedFeedbackSound;                       // 0xC8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                            MissionCompletedFeedbackSound;                     // 0xD0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8466[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerFeedbackAudioComponent* GetDefaultObj();

	void ProcessMissionNotifies();
	void PlayStatRollSuccess(class AIcarusPlayerCharacter* Player, const struct FStatsRowHandle& Stat);
	void PlayNegativeFeedback(class AIcarusPlayerCharacter* Player);
	void PlayCriticalHit(class AIcarusPlayerCharacter* Player, const struct FVector& HitLocation, const struct FCriticalHitAreasEnum& CriticalHitArea);
	void PlayCausedAfflictions(class AIcarusPlayerCharacter* Player, TSet<struct FStatAfflictionsRowHandle> Afflictions);
	void OnMissionUpdated(class AQuest* Quest);
	void OnMissionCompleted(class AQuest* Quest, const struct FFactionMissionsRowHandle& Mission);
	void Client_PlayStatRollSuccess();
	void Client_PlayNegativeFeedback();
	void Client_PlayMissionUpdated();
	void Client_PlayMissionCompleted();
	void Client_PlayCriticalHit(const struct FVector& HitLocation, const struct FCriticalHitAreasRowHandle& CriticalHitArea);
	void Client_PlayCausedAfflictions();
};

// 0x60 (0x90 - 0x30)
// Class Icarus.PlayerFeedbackSubsystem
class UPlayerFeedbackSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnStatChanceRollSuccessNotify;                     // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerActionFailedNotify;                        // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerPerformedCriticalHitNotify;                // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerPerformedStealthAttackNotify;              // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerAttackCausedAfflictionsNotify;             // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnNightSkippedNotify;                              // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPlayerFeedbackSubsystem* GetDefaultObj();

	void BroadcastStatChanceRollSuccessDelegate(class AIcarusPlayerCharacter* Player, const struct FStatsRowHandle& Stat);
	void BroadcastPlayerPerformedStealthAttackDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerPerformedCriticalHitDelegate(class AIcarusPlayerCharacter* Player, const struct FVector& HitLocation, const struct FCriticalHitAreasEnum& CriticalHitArea);
	void BroadcastPlayerAttackCausedAfflictionsDelegate(class AIcarusPlayerCharacter* Player, TSet<struct FStatAfflictionsRowHandle> Afflictions);
	void BroadcastPlayerActionFailedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastNightSkippedDelegate(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerFootstepAudioDataLibrary
class UPlayerFootstepAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerFootstepAudioDataLibrary* GetDefaultObj();

	struct FPlayerFootstepAudioDataRowHandle StructToRowHandle(const struct FPlayerFootstepAudioDataEnum& EnumValue);
	class FName StructToName(const struct FPlayerFootstepAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FPlayerFootstepAudioDataEnum& EnumValue);
	struct FPlayerFootstepAudioDataEnum RowHandleToStruct(const struct FPlayerFootstepAudioDataRowHandle& RowHandle);
	void RemoveRowFromPlayerFootstepAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPlayerFootstepAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPlayerFootstepAudioDataEnum& A, const struct FPlayerFootstepAudioDataEnum& B);
	struct FPlayerFootstepAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPlayerFootstepAudioDataRowHandle MakePlayerFootstepAudioDataFromIndex(int32 Index);
	struct FPlayerFootstepAudioDataEnum MakePlayerFootstepAudioDataEnum(const struct FPlayerFootstepAudioDataEnum& Enum);
	struct FPlayerFootstepAudioDataRowHandle MakePlayerFootstepAudioData(class FName RowName);
	struct FPlayerFootstepAudioDataRowHandle MakeLiteralPlayerFootstepAudioData(const struct FPlayerFootstepAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPlayerFootstepAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPlayerFootstepAudioDataStruct(const struct FPlayerFootstepAudioDataRowHandle& RowHandle, struct FPlayerFootstepAudioData* PlayerFootstepAudioData, enum class EValid* Paths);
	bool EqualEqual_FPlayerFootstepAudioDataRowHandleFPlayerFootstepAudioDataRowHandle(const struct FPlayerFootstepAudioDataRowHandle& RowHandleA, const struct FPlayerFootstepAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPlayerFootstepAudioDataEnum& A, const struct FPlayerFootstepAudioDataEnum& B);
	struct FPlayerFootstepAudioDataRowHandle CastToPlayerFootstepAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPlayerFootstepAudioDataEnum(const struct FPlayerFootstepAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPlayerFootstepAudioDataTable(class FName Name, const struct FPlayerFootstepAudioData& Data, struct FPlayerFootstepAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerFootstepAudioDataTable
class UPlayerFootstepAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPlayerFootstepAudioDataTable* GetDefaultObj();

};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.PlayerHistoryRecorderComponent
class UPlayerHistoryRecorderComponent : public UActorStateRecorderComponent
{
public:
	TArray<struct FPlayerHistoryEntryRecord>     SavedHistoryData;                                  // 0x1A8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_8473[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerHistoryRecorderComponent* GetDefaultObj();

};

// 0x10 (0x2D0 - 0x2C0)
// Class Icarus.PlayerHistoryTracker
class APlayerHistoryTracker : public AIcarusActor
{
public:
	TArray<struct FPlayerHistoryEntry>           History;                                           // 0x2C0(0x10)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class APlayerHistoryTracker* GetDefaultObj();

	struct FPlayerHistoryEntry GetPlayerInfo(int32 Index);
	int32 GetPlayerIndex(class AIcarusPlayerState* Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerIdentityLibrary
class UPlayerIdentityLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerIdentityLibrary* GetDefaultObj();

	struct FPlayerIdentityRowHandle StructToRowHandle(const struct FPlayerIdentityEnum& EnumValue);
	class FName StructToName(const struct FPlayerIdentityEnum& EnumValue);
	int32 StructToInt(const struct FPlayerIdentityEnum& EnumValue);
	struct FPlayerIdentityEnum RowHandleToStruct(const struct FPlayerIdentityRowHandle& RowHandle);
	void RemoveRowFromPlayerIdentityTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPlayerIdentityEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPlayerIdentityEnum& A, const struct FPlayerIdentityEnum& B);
	struct FPlayerIdentityEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPlayerIdentityRowHandle MakePlayerIdentityFromIndex(int32 Index);
	struct FPlayerIdentityEnum MakePlayerIdentityEnum(const struct FPlayerIdentityEnum& Enum);
	struct FPlayerIdentityRowHandle MakePlayerIdentity(class FName RowName);
	struct FPlayerIdentityRowHandle MakeLiteralPlayerIdentity(const struct FPlayerIdentityRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPlayerIdentityEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPlayerIdentityStruct(const struct FPlayerIdentityRowHandle& RowHandle, struct FPlayerIdentityData* PlayerIdentity, enum class EValid* Paths);
	bool EqualEqual_FPlayerIdentityRowHandleFPlayerIdentityRowHandle(const struct FPlayerIdentityRowHandle& RowHandleA, const struct FPlayerIdentityRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPlayerIdentityEnum& A, const struct FPlayerIdentityEnum& B);
	struct FPlayerIdentityRowHandle CastToPlayerIdentityRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPlayerIdentityEnum(const struct FPlayerIdentityEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPlayerIdentityTable(class FName Name, const struct FPlayerIdentityData& Data, struct FPlayerIdentityRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerIdentityTable
class UPlayerIdentityTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPlayerIdentityTable* GetDefaultObj();

};

// 0x10 (0xC0 - 0xB0)
// Class Icarus.PlayerModifierAudioComponent
class UPlayerModifierAudioComponent : public UActorComponent
{
public:
	TArray<class UPlayerModifierSound*>          Sounds;                                            // 0xB0(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UPlayerModifierAudioComponent* GetDefaultObj();

	void HandleModifierEffectivenessUpdated(class UModifierStateComponent* Modifier);
};

// 0x30 (0x58 - 0x28)
// Class Icarus.PlayerModifierSound
class UPlayerModifierSound : public UObject
{
public:
	uint8                                        Pad_8481[0x30];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerModifierSound* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.PlayerMovementAudioComponent
class UPlayerMovementAudioComponent : public UActorComponent
{
public:
	float                                        CurrentWaterImmersion;                             // 0xB0(0x4)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8483[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerMovementAudioComponent* GetDefaultObj();

	class UFMODEvent* GetItemAnimSound(class AIcarusItem* Item, class FName ItemAnimSoundName, int32 ItemAnimSoundIndex);
};

// 0xA0 (0xD0 - 0x30)
// Class Icarus.PlayerObserverSubsystem
class UPlayerObserverSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnPlayerDeath;                                     // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerRevived;                                   // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnRevivedOtherPlayer;                              // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerLevelledUp;                                // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemCrafted;                                     // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFoodConsumed;                                    // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnProjectileFired;                                 // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnNightSurvived;                                   // 0xA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnExperienceGained;                                // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDistanceTravelled;                               // 0xC0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPlayerObserverSubsystem* GetDefaultObj();

};

// 0x28 (0x100 - 0xD8)
// Class Icarus.PlayerRecorderComponent
class UPlayerRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	struct FPlayerCharacterID                    PlayerCharacterID;                                 // 0xD8(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        AssignedDropshipSpawnUID;                          // 0xF0(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        AssignedDropshipUID;                               // 0xF4(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        AssignedGravestoneUID;                             // 0xF8(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        PlayerRecorderVersion;                             // 0xFC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UPlayerRecorderComponent* GetDefaultObj();

};

// 0xE8 (0x198 - 0xB0)
// Class Icarus.PlayerReflectionAudioComponent
class UPlayerReflectionAudioComponent : public UActorComponent
{
public:
	uint8                                        Pad_8484[0xE8];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerReflectionAudioComponent* GetDefaultObj();

};

// 0x68 (0x210 - 0x1A8)
// Class Icarus.PlayerStateRecorderComponent
class UPlayerStateRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FPlayerCharacterID                    PlayerCharacterID;                                 // 0x1A8(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               Location;                                          // 0x1C0(0xC)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                              Rotation;                                          // 0x1CC(0xC)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                         bIsAlive;                                          // 0x1D8(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8485[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        Health;                                            // 0x1DC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        FoodLevel;                                         // 0x1E0(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        WaterLevel;                                        // 0x1E4(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        OxygenLevel;                                       // 0x1E8(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8486[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FStomachContentSaveData>       StomachContents;                                   // 0x1F0(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	int32                                        RespawnCount;                                      // 0x200(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         HasGrantedLoadout;                                 // 0x204(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8487[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        PlayerStateRecorderVersion;                        // 0x208(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8488[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerStateRecorderComponent* GetDefaultObj();

};

// 0x190 (0x1C0 - 0x30)
// Class Icarus.PlayerSubsystem
class UPlayerSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnItemAddedNotify;                                 // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemCraftedNotify;                               // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSuitSlotUpdatedNotify;                           // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemShiftedNotify;                               // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemConsumedNotify;                              // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnEnteredWaterNotify;                              // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnBiomeUpdatedNotify;                              // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLevelUpdatedNotify;                              // 0xA0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTimeSurvivedNotify;                              // 0xB0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnDistanceTraveledNotify;                          // 0xC0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnItemAlteredNotify;                               // 0xD0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerIgnitedBuildingPieceNotify;                // 0xE0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFireExtinguishedNotify;                          // 0xF0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerDownedNotify;                              // 0x100(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerRespawnedNotify;                           // 0x110(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerRevivedNotify;                             // 0x120(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnOtherPlayerRevivedNotify;                        // 0x130(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnStruckByLightningNotify;                         // 0x140(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerEquipmentChangedNotify;                    // 0x150(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerEarnedCurrencyNotify;                      // 0x160(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerCaughtFishNotify;                          // 0x170(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerBestiaryUnlockedNotify;                    // 0x180(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerBestiaryMaxRankNotify;                     // 0x190(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerCompletedDynamicMissionNotify;             // 0x1A0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnLivingItemSlotUnlockedNotify;                    // 0x1B0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPlayerSubsystem* GetDefaultObj();

	void BroadcastTimeSurvivedDelegate(class AIcarusPlayerCharacter* Player, int32 MinutesSurvived, enum class EProspectLocation Biome);
	void BroadcastSuitSlotUpdatedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastStruckByLightningDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerRevivedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerRespawnedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerIgnitedBuildingPieceDelegate(class AIcarusPlayerCharacter* Player, class ABuildingBase* Building);
	void BroadcastPlayerEquipmentChangedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerEarnedCurrencyDelegate(class AIcarusPlayerCharacter* Player, const struct FMetaCurrencyRowHandle& Currency, int32 Amount);
	void BroadcastPlayerDownedDelegate(class AIcarusPlayerCharacter* Player, const struct FIcarusDamagePacket& LastDamagePacket);
	void BroadcastPlayerCompletedDynamicMissionDelegate(class AIcarusPlayerCharacter* Player, const struct FFactionMissionsRowHandle& FactionMission);
	void BroadcastPlayerCaughtFishDelegate(class AIcarusPlayerCharacter* Player, const struct FFishDataRowHandle& FishType);
	void BroadcastPlayerBestiaryUnlockedDelegate(class AIcarusPlayerCharacter* Player, const struct FBestiaryDataRowHandle& BestiaryGroup);
	void BroadcastPlayerBestiaryMaxRankDelegate(class AIcarusPlayerCharacter* Player, const struct FBestiaryDataRowHandle& BestiaryGroup);
	void BroadcastOtherPlayerRevivedDelegate(class AIcarusPlayerCharacter* Player, class AIcarusPlayerCharacter* OtherPlayer);
	void BroadcastLivingItemSlotUnlockedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastLevelUpdatedDelegate(class AIcarusPlayerCharacter* Player, int32 CurrentLevel);
	void BroadcastItemShiftedDelegate(class AIcarusPlayerCharacter* Player, class UInventory* SourceInventory, int32 SourceLocation, class UInventory* DestinationInventory, int32 DestinationLocation, int32 Amount);
	void BroadcastItemCraftedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastItemConsumedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastItemAlteredDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item, const struct FIcarusAttachmentsRowHandle& Attachment);
	void BroadcastItemAddedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastFireExtinguishedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastEnteredWaterDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastDistanceTraveledDelegate(class AIcarusPlayerCharacter* Player, int32 Distance, enum class EProspectLocation Biome);
	void BroadcastBiomeUpdatedDelegate(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.PlayerTalentControllerComponent
class UPlayerTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class UPlayerTalentControllerComponent* GetDefaultObj();

};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.PlayerTalentModel
class UPlayerTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class UPlayerTalentModel* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerTrackerCategoriesLibrary
class UPlayerTrackerCategoriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerTrackerCategoriesLibrary* GetDefaultObj();

	struct FPlayerTrackerCategoriesRowHandle StructToRowHandle(const struct FPlayerTrackerCategoriesEnum& EnumValue);
	class FName StructToName(const struct FPlayerTrackerCategoriesEnum& EnumValue);
	int32 StructToInt(const struct FPlayerTrackerCategoriesEnum& EnumValue);
	struct FPlayerTrackerCategoriesEnum RowHandleToStruct(const struct FPlayerTrackerCategoriesRowHandle& RowHandle);
	void RemoveRowFromPlayerTrackerCategoriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPlayerTrackerCategoriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPlayerTrackerCategoriesEnum& A, const struct FPlayerTrackerCategoriesEnum& B);
	struct FPlayerTrackerCategoriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPlayerTrackerCategoriesRowHandle MakePlayerTrackerCategoriesFromIndex(int32 Index);
	struct FPlayerTrackerCategoriesEnum MakePlayerTrackerCategoriesEnum(const struct FPlayerTrackerCategoriesEnum& Enum);
	struct FPlayerTrackerCategoriesRowHandle MakePlayerTrackerCategories(class FName RowName);
	struct FPlayerTrackerCategoriesRowHandle MakeLiteralPlayerTrackerCategories(const struct FPlayerTrackerCategoriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPlayerTrackerCategoriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPlayerTrackerCategoriesStruct(const struct FPlayerTrackerCategoriesRowHandle& RowHandle, struct FPlayerTrackerCategory* PlayerTrackerCategories, enum class EValid* Paths);
	bool EqualEqual_FPlayerTrackerCategoriesRowHandleFPlayerTrackerCategoriesRowHandle(const struct FPlayerTrackerCategoriesRowHandle& RowHandleA, const struct FPlayerTrackerCategoriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPlayerTrackerCategoriesEnum& A, const struct FPlayerTrackerCategoriesEnum& B);
	struct FPlayerTrackerCategoriesRowHandle CastToPlayerTrackerCategoriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPlayerTrackerCategoriesEnum(const struct FPlayerTrackerCategoriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPlayerTrackerCategoriesTable(class FName Name, const struct FPlayerTrackerCategory& Data, struct FPlayerTrackerCategoriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerTrackerCategoriesTable
class UPlayerTrackerCategoriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPlayerTrackerCategoriesTable* GetDefaultObj();

};

// 0x100 (0x130 - 0x30)
// Class Icarus.PlayerTrackerListener
class UPlayerTrackerListener : public UGeneratedPlayerTrackerListener
{
public:
	TMap<struct FPlayerTrackersRowHandle, int32> PlayerTrackers;                                    // 0x30(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                        Pad_849E[0x50];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FPlayerTrackersRowHandle, struct FTrackerTaskListProgress> PlayerTaskListTrackers;                            // 0xD0(0x50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                        SaveTimerDuration;                                 // 0x120(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_849F[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerTrackerListener* GetDefaultObj();

	void SetPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker, int32 NewAmount);
	void SaveTrackers();
	bool IsAnyTalentAllocated(class UTalentModelInterface_Const* TalentModel, TArray<struct FRowHandle>& TalentRows);
	void IncrementPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker, int32 AmountToAdd);
	void IncrementAllTrackersInArray(TArray<struct FPlayerTrackersRowHandle>& Trackers, class AIcarusPlayerCharacter* Player, int32 AmountToAdd);
	TArray<struct FPlayerTrackersRowHandle> GetPlayerTrackersForCategoryAndTagContainer(const struct FPlayerTrackerCategoriesRowHandle& Category, struct FGameplayTagContainer& Container);
	TArray<struct FPlayerTrackersRowHandle> GetPlayerTrackersForCategory(const struct FPlayerTrackerCategoriesEnum& Category);
	int32 GetPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker);
	struct FTrackerTaskListProgress GetPlayerTaskListTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker);
	void CheckOffTaskRow(class AIcarusPlayerCharacter* Player, const struct FAccoladesRowHandle& Accolade, const struct FRowHandle& TaskRow);
	void CheckEntireTalentTreeUnlockedTask(class AIcarusPlayerCharacter* Player, const struct FAccoladesRowHandle& Accolade);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PlayerTrackersLibrary
class UPlayerTrackersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPlayerTrackersLibrary* GetDefaultObj();

	struct FPlayerTrackersRowHandle StructToRowHandle(const struct FPlayerTrackersEnum& EnumValue);
	class FName StructToName(const struct FPlayerTrackersEnum& EnumValue);
	int32 StructToInt(const struct FPlayerTrackersEnum& EnumValue);
	struct FPlayerTrackersEnum RowHandleToStruct(const struct FPlayerTrackersRowHandle& RowHandle);
	void RemoveRowFromPlayerTrackersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPlayerTrackersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPlayerTrackersEnum& A, const struct FPlayerTrackersEnum& B);
	struct FPlayerTrackersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPlayerTrackersRowHandle MakePlayerTrackersFromIndex(int32 Index);
	struct FPlayerTrackersEnum MakePlayerTrackersEnum(const struct FPlayerTrackersEnum& Enum);
	struct FPlayerTrackersRowHandle MakePlayerTrackers(class FName RowName);
	struct FPlayerTrackersRowHandle MakeLiteralPlayerTrackers(const struct FPlayerTrackersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPlayerTrackersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPlayerTrackersStruct(const struct FPlayerTrackersRowHandle& RowHandle, struct FPlayerTracker* PlayerTrackers, enum class EValid* Paths);
	bool EqualEqual_FPlayerTrackersRowHandleFPlayerTrackersRowHandle(const struct FPlayerTrackersRowHandle& RowHandleA, const struct FPlayerTrackersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPlayerTrackersEnum& A, const struct FPlayerTrackersEnum& B);
	struct FPlayerTrackersRowHandle CastToPlayerTrackersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPlayerTrackersEnum(const struct FPlayerTrackersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPlayerTrackersTable(class FName Name, const struct FPlayerTracker& Data, struct FPlayerTrackersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerTrackersTable
class UPlayerTrackersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPlayerTrackersTable* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.PlayerTrackerSubsystem
class UPlayerTrackerSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnPlayerTrackerUpdated;                            // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UPlayerTrackerSubsystem* GetDefaultObj();

	void SetPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker, int32 NewAmount);
	void ResetTrackers();
	void PostLocalPlayerCreatedInitializeSubsystem();
	void IncrementPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker, int32 AmountToAdd);
	int32 GetPlayerTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker);
	struct FTrackerTaskListProgress GetPlayerTaskListTracker(class AIcarusPlayerCharacter* Player, const struct FPlayerTrackersRowHandle& PlayerTracker);
	void CheckOffPlayerTrackerTask(class AIcarusPlayerCharacter* Player, const struct FAccoladesRowHandle& Accolade, const struct FRowHandle& TaskRow);
	void CheckEntireTalentTreeUnlockedTrackerTask(class AIcarusPlayerCharacter* Player, const struct FAccoladesRowHandle& Accolade);
};

// 0x98 (0x1A0 - 0x108)
// Class Icarus.PlayerVocalisationComponent
class UPlayerVocalisationComponent : public UVocalisationComponent
{
public:
	struct FVocalisationsRowHandle               BreathingVocalisation;                             // 0x108(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVocalisationsRowHandle               LowHealthVocalisation;                             // 0x120(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        LowHealthVocalisationThreshold;                    // 0x138(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_84AF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class UModifierStateComponent*>         ActiveModifiers;                                   // 0x140(0x50)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                        Pad_84B0[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPlayerVocalisationComponent* GetDefaultObj();

	void UpdatePerspective(bool bIsThirdPerson);
	void SetDamageParameter(int32 DamageAmount);
	void OnHealthUpdated(class UActorState* ActorState, float NewHealth);
	void HandleModifierEffectivenessUpdated(class UModifierStateComponent* Component);
};

// 0x38 (0x140 - 0x108)
// Class Icarus.Pointer
class UPointer : public UWidget
{
public:
	struct FLinearColor                          Tint;                                              // 0x108(0x10)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bAntiAlias;                                        // 0x118(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_84B1[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        Thickness;                                         // 0x11C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        Angle;                                             // 0x120(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ArrowLength;                                       // 0x124(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        HeadLength;                                        // 0x128(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_84B2[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UPointer* GetDefaultObj();

	void SetTint(const struct FLinearColor& InTint);
	void SetThickness(float InThickness);
	void SetHeadLength(float InLength);
	void SetArrowLength(float InLength);
	void SetAntiAlias(bool bInAntiAlias);
	void SetAngle(float InDegrees);
	struct FLinearColor GetTint();
	float GetThickness();
	float GetHeadLength();
	float GetArrowLength();
	bool GetAntiAlias();
	float GetAngle();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PossessTargetInterface
class IPossessTargetInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IPossessTargetInterface* GetDefaultObj();

	bool IsThirdPersonToggleBlocked();
};

// 0x28 (0x2E8 - 0x2C0)
// Class Icarus.PrebuiltStructure
class APrebuiltStructure : public AIcarusActor
{
public:
	TArray<class AIcarusActor*>                  SpawnedActors;                                     // 0x2C0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrebuiltStructuresRowHandle          PrebuiltStructureRow;                              // 0x2D0(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class APrebuiltStructure* GetDefaultObj();

	void Reload(const struct FPrebuiltStructuresRowHandle& Structure, const TArray<class AIcarusActor*>& Actors);
	void RegisterSpawnedActor(class AIcarusActor* Actor);
	void LoadStructure(const struct FSerializedStructure& SerializedStructure);
	void BuildStructureFromRawString(const class FString& StructureString);
	void BuildStructureFromFileName(const class FString& Filename);
	void BuildStructure(const struct FPrebuiltStructuresRowHandle& PrebuiltRowHandle);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.PrebuildStructureFunctionLibrary
class UPrebuildStructureFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UPrebuildStructureFunctionLibrary* GetDefaultObj();

	void SaveStructure(const class FString& Filename, class UObject* WorldContext);
	struct FSerializedStructure LoadStructureFromString(const class FString& JsonString);
	struct FSerializedStructure LoadStructure(const class FString& Filename);
	class FString GetSaveStructureString(const class FString& Filename);
	TArray<class FString> GetSavedStructureFiles();
};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.PrebuiltStructureRecorderComponent
class UPrebuiltStructureRecorderComponent : public UActorStateRecorderComponent
{
public:
	class FName                                  PrebuiltStructureName;                             // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPrebuiltSpawnedActorRecord>   RelevantActorRecords;                              // 0x1B0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UPrebuiltStructureRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PrebuiltStructuresLibrary
class UPrebuiltStructuresLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPrebuiltStructuresLibrary* GetDefaultObj();

	struct FPrebuiltStructuresRowHandle StructToRowHandle(const struct FPrebuiltStructuresEnum& EnumValue);
	class FName StructToName(const struct FPrebuiltStructuresEnum& EnumValue);
	int32 StructToInt(const struct FPrebuiltStructuresEnum& EnumValue);
	struct FPrebuiltStructuresEnum RowHandleToStruct(const struct FPrebuiltStructuresRowHandle& RowHandle);
	void RemoveRowFromPrebuiltStructuresTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPrebuiltStructuresEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPrebuiltStructuresEnum& A, const struct FPrebuiltStructuresEnum& B);
	struct FPrebuiltStructuresEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPrebuiltStructuresRowHandle MakePrebuiltStructuresFromIndex(int32 Index);
	struct FPrebuiltStructuresEnum MakePrebuiltStructuresEnum(const struct FPrebuiltStructuresEnum& Enum);
	struct FPrebuiltStructuresRowHandle MakePrebuiltStructures(class FName RowName);
	struct FPrebuiltStructuresRowHandle MakeLiteralPrebuiltStructures(const struct FPrebuiltStructuresRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPrebuiltStructuresEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPrebuiltStructuresStruct(const struct FPrebuiltStructuresRowHandle& RowHandle, struct FPrebuiltData* PrebuiltStructures, enum class EValid* Paths);
	bool EqualEqual_FPrebuiltStructuresRowHandleFPrebuiltStructuresRowHandle(const struct FPrebuiltStructuresRowHandle& RowHandleA, const struct FPrebuiltStructuresRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPrebuiltStructuresEnum& A, const struct FPrebuiltStructuresEnum& B);
	struct FPrebuiltStructuresRowHandle CastToPrebuiltStructuresRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPrebuiltStructuresEnum(const struct FPrebuiltStructuresEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPrebuiltStructuresTable(class FName Name, const struct FPrebuiltData& Data, struct FPrebuiltStructuresRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PrebuiltStructuresTable
class UPrebuiltStructuresTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPrebuiltStructuresTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.PreviewCameraSettingsLibrary
class UPreviewCameraSettingsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UPreviewCameraSettingsLibrary* GetDefaultObj();

	struct FPreviewCameraSettingsRowHandle StructToRowHandle(const struct FPreviewCameraSettingsEnum& EnumValue);
	class FName StructToName(const struct FPreviewCameraSettingsEnum& EnumValue);
	int32 StructToInt(const struct FPreviewCameraSettingsEnum& EnumValue);
	struct FPreviewCameraSettingsEnum RowHandleToStruct(const struct FPreviewCameraSettingsRowHandle& RowHandle);
	void RemoveRowFromPreviewCameraSettingsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FPreviewCameraSettingsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FPreviewCameraSettingsEnum& A, const struct FPreviewCameraSettingsEnum& B);
	struct FPreviewCameraSettingsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FPreviewCameraSettingsRowHandle MakePreviewCameraSettingsFromIndex(int32 Index);
	struct FPreviewCameraSettingsEnum MakePreviewCameraSettingsEnum(const struct FPreviewCameraSettingsEnum& Enum);
	struct FPreviewCameraSettingsRowHandle MakePreviewCameraSettings(class FName RowName);
	struct FPreviewCameraSettingsRowHandle MakeLiteralPreviewCameraSettings(const struct FPreviewCameraSettingsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FPreviewCameraSettingsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetPreviewCameraSettingsStruct(const struct FPreviewCameraSettingsRowHandle& RowHandle, struct FPreviewCameraSettings* PreviewCameraSettings, enum class EValid* Paths);
	bool EqualEqual_FPreviewCameraSettingsRowHandleFPreviewCameraSettingsRowHandle(const struct FPreviewCameraSettingsRowHandle& RowHandleA, const struct FPreviewCameraSettingsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FPreviewCameraSettingsEnum& A, const struct FPreviewCameraSettingsEnum& B);
	struct FPreviewCameraSettingsRowHandle CastToPreviewCameraSettingsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakPreviewCameraSettingsEnum(const struct FPreviewCameraSettingsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToPreviewCameraSettingsTable(class FName Name, const struct FPreviewCameraSettings& Data, struct FPreviewCameraSettingsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PreviewCameraSettingsTable
class UPreviewCameraSettingsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UPreviewCameraSettingsTable* GetDefaultObj();

};

// 0x158 (0x228 - 0xD0)
// Class Icarus.ProcessingComponent
class UProcessingComponent : public UTraitComponent
{
public:
	uint8                                        Pad_84DD[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FProcessingItem>               ProcessingQueue;                                   // 0xD8(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_84DE[0x64];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            OnProcessorStateUpdated;                           // 0x14C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_84DF[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class UInventory*                            Inventory;                                         // 0x150(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AResourceDeposit*                      LinkedResource;                                    // 0x158(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ProcessingProgress;                                // 0x160(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bProcessorActive;                                  // 0x164(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_84E0[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FProcessingItem                       ProcessingItem;                                    // 0x168(0x24)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_84E1[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FRecipeSet                            RecipeSetOverride;                                 // 0x190(0x78)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	int32                                        MillijoulesProcessed;                              // 0x208(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnProcessingStopped;                               // 0x20C(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnProcessingItemUpdated;                           // 0x20D(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnProcessingItemCompleted;                         // 0x20E(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_84E2[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<enum class EIcarusResourceType>       ActivatedNetworks;                                 // 0x210(0x10)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_84E3[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UProcessingComponent* GetDefaultObj();

	void StopProcessing(enum class EProcessorStoppedReason Reason);
	bool ShouldSendItemToPlayerInventory();
	bool ShelterRequirementsMet(class AIcarusPlayerCharacter* CraftingPlayer, enum class EProcessorPurpose Purpose);
	void SetProcessorState(bool bActive);
	void SetProcessingItem(const struct FProcessingItem& NewProcessingItem);
	bool SatisfyQueue(const struct FProcessingItem& AdditionalRecipe, const TArray<class UInventory*>& AdditionalInventories, bool ShiftItems);
	void RestartAutoProcessing();
	void ProcessNextRecipe();
	void ProcessingInventoryItemRemoved(class UInventory* Inventory, int32 Location);
	void ProcessingInventoryItemAdded(class UInventory* Inventory, int32 Location);
	void ProcessingComplete();
	void Process(float Delta);
	void PopulateRecipe(const struct FProcessingItem& SelectedRecipe, class UInventory* PlayerInventory);
	void OnServerStopProcessing(class AIcarusPlayerCharacter* LeavingPlayer);
	void OnServerStopAndClear(class AIcarusPlayerCharacter* LeavingPlayer);
	void OnServer_StopCurrentRecipe();
	void OnServer_StartProcessing();
	void OnServer_SetResourceNode(class AResourceDeposit* ResourceNode);
	void OnServer_SetRecipeSet(const struct FRecipeSet& Set);
	void OnServer_RemoveProcessingRecipe(int32 Location);
	void OnServer_Process(float Delta);
	void OnServer_AddProcessingRecipe(const struct FProcessorRecipesRowHandle& Recipe, int32 Count, TArray<class UInventory*>& AdditionalInventories, class AIcarusPlayerCharacter* Player);
	void OnServer_ActivateProcessor();
	void OnRep_ProcessorActive();
	void OnRep_ProcessingItem();
	bool IsRecipeUnlocked(struct FProcessorRecipesRowHandle* Recipe, class AIcarusPlayerCharacter* PlayerCharacter);
	void Initialise(class UInventory* ProcessorInventory);
	bool HasWaterSourceConnection();
	void GrantOutputItem(struct FCraftingOutput& Output, TArray<struct FItemData>* ConsumedItems);
	int32 GetResourceRecipeValidility(enum class EIcarusResourceType ResourceType, int32 RequiredAmount, const TArray<class UInventory*>& AdditionalInventories);
	struct FRecipeSetsRowHandle GetRecipeSetRow();
	struct FRecipeSet GetRecipeSet();
	bool GetRecipeInputs();
	TArray<struct FProcessingItem> GetProcessingQueue();
	bool GetProcessingData(struct FProcessingData* OutData);
	int32 GetMaxCraftableStack(const struct FProcessorRecipesRowHandle& Recipe, const TArray<class UInventory*>& AdditionalInventories, class AIcarusPlayerCharacter* CraftingPlayer);
	float GetCurrentProcessingItemCraftingSpeedMultiplier();
	float GetCurrentClogCraftingSpeedMultiplier();
	class AIcarusPlayerCharacter* GetCraftingPlayer();
	bool FindRecipe();
	void DeactivateNetworksForProcessing();
	bool CheckRecipeValidityItems(const struct FItemData& Item, int32 Multiplier, const TArray<class UInventory*>& AdditionalInventories, int32* CurrentAmount);
	bool CheckRecipe(const struct FProcessorRecipesRowHandle& Recipe, class AIcarusPlayerCharacter* CraftingPlayer);
	bool CheckOutputStorageAvailable(const struct FProcessorRecipesRowHandle& RecipeRow);
	bool CheckEnergyRequirements();
	bool CanStartProcessing();
	bool CanQueueItem(const struct FProcessingItem& RecipeToQueue, const TArray<class UInventory*>& AdditionalInventories);
	bool CanProcess();
	void AddItem(const struct FItemData& Item);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProcessingFunctionLibrary
class UProcessingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UProcessingFunctionLibrary* GetDefaultObj();

	void SmeltItemsBasedOnChanceSplit(TArray<struct FItemData>& ItemsIn, int32 ChancePercent, TArray<struct FItemData>& ItemsOut, TArray<struct FItemData>& SmeltedItemsOut, class UObject* WorldContextObject);
	TArray<struct FItemData> SmeltItemsBasedOnChance(TArray<struct FItemData>& ItemsIn, int32 ChancePercent, class UObject* WorldContextObject);
	int32 GetPlayerSkinningCookChance(class AIcarusPlayerCharacter* Player);
	int32 GetPlayerShatterSmeltChance(class AIcarusPlayerCharacter* Player);
	int32 GetPlayerMiningSmeltChance(class AIcarusPlayerCharacter* Player);
	int32 GetPlayerFellingScorchConversion(class AIcarusPlayerCharacter* Player);
	int32 GetPlayerFellingScorchChance(class AIcarusPlayerCharacter* Player);
	TArray<struct FProcessorRecipe> GetAllRecipesForSet(struct FRecipeSetsRowHandle& RecipeSetRow);
	TArray<struct FProcessorRecipesRowHandle> GetAllRecipeRowsForSet(struct FRecipeSetsRowHandle& RecipeSetRow);
	TArray<struct FItemData> CookItemsBasedOnChance(TArray<struct FItemData>& Items, int32 ChancePercent, class UObject* WorldContextObject);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProcessingLibrary
class UProcessingLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProcessingLibrary* GetDefaultObj();

	struct FProcessingRowHandle StructToRowHandle(const struct FProcessingEnum& EnumValue);
	class FName StructToName(const struct FProcessingEnum& EnumValue);
	int32 StructToInt(const struct FProcessingEnum& EnumValue);
	struct FProcessingEnum RowHandleToStruct(const struct FProcessingRowHandle& RowHandle);
	void RemoveRowFromProcessingTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProcessingEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProcessingEnum& A, const struct FProcessingEnum& B);
	struct FProcessingEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProcessingRowHandle MakeProcessingFromIndex(int32 Index);
	struct FProcessingEnum MakeProcessingEnum(const struct FProcessingEnum& Enum);
	struct FProcessingRowHandle MakeProcessing(class FName RowName);
	struct FProcessingRowHandle MakeLiteralProcessing(const struct FProcessingRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProcessingEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProcessingStruct(const struct FProcessingRowHandle& RowHandle, struct FProcessingData* Processing, enum class EValid* Paths);
	bool EqualEqual_FProcessingRowHandleFProcessingRowHandle(const struct FProcessingRowHandle& RowHandleA, const struct FProcessingRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProcessingEnum& A, const struct FProcessingEnum& B);
	struct FProcessingRowHandle CastToProcessingRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProcessingEnum(const struct FProcessingEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProcessingTable(class FName Name, const struct FProcessingData& Data, struct FProcessingRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProcessingTable
class UProcessingTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProcessingTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProcessorRecipesLibrary
class UProcessorRecipesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProcessorRecipesLibrary* GetDefaultObj();

	struct FProcessorRecipesRowHandle StructToRowHandle(const struct FProcessorRecipesEnum& EnumValue);
	class FName StructToName(const struct FProcessorRecipesEnum& EnumValue);
	int32 StructToInt(const struct FProcessorRecipesEnum& EnumValue);
	struct FProcessorRecipesEnum RowHandleToStruct(const struct FProcessorRecipesRowHandle& RowHandle);
	void RemoveRowFromProcessorRecipesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProcessorRecipesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProcessorRecipesEnum& A, const struct FProcessorRecipesEnum& B);
	struct FProcessorRecipesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProcessorRecipesRowHandle MakeProcessorRecipesFromIndex(int32 Index);
	struct FProcessorRecipesEnum MakeProcessorRecipesEnum(const struct FProcessorRecipesEnum& Enum);
	struct FProcessorRecipesRowHandle MakeProcessorRecipes(class FName RowName);
	struct FProcessorRecipesRowHandle MakeLiteralProcessorRecipes(const struct FProcessorRecipesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProcessorRecipesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProcessorRecipesStruct(const struct FProcessorRecipesRowHandle& RowHandle, struct FProcessorRecipe* ProcessorRecipes, enum class EValid* Paths);
	bool EqualEqual_FProcessorRecipesRowHandleFProcessorRecipesRowHandle(const struct FProcessorRecipesRowHandle& RowHandleA, const struct FProcessorRecipesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProcessorRecipesEnum& A, const struct FProcessorRecipesEnum& B);
	struct FProcessorRecipesRowHandle CastToProcessorRecipesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProcessorRecipesEnum(const struct FProcessorRecipesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProcessorRecipesTable(class FName Name, const struct FProcessorRecipe& Data, struct FProcessorRecipesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProcessorRecipesTable
class UProcessorRecipesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProcessorRecipesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProjectileTypesLibrary
class UProjectileTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProjectileTypesLibrary* GetDefaultObj();

	struct FProjectileTypesRowHandle StructToRowHandle(const struct FProjectileTypesEnum& EnumValue);
	class FName StructToName(const struct FProjectileTypesEnum& EnumValue);
	int32 StructToInt(const struct FProjectileTypesEnum& EnumValue);
	struct FProjectileTypesEnum RowHandleToStruct(const struct FProjectileTypesRowHandle& RowHandle);
	void RemoveRowFromProjectileTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProjectileTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProjectileTypesEnum& A, const struct FProjectileTypesEnum& B);
	struct FProjectileTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProjectileTypesRowHandle MakeProjectileTypesFromIndex(int32 Index);
	struct FProjectileTypesEnum MakeProjectileTypesEnum(const struct FProjectileTypesEnum& Enum);
	struct FProjectileTypesRowHandle MakeProjectileTypes(class FName RowName);
	struct FProjectileTypesRowHandle MakeLiteralProjectileTypes(const struct FProjectileTypesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProjectileTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProjectileTypesStruct(const struct FProjectileTypesRowHandle& RowHandle, struct FIcarusProjectileType* ProjectileTypes, enum class EValid* Paths);
	bool EqualEqual_FProjectileTypesRowHandleFProjectileTypesRowHandle(const struct FProjectileTypesRowHandle& RowHandleA, const struct FProjectileTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProjectileTypesEnum& A, const struct FProjectileTypesEnum& B);
	struct FProjectileTypesRowHandle CastToProjectileTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProjectileTypesEnum(const struct FProjectileTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProjectileTypesTable(class FName Name, const struct FIcarusProjectileType& Data, struct FProjectileTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProjectileTypesTable
class UProjectileTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProjectileTypesTable* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.ProspectAudioComponent
class UProspectAudioComponent : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UProspectAudioComponent* GetDefaultObj();

	void OnLoadingScreenChanged(bool bIsLoadingScreenShowing);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProspectForecastLibrary
class UProspectForecastLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProspectForecastLibrary* GetDefaultObj();

	struct FProspectForecastRowHandle StructToRowHandle(const struct FProspectForecastEnum& EnumValue);
	class FName StructToName(const struct FProspectForecastEnum& EnumValue);
	int32 StructToInt(const struct FProspectForecastEnum& EnumValue);
	struct FProspectForecastEnum RowHandleToStruct(const struct FProspectForecastRowHandle& RowHandle);
	void RemoveRowFromProspectForecastTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProspectForecastEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProspectForecastEnum& A, const struct FProspectForecastEnum& B);
	struct FProspectForecastEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProspectForecastRowHandle MakeProspectForecastFromIndex(int32 Index);
	struct FProspectForecastEnum MakeProspectForecastEnum(const struct FProspectForecastEnum& Enum);
	struct FProspectForecastRowHandle MakeProspectForecast(class FName RowName);
	struct FProspectForecastRowHandle MakeLiteralProspectForecast(const struct FProspectForecastRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProspectForecastEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProspectForecastStruct(const struct FProspectForecastRowHandle& RowHandle, struct FProspectForecast* ProspectForecast, enum class EValid* Paths);
	bool EqualEqual_FProspectForecastRowHandleFProspectForecastRowHandle(const struct FProspectForecastRowHandle& RowHandleA, const struct FProspectForecastRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProspectForecastEnum& A, const struct FProspectForecastEnum& B);
	struct FProspectForecastRowHandle CastToProspectForecastRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProspectForecastEnum(const struct FProspectForecastEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProspectForecastTable(class FName Name, const struct FProspectForecast& Data, struct FProspectForecastRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProspectForecastTable
class UProspectForecastTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProspectForecastTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProspectForecastValidation
class UProspectForecastValidation : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UProspectForecastValidation* GetDefaultObj();

	int32 ValidateRow(struct FProspectForecastRowHandle& ProspectForecastRow, class FString* OutString);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProspectListLibrary
class UProspectListLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProspectListLibrary* GetDefaultObj();

	struct FProspectListRowHandle StructToRowHandle(const struct FProspectListEnum& EnumValue);
	class FName StructToName(const struct FProspectListEnum& EnumValue);
	int32 StructToInt(const struct FProspectListEnum& EnumValue);
	struct FProspectListEnum RowHandleToStruct(const struct FProspectListRowHandle& RowHandle);
	void RemoveRowFromProspectListTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProspectListEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProspectListEnum& A, const struct FProspectListEnum& B);
	struct FProspectListEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProspectListRowHandle MakeProspectListFromIndex(int32 Index);
	struct FProspectListEnum MakeProspectListEnum(const struct FProspectListEnum& Enum);
	struct FProspectListRowHandle MakeProspectList(class FName RowName);
	struct FProspectListRowHandle MakeLiteralProspectList(const struct FProspectListRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProspectListEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProspectListStruct(const struct FProspectListRowHandle& RowHandle, struct FIcarusProspect* ProspectList, enum class EValid* Paths);
	bool EqualEqual_FProspectListRowHandleFProspectListRowHandle(const struct FProspectListRowHandle& RowHandleA, const struct FProspectListRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProspectListEnum& A, const struct FProspectListEnum& B);
	struct FProspectListRowHandle CastToProspectListRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProspectListEnum(const struct FProspectListEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProspectListTable(class FName Name, const struct FIcarusProspect& Data, struct FProspectListRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProspectListTable
class UProspectListTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProspectListTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ProspectStatsLibrary
class UProspectStatsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UProspectStatsLibrary* GetDefaultObj();

	struct FProspectStatsRowHandle StructToRowHandle(const struct FProspectStatsEnum& EnumValue);
	class FName StructToName(const struct FProspectStatsEnum& EnumValue);
	int32 StructToInt(const struct FProspectStatsEnum& EnumValue);
	struct FProspectStatsEnum RowHandleToStruct(const struct FProspectStatsRowHandle& RowHandle);
	void RemoveRowFromProspectStatsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FProspectStatsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FProspectStatsEnum& A, const struct FProspectStatsEnum& B);
	struct FProspectStatsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FProspectStatsRowHandle MakeProspectStatsFromIndex(int32 Index);
	struct FProspectStatsEnum MakeProspectStatsEnum(const struct FProspectStatsEnum& Enum);
	struct FProspectStatsRowHandle MakeProspectStats(class FName RowName);
	struct FProspectStatsRowHandle MakeLiteralProspectStats(const struct FProspectStatsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FProspectStatsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetProspectStatsStruct(const struct FProspectStatsRowHandle& RowHandle, struct FProspectStat* ProspectStats, enum class EValid* Paths);
	bool EqualEqual_FProspectStatsRowHandleFProspectStatsRowHandle(const struct FProspectStatsRowHandle& RowHandleA, const struct FProspectStatsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FProspectStatsEnum& A, const struct FProspectStatsEnum& B);
	struct FProspectStatsRowHandle CastToProspectStatsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakProspectStatsEnum(const struct FProspectStatsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToProspectStatsTable(class FName Name, const struct FProspectStat& Data, struct FProspectStatsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ProspectStatsTable
class UProspectStatsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UProspectStatsTable* GetDefaultObj();

};

// 0x180 (0x1B0 - 0x30)
// Class Icarus.ProspectSubsystem
class UProspectSubsystem : public UGameInstanceSubsystem
{
public:
	struct FProspectInfo                         ActiveProspect;                                    // 0x30(0x90)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	enum class ELobbyPrivacy                     SelectedLobbyPrivacy;                              // 0xC0(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRequiresSessionUpdate;                            // 0xC1(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8537[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FProspectSaveState                    ActiveProspectSaveState;                           // 0xC8(0xE8)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UProspectSubsystem* GetDefaultObj();

	bool LoadProspectSaveHeader(const class FString& ProspectFilePath, struct FProspectSaveStateHeader* OutProspectSaveStateHeader);
	bool IsTestProspectActive();
	bool IsTestProspect(struct FProspectInfo& ProspectInfo);
	bool IsProspectBackendCompatible(struct FProspectInfo& ProspectInfo);
	bool IsPlayerStillAssociatedWithActiveProspect(const class FString& PlayerID, int32 ChrSlot);
	bool IsOutpostProspect(struct FProspectInfo& ProspectInfo);
	bool IsOpenWorldProspect(struct FProspectInfo& ProspectInfo);
	bool IsActiveProspectBackendCompatible();
	bool HasActiveProspect();
	class FString GetTestProspectID();
	TArray<class FString> GetSavedDeveloperProspectFileNames();
	struct FProspectListRowHandle GetProspectRowHandleFromProspectInfo(struct FProspectInfo& ProspectInfo);
	struct FIcarusProspect GetProspectDataFromProspectInfo(struct FProspectInfo& ProspectInfo);
	class FString GetOutpostProspectFilePath(struct FProspectInfo& ProspectInfo);
	TArray<struct FExistingOutpostData> GetExistingOutpostsOfType(const class FString& ProspectRowName);
	TArray<struct FExistingOutpostData> GetExistingOutpostArchivesOfType(const class FString& ProspectRowName);
	class FString GetDirectoryForProspects();
	class FString GetDirectoryForLocalOutposts();
	class FString GetDirectoryForDeveloperProspects();
	class FString GetDirectoryForBackupProspects();
	class FString GetDeveloperProspectFilePath(const class FString& ProspectFileName);
	class FString GetBackupProspectFilePath(const class FString& ProspectFileName);
	struct FProspectListRowHandle GetActiveProspectRowHandle();
	struct FProspectInfo GetActiveProspectInfo();
	class FString GetActiveProspectID();
	struct FIcarusProspect GetActiveProspectData();
	bool DeleteProspect(const class FString& ProspectID, int32 ChrSlot);
	bool DeleteExistingLocalOutpost(const class FString& OutpostName);
};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.ProspectTalentControllerComponent
class UProspectTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class UProspectTalentControllerComponent* GetDefaultObj();

};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.ProspectTalentModel
class UProspectTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class UProspectTalentModel* GetDefaultObj();

};

// 0xC0 (0x380 - 0x2C0)
// Class Icarus.Quest
class AQuest : public AIcarusActor
{
public:
	FMulticastSparseDelegateProperty_            OnQuestStarted;                                    // 0x2C0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            OnQuestEnded;                                      // 0x2C1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8549[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FQuestsRowHandle                      QuestData;                                         // 0x2C4(0x18)(Edit, BlueprintVisible, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_854A[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FQuestActor>                   RelevantActors;                                    // 0x2E0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AQuest*>                        ActiveQuests;                                      // 0x2F0(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQuestVariable>                QuestVariables;                                    // 0x300(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSubQuest>                     SubQuests;                                         // 0x310(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class AQuest*                                QuestParent;                                       // 0x320(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        CachedDeltaSeconds;                                // 0x328(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bArtificiallyComplete;                             // 0x32C(0x1)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bReloaded;                                         // 0x32D(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_854B[0x52];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQuest* GetDefaultObj();

	void TriggerEvent(const struct FQuestEventsEnum& Event);
	bool SkipStep();
	void Setup(bool bFirstTime);
	void SetRelevantActor(const class FString& Name, bool bUseVariation, class AIcarusActor* Actor);
	void SetQuestFlag(const struct FSessionFlagsEnum& Flag, bool State);
	void SetIntVariable(const class FString& VariableName, int32 Variable);
	void SetFloatVariable(const class FString& VariableName, float Variable);
	void SetBooleanVariable(const class FString& VariableName, bool Variable);
	void RunQuest(const struct FQuestsEnum& Quest, enum class EQuestState* QuestState);
	void RunOperations(float DeltaSeconds);
	void RunFlow();
	bool Run(float DeltaSeconds);
	void RemoveActiveQuest(class AQuest* Quest);
	void ReceiveQuestStarted();
	void ReceiveQuestEnded(bool bWasAbandoned);
	void ReceiveQuestAbandoned();
	void PassEvent(const struct FQuestEventsEnum& Event, class AQuest* Quest);
	void OnIntVariableUpdated(const class FString& Name, float IValue);
	void OnFloatVariableUpdated(const class FString& Name, float FValue);
	void OnBoolVariableUpdated(const class FString& Name, bool bValue);
	void LoadAndCreateQuest(const struct FQuestsEnum& Quest);
	void Initialise(class AQuest* Parent, const struct FQuestsRowHandle& Quest);
	void HandleQuestEvent(const struct FQuestEventsEnum& Event, class AQuest* Quest);
	int32 GetVariation();
	class AIcarusActor* GetRelevantActor(const class FString& Name, bool bUseVariation, enum class EQuestActorState* QuestActorState);
	bool GetQuestFlag(const struct FSessionFlagsEnum& Flag);
	TArray<struct FQuestDescription> GetQuestDescription(int32 Depth);
	int32 GetIntVariable(const class FString& VariableName);
	float GetFloatVariable(const class FString& VariableName);
	void GetDescription(class FText& InDescription, class FText* OutDescription, bool* bOutComplete);
	bool GetBooleanVariable(const class FString& VariableName);
	void GetActiveQuestsData(TArray<struct FQuestsRowHandle>* OutActiveQuests);
	class AQuest* CreateQuest(const struct FQuestsEnum& Quest);
	void CleanupQuest(bool bAbandoned);
	bool Check();
	void ArtificiallyComplete();
	void AddActiveQuest(class AQuest* Quest);
	void AbandonQuest();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestEnemyModifiersLibrary
class UQuestEnemyModifiersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestEnemyModifiersLibrary* GetDefaultObj();

	struct FQuestEnemyModifiersRowHandle StructToRowHandle(const struct FQuestEnemyModifiersEnum& EnumValue);
	class FName StructToName(const struct FQuestEnemyModifiersEnum& EnumValue);
	int32 StructToInt(const struct FQuestEnemyModifiersEnum& EnumValue);
	struct FQuestEnemyModifiersEnum RowHandleToStruct(const struct FQuestEnemyModifiersRowHandle& RowHandle);
	void RemoveRowFromQuestEnemyModifiersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestEnemyModifiersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestEnemyModifiersEnum& A, const struct FQuestEnemyModifiersEnum& B);
	struct FQuestEnemyModifiersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestEnemyModifiersRowHandle MakeQuestEnemyModifiersFromIndex(int32 Index);
	struct FQuestEnemyModifiersEnum MakeQuestEnemyModifiersEnum(const struct FQuestEnemyModifiersEnum& Enum);
	struct FQuestEnemyModifiersRowHandle MakeQuestEnemyModifiers(class FName RowName);
	struct FQuestEnemyModifiersRowHandle MakeLiteralQuestEnemyModifiers(const struct FQuestEnemyModifiersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestEnemyModifiersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestEnemyModifiersStruct(const struct FQuestEnemyModifiersRowHandle& RowHandle, struct FQuestEnemyModifier* QuestEnemyModifiers, enum class EValid* Paths);
	bool EqualEqual_FQuestEnemyModifiersRowHandleFQuestEnemyModifiersRowHandle(const struct FQuestEnemyModifiersRowHandle& RowHandleA, const struct FQuestEnemyModifiersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestEnemyModifiersEnum& A, const struct FQuestEnemyModifiersEnum& B);
	struct FQuestEnemyModifiersRowHandle CastToQuestEnemyModifiersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestEnemyModifiersEnum(const struct FQuestEnemyModifiersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestEnemyModifiersTable(class FName Name, const struct FQuestEnemyModifier& Data, struct FQuestEnemyModifiersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestEnemyModifiersTable
class UQuestEnemyModifiersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestEnemyModifiersTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestEventsLibrary
class UQuestEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestEventsLibrary* GetDefaultObj();

	struct FQuestEventsRowHandle StructToRowHandle(const struct FQuestEventsEnum& EnumValue);
	class FName StructToName(const struct FQuestEventsEnum& EnumValue);
	int32 StructToInt(const struct FQuestEventsEnum& EnumValue);
	struct FQuestEventsEnum RowHandleToStruct(const struct FQuestEventsRowHandle& RowHandle);
	void RemoveRowFromQuestEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestEventsEnum& A, const struct FQuestEventsEnum& B);
	struct FQuestEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestEventsRowHandle MakeQuestEventsFromIndex(int32 Index);
	struct FQuestEventsEnum MakeQuestEventsEnum(const struct FQuestEventsEnum& Enum);
	struct FQuestEventsRowHandle MakeQuestEvents(class FName RowName);
	struct FQuestEventsRowHandle MakeLiteralQuestEvents(const struct FQuestEventsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestEventsStruct(const struct FQuestEventsRowHandle& RowHandle, struct FQuestEvent* QuestEvents, enum class EValid* Paths);
	bool EqualEqual_FQuestEventsRowHandleFQuestEventsRowHandle(const struct FQuestEventsRowHandle& RowHandleA, const struct FQuestEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestEventsEnum& A, const struct FQuestEventsEnum& B);
	struct FQuestEventsRowHandle CastToQuestEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestEventsEnum(const struct FQuestEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestEventsTable(class FName Name, const struct FQuestEvent& Data, struct FQuestEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestEventsTable
class UQuestEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestEventsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestFunctionLibrary
class UQuestFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestFunctionLibrary* GetDefaultObj();

	class FName GetQuestsModifierTableName(enum class EQuestModifiersTableType TableType);
	bool GetQuestModifierDataFromRowHandle(struct FRowHandle& RowHandle, struct FQuestModifierData* OutData);
	bool GetQuestModifierData(struct FQuestModifiersMultiRowHandle& RowHandle, struct FQuestModifierData* OutData);
	bool GetQuestModifierClassFromRow(struct FQuestModifiersMultiRowHandle& RowHandle, TSoftClassPtr<class UQuestModifierBase>* OutQuestModifierClass);
	bool FindProspectListRowHandleFromFactionMission(struct FFactionMissionsRowHandle& MissionRowHandle, struct FProspectListRowHandle* FoundProspectListRowHandle);
	float CalculateMissionRewardModifier(struct FProspectInfo& ProspectInfo, class AIcarusPlayerController* Player, bool bCheckInsurance);
};

// 0xB0 (0x370 - 0x2C0)
// Class Icarus.QuestManager
class AQuestManager : public AIcarusActor
{
public:
	struct FFactionMissionsRowHandle             FactionMission;                                    // 0x2C0(0x18)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EDynamicQuestDifficulty           DynamicQuestDifficulty;                            // 0x2D8(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_856A[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AQuest*                                InitialQuest;                                      // 0x2E0(0x8)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bReloadedFromDatabase;                             // 0x2E8(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIcarusBegunPlay;                                  // 0x2E9(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bMissionComplete;                                  // 0x2EA(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_856B[0x5];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnQuestStarted;                                    // 0x2F0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQuestComplete;                                   // 0x300(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQuestFailed;                                     // 0x310(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQuestAbandoned;                                  // 0x320(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        DynamicQuestDelay;                                 // 0x330(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRunQuests;                                        // 0x334(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_856C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FProspectListRowHandle                DynamicMissionProspect;                            // 0x338(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFactionMissionChanged;                           // 0x350(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        AutoClearCompletedMissionDuration;                 // 0x360(0x4)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_856D[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AQuestManager* GetDefaultObj();

	void TriggerRandomDynamicQuest();
	void TriggerNewMission(struct FFactionMissionsRowHandle& Mission);
	void TriggerDynamicQuest(const struct FDynamicQuestsRowHandle& DynamicQuest, enum class EDynamicQuestDifficulty Difficulty);
	void SetupNewDynamicFactionMission(struct FFactionMissionsRowHandle& Mission, struct FProspectListRowHandle& MissionProspect);
	void SetupFactionMission(struct FFactionMissionsRowHandle& FactionMissionRow, bool bForceSetup);
	void SetupDynamicProspectData(struct FProspectListRowHandle& MissionProspect);
	void OnRep_FactionMission();
	void OnDynamicFactionMissionComplete();
	void InitialQuestAsyncLoadComplete();
	class AQuest* GetQuest();
	void GetActiveQuestsData(TArray<struct FQuestsRowHandle>* OutActiveQuests);
	void CompleteQuest();
	void ClearCompletedMission();
	void CleanupQuests(bool bAbandoned);
	void CancelDynamicQuest();
	void ArtificiallyComplete();
};

// 0x28 (0x248 - 0x220)
// Class Icarus.QuestMarker
class AQuestMarker : public AActor
{
public:
	uint8                                        Pad_856E[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FGameplayTagContainer                 GameplayTags;                                      // 0x228(0x20)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AQuestMarker* GetDefaultObj();

};

// 0x18 (0xC8 - 0xB0)
// Class Icarus.QuestModifierBase
class UQuestModifierBase : public UActorComponent
{
public:
	struct FQuestModifiersMultiRowHandle         ModifierRow;                                       // 0xB0(0x18)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQuestModifierBase* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestModifiersMultiRowHandleLibrary
class UQuestModifiersMultiRowHandleLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestModifiersMultiRowHandleLibrary* GetDefaultObj();

	struct FQuestWeatherModifiersRowHandle ToQuestWeatherModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle);
	struct FQuestVocalisationModifiersRowHandle ToQuestVocalisationModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle);
	struct FQuestEnemyModifiersRowHandle ToQuestEnemyModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle);
	bool NotEqual_QuestModifiersMultiRowHandleQuestModifiersMultiRowHandle(const struct FQuestModifiersMultiRowHandle& A, const struct FQuestModifiersMultiRowHandle& B);
	bool NotEqual_QuestModifiersMultiRowHandleFQuestWeatherModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestWeatherModifiersRowHandle& RowHandle);
	bool NotEqual_QuestModifiersMultiRowHandleFQuestVocalisationModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestVocalisationModifiersRowHandle& RowHandle);
	bool NotEqual_QuestModifiersMultiRowHandleFQuestEnemyModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestEnemyModifiersRowHandle& RowHandle);
	struct FQuestModifiersMultiRowHandle Make(enum class EQuestModifiersTableType Enum, class FName RowName);
	bool IsValid(const struct FQuestModifiersMultiRowHandle& MultiRowHandle);
	bool IsNone(const struct FQuestModifiersMultiRowHandle& MultiRowHandle);
	class FName GetTableNameByIndex(uint8 TableIndex);
	uint8 GetTableIndexByName(class FName TableName);
	void GetQuestWeatherModifiersStruct(const struct FQuestModifiersMultiRowHandle& MultiHandle, struct FQuestWeatherModifier* QuestWeatherModifiersStruct, enum class EValid* Paths);
	void GetQuestVocalisationModifiersStruct(const struct FQuestModifiersMultiRowHandle& MultiHandle, struct FQuestVocalisationModifier* QuestVocalisationModifiersStruct, enum class EValid* Paths);
	void GetQuestEnemyModifiersStruct(const struct FQuestModifiersMultiRowHandle& MultiHandle, struct FQuestEnemyModifier* QuestEnemyModifiersStruct, enum class EValid* Paths);
	struct FRowMetadata GetMetadata(const struct FQuestModifiersMultiRowHandle& MultiRowHandle);
	struct FQuestModifiersMultiRowHandle FromQuestWeatherModifiersRowHandle(const struct FQuestWeatherModifiersRowHandle& RowHandle);
	struct FQuestModifiersMultiRowHandle FromQuestVocalisationModifiersRowHandle(const struct FQuestVocalisationModifiersRowHandle& RowHandle);
	struct FQuestModifiersMultiRowHandle FromQuestEnemyModifiersRowHandle(const struct FQuestEnemyModifiersRowHandle& RowHandle);
	bool EqualEqual_QuestModifiersMultiRowHandleQuestModifiersMultiRowHandle(const struct FQuestModifiersMultiRowHandle& A, const struct FQuestModifiersMultiRowHandle& B);
	bool EqualEqual_QuestModifiersMultiRowHandleFQuestWeatherModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestWeatherModifiersRowHandle& RowHandle);
	bool EqualEqual_QuestModifiersMultiRowHandleFQuestVocalisationModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestVocalisationModifiersRowHandle& RowHandle);
	bool EqualEqual_QuestModifiersMultiRowHandleFQuestEnemyModifiersRowHandle(const struct FQuestModifiersMultiRowHandle& MultiHandle, const struct FQuestEnemyModifiersRowHandle& RowHandle);
	void Break(const struct FQuestModifiersMultiRowHandle& MultiRowHandle, enum class EQuestModifiersTableType* OutEnum, class FName* OutName);
};

// 0x18 (0xE0 - 0xC8)
// Class Icarus.QuestModifierVocalisation
class UQuestModifierVocalisation : public UQuestModifierBase
{
public:
	struct FQuestVocalisationModifiersRowHandle  VocalisationRowHandle;                             // 0xC8(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQuestModifierVocalisation* GetDefaultObj();

	void OnQuestStarted();
	void OnQuestEnded();
};

// 0x70 (0xA0 - 0x30)
// Class Icarus.QuestNotificationSubsystem
class UQuestNotificationSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnQuestStartedNotify;                              // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnQuestEndedNotify;                                // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMissionStartedNotify;                            // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMissionCompletedNotify;                          // 0x60(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMissionFailedNotify;                             // 0x70(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnMissionAbandonedNotify;                          // 0x80(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnRequestResupplyNotify;                           // 0x90(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UQuestNotificationSubsystem* GetDefaultObj();

	void BroadcastRequestResupplyDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastQuestStartedDelegate(class AQuest* Quest);
	void BroadcastQuestEndedDelegate(class AQuest* Quest);
	void BroadcastMissionStartedDelegate(const struct FFactionMissionsRowHandle& Mission);
	void BroadcastMissionFailedDelegate(class AQuest* Quest, const struct FFactionMissionsRowHandle& Mission);
	void BroadcastMissionCompletedDelegate(class AQuest* Quest, const struct FFactionMissionsRowHandle& Mission);
	void BroadcastMissionAbandonedDelegate(const struct FFactionMissionsRowHandle& Mission);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestQueriesLibrary
class UQuestQueriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestQueriesLibrary* GetDefaultObj();

	struct FQuestQueriesRowHandle StructToRowHandle(const struct FQuestQueriesEnum& EnumValue);
	class FName StructToName(const struct FQuestQueriesEnum& EnumValue);
	int32 StructToInt(const struct FQuestQueriesEnum& EnumValue);
	struct FQuestQueriesEnum RowHandleToStruct(const struct FQuestQueriesRowHandle& RowHandle);
	void RemoveRowFromQuestQueriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestQueriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestQueriesEnum& A, const struct FQuestQueriesEnum& B);
	struct FQuestQueriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestQueriesRowHandle MakeQuestQueriesFromIndex(int32 Index);
	struct FQuestQueriesEnum MakeQuestQueriesEnum(const struct FQuestQueriesEnum& Enum);
	struct FQuestQueriesRowHandle MakeQuestQueries(class FName RowName);
	struct FQuestQueriesRowHandle MakeLiteralQuestQueries(const struct FQuestQueriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestQueriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestQueriesStruct(const struct FQuestQueriesRowHandle& RowHandle, struct FQuestQueries* QuestQueries, enum class EValid* Paths);
	bool EqualEqual_FQuestQueriesRowHandleFQuestQueriesRowHandle(const struct FQuestQueriesRowHandle& RowHandleA, const struct FQuestQueriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestQueriesEnum& A, const struct FQuestQueriesEnum& B);
	struct FQuestQueriesRowHandle CastToQuestQueriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestQueriesEnum(const struct FQuestQueriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestQueriesTable(class FName Name, const struct FQuestQueries& Data, struct FQuestQueriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestQueriesTable
class UQuestQueriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestQueriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestsLibrary
class UQuestsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestsLibrary* GetDefaultObj();

	struct FQuestsRowHandle StructToRowHandle(const struct FQuestsEnum& EnumValue);
	class FName StructToName(const struct FQuestsEnum& EnumValue);
	int32 StructToInt(const struct FQuestsEnum& EnumValue);
	struct FQuestsEnum RowHandleToStruct(const struct FQuestsRowHandle& RowHandle);
	void RemoveRowFromQuestsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestsEnum& A, const struct FQuestsEnum& B);
	struct FQuestsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestsRowHandle MakeQuestsFromIndex(int32 Index);
	struct FQuestsEnum MakeQuestsEnum(const struct FQuestsEnum& Enum);
	struct FQuestsRowHandle MakeQuests(class FName RowName);
	struct FQuestsRowHandle MakeLiteralQuests(const struct FQuestsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestsStruct(const struct FQuestsRowHandle& RowHandle, struct FQuestSetup* Quests, enum class EValid* Paths);
	bool EqualEqual_FQuestsRowHandleFQuestsRowHandle(const struct FQuestsRowHandle& RowHandleA, const struct FQuestsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestsEnum& A, const struct FQuestsEnum& B);
	struct FQuestsRowHandle CastToQuestsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestsEnum(const struct FQuestsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestsTable(class FName Name, const struct FQuestSetup& Data, struct FQuestsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestsTable
class UQuestsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestVocalisationModifiersLibrary
class UQuestVocalisationModifiersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestVocalisationModifiersLibrary* GetDefaultObj();

	struct FQuestVocalisationModifiersRowHandle StructToRowHandle(const struct FQuestVocalisationModifiersEnum& EnumValue);
	class FName StructToName(const struct FQuestVocalisationModifiersEnum& EnumValue);
	int32 StructToInt(const struct FQuestVocalisationModifiersEnum& EnumValue);
	struct FQuestVocalisationModifiersEnum RowHandleToStruct(const struct FQuestVocalisationModifiersRowHandle& RowHandle);
	void RemoveRowFromQuestVocalisationModifiersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestVocalisationModifiersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestVocalisationModifiersEnum& A, const struct FQuestVocalisationModifiersEnum& B);
	struct FQuestVocalisationModifiersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestVocalisationModifiersRowHandle MakeQuestVocalisationModifiersFromIndex(int32 Index);
	struct FQuestVocalisationModifiersEnum MakeQuestVocalisationModifiersEnum(const struct FQuestVocalisationModifiersEnum& Enum);
	struct FQuestVocalisationModifiersRowHandle MakeQuestVocalisationModifiers(class FName RowName);
	struct FQuestVocalisationModifiersRowHandle MakeLiteralQuestVocalisationModifiers(const struct FQuestVocalisationModifiersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestVocalisationModifiersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestVocalisationModifiersStruct(const struct FQuestVocalisationModifiersRowHandle& RowHandle, struct FQuestVocalisationModifier* QuestVocalisationModifiers, enum class EValid* Paths);
	bool EqualEqual_FQuestVocalisationModifiersRowHandleFQuestVocalisationModifiersRowHandle(const struct FQuestVocalisationModifiersRowHandle& RowHandleA, const struct FQuestVocalisationModifiersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestVocalisationModifiersEnum& A, const struct FQuestVocalisationModifiersEnum& B);
	struct FQuestVocalisationModifiersRowHandle CastToQuestVocalisationModifiersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestVocalisationModifiersEnum(const struct FQuestVocalisationModifiersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestVocalisationModifiersTable(class FName Name, const struct FQuestVocalisationModifier& Data, struct FQuestVocalisationModifiersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestVocalisationModifiersTable
class UQuestVocalisationModifiersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestVocalisationModifiersTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuestWeatherModifiersLibrary
class UQuestWeatherModifiersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuestWeatherModifiersLibrary* GetDefaultObj();

	struct FQuestWeatherModifiersRowHandle StructToRowHandle(const struct FQuestWeatherModifiersEnum& EnumValue);
	class FName StructToName(const struct FQuestWeatherModifiersEnum& EnumValue);
	int32 StructToInt(const struct FQuestWeatherModifiersEnum& EnumValue);
	struct FQuestWeatherModifiersEnum RowHandleToStruct(const struct FQuestWeatherModifiersRowHandle& RowHandle);
	void RemoveRowFromQuestWeatherModifiersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuestWeatherModifiersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuestWeatherModifiersEnum& A, const struct FQuestWeatherModifiersEnum& B);
	struct FQuestWeatherModifiersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuestWeatherModifiersRowHandle MakeQuestWeatherModifiersFromIndex(int32 Index);
	struct FQuestWeatherModifiersEnum MakeQuestWeatherModifiersEnum(const struct FQuestWeatherModifiersEnum& Enum);
	struct FQuestWeatherModifiersRowHandle MakeQuestWeatherModifiers(class FName RowName);
	struct FQuestWeatherModifiersRowHandle MakeLiteralQuestWeatherModifiers(const struct FQuestWeatherModifiersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuestWeatherModifiersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuestWeatherModifiersStruct(const struct FQuestWeatherModifiersRowHandle& RowHandle, struct FQuestWeatherModifier* QuestWeatherModifiers, enum class EValid* Paths);
	bool EqualEqual_FQuestWeatherModifiersRowHandleFQuestWeatherModifiersRowHandle(const struct FQuestWeatherModifiersRowHandle& RowHandleA, const struct FQuestWeatherModifiersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuestWeatherModifiersEnum& A, const struct FQuestWeatherModifiersEnum& B);
	struct FQuestWeatherModifiersRowHandle CastToQuestWeatherModifiersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuestWeatherModifiersEnum(const struct FQuestWeatherModifiersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuestWeatherModifiersTable(class FName Name, const struct FQuestWeatherModifier& Data, struct FQuestWeatherModifiersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuestWeatherModifiersTable
class UQuestWeatherModifiersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuestWeatherModifiersTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.QuickMoveLibrary
class UQuickMoveLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UQuickMoveLibrary* GetDefaultObj();

	struct FQuickMoveRowHandle StructToRowHandle(const struct FQuickMoveEnum& EnumValue);
	class FName StructToName(const struct FQuickMoveEnum& EnumValue);
	int32 StructToInt(const struct FQuickMoveEnum& EnumValue);
	struct FQuickMoveEnum RowHandleToStruct(const struct FQuickMoveRowHandle& RowHandle);
	void RemoveRowFromQuickMoveTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FQuickMoveEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FQuickMoveEnum& A, const struct FQuickMoveEnum& B);
	struct FQuickMoveEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FQuickMoveRowHandle MakeQuickMoveRowFromSource(struct FInventoryIDEnum& InSource);
	struct FQuickMoveRowHandle MakeQuickMoveFromIndex(int32 Index);
	struct FQuickMoveEnum MakeQuickMoveEnum(const struct FQuickMoveEnum& Enum);
	struct FQuickMoveRowHandle MakeQuickMove(class FName RowName);
	struct FQuickMoveRowHandle MakeLiteralQuickMove(const struct FQuickMoveRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FQuickMoveEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetQuickMoveStruct(const struct FQuickMoveRowHandle& RowHandle, struct FQuickMove* QuickMove, enum class EValid* Paths);
	bool EqualEqual_FQuickMoveRowHandleFQuickMoveRowHandle(const struct FQuickMoveRowHandle& RowHandleA, const struct FQuickMoveRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FQuickMoveEnum& A, const struct FQuickMoveEnum& B);
	struct FQuickMoveRowHandle CastToQuickMoveRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakQuickMoveEnum(const struct FQuickMoveEnum& Enum, class FName* Name, int32* Index);
	void AddRowToQuickMoveTable(class FName Name, const struct FQuickMove& Data, struct FQuickMoveRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.QuickMoveTable
class UQuickMoveTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UQuickMoveTable* GetDefaultObj();

};

// 0x80 (0x2E0 - 0x260)
// Class Icarus.RadarMapGridBase
class URadarMapGridBase : public UUserWidget
{
public:
	struct FSlateFontInfo                        FontInfo;                                          // 0x260(0x58)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                             NameOffset;                                        // 0x2B8(0x8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                          GridTint;                                          // 0x2C0(0x10)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        GridNumX;                                          // 0x2D0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        GridNumY;                                          // 0x2D4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        GridThickness;                                     // 0x2D8(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_85B9[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URadarMapGridBase* GetDefaultObj();

	void RenderGridImage(bool bInRenderImage);
	void OnRenderGridImage(bool bInRenderImage);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RadialMenuDataLibrary
class URadialMenuDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URadialMenuDataLibrary* GetDefaultObj();

	struct FRadialMenuDataRowHandle StructToRowHandle(const struct FRadialMenuDataEnum& EnumValue);
	class FName StructToName(const struct FRadialMenuDataEnum& EnumValue);
	int32 StructToInt(const struct FRadialMenuDataEnum& EnumValue);
	struct FRadialMenuDataEnum RowHandleToStruct(const struct FRadialMenuDataRowHandle& RowHandle);
	void RemoveRowFromRadialMenuDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRadialMenuDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRadialMenuDataEnum& A, const struct FRadialMenuDataEnum& B);
	struct FRadialMenuDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRadialMenuDataRowHandle MakeRadialMenuDataFromIndex(int32 Index);
	struct FRadialMenuDataEnum MakeRadialMenuDataEnum(const struct FRadialMenuDataEnum& Enum);
	struct FRadialMenuDataRowHandle MakeRadialMenuData(class FName RowName);
	struct FRadialMenuDataRowHandle MakeLiteralRadialMenuData(const struct FRadialMenuDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRadialMenuDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRadialMenuDataStruct(const struct FRadialMenuDataRowHandle& RowHandle, struct FRadialMenuData* RadialMenuData, enum class EValid* Paths);
	bool EqualEqual_FRadialMenuDataRowHandleFRadialMenuDataRowHandle(const struct FRadialMenuDataRowHandle& RowHandleA, const struct FRadialMenuDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRadialMenuDataEnum& A, const struct FRadialMenuDataEnum& B);
	struct FRadialMenuDataRowHandle CastToRadialMenuDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRadialMenuDataEnum(const struct FRadialMenuDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRadialMenuDataTable(class FName Name, const struct FRadialMenuData& Data, struct FRadialMenuDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RadialMenuDataTable
class URadialMenuDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URadialMenuDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RadialOptionsLibrary
class URadialOptionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URadialOptionsLibrary* GetDefaultObj();

	struct FRadialOptionsRowHandle StructToRowHandle(const struct FRadialOptionsEnum& EnumValue);
	class FName StructToName(const struct FRadialOptionsEnum& EnumValue);
	int32 StructToInt(const struct FRadialOptionsEnum& EnumValue);
	struct FRadialOptionsEnum RowHandleToStruct(const struct FRadialOptionsRowHandle& RowHandle);
	void RemoveRowFromRadialOptionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRadialOptionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRadialOptionsEnum& A, const struct FRadialOptionsEnum& B);
	struct FRadialOptionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRadialOptionsRowHandle MakeRadialOptionsFromIndex(int32 Index);
	struct FRadialOptionsEnum MakeRadialOptionsEnum(const struct FRadialOptionsEnum& Enum);
	struct FRadialOptionsRowHandle MakeRadialOptions(class FName RowName);
	struct FRadialOptionsRowHandle MakeLiteralRadialOptions(const struct FRadialOptionsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRadialOptionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRadialOptionsStruct(const struct FRadialOptionsRowHandle& RowHandle, struct FRadialOption* RadialOptions, enum class EValid* Paths);
	bool EqualEqual_FRadialOptionsRowHandleFRadialOptionsRowHandle(const struct FRadialOptionsRowHandle& RowHandleA, const struct FRadialOptionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRadialOptionsEnum& A, const struct FRadialOptionsEnum& B);
	struct FRadialOptionsRowHandle CastToRadialOptionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRadialOptionsEnum(const struct FRadialOptionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRadialOptionsTable(class FName Name, const struct FRadialOption& Data, struct FRadialOptionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RadialOptionsTable
class URadialOptionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URadialOptionsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RangedWeaponDataLibrary
class URangedWeaponDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URangedWeaponDataLibrary* GetDefaultObj();

	struct FRangedWeaponDataRowHandle StructToRowHandle(const struct FRangedWeaponDataEnum& EnumValue);
	class FName StructToName(const struct FRangedWeaponDataEnum& EnumValue);
	int32 StructToInt(const struct FRangedWeaponDataEnum& EnumValue);
	struct FRangedWeaponDataEnum RowHandleToStruct(const struct FRangedWeaponDataRowHandle& RowHandle);
	void RemoveRowFromRangedWeaponDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRangedWeaponDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRangedWeaponDataEnum& A, const struct FRangedWeaponDataEnum& B);
	struct FRangedWeaponDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRangedWeaponDataRowHandle MakeRangedWeaponDataFromIndex(int32 Index);
	struct FRangedWeaponDataEnum MakeRangedWeaponDataEnum(const struct FRangedWeaponDataEnum& Enum);
	struct FRangedWeaponDataRowHandle MakeRangedWeaponData(class FName RowName);
	struct FRangedWeaponDataRowHandle MakeLiteralRangedWeaponData(const struct FRangedWeaponDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRangedWeaponDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRangedWeaponDataStruct(const struct FRangedWeaponDataRowHandle& RowHandle, struct FRangedWeaponData* RangedWeaponData, enum class EValid* Paths);
	bool EqualEqual_FRangedWeaponDataRowHandleFRangedWeaponDataRowHandle(const struct FRangedWeaponDataRowHandle& RowHandleA, const struct FRangedWeaponDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRangedWeaponDataEnum& A, const struct FRangedWeaponDataEnum& B);
	struct FRangedWeaponDataRowHandle CastToRangedWeaponDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRangedWeaponDataEnum(const struct FRangedWeaponDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRangedWeaponDataTable(class FName Name, const struct FRangedWeaponData& Data, struct FRangedWeaponDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RangedWeaponDataTable
class URangedWeaponDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URangedWeaponDataTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RCONCommandLibrary
class URCONCommandLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URCONCommandLibrary* GetDefaultObj();

	struct FRCONCommandRowHandle StructToRowHandle(const struct FRCONCommandEnum& EnumValue);
	class FName StructToName(const struct FRCONCommandEnum& EnumValue);
	int32 StructToInt(const struct FRCONCommandEnum& EnumValue);
	struct FRCONCommandEnum RowHandleToStruct(const struct FRCONCommandRowHandle& RowHandle);
	void RemoveRowFromRCONCommandTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRCONCommandEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRCONCommandEnum& A, const struct FRCONCommandEnum& B);
	struct FRCONCommandEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRCONCommandRowHandle MakeRCONCommandFromIndex(int32 Index);
	struct FRCONCommandEnum MakeRCONCommandEnum(const struct FRCONCommandEnum& Enum);
	struct FRCONCommandRowHandle MakeRCONCommand(class FName RowName);
	struct FRCONCommandRowHandle MakeLiteralRCONCommand(const struct FRCONCommandRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRCONCommandEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRCONCommandStruct(const struct FRCONCommandRowHandle& RowHandle, struct FRCONCommandData* RCONCommand, enum class EValid* Paths);
	bool EqualEqual_FRCONCommandRowHandleFRCONCommandRowHandle(const struct FRCONCommandRowHandle& RowHandleA, const struct FRCONCommandRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRCONCommandEnum& A, const struct FRCONCommandEnum& B);
	struct FRCONCommandRowHandle CastToRCONCommandRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRCONCommandEnum(const struct FRCONCommandEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRCONCommandTable(class FName Name, const struct FRCONCommandData& Data, struct FRCONCommandRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RCONCommandTable
class URCONCommandTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URCONCommandTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RecipeSetsLibrary
class URecipeSetsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URecipeSetsLibrary* GetDefaultObj();

	struct FRecipeSetsRowHandle StructToRowHandle(const struct FRecipeSetsEnum& EnumValue);
	class FName StructToName(const struct FRecipeSetsEnum& EnumValue);
	int32 StructToInt(const struct FRecipeSetsEnum& EnumValue);
	struct FRecipeSetsEnum RowHandleToStruct(const struct FRecipeSetsRowHandle& RowHandle);
	void RemoveRowFromRecipeSetsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRecipeSetsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRecipeSetsEnum& A, const struct FRecipeSetsEnum& B);
	struct FRecipeSetsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRecipeSetsRowHandle MakeRecipeSetsFromIndex(int32 Index);
	struct FRecipeSetsEnum MakeRecipeSetsEnum(const struct FRecipeSetsEnum& Enum);
	struct FRecipeSetsRowHandle MakeRecipeSets(class FName RowName);
	struct FRecipeSetsRowHandle MakeLiteralRecipeSets(const struct FRecipeSetsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRecipeSetsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRecipeSetsStruct(const struct FRecipeSetsRowHandle& RowHandle, struct FRecipeSet* RecipeSets, enum class EValid* Paths);
	bool EqualEqual_FRecipeSetsRowHandleFRecipeSetsRowHandle(const struct FRecipeSetsRowHandle& RowHandleA, const struct FRecipeSetsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRecipeSetsEnum& A, const struct FRecipeSetsEnum& B);
	struct FRecipeSetsRowHandle CastToRecipeSetsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRecipeSetsEnum(const struct FRecipeSetsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRecipeSetsTable(class FName Name, const struct FRecipeSet& Data, struct FRecipeSetsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RecipeSetsTable
class URecipeSetsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URecipeSetsTable* GetDefaultObj();

};

// 0x50 (0x100 - 0xB0)
// Class Icarus.RemoteUserSettings
class URemoteUserSettings : public UActorComponent
{
public:
	uint8                                        Pad_85F3[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URemoteUserSettings* GetDefaultObj();

	void Server_ReceiveSettings(TArray<struct FRemoteUserSettingAndValue>& SettingsIn);
	void Server_ReceiveSetting(struct FRemoteUserSettingAndValue& SettingIn);
	void RemoteUserSettingChanged(enum class ERemoteUserSetting UserSetting, int32 Value);
	void Client_PushSettings();
	void Client_PushSetting(enum class ERemoteUserSetting ID, int32 Value);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RepairFunctionLibrary
class URepairFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class URepairFunctionLibrary* GetDefaultObj();

	void SplitRepairableItems(TArray<struct FRepairableItem>& RepairListIn, TArray<struct FRepairableItem>& CanRepairOut, TArray<struct FQueueItem>& CanRepairMaterialsOut, TArray<struct FRepairableItem>& CantRepairOut, TArray<struct FRepairableItem>& NeedsPowerOut);
	void SortAndTagRepairableItems(TArray<struct FRepairableItem>& RepairList, TArray<struct FQueueItem>& PlayerMaterials);
	enum class ERepairItemTier RepairItemTier(struct FItemData& Item);
	bool RepairItemIsArmour(struct FItemData& Item);
	void GetRepairableItems(const TArray<class UInventory*>& Inventories, TArray<struct FRepairableItem>& RepairListOut, bool bHavePower, bool bArmor, bool bWorkshopOnly, bool bExcludeWorkshop);
	void GetQueueItemDetails(struct FQueueItem& QueueItem, struct FItemsStaticRowHandle* Item, int32* Count);
	void GetPlayerMaterials(class AIcarusPlayerCharacter* Character, TArray<struct FRepairableItem>& RepairListIn, TArray<struct FQueueItem>& MaterialsOut);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RepGraphClassPoliciesLibrary
class URepGraphClassPoliciesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URepGraphClassPoliciesLibrary* GetDefaultObj();

	struct FRepGraphClassPoliciesRowHandle StructToRowHandle(const struct FRepGraphClassPoliciesEnum& EnumValue);
	class FName StructToName(const struct FRepGraphClassPoliciesEnum& EnumValue);
	int32 StructToInt(const struct FRepGraphClassPoliciesEnum& EnumValue);
	struct FRepGraphClassPoliciesEnum RowHandleToStruct(const struct FRepGraphClassPoliciesRowHandle& RowHandle);
	void RemoveRowFromRepGraphClassPoliciesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRepGraphClassPoliciesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRepGraphClassPoliciesEnum& A, const struct FRepGraphClassPoliciesEnum& B);
	struct FRepGraphClassPoliciesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRepGraphClassPoliciesRowHandle MakeRepGraphClassPoliciesFromIndex(int32 Index);
	struct FRepGraphClassPoliciesEnum MakeRepGraphClassPoliciesEnum(const struct FRepGraphClassPoliciesEnum& Enum);
	struct FRepGraphClassPoliciesRowHandle MakeRepGraphClassPolicies(class FName RowName);
	struct FRepGraphClassPoliciesRowHandle MakeLiteralRepGraphClassPolicies(const struct FRepGraphClassPoliciesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRepGraphClassPoliciesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRepGraphClassPoliciesStruct(const struct FRepGraphClassPoliciesRowHandle& RowHandle, struct FRepGraphClassPolicy* RepGraphClassPolicies, enum class EValid* Paths);
	bool EqualEqual_FRepGraphClassPoliciesRowHandleFRepGraphClassPoliciesRowHandle(const struct FRepGraphClassPoliciesRowHandle& RowHandleA, const struct FRepGraphClassPoliciesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRepGraphClassPoliciesEnum& A, const struct FRepGraphClassPoliciesEnum& B);
	struct FRepGraphClassPoliciesRowHandle CastToRepGraphClassPoliciesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRepGraphClassPoliciesEnum(const struct FRepGraphClassPoliciesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRepGraphClassPoliciesTable(class FName Name, const struct FRepGraphClassPolicy& Data, struct FRepGraphClassPoliciesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RepGraphClassPoliciesTable
class URepGraphClassPoliciesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URepGraphClassPoliciesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RepGraphClassSettingsLibrary
class URepGraphClassSettingsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URepGraphClassSettingsLibrary* GetDefaultObj();

	struct FRepGraphClassSettingsRowHandle StructToRowHandle(const struct FRepGraphClassSettingsEnum& EnumValue);
	class FName StructToName(const struct FRepGraphClassSettingsEnum& EnumValue);
	int32 StructToInt(const struct FRepGraphClassSettingsEnum& EnumValue);
	struct FRepGraphClassSettingsEnum RowHandleToStruct(const struct FRepGraphClassSettingsRowHandle& RowHandle);
	void RemoveRowFromRepGraphClassSettingsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRepGraphClassSettingsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRepGraphClassSettingsEnum& A, const struct FRepGraphClassSettingsEnum& B);
	struct FRepGraphClassSettingsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRepGraphClassSettingsRowHandle MakeRepGraphClassSettingsFromIndex(int32 Index);
	struct FRepGraphClassSettingsEnum MakeRepGraphClassSettingsEnum(const struct FRepGraphClassSettingsEnum& Enum);
	struct FRepGraphClassSettingsRowHandle MakeRepGraphClassSettings(class FName RowName);
	struct FRepGraphClassSettingsRowHandle MakeLiteralRepGraphClassSettings(const struct FRepGraphClassSettingsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRepGraphClassSettingsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRepGraphClassSettingsStruct(const struct FRepGraphClassSettingsRowHandle& RowHandle, struct FRepGraphClassSettings* RepGraphClassSettings, enum class EValid* Paths);
	bool EqualEqual_FRepGraphClassSettingsRowHandleFRepGraphClassSettingsRowHandle(const struct FRepGraphClassSettingsRowHandle& RowHandleA, const struct FRepGraphClassSettingsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRepGraphClassSettingsEnum& A, const struct FRepGraphClassSettingsEnum& B);
	struct FRepGraphClassSettingsRowHandle CastToRepGraphClassSettingsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRepGraphClassSettingsEnum(const struct FRepGraphClassSettingsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRepGraphClassSettingsTable(class FName Name, const struct FRepGraphClassSettings& Data, struct FRepGraphClassSettingsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RepGraphClassSettingsTable
class URepGraphClassSettingsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URepGraphClassSettingsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RepGraphPolicyFunctionLibrary
class URepGraphPolicyFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class URepGraphPolicyFunctionLibrary* GetDefaultObj();

	TSoftClassPtr<class AActor> GetPolicyClassSoftPtr(struct FRepGraphClassPolicy& Policy);
};

// 0x28 (0x248 - 0x220)
// Class Icarus.ReplicatedNiagaraSystem
class AReplicatedNiagaraSystem : public AActor
{
public:
	class UNiagaraSystem*                        SystemTemplate;                                    // 0x220(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoDestroy;                                      // 0x228(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAutoActivate;                                     // 0x229(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ENCPoolMethod                     PoolingMethod;                                     // 0x22A(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bPreCullCheck;                                     // 0x22B(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_860E[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USceneComponent*                       PositionComponent;                                 // 0x230(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  PositionComponentSocket;                           // 0x238(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                     SpawnedNiagaraComponent;                           // 0x240(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class AReplicatedNiagaraSystem* GetDefaultObj();

};

// 0x80 (0xB0 - 0x30)
// Class Icarus.RequestPlayerPersona
class URequestPlayerPersona : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_            OnSuccess;                                         // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnFailure;                                         // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_8610[0x60];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URequestPlayerPersona* GetDefaultObj();

	void TryCompleteRequest();
	void RequestTimedOut();
	class URequestPlayerPersona* IcarusRequestPlayerPersona(class UObject* WorldContextObject, const class FString& PlayerID, bool bNameOnly);
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.ResourceComponent
class UResourceComponent : public UActorComponent
{
public:
	TArray<struct FResourceFlow>                 Resources;                                         // 0xB0(0x10)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                PartialUnits;                                      // 0xC0(0x10)(ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UResourceComponent* GetDefaultObj();

	bool WillCauseOverdraw(enum class EIcarusResourceType ResourceType, float FlowRate);
	void UpdateResourceFlow(class UTraitComponent* TraitComponent, enum class EIcarusResourceType ResourceType, float FlowRate);
	void StopProducers(enum class EIcarusResourceType ResourceType);
	void StopConsumers(enum class EIcarusResourceType ResourceType);
	void ProcessResourceFlow(float DeltaTime);
	float GetResourceFlowRate(enum class EIcarusResourceType ResourceType);
	int32 GetCurrentSourceFlow(class UTraitComponent* TraitComponent, enum class EIcarusResourceType ResourceType);
	float GetCurrentClogFlowMultiplier();
	void ClearResourceFlow(class UTraitComponent* TraitComponent);
};

// 0x20 (0x2E0 - 0x2C0)
// Class Icarus.ResourceDeposit
class AResourceDeposit : public AIcarusActor
{
public:
	int32                                        ResourceRemaining;                                 // 0x2C0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOreDepositRowHandle                  Type;                                              // 0x2C4(0x18)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8616[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AResourceDeposit* GetDefaultObj();

};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.ResourceDepositRecorderComponent
class UResourceDepositRecorderComponent : public UActorStateRecorderComponent
{
public:
	int32                                        ResourceRemaining;                                 // 0x1A8(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  ResourceDTKey;                                     // 0x1AC(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bShowingMapIcon;                                   // 0x1B4(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8617[0xB];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UResourceDepositRecorderComponent* GetDefaultObj();

};

// 0x0 (0x1C0 - 0x1C0)
// Class Icarus.ResourceDepositIceRecorderComponent
class UResourceDepositIceRecorderComponent : public UResourceDepositRecorderComponent
{
public:

	static class UClass* StaticClass();
	static class UResourceDepositIceRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ResourceInteractionInterface
class IResourceInteractionInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IResourceInteractionInterface* GetDefaultObj();

};

// 0x70 (0x330 - 0x2C0)
// Class Icarus.ResourceNetwork
class AResourceNetwork : public AIcarusActor
{
public:
	TMap<class ADeployable*, int32>              ActiveDevices;                                     // 0x2C0(0x50)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class ADeployable*>                   LinkedDevices;                                     // 0x310(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                        ProviderSum;                                       // 0x320(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        ConsumerSum;                                       // 0x324(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class EIcarusResourceType               NetworkType;                                       // 0x328(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_861D[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AResourceNetwork* GetDefaultObj();

	bool WillOverdraw(int32 Rate);
	bool UpdateDevice(class ADeployable* Device, int32 Rate);
	void RemoveLinkedDevice(class ADeployable* Device);
	bool IsActiveDevice(class ADeployable* Device, int32 Rate);
	enum class EIcarusResourceType GetNetworkType();
	bool DeactivateDevice(class ADeployable* Device);
	bool ActivateDevice(class ADeployable* Device, int32 Rate);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ResourceNodeAudioDataLibrary
class UResourceNodeAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UResourceNodeAudioDataLibrary* GetDefaultObj();

	struct FResourceNodeAudioDataRowHandle StructToRowHandle(const struct FResourceNodeAudioDataEnum& EnumValue);
	class FName StructToName(const struct FResourceNodeAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FResourceNodeAudioDataEnum& EnumValue);
	struct FResourceNodeAudioDataEnum RowHandleToStruct(const struct FResourceNodeAudioDataRowHandle& RowHandle);
	void RemoveRowFromResourceNodeAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FResourceNodeAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FResourceNodeAudioDataEnum& A, const struct FResourceNodeAudioDataEnum& B);
	struct FResourceNodeAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FResourceNodeAudioDataRowHandle MakeResourceNodeAudioDataFromIndex(int32 Index);
	struct FResourceNodeAudioDataEnum MakeResourceNodeAudioDataEnum(const struct FResourceNodeAudioDataEnum& Enum);
	struct FResourceNodeAudioDataRowHandle MakeResourceNodeAudioData(class FName RowName);
	struct FResourceNodeAudioDataRowHandle MakeLiteralResourceNodeAudioData(const struct FResourceNodeAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FResourceNodeAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetResourceNodeAudioDataStruct(const struct FResourceNodeAudioDataRowHandle& RowHandle, struct FResourceNodeAudioData* ResourceNodeAudioData, enum class EValid* Paths);
	bool EqualEqual_FResourceNodeAudioDataRowHandleFResourceNodeAudioDataRowHandle(const struct FResourceNodeAudioDataRowHandle& RowHandleA, const struct FResourceNodeAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FResourceNodeAudioDataEnum& A, const struct FResourceNodeAudioDataEnum& B);
	struct FResourceNodeAudioDataRowHandle CastToResourceNodeAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakResourceNodeAudioDataEnum(const struct FResourceNodeAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToResourceNodeAudioDataTable(class FName Name, const struct FResourceNodeAudioData& Data, struct FResourceNodeAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ResourceNodeAudioDataTable
class UResourceNodeAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UResourceNodeAudioDataTable* GetDefaultObj();

};

// 0x50 (0x80 - 0x30)
// Class Icarus.RevisionsSubsystem
class URevisionsSubsystem : public UGameInstanceSubsystem
{
public:
	TMap<class FString, int32>                   RevisionsMap;                                      // 0x30(0x50)(Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class URevisionsSubsystem* GetDefaultObj();

	int32 GetRevisionFromPath(const class FString& Path);
	int32 GetRevisionFromObject(TSoftObjectPtr<class UObject>& Object);
};

// 0x10 (0x348 - 0x338)
// Class Icarus.River
class ARiver : public AWaterBody
{
public:
	TArray<struct FLavaRiverFlowPointData>       LavaFlowPointData;                                 // 0x338(0x10)(Edit, BlueprintVisible, ZeroConstructor, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ARiver* GetDefaultObj();

	void DisableOcclusionForSplineMeshComponent(class USplineMeshComponent* SplineMeshComponent);
};

// 0x28 (0x220 - 0x1F8)
// Class Icarus.RiverAudioComponent
class URiverAudioComponent : public USceneComponent
{
public:
	uint8                                        Pad_862B[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	enum class ERiverAudioState                  State;                                             // 0x200(0x1)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_862C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LavaFlowFeatheringDistance;                        // 0x204(0x4)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                             LavaFlowSpeedRange;                                // 0x208(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                             LavaBaseToFlowingRange;                            // 0x210(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_862D[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URiverAudioComponent* GetDefaultObj();

	float GetLavaFlowValue();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RiverAudioDataLibrary
class URiverAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URiverAudioDataLibrary* GetDefaultObj();

	struct FRiverAudioDataRowHandle StructToRowHandle(const struct FRiverAudioDataEnum& EnumValue);
	class FName StructToName(const struct FRiverAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FRiverAudioDataEnum& EnumValue);
	struct FRiverAudioDataEnum RowHandleToStruct(const struct FRiverAudioDataRowHandle& RowHandle);
	void RemoveRowFromRiverAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRiverAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRiverAudioDataEnum& A, const struct FRiverAudioDataEnum& B);
	struct FRiverAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRiverAudioDataRowHandle MakeRiverAudioDataFromIndex(int32 Index);
	struct FRiverAudioDataEnum MakeRiverAudioDataEnum(const struct FRiverAudioDataEnum& Enum);
	struct FRiverAudioDataRowHandle MakeRiverAudioData(class FName RowName);
	struct FRiverAudioDataRowHandle MakeLiteralRiverAudioData(const struct FRiverAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRiverAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRiverAudioDataStruct(const struct FRiverAudioDataRowHandle& RowHandle, struct FRiverAudioData* RiverAudioData, enum class EValid* Paths);
	bool EqualEqual_FRiverAudioDataRowHandleFRiverAudioDataRowHandle(const struct FRiverAudioDataRowHandle& RowHandleA, const struct FRiverAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRiverAudioDataEnum& A, const struct FRiverAudioDataEnum& B);
	struct FRiverAudioDataRowHandle CastToRiverAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRiverAudioDataEnum(const struct FRiverAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRiverAudioDataTable(class FName Name, const struct FRiverAudioData& Data, struct FRiverAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RiverAudioDataTable
class URiverAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URiverAudioDataTable* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.RiverEdgeSplineGeneratorComponent
class URiverEdgeSplineGeneratorComponent : public UActorComponent
{
public:
	float                                        DistanceStepSize;                                  // 0xB0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_863A[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URiverEdgeSplineGeneratorComponent* GetDefaultObj();

	void GenerateSplines(class USplineComponent* RiverSpline, class USplineComponent* LeftSpline, class USplineComponent* RightSpline, float WaterfallCullHeight, float SplineMeshHeightOffset, float Scale);
	void ClearSplines(class USplineComponent* LeftSpline, class USplineComponent* RightSpline);
};

// 0x140 (0x400 - 0x2C0)
// Class Icarus.RockBase
class ARockBase : public AIcarusActor
{
public:
	class UDurableComponent*                     DurableComponent;                                  // 0x2C0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitableComponent*                     HitableComponent;                                  // 0x2C8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                       BreakableMeshContainer;                            // 0x2D0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                  BaseMesh;                                          // 0x2D8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFLODActorComponent*                   FLODActorComponent;                                // 0x2E0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBreakableRockDataRowHandle           BreakableRockData;                                 // 0x2E8(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                 BreakArray;                                        // 0x300(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>          MeshArray;                                         // 0x310(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                        Pad_863C[0xE0];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ARockBase* GetDefaultObj();

	void PlayBreakingHitEffects(const struct FVector& Location);
	void OnRep_BreakArray();
	void OnHealthUpdated(class UActorState* State, float NewHealth);
	void OnActorDamaged(const struct FIcarusDamagePacket& DamagePacket);
	void Multi_OnRockItemSpawned(const struct FVector& Location);
	bool HasInitialized();
	int32 GetBreakCount();
	int32 CalculateBreakCount();
};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.RockBaseRecorderComponent
class URockBaseRecorderComponent : public UActorStateRecorderComponent
{
public:
	TArray<bool>                                 BreakArray;                                        // 0x1A8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_863D[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class URockBaseRecorderComponent* GetDefaultObj();

};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.RocketableComponent
class URocketableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class URocketableComponent* GetDefaultObj();

	bool GetRocketableData(struct FRocketableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RocketableLibrary
class URocketableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URocketableLibrary* GetDefaultObj();

	struct FRocketableRowHandle StructToRowHandle(const struct FRocketableEnum& EnumValue);
	class FName StructToName(const struct FRocketableEnum& EnumValue);
	int32 StructToInt(const struct FRocketableEnum& EnumValue);
	struct FRocketableEnum RowHandleToStruct(const struct FRocketableRowHandle& RowHandle);
	void RemoveRowFromRocketableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRocketableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRocketableEnum& A, const struct FRocketableEnum& B);
	struct FRocketableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRocketableRowHandle MakeRocketableFromIndex(int32 Index);
	struct FRocketableEnum MakeRocketableEnum(const struct FRocketableEnum& Enum);
	struct FRocketableRowHandle MakeRocketable(class FName RowName);
	struct FRocketableRowHandle MakeLiteralRocketable(const struct FRocketableRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRocketableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRocketableStruct(const struct FRocketableRowHandle& RowHandle, struct FRocketableData* Rocketable, enum class EValid* Paths);
	bool EqualEqual_FRocketableRowHandleFRocketableRowHandle(const struct FRocketableRowHandle& RowHandleA, const struct FRocketableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRocketableEnum& A, const struct FRocketableEnum& B);
	struct FRocketableRowHandle CastToRocketableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRocketableEnum(const struct FRocketableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRocketableTable(class FName Name, const struct FRocketableData& Data, struct FRocketableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RocketableTable
class URocketableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URocketableTable* GetDefaultObj();

};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.RocketRecorderComponent
class URocketRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FPlayerCharacterID                    AssignedPlayerCharacterID;                         // 0x1A8(0x18)(Edit, EditConst, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               SpawnLocation;                                     // 0x1C0(0xC)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                               DescentOrigin;                                     // 0x1CC(0xC)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         DropshipPositionsSet;                              // 0x1D8(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         PlayerHasLeft;                                     // 0x1D9(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bStoredLoadout;                                    // 0x1DA(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ERocketState                      RocketState;                                       // 0x1DB(0x1)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        RocketRecorderVersion;                             // 0x1DC(0x4)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class URocketRecorderComponent* GetDefaultObj();

};

// 0x40 (0x300 - 0x2C0)
// Class Icarus.IcarusRocketSpawnBase
class AIcarusRocketSpawnBase : public AIcarusActor
{
public:
	TSoftClassPtr<class AIcarusRocket>           SpawnDropshipClass;                                // 0x2C0(0x28)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCharacterID                    AssignedPlayerID;                                  // 0x2E8(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AIcarusRocketSpawnBase* GetDefaultObj();

	int32 GetGroupIndex();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RTXGIVolumesLibrary
class URTXGIVolumesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URTXGIVolumesLibrary* GetDefaultObj();

	struct FRTXGIVolumesRowHandle StructToRowHandle(const struct FRTXGIVolumesEnum& EnumValue);
	class FName StructToName(const struct FRTXGIVolumesEnum& EnumValue);
	int32 StructToInt(const struct FRTXGIVolumesEnum& EnumValue);
	struct FRTXGIVolumesEnum RowHandleToStruct(const struct FRTXGIVolumesRowHandle& RowHandle);
	void RemoveRowFromRTXGIVolumesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRTXGIVolumesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRTXGIVolumesEnum& A, const struct FRTXGIVolumesEnum& B);
	struct FRTXGIVolumesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRTXGIVolumesRowHandle MakeRTXGIVolumesFromIndex(int32 Index);
	struct FRTXGIVolumesEnum MakeRTXGIVolumesEnum(const struct FRTXGIVolumesEnum& Enum);
	struct FRTXGIVolumesRowHandle MakeRTXGIVolumes(class FName RowName);
	struct FRTXGIVolumesRowHandle MakeLiteralRTXGIVolumes(const struct FRTXGIVolumesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRTXGIVolumesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRTXGIVolumesStruct(const struct FRTXGIVolumesRowHandle& RowHandle, struct FRTXGIVolumes* RTXGIVolumes, enum class EValid* Paths);
	bool EqualEqual_FRTXGIVolumesRowHandleFRTXGIVolumesRowHandle(const struct FRTXGIVolumesRowHandle& RowHandleA, const struct FRTXGIVolumesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRTXGIVolumesEnum& A, const struct FRTXGIVolumesEnum& B);
	struct FRTXGIVolumesRowHandle CastToRTXGIVolumesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRTXGIVolumesEnum(const struct FRTXGIVolumesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRTXGIVolumesTable(class FName Name, const struct FRTXGIVolumes& Data, struct FRTXGIVolumesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RTXGIVolumesTable
class URTXGIVolumesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URTXGIVolumesTable* GetDefaultObj();

};

// 0x20 (0x48 - 0x28)
// Class Icarus.Ruleset
class URuleset : public UObject
{
public:
	class URulesetSubsystem*                     RulesetSubsystem;                                  // 0x28(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRulesetsRowHandle                    RulesetRowHandle;                                  // 0x30(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class URuleset* GetDefaultObj();

	void ReceiveOnRulesetCreated();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.RulesetFunctionLibrary
class URulesetFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class URulesetFunctionLibrary* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.RulesetsLibrary
class URulesetsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class URulesetsLibrary* GetDefaultObj();

	struct FRulesetsRowHandle StructToRowHandle(const struct FRulesetsEnum& EnumValue);
	class FName StructToName(const struct FRulesetsEnum& EnumValue);
	int32 StructToInt(const struct FRulesetsEnum& EnumValue);
	struct FRulesetsEnum RowHandleToStruct(const struct FRulesetsRowHandle& RowHandle);
	void RemoveRowFromRulesetsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FRulesetsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FRulesetsEnum& A, const struct FRulesetsEnum& B);
	struct FRulesetsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FRulesetsRowHandle MakeRulesetsRowFromRulesetClass(class UClass* InRulesetClass);
	struct FRulesetsRowHandle MakeRulesetsFromIndex(int32 Index);
	struct FRulesetsEnum MakeRulesetsEnum(const struct FRulesetsEnum& Enum);
	struct FRulesetsRowHandle MakeRulesets(class FName RowName);
	struct FRulesetsRowHandle MakeLiteralRulesets(const struct FRulesetsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FRulesetsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetRulesetsStruct(const struct FRulesetsRowHandle& RowHandle, struct FRulesetData* Rulesets, enum class EValid* Paths);
	bool EqualEqual_FRulesetsRowHandleFRulesetsRowHandle(const struct FRulesetsRowHandle& RowHandleA, const struct FRulesetsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FRulesetsEnum& A, const struct FRulesetsEnum& B);
	struct FRulesetsRowHandle CastToRulesetsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakRulesetsEnum(const struct FRulesetsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToRulesetsTable(class FName Name, const struct FRulesetData& Data, struct FRulesetsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.RulesetsTable
class URulesetsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class URulesetsTable* GetDefaultObj();

};

// 0x70 (0xA0 - 0x30)
// Class Icarus.RulesetSubsystem
class URulesetSubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_8663[0x20];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<struct FRulesetsRowHandle, class URuleset*> Rulesets;                                          // 0x50(0x50)(Transient, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class URulesetSubsystem* GetDefaultObj();

	void WorldStatsReady();
	bool HasRuleset(struct FRulesetsRowHandle& RulesetType);
	class URuleset* GetRuleset(struct FRulesetsRowHandle& RulesetType);
	void AddRuleset(struct FRulesetsRowHandle& Ruleset);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SaddlesLibrary
class USaddlesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USaddlesLibrary* GetDefaultObj();

	struct FSaddlesRowHandle StructToRowHandle(const struct FSaddlesEnum& EnumValue);
	class FName StructToName(const struct FSaddlesEnum& EnumValue);
	int32 StructToInt(const struct FSaddlesEnum& EnumValue);
	struct FSaddlesEnum RowHandleToStruct(const struct FSaddlesRowHandle& RowHandle);
	void RemoveRowFromSaddlesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSaddlesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSaddlesEnum& A, const struct FSaddlesEnum& B);
	struct FSaddlesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSaddlesRowHandle MakeSaddlesFromIndex(int32 Index);
	struct FSaddlesEnum MakeSaddlesEnum(const struct FSaddlesEnum& Enum);
	struct FSaddlesRowHandle MakeSaddles(class FName RowName);
	struct FSaddlesRowHandle MakeLiteralSaddles(const struct FSaddlesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSaddlesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSaddlesStruct(const struct FSaddlesRowHandle& RowHandle, struct FSaddleData* Saddles, enum class EValid* Paths);
	bool EqualEqual_FSaddlesRowHandleFSaddlesRowHandle(const struct FSaddlesRowHandle& RowHandleA, const struct FSaddlesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSaddlesEnum& A, const struct FSaddlesEnum& B);
	struct FSaddlesRowHandle CastToSaddlesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSaddlesEnum(const struct FSaddlesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSaddlesTable(class FName Name, const struct FSaddleData& Data, struct FSaddlesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SaddlesTable
class USaddlesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USaddlesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ScalingRulesLibrary
class UScalingRulesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UScalingRulesLibrary* GetDefaultObj();

	struct FScalingRulesRowHandle StructToRowHandle(const struct FScalingRulesEnum& EnumValue);
	class FName StructToName(const struct FScalingRulesEnum& EnumValue);
	int32 StructToInt(const struct FScalingRulesEnum& EnumValue);
	struct FScalingRulesEnum RowHandleToStruct(const struct FScalingRulesRowHandle& RowHandle);
	void RemoveRowFromScalingRulesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FScalingRulesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FScalingRulesEnum& A, const struct FScalingRulesEnum& B);
	struct FScalingRulesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FScalingRulesRowHandle MakeScalingRulesFromIndex(int32 Index);
	struct FScalingRulesEnum MakeScalingRulesEnum(const struct FScalingRulesEnum& Enum);
	struct FScalingRulesRowHandle MakeScalingRules(class FName RowName);
	struct FScalingRulesRowHandle MakeLiteralScalingRules(const struct FScalingRulesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FScalingRulesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetScalingRulesStruct(const struct FScalingRulesRowHandle& RowHandle, struct FScalingRuleData* ScalingRules, enum class EValid* Paths);
	bool EqualEqual_FScalingRulesRowHandleFScalingRulesRowHandle(const struct FScalingRulesRowHandle& RowHandleA, const struct FScalingRulesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FScalingRulesEnum& A, const struct FScalingRulesEnum& B);
	struct FScalingRulesRowHandle CastToScalingRulesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakScalingRulesEnum(const struct FScalingRulesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToScalingRulesTable(class FName Name, const struct FScalingRuleData& Data, struct FScalingRulesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ScalingRulesTable
class UScalingRulesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UScalingRulesTable* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class Icarus.ScopedViewportBlocker
class UScopedViewportBlocker : public UObject
{
public:
	bool                                         bViewportBlockerIncremented;                       // 0x28(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_867A[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  ViewportBlockerContext;                            // 0x2C(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_867B[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UScopedViewportBlocker* GetDefaultObj();

};

// 0x50 (0x270 - 0x220)
// Class Icarus.ScriptedEvent
class AScriptedEvent : public AActor
{
public:
	struct FBiomesRowHandle                      AssociatedBiome;                                   // 0x220(0x18)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class EIcarusProspectDifficulty         ProspectDifficulty;                                // 0x238(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_867C[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        TimeoutInSeconds;                                  // 0x23C(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        TickFrequency;                                     // 0x240(0x4)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_867D[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class AActor*>                        TargetActors;                                      // 0x248(0x10)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnScriptedEventFinished;                           // 0x258(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_867E[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AScriptedEvent* GetDefaultObj();

	bool ShouldAbortEvent();
	bool IsEventCompleted();
	void EventStart();
	void EventEnd(enum class EEventEndReason EndReason);
	TArray<class AActor*> DetermineTargetActors();
	bool CanPerformEvent();
	void AbortScriptedEvent();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ScriptedEventsLibrary
class UScriptedEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UScriptedEventsLibrary* GetDefaultObj();

	struct FScriptedEventsRowHandle StructToRowHandle(const struct FScriptedEventsEnum& EnumValue);
	class FName StructToName(const struct FScriptedEventsEnum& EnumValue);
	int32 StructToInt(const struct FScriptedEventsEnum& EnumValue);
	struct FScriptedEventsEnum RowHandleToStruct(const struct FScriptedEventsRowHandle& RowHandle);
	void RemoveRowFromScriptedEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FScriptedEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FScriptedEventsEnum& A, const struct FScriptedEventsEnum& B);
	struct FScriptedEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FScriptedEventsRowHandle MakeScriptedEventsFromIndex(int32 Index);
	struct FScriptedEventsEnum MakeScriptedEventsEnum(const struct FScriptedEventsEnum& Enum);
	struct FScriptedEventsRowHandle MakeScriptedEvents(class FName RowName);
	struct FScriptedEventsRowHandle MakeLiteralScriptedEvents(const struct FScriptedEventsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FScriptedEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetScriptedEventsStruct(const struct FScriptedEventsRowHandle& RowHandle, struct FScriptedEventData* ScriptedEvents, enum class EValid* Paths);
	bool EqualEqual_FScriptedEventsRowHandleFScriptedEventsRowHandle(const struct FScriptedEventsRowHandle& RowHandleA, const struct FScriptedEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FScriptedEventsEnum& A, const struct FScriptedEventsEnum& B);
	struct FScriptedEventsRowHandle CastToScriptedEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakScriptedEventsEnum(const struct FScriptedEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToScriptedEventsTable(class FName Name, const struct FScriptedEventData& Data, struct FScriptedEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ScriptedEventsTable
class UScriptedEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UScriptedEventsTable* GetDefaultObj();

};

// 0xBD0 (0xE30 - 0x260)
// Class Icarus.SearchBox
class USearchBox : public UUserWidget
{
public:
	uint8                                        Pad_868B[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FSearchBoxStyle                       Style;                                             // 0x270(0xA90)(Edit, NativeAccessSpecifierPublic)
	class FText                                  HintText;                                          // 0xD00(0x18)(Edit, NativeAccessSpecifierPublic)
	class FText                                  InitialText;                                       // 0xD18(0x18)(Edit, NativeAccessSpecifierPublic)
	bool                                         IsSearching;                                       // 0xD30(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_868C[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnSearchTextChanged;                               // 0xD38(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSearchTextCommitted;                             // 0xD48(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnSearchKeyDownHandler;                            // 0xD58(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_868D[0xB8];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         SelectAllTextWhenFocused;                          // 0xE20(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_868E[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MinDesiredWidth;                                   // 0xE24(0x4)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         DelayChangeNotificationsWhileTyping;               // 0xE28(0x1)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bCommitting;                                       // 0xE29(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_868F[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USearchBox* GetDefaultObj();

	void SetText(class FText Text);
	void SelectAllText();
	void SearchBoxReply__DelegateSignature(struct FKeyEvent& KeyEvent);
	void OnSearchBoxCommittedEvent__DelegateSignature(class FText& Text, enum class ETextCommit CommitMethod);
	void OnSearchBoxChangedEvent__DelegateSignature(class FText& Text);
	void KeyDownHandled();
	class FText GetText();
	class FText GetSearchText();
};

// 0x30 (0x2F0 - 0x2C0)
// Class Icarus.SeatBase
class ASeatBase : public AIcarusActor
{
public:
	TWeakObjectPtr<class AIcarusPlayerCharacter> AttachedPlayer;                                    // 0x2C0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  AttachSocketName;                                  // 0x2C8(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                       AttachComponent;                                   // 0x2D0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MinViewPitch;                                      // 0x2D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxViewPitch;                                      // 0x2DC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MinViewYaw;                                        // 0x2E0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxViewYaw;                                        // 0x2E4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAllowCameraControl;                               // 0x2E8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIgnoreOutOfBoundsCheck;                           // 0x2E9(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8697[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ASeatBase* GetDefaultObj();

	void OnRep_AttachedPlayer();
	void OnAttachedPlayerDestroyed(class AActor* DestroyedAttachedPlayer);
	void Multicast_DetachPlayerFromSeat(class AIcarusPlayerCharacter* PlayerCharacter, struct FVector& ExitLocation, struct FRotator& ExitRotation, bool bChangeSeat);
	void Multicast_AttachPlayerToSeat(class AIcarusPlayerCharacter* PlayerCharacter, struct FRotator& EnterRotation);
	bool LeaveSeat(bool bChangeSeat, bool bForce);
	bool IsPossessTargetLocallyControlled();
	bool IsMountSeat();
	struct FRotator GetSeatedPlayerControlRotation();
	class AIcarusPlayerController* GetPossesTargetController();
	class APawn* GetPossesTarget();
	class AIcarusPlayerCharacter* GetAttachedPlayer();
	bool FindExit(struct FVector* OutExitLocation, struct FRotator* OutExitRotation);
	bool EnterSeat(class AIcarusPlayerCharacter* PlayerCharacter);
	void DetachPlayerFromSeat(class AIcarusPlayerCharacter* PlayerCharacter, struct FVector& ExitLocation, struct FRotator& ExitRotation, bool bChangeSeat);
	bool CanPlayerEnterSeat(class AIcarusPlayerCharacter* PlayerCharacter);
	void AttachPlayerToSeat(class AIcarusPlayerCharacter* PlayerCharacter, struct FRotator& EnterRotation);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SeedModificationsLibrary
class USeedModificationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USeedModificationsLibrary* GetDefaultObj();

	struct FSeedModificationsRowHandle StructToRowHandle(const struct FSeedModificationsEnum& EnumValue);
	class FName StructToName(const struct FSeedModificationsEnum& EnumValue);
	int32 StructToInt(const struct FSeedModificationsEnum& EnumValue);
	struct FSeedModificationsEnum RowHandleToStruct(const struct FSeedModificationsRowHandle& RowHandle);
	void RemoveRowFromSeedModificationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSeedModificationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSeedModificationsEnum& A, const struct FSeedModificationsEnum& B);
	struct FSeedModificationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSeedModificationsRowHandle MakeSeedModificationsFromIndex(int32 Index);
	struct FSeedModificationsEnum MakeSeedModificationsEnum(const struct FSeedModificationsEnum& Enum);
	struct FSeedModificationsRowHandle MakeSeedModifications(class FName RowName);
	struct FSeedModificationsRowHandle MakeLiteralSeedModifications(const struct FSeedModificationsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSeedModificationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSeedModificationsStruct(const struct FSeedModificationsRowHandle& RowHandle, struct FSeedModification* SeedModifications, enum class EValid* Paths);
	bool EqualEqual_FSeedModificationsRowHandleFSeedModificationsRowHandle(const struct FSeedModificationsRowHandle& RowHandleA, const struct FSeedModificationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSeedModificationsEnum& A, const struct FSeedModificationsEnum& B);
	struct FSeedModificationsRowHandle CastToSeedModificationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSeedModificationsEnum(const struct FSeedModificationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSeedModificationsTable(class FName Name, const struct FSeedModification& Data, struct FSeedModificationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SeedModificationsTable
class USeedModificationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USeedModificationsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SentryBlueprintFunctionLibrary
class USentryBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class USentryBlueprintFunctionLibrary* GetDefaultObj();

	void LogSentryUnlikelyEvent_TwoDetail(class UObject* WorldContextObject, const class FString& FunctionName, const class FString& Detail1, const class FString& Detail2);
	void LogSentryUnlikelyEvent_ThreeDetail(class UObject* WorldContextObject, const class FString& FunctionName, const class FString& Detail1, const class FString& Detail2, const class FString& Detail3);
	void LogSentryUnlikelyEvent(class UObject* WorldContextObject, const class FString& FunctionName, const class FString& Detail);
};

// 0x20 (0x240 - 0x220)
// Class Icarus.ServerShutdownTimer
class AServerShutdownTimer : public AActor
{
public:
	FDelegateProperty_                           OnTimerElapsed;                                    // 0x220(0x10)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_86A3[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AServerShutdownTimer* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SessionFlagsLibrary
class USessionFlagsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USessionFlagsLibrary* GetDefaultObj();

	struct FSessionFlagsRowHandle StructToRowHandle(const struct FSessionFlagsEnum& EnumValue);
	class FName StructToName(const struct FSessionFlagsEnum& EnumValue);
	int32 StructToInt(const struct FSessionFlagsEnum& EnumValue);
	struct FSessionFlagsEnum RowHandleToStruct(const struct FSessionFlagsRowHandle& RowHandle);
	void RemoveRowFromSessionFlagsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSessionFlagsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSessionFlagsEnum& A, const struct FSessionFlagsEnum& B);
	struct FSessionFlagsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSessionFlagsRowHandle MakeSessionFlagsFromIndex(int32 Index);
	struct FSessionFlagsEnum MakeSessionFlagsEnum(const struct FSessionFlagsEnum& Enum);
	struct FSessionFlagsRowHandle MakeSessionFlags(class FName RowName);
	struct FSessionFlagsRowHandle MakeLiteralSessionFlags(const struct FSessionFlagsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSessionFlagsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSessionFlagsStruct(const struct FSessionFlagsRowHandle& RowHandle, struct FSessionFlag* SessionFlags, enum class EValid* Paths);
	bool EqualEqual_FSessionFlagsRowHandleFSessionFlagsRowHandle(const struct FSessionFlagsRowHandle& RowHandleA, const struct FSessionFlagsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSessionFlagsEnum& A, const struct FSessionFlagsEnum& B);
	struct FSessionFlagsRowHandle CastToSessionFlagsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSessionFlagsEnum(const struct FSessionFlagsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSessionFlagsTable(class FName Name, const struct FSessionFlag& Data, struct FSessionFlagsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SessionFlagsTable
class USessionFlagsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USessionFlagsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SessionFunctionLibrary
class USessionFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class USessionFunctionLibrary* GetDefaultObj();

	bool ProspectInfoIsValid(struct FIcarusSession& IcarusSession, bool RequiresSession);
	TArray<struct FSessionPropertyKeyPair> MakeSessionExtraSettingsFromProspect(class UObject* WorldContextObject, struct FProspectInfo& ProspectInfo);
	struct FProspectInfo MakeProspectInfoFromExtraSettings(class UObject* WorldContextObject, TArray<struct FSessionPropertyKeyPair>& ExtraSettings);
	bool HasJoinedProspect(const class FString& UserID, const TArray<struct FAssociatedMemberInfo>& Members);
	int32 GetMaxPlayersConfig();
	bool GetLockedFromExtraSettings(TArray<struct FSessionPropertyKeyPair>& ExtraSettings);
	class FString GetGameVersionFromExtraSettings(TArray<struct FSessionPropertyKeyPair>& ExtraSettings);
	bool GetDedicatedFromExtraSettings(TArray<struct FSessionPropertyKeyPair>& ExtraSettings);
	class FString GenerateProspectSessionId(const class FString& UserID, struct FProspectInfo& ProspectInfo);
	struct FIcarusSession CreateIcarusSessionFromSession(class UObject* WorldContextObject, struct FBlueprintSessionResult& Session);
};

// 0x1C8 (0x1F0 - 0x28)
// Class Icarus.IcarusSessionResult
class UIcarusSessionResult : public UObject
{
public:
	struct FIcarusSession                        SessionInfo;                                       // 0x28(0x1B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                        FriendCount;                                       // 0x1D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86B3[0x14];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UIcarusSessionResult* GetDefaultObj();

	bool IsInLobby();
	class FString GetSessionVersion();
	class FString GetSessionName();
	struct FProspectListRowHandle GetProspectRow();
	class FText GetProspectName();
	struct FProspectInfo GetProspectInfo();
	class FString GetProspectID();
	int32 GetPlayerCount();
	int32 GetPing();
	int32 GetMaxPlayerCount();
	bool GetIsHardcore();
	struct FFactionMissionsRowHandle GetFactionMissionRow();
	int64 GetDuration();
	enum class EMissionDifficulty GetDifficulty();
};

// 0xD0 (0xF8 - 0x28)
// Class Icarus.ProspectHistoryResult
class UProspectHistoryResult : public UObject
{
public:
	struct FAssociatedProspectInfo               AssociatedProspectInfo;                            // 0x28(0xC8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UIcarusSessionResult*                  SessionResult;                                     // 0xF0(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UProspectHistoryResult* GetDefaultObj();

	bool IsAvailable();
	struct FProspectInfo GetProspectInfo();
	enum class ELastProspectHostType GetHostType();
};

// 0x8 (0x2A0 - 0x298)
// Class Icarus.SettingRowBorder
class USettingRowBorder : public UIcarusWidget
{
public:
	class USettingWidget*                        SettingWidget;                                     // 0x298(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class USettingRowBorder* GetDefaultObj();

	void SetSettingWidget(class USettingWidget* InSettingWidget);
	void HideName();
};

// 0x0 (0x298 - 0x298)
// Class Icarus.SettingsMenu
class USettingsMenu : public UIcarusWidget
{
public:

	static class UClass* StaticClass();
	static class USettingsMenu* GetDefaultObj();

	void Save(bool bForce);
};

// 0x88 (0x2E8 - 0x260)
// Class Icarus.SettingsSection
class USettingsSection : public UUserWidget
{
public:
	class USettingsView*                         SettingsView;                                      // 0x260(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  SettingCategory;                                   // 0x268(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  SettingSection;                                    // 0x270(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class FText>                     Requirements;                                      // 0x278(0x50)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                  ConfirmMessage;                                    // 0x2C8(0x18)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                         bHasApply;                                         // 0x2E0(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasReset;                                         // 0x2E1(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasConfirm;                                       // 0x2E2(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86B4[0x5];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USettingsSection* GetDefaultObj();

	void SetSettingsView(class USettingsView* View);
	void SetDisplayName(class FText& DisplayName);
	void RevertSettings();
	void PostSetup();
	void OnRefresh();
	void DirtySection();
	void ConfirmSettings();
	void ApplySettings();
	void AddWidgetToSection(class USettingWidget* Widget);
};

// 0x10 (0x2A8 - 0x298)
// Class Icarus.SettingsView
class USettingsView : public UIcarusWidget
{
public:
	class FName                                  SettingCategory;                                   // 0x298(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USettingsMenu*                         SettingsMenu;                                      // 0x2A0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class USettingsView* GetDefaultObj();

	void SetSettingsMenu(class USettingsMenu* Menu);
	void PostSetup();
	void OnRefresh();
	void LoadApplySaveSettings(bool bLoadSettings, bool bApplySettings, bool bSaveSettings);
	class USettingsSection* CreateNewSection();
};

// 0xF8 (0x390 - 0x298)
// Class Icarus.SettingWidget
class USettingWidget : public UIcarusWidget
{
public:
	uint8                                        Pad_86B5[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class USettingRowBorder*                     RowBorder;                                         // 0x2A8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                  SettingName;                                       // 0x2B0(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                  DisplayName;                                       // 0x2B8(0x18)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                  Description;                                       // 0x2D0(0x18)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class FText>                     Requirements;                                      // 0x2E8(0x50)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class USettingsSection*                      Section;                                           // 0x338(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86B6[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USettingWidget* GetDefaultObj();

	void Setup();
	void Refresh();
	void OnRefresh();
	void OnDirty();
	void Change();
	void Apply();
};

// 0x0 (0x390 - 0x390)
// Class Icarus.SettingWidget_Combo
class USettingWidget_Combo : public USettingWidget
{
public:

	static class UClass* StaticClass();
	static class USettingWidget_Combo* GetDefaultObj();

	void SetValueIndex(int32 Index);
	void SetOptions(TArray<class FText>& Options);
	void SetHideOptions(TArray<class FText>& HideOptions);
	int32 GetValueIndex();
};

// 0x0 (0x390 - 0x390)
// Class Icarus.SettingWidget_ContinuousRange
class USettingWidget_ContinuousRange : public USettingWidget
{
public:

	static class UClass* StaticClass();
	static class USettingWidget_ContinuousRange* GetDefaultObj();

	void SetValue(float Value, bool bForceRefresh);
	void SetStepSize(float StepSize);
	void SetRange(float MinVal, float MaxVal);
	void SetApplyDuringDrag(bool bApplyDuringDrag);
};

// 0x0 (0x390 - 0x390)
// Class Icarus.SettingWidget_DiscreteRange
class USettingWidget_DiscreteRange : public USettingWidget
{
public:

	static class UClass* StaticClass();
	static class USettingWidget_DiscreteRange* GetDefaultObj();

	void SetValueIndex(int32 Index, bool bForceRefresh);
	void SetOptions(TArray<class FText>& Options);
};

// 0x0 (0x390 - 0x390)
// Class Icarus.SettingWidget_Keybindings
class USettingWidget_Keybindings : public USettingWidget
{
public:

	static class UClass* StaticClass();
	static class USettingWidget_Keybindings* GetDefaultObj();

	class UKeybindingWidget* CreateKeybindingWidget(struct FKeybindingsRowHandle& Keybinding);
	void ClearKeybindingWidgets();
};

// 0x10 (0x3A0 - 0x390)
// Class Icarus.SettingWidget_Language
class USettingWidget_Language : public USettingWidget
{
public:
	uint8                                        Pad_86B9[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USettingWidget_Language* GetDefaultObj();

	void SetOptions(TArray<class FText>& NewOptions);
	void SetLanguage(const class FString& Language);
};

// 0x0 (0x390 - 0x390)
// Class Icarus.SettingWidget_Switch
class USettingWidget_Switch : public USettingWidget
{
public:

	static class UClass* StaticClass();
	static class USettingWidget_Switch* GetDefaultObj();

	void SetValueIndex(int32 Index);
	void SetLabels(TArray<class FText>& Labels);
};

// 0xB0 (0x180 - 0xD0)
// Class Icarus.ShelteredComponent
class UShelteredComponent : public UTraitComponent
{
public:
	bool                                         bDisableShelterTraces;                             // 0xD0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86BB[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ShelterTraceTimeInterval;                          // 0xD4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ShelterTraceDistancePriorityScale;                 // 0xD8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        ShelterTraceStarvationPriorityScale;               // 0xDC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CurrentShelterValue;                               // 0xE0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         Debug;                                             // 0xE4(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86BC[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        DebugDrawTraces;                                   // 0xE8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDebugDrawModifiers;                               // 0xEC(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86BD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LastShelterCheckTime;                              // 0xF0(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bPerformingTraces;                                 // 0xF4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86BE[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ShelterTraceAccumulatedPriority;                   // 0xF8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86BF[0x1C];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	TSet<class UShelteredModifierComponent*>     PendingShelteredModifiers;                         // 0x118(0x50)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBox>                          PendingShelteredModifierBoxes;                     // 0x168(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                         bRunningAsyncBeginTrace;                           // 0x178(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86C0[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UShelteredComponent* GetDefaultObj();

	void OnShelterTracesCompleted(int32 NumPrimaryTraceSuccesses, int32 NumPrimaryTraceFailures, int32 NumSecondaryTraceSuccesses, int32 NumSecondaryTraceFailures);
	bool IsSheltered();
	int32 GetShelteredTemperatureEffect(int32 CurrentExternalTemperature);
	float GetCurrentExposureValue();
	void DisableTraces(bool bDisable);
	bool CanSkipShelterCheck(class AIcarusPlayerCharacter* CraftingPlayer, bool Repairing);
};

// 0x20 (0xD0 - 0xB0)
// Class Icarus.ShelteredModifierComponent
class UShelteredModifierComponent : public UActorComponent
{
public:
	bool                                         bUseDeferredInitialUpdate;                         // 0xB0(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDebugBounds;                                      // 0xB1(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_86C1[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FBox                                  LastModifierBounds;                                // 0xB4(0x1C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UShelteredModifierComponent* GetDefaultObj();

	void UpdateBounds(bool bForceUpdate);
};

// 0x90 (0xC0 - 0x30)
// Class Icarus.ShelterSubsystem
class UShelterSubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_86C2[0x54];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bDebugPrintStats;                                  // 0x84(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86C3[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UShelteredComponent*>           ShelteredComponents;                               // 0x88(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                         bRunningAsyncPrioritization;                       // 0x98(0x1)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86C4[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UShelteredComponent*>           PriorityOrderedShelteredComponents;                // 0xA0(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UShelteredModifierComponent>> QueuedShelteredModifiersForInitialUpdate;          // 0xB0(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UShelterSubsystem* GetDefaultObj();

};

// 0x18 (0x40 - 0x28)
// Class Icarus.SignIconListItem
class USignIconListItem : public UObject
{
public:
	struct FItemableRowHandle                    ItemRowHandle;                                     // 0x28(0x18)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class USignIconListItem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SignRecorderInterface
class ISignRecorderInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ISignRecorderInterface* GetDefaultObj();

	void SetSignText(class FText& Text, struct FLinearColor& Color);
	void SetSignIcon(struct FItemableRowHandle& IconRow);
	class FText GetSignText();
	struct FItemableRowHandle GetSignIconRow();
	struct FLinearColor GetSignColor();
};

// 0x38 (0x290 - 0x258)
// Class Icarus.SignRecorderComponent
class USignRecorderComponent : public UDeployableRecorderComponent
{
public:
	class FText                                  SignTextRecord;                                    // 0x258(0x18)(SaveGame, NativeAccessSpecifierPublic)
	struct FLinearColor                          SignFontColorRecord;                               // 0x270(0x10)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                  SignIconRecord;                                    // 0x280(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86C5[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USignRecorderComponent* GetDefaultObj();

};

// 0x18 (0x4D0 - 0x4B8)
// Class Icarus.SimpleCharacter
class ASimpleCharacter : public ACharacter
{
public:
	uint8                                        Pad_86C6[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bForceMaxLODWhenNotRendered;                       // 0x4C8(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86C7[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ASimpleCharacter* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SkinningFunctionLibrary
class USkinningFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class USkinningFunctionLibrary* GetDefaultObj();

	class UPlayerDataComponent* GetPlayerDataComponentFromCraftingPlayer(class AIcarusPlayerCharacter* CraftingPlayer);
	class UBestiaryManagerComponent* GetBestiaryManagerForPlayer(class AIcarusPlayerCharacter* Character);
	struct FBestiaryDataRowHandle GetBestiaryFromItemsStaticTrophy(struct FItemsStaticRowHandle& TrophyRow);
	struct FBestiaryDataRowHandle GetBestiaryFromItemsStaticCorpse(struct FItemsStaticRowHandle& CorpseRow);
	void AwardTrophyBestiaryProgress(struct FProcessingItem& Item);
	void AwardSkinningBestiaryProgress(struct FProcessingItem& Item);
};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.SlotableComponent
class USlotableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class USlotableComponent* GetDefaultObj();

	class AIcarusActor* GetActorInSlot(int32 Index);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SlotableItem
class ISlotableItem : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ISlotableItem* GetDefaultObj();

	void GetSpawnTransformOffset(struct FTransform* OutTransformOffset);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SlotableLibrary
class USlotableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USlotableLibrary* GetDefaultObj();

	struct FSlotableRowHandle StructToRowHandle(const struct FSlotableEnum& EnumValue);
	class FName StructToName(const struct FSlotableEnum& EnumValue);
	int32 StructToInt(const struct FSlotableEnum& EnumValue);
	struct FSlotableEnum RowHandleToStruct(const struct FSlotableRowHandle& RowHandle);
	void RemoveRowFromSlotableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSlotableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSlotableEnum& A, const struct FSlotableEnum& B);
	struct FSlotableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSlotableRowHandle MakeSlotableFromIndex(int32 Index);
	struct FSlotableEnum MakeSlotableEnum(const struct FSlotableEnum& Enum);
	struct FSlotableRowHandle MakeSlotable(class FName RowName);
	struct FSlotableRowHandle MakeLiteralSlotable(const struct FSlotableRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSlotableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSlotableStruct(const struct FSlotableRowHandle& RowHandle, struct FSlotableData* Slotable, enum class EValid* Paths);
	bool EqualEqual_FSlotableRowHandleFSlotableRowHandle(const struct FSlotableRowHandle& RowHandleA, const struct FSlotableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSlotableEnum& A, const struct FSlotableEnum& B);
	struct FSlotableRowHandle CastToSlotableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSlotableEnum(const struct FSlotableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSlotableTable(class FName Name, const struct FSlotableData& Data, struct FSlotableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SlotableTable
class USlotableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USlotableTable* GetDefaultObj();

};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.SoloTalentControllerComponent
class USoloTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class USoloTalentControllerComponent* GetDefaultObj();

};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.SoloTalentModel
class USoloTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class USoloTalentModel* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SortTypePriorityLibrary
class USortTypePriorityLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USortTypePriorityLibrary* GetDefaultObj();

	struct FSortTypePriorityRowHandle StructToRowHandle(const struct FSortTypePriorityEnum& EnumValue);
	class FName StructToName(const struct FSortTypePriorityEnum& EnumValue);
	int32 StructToInt(const struct FSortTypePriorityEnum& EnumValue);
	struct FSortTypePriorityEnum RowHandleToStruct(const struct FSortTypePriorityRowHandle& RowHandle);
	void RemoveRowFromSortTypePriorityTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSortTypePriorityEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSortTypePriorityEnum& A, const struct FSortTypePriorityEnum& B);
	struct FSortTypePriorityEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSortTypePriorityRowHandle MakeSortTypePriorityFromIndex(int32 Index);
	struct FSortTypePriorityEnum MakeSortTypePriorityEnum(const struct FSortTypePriorityEnum& Enum);
	struct FSortTypePriorityRowHandle MakeSortTypePriority(class FName RowName);
	struct FSortTypePriorityRowHandle MakeLiteralSortTypePriority(const struct FSortTypePriorityRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSortTypePriorityEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSortTypePriorityStruct(const struct FSortTypePriorityRowHandle& RowHandle, struct FIcarusSortTypePriority* SortTypePriority, enum class EValid* Paths);
	bool EqualEqual_FSortTypePriorityRowHandleFSortTypePriorityRowHandle(const struct FSortTypePriorityRowHandle& RowHandleA, const struct FSortTypePriorityRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSortTypePriorityEnum& A, const struct FSortTypePriorityEnum& B);
	struct FSortTypePriorityRowHandle CastToSortTypePriorityRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSortTypePriorityEnum(const struct FSortTypePriorityEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSortTypePriorityTable(class FName Name, const struct FIcarusSortTypePriority& Data, struct FSortTypePriorityRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SortTypePriorityTable
class USortTypePriorityTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USortTypePriorityTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.SpawnableAI
class ISpawnableAI : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ISpawnableAI* GetDefaultObj();

	void UpdateCreatureGrowthStats();
	void TrackBestiaryDeath(class UActorState* ActorStateIn);
	void TrackBestiaryDamage(const struct FIcarusDamagePacket& DamagePacketIn);
	void SetupAI(const struct FAISetupRowHandle& AISetupData, const struct FEpicCreaturesRowHandle& EpicCreatureSetup);
	void SetEpicCreatureName(class FText& NewName);
	struct FEpicCreaturesRowHandle GetEpicCreatureRowHandle();
	class FText GetEpicCreatureName();
	int32 GetCurrentLevel();
	TArray<class AIcarusPlayerCharacter*> GetAllDamagingPlayerCharacters();
	class UIcarusStatContainer* GetAIStatContainer();
	struct FAISetupRowHandle GetAISetupRowHandle();
	class UActorState* GetAIActorState();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SpawnBlockerInterface
class ISpawnBlockerInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ISpawnBlockerInterface* GetDefaultObj();

	int32 GetSpawnBlockerEffectiveRadius();
};

// 0x10 (0x230 - 0x220)
// Class Icarus.SplineActorBase
class ASplineActorBase : public AActor
{
public:
	int32                                        UniqueSplineID;                                    // 0x220(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86DF[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class USplineRecorderComponent*              Recorder;                                          // 0x228(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class ASplineActorBase* GetDefaultObj();

	struct FRecordedSplineActorStruct RecordSplineState();
	void ReconnectFromDatabase(struct FRecordedSplineActorStruct& FromDatabase);
	void PostDatabaseSpawn(struct FRecordedSplineActorStruct& FromDatabase);
};

// 0x18 (0x560 - 0x548)
// Class Icarus.SplineGripTargetComponent
class USplineGripTargetComponent : public USplineComponent
{
public:
	class UBodySetup*                            ShapeBodySetup;                                    // 0x548(0x8)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_86E0[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USplineGripTargetComponent* GetDefaultObj();

	struct FBox CalcBoundingBox();
};

// 0x88 (0x230 - 0x1A8)
// Class Icarus.SplineRecorderComponent
class USplineRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FRecordedSplineActorStruct            Record;                                            // 0x1A8(0x88)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class USplineRecorderComponent* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.SplineSubsystem
class USplineSubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_86E2[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USplineSubsystem* GetDefaultObj();

	void RegisterSplineActor(class ASplineActorBase* SplineActor);
	class ASplineActorBase* FindSplineBySplineID(int32 UniqueSplineID);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.StaminaActionCostsLibrary
class UStaminaActionCostsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStaminaActionCostsLibrary* GetDefaultObj();

	struct FStaminaActionCostsRowHandle StructToRowHandle(const struct FStaminaActionCostsEnum& EnumValue);
	class FName StructToName(const struct FStaminaActionCostsEnum& EnumValue);
	int32 StructToInt(const struct FStaminaActionCostsEnum& EnumValue);
	struct FStaminaActionCostsEnum RowHandleToStruct(const struct FStaminaActionCostsRowHandle& RowHandle);
	void RemoveRowFromStaminaActionCostsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStaminaActionCostsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStaminaActionCostsEnum& A, const struct FStaminaActionCostsEnum& B);
	struct FStaminaActionCostsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStaminaActionCostsRowHandle MakeStaminaActionCostsFromIndex(int32 Index);
	struct FStaminaActionCostsEnum MakeStaminaActionCostsEnum(const struct FStaminaActionCostsEnum& Enum);
	struct FStaminaActionCostsRowHandle MakeStaminaActionCosts(class FName RowName);
	struct FStaminaActionCostsRowHandle MakeLiteralStaminaActionCosts(const struct FStaminaActionCostsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStaminaActionCostsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStaminaActionCostsStruct(const struct FStaminaActionCostsRowHandle& RowHandle, struct FStaminaCost* StaminaActionCosts, enum class EValid* Paths);
	bool EqualEqual_FStaminaActionCostsRowHandleFStaminaActionCostsRowHandle(const struct FStaminaActionCostsRowHandle& RowHandleA, const struct FStaminaActionCostsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStaminaActionCostsEnum& A, const struct FStaminaActionCostsEnum& B);
	struct FStaminaActionCostsRowHandle CastToStaminaActionCostsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStaminaActionCostsEnum(const struct FStaminaActionCostsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStaminaActionCostsTable(class FName Name, const struct FStaminaCost& Data, struct FStaminaActionCostsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StaminaActionCostsTable
class UStaminaActionCostsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStaminaActionCostsTable* GetDefaultObj();

};

// 0x18 (0x278 - 0x260)
// Class Icarus.StaminaBarBase
class UStaminaBarBase : public UUserWidget
{
public:
	uint8                                        Pad_86F0[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        LowStaminaPct;                                     // 0x268(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APawn>                  LastPlayerPawn;                                    // 0x26C(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_86F1[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UStaminaBarBase* GetDefaultObj();

	void UpdateStaminaUI(float CurrentStamina, float MaxStamina, float StaminaPct, enum class EStaminaBracket CurrentBracket, enum class EStaminaBracket LastBracket);
	void ResetStaminaUI(float CurrentStamina, float MaxStamina, float StaminaPct, enum class EStaminaBracket CurrentBracket);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatAfflictionsLibrary
class UStatAfflictionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatAfflictionsLibrary* GetDefaultObj();

	struct FStatAfflictionsRowHandle StructToRowHandle(const struct FStatAfflictionsEnum& EnumValue);
	class FName StructToName(const struct FStatAfflictionsEnum& EnumValue);
	int32 StructToInt(const struct FStatAfflictionsEnum& EnumValue);
	struct FStatAfflictionsEnum RowHandleToStruct(const struct FStatAfflictionsRowHandle& RowHandle);
	void RemoveRowFromStatAfflictionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStatAfflictionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStatAfflictionsEnum& A, const struct FStatAfflictionsEnum& B);
	struct FStatAfflictionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStatAfflictionsRowHandle MakeStatAfflictionsFromIndex(int32 Index);
	struct FStatAfflictionsEnum MakeStatAfflictionsEnum(const struct FStatAfflictionsEnum& Enum);
	struct FStatAfflictionsRowHandle MakeStatAfflictions(class FName RowName);
	struct FStatAfflictionsRowHandle MakeLiteralStatAfflictions(const struct FStatAfflictionsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStatAfflictionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStatAfflictionsStruct(const struct FStatAfflictionsRowHandle& RowHandle, struct FStatAfflictions* StatAfflictions, enum class EValid* Paths);
	bool EqualEqual_FStatAfflictionsRowHandleFStatAfflictionsRowHandle(const struct FStatAfflictionsRowHandle& RowHandleA, const struct FStatAfflictionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStatAfflictionsEnum& A, const struct FStatAfflictionsEnum& B);
	struct FStatAfflictionsRowHandle CastToStatAfflictionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStatAfflictionsEnum(const struct FStatAfflictionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStatAfflictionsTable(class FName Name, const struct FStatAfflictions& Data, struct FStatAfflictionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StatAfflictionsTable
class UStatAfflictionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStatAfflictionsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatCategoriesLibrary
class UStatCategoriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatCategoriesLibrary* GetDefaultObj();

	struct FStatCategoriesRowHandle StructToRowHandle(const struct FStatCategoriesEnum& EnumValue);
	class FName StructToName(const struct FStatCategoriesEnum& EnumValue);
	int32 StructToInt(const struct FStatCategoriesEnum& EnumValue);
	struct FStatCategoriesEnum RowHandleToStruct(const struct FStatCategoriesRowHandle& RowHandle);
	void RemoveRowFromStatCategoriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStatCategoriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStatCategoriesEnum& A, const struct FStatCategoriesEnum& B);
	struct FStatCategoriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStatCategoriesRowHandle MakeStatCategoriesFromIndex(int32 Index);
	struct FStatCategoriesEnum MakeStatCategoriesEnum(const struct FStatCategoriesEnum& Enum);
	struct FStatCategoriesRowHandle MakeStatCategories(class FName RowName);
	struct FStatCategoriesRowHandle MakeLiteralStatCategories(const struct FStatCategoriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStatCategoriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStatCategoriesStruct(const struct FStatCategoriesRowHandle& RowHandle, struct FStatCategory* StatCategories, enum class EValid* Paths);
	bool EqualEqual_FStatCategoriesRowHandleFStatCategoriesRowHandle(const struct FStatCategoriesRowHandle& RowHandleA, const struct FStatCategoriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStatCategoriesEnum& A, const struct FStatCategoriesEnum& B);
	struct FStatCategoriesRowHandle CastToStatCategoriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStatCategoriesEnum(const struct FStatCategoriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStatCategoriesTable(class FName Name, const struct FStatCategory& Data, struct FStatCategoriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StatCategoriesTable
class UStatCategoriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStatCategoriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatGameplayTagsLibrary
class UStatGameplayTagsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatGameplayTagsLibrary* GetDefaultObj();

	struct FStatGameplayTagsRowHandle StructToRowHandle(const struct FStatGameplayTagsEnum& EnumValue);
	class FName StructToName(const struct FStatGameplayTagsEnum& EnumValue);
	int32 StructToInt(const struct FStatGameplayTagsEnum& EnumValue);
	struct FStatGameplayTagsEnum RowHandleToStruct(const struct FStatGameplayTagsRowHandle& RowHandle);
	void RemoveRowFromStatGameplayTagsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStatGameplayTagsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStatGameplayTagsEnum& A, const struct FStatGameplayTagsEnum& B);
	struct FStatGameplayTagsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStatGameplayTagsRowHandle MakeStatGameplayTagsFromIndex(int32 Index);
	struct FStatGameplayTagsEnum MakeStatGameplayTagsEnum(const struct FStatGameplayTagsEnum& Enum);
	struct FStatGameplayTagsRowHandle MakeStatGameplayTags(class FName RowName);
	struct FStatGameplayTagsRowHandle MakeLiteralStatGameplayTags(const struct FStatGameplayTagsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStatGameplayTagsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStatGameplayTagsStruct(const struct FStatGameplayTagsRowHandle& RowHandle, struct FStatGameplayTag* StatGameplayTags, enum class EValid* Paths);
	bool EqualEqual_FStatGameplayTagsRowHandleFStatGameplayTagsRowHandle(const struct FStatGameplayTagsRowHandle& RowHandleA, const struct FStatGameplayTagsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStatGameplayTagsEnum& A, const struct FStatGameplayTagsEnum& B);
	struct FStatGameplayTagsRowHandle CastToStatGameplayTagsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStatGameplayTagsEnum(const struct FStatGameplayTagsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStatGameplayTagsTable(class FName Name, const struct FStatGameplayTag& Data, struct FStatGameplayTagsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StatGameplayTagsTable
class UStatGameplayTagsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStatGameplayTagsTable* GetDefaultObj();

};

// 0x10 (0x580 - 0x570)
// Class Icarus.StaticItem
class AStaticItem : public AIcarusItem
{
public:
	class UStaticMeshComponent*                  StaticMeshRoot;                                    // 0x570(0x8)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8713[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AStaticItem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatisticsLibrary
class UStatisticsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatisticsLibrary* GetDefaultObj();

	struct FStatisticsRowHandle StructToRowHandle(const struct FStatisticsEnum& EnumValue);
	class FName StructToName(const struct FStatisticsEnum& EnumValue);
	int32 StructToInt(const struct FStatisticsEnum& EnumValue);
	struct FStatisticsEnum RowHandleToStruct(const struct FStatisticsRowHandle& RowHandle);
	void RemoveRowFromStatisticsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FStatisticsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FStatisticsEnum& A, const struct FStatisticsEnum& B);
	struct FStatisticsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FStatisticsRowHandle MakeStatisticsFromIndex(int32 Index);
	struct FStatisticsEnum MakeStatisticsEnum(const struct FStatisticsEnum& Enum);
	struct FStatisticsRowHandle MakeStatistics(class FName RowName);
	struct FStatisticsRowHandle MakeLiteralStatistics(const struct FStatisticsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FStatisticsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetStatisticsStruct(const struct FStatisticsRowHandle& RowHandle, struct FStatistic* Statistics, enum class EValid* Paths);
	bool EqualEqual_FStatisticsRowHandleFStatisticsRowHandle(const struct FStatisticsRowHandle& RowHandleA, const struct FStatisticsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FStatisticsEnum& A, const struct FStatisticsEnum& B);
	struct FStatisticsRowHandle CastToStatisticsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakStatisticsEnum(const struct FStatisticsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToStatisticsTable(class FName Name, const struct FStatistic& Data, struct FStatisticsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StatisticsTable
class UStatisticsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStatisticsTable* GetDefaultObj();

};

// 0x50 (0x80 - 0x30)
// Class Icarus.StatisticTrackerSubsystem
class UStatisticTrackerSubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_8722[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UStatisticTrackerSubsystem* GetDefaultObj();

	bool SetStatisticValue(const class FString& PlayerID, const struct FStatisticsRowHandle& StatisticRow, int32 Value);
	void OnTreeChopped(const class FString& PlayerID);
	void OnPlayerRevivedOtherPlayer(const class FString& PlayerID);
	void OnPlayerRevived(const class FString& PlayerID);
	void OnPlayerDeath(const class FString& PlayerID);
	bool IncrementStatistic(const class FString& PlayerID, const struct FStatisticsRowHandle& StatisticRow);
	struct FPlayerStatistics GetTrackedStatisticsForPlayer(const class FString& PlayerID);
	bool ClearTrackedStatisticsForPlayer(const class FString& PlayerID);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.StatsFunctionLibrary
class UStatsFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UStatsFunctionLibrary* GetDefaultObj();

	bool RollChanceStat(const struct FStatsEnum& Stat, class UIcarusStatContainer* StatContainer);
	float ModifyValueByPlusPercent(int32 Value, int32 StatValue);
	bool HasStatDescription(const struct FStatsEnum& Stat);
	void GetStatTitleBP(const struct FStatsEnum& Stat, int32 Value, class FText* TitleDescription, enum class EFunctionOutcome* Outcome);
	TMap<struct FStatCategoriesEnum, struct FStatCollection> GetStatDisplay(class UIcarusStatContainer* StatContainer);
	void GetStatDescriptionBP(const struct FStatsEnum& Stat, int32 Value, class FText* Description, enum class EFunctionOutcome* Outcome);
	TMap<struct FStatsRowHandle, int32> GetStatBoxItemStats(class UObject* WorldContextObject, struct FItemData& Item);
	int32 GetStatAdjustedDurabilityLoss(class AIcarusPlayerCharacter* Player, int32 Durability);
	void CompareItemStats(class UObject* WorldContextObject, struct FItemData& ItemBase, struct FItemData& CompareToItem, TArray<struct FStatComparisonResult>* ComparisonResults);
	bool CheckStatComparison(struct FStatComparison& Comparison, class UIcarusStatContainer* StatContainer);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.StatsTable
class UStatsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UStatsTable* GetDefaultObj();

};

// 0x18 (0xC8 - 0xB0)
// Class Icarus.StomachComponent
class UStomachComponent : public UActorComponent
{
public:
	TArray<struct FStomachContent>               StomachContents;                                   // 0xB0(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            StomachContentsUpdated;                            // 0xC0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_872B[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UStomachComponent* GetDefaultObj();

	void OnRep_StomachContents();
	TArray<struct FBarSegment> GetStomachBarSegments();
	void FoodModifierRemoved(class UModifierStateComponent* Component, bool bRemoved);
};

// 0x10 (0x38 - 0x28)
// Class Icarus.SubtitleQueue
class USubtitleQueue : public UObject
{
public:
	uint8                                        Pad_872C[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USubtitleQueue* GetDefaultObj();

	void TickSubtitles(float DeltaTime, FDelegateProperty_& OnSubtitleReadyToPlay);
	bool HasQueuedSubtitles();
	void ClearSubtitlesWithCallback(FDelegateProperty_& OnSubtitleCleared);
	void ClearSubtitles();
	void AddDialogue(const struct FDialogueRowHandle& Dialogue);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SurfacesLibrary
class USurfacesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USurfacesLibrary* GetDefaultObj();

	struct FSurfacesRowHandle StructToRowHandle(const struct FSurfacesEnum& EnumValue);
	class FName StructToName(const struct FSurfacesEnum& EnumValue);
	int32 StructToInt(const struct FSurfacesEnum& EnumValue);
	struct FSurfacesEnum RowHandleToStruct(const struct FSurfacesRowHandle& RowHandle);
	void RemoveRowFromSurfacesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSurfacesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSurfacesEnum& A, const struct FSurfacesEnum& B);
	struct FSurfacesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSurfacesRowHandle MakeSurfacesRowFromSurfaceType(enum class EPhysicalSurface& InSurfaceType);
	struct FSurfacesRowHandle MakeSurfacesFromIndex(int32 Index);
	struct FSurfacesEnum MakeSurfacesEnum(const struct FSurfacesEnum& Enum);
	struct FSurfacesRowHandle MakeSurfaces(class FName RowName);
	struct FSurfacesRowHandle MakeLiteralSurfaces(const struct FSurfacesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSurfacesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSurfacesStruct(const struct FSurfacesRowHandle& RowHandle, struct FSurfacesData* Surfaces, enum class EValid* Paths);
	bool EqualEqual_FSurfacesRowHandleFSurfacesRowHandle(const struct FSurfacesRowHandle& RowHandleA, const struct FSurfacesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSurfacesEnum& A, const struct FSurfacesEnum& B);
	struct FSurfacesRowHandle CastToSurfacesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSurfacesEnum(const struct FSurfacesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSurfacesTable(class FName Name, const struct FSurfacesData& Data, struct FSurfacesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SurfacesTable
class USurfacesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USurfacesTable* GetDefaultObj();

};

// 0x10 (0x270 - 0x260)
// Class Icarus.SurvivalProgressBar
class USurvivalProgressBar : public UUserWidget
{
public:
	float                                        CurrentPct;                                        // 0x260(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	enum class ESurvivalStatType                 StatType;                                          // 0x264(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8739[0xB];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class USurvivalProgressBar* GetDefaultObj();

	void UpdateDisplay();
	void TryBindEvents();
	void Setup(enum class ESurvivalStatType NewStatType);
	void OnStatUpdated(int32 NewValue);
	void InitStatIcon();
	float GetCurrentPct();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.SurvivalTriggersLibrary
class USurvivalTriggersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class USurvivalTriggersLibrary* GetDefaultObj();

	struct FSurvivalTriggersRowHandle StructToRowHandle(const struct FSurvivalTriggersEnum& EnumValue);
	class FName StructToName(const struct FSurvivalTriggersEnum& EnumValue);
	int32 StructToInt(const struct FSurvivalTriggersEnum& EnumValue);
	struct FSurvivalTriggersEnum RowHandleToStruct(const struct FSurvivalTriggersRowHandle& RowHandle);
	void RemoveRowFromSurvivalTriggersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FSurvivalTriggersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FSurvivalTriggersEnum& A, const struct FSurvivalTriggersEnum& B);
	struct FSurvivalTriggersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FSurvivalTriggersRowHandle MakeSurvivalTriggersFromIndex(int32 Index);
	struct FSurvivalTriggersEnum MakeSurvivalTriggersEnum(const struct FSurvivalTriggersEnum& Enum);
	struct FSurvivalTriggersRowHandle MakeSurvivalTriggers(class FName RowName);
	struct FSurvivalTriggersRowHandle MakeLiteralSurvivalTriggers(const struct FSurvivalTriggersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FSurvivalTriggersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetSurvivalTriggersStruct(const struct FSurvivalTriggersRowHandle& RowHandle, struct FSurvivalTriggers* SurvivalTriggers, enum class EValid* Paths);
	bool EqualEqual_FSurvivalTriggersRowHandleFSurvivalTriggersRowHandle(const struct FSurvivalTriggersRowHandle& RowHandleA, const struct FSurvivalTriggersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FSurvivalTriggersEnum& A, const struct FSurvivalTriggersEnum& B);
	struct FSurvivalTriggersRowHandle CastToSurvivalTriggersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakSurvivalTriggersEnum(const struct FSurvivalTriggersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToSurvivalTriggersTable(class FName Name, const struct FSurvivalTriggers& Data, struct FSurvivalTriggersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.SurvivalTriggersTable
class USurvivalTriggersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class USurvivalTriggersTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TagQueriesLibrary
class UTagQueriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTagQueriesLibrary* GetDefaultObj();

	struct FTagQueriesRowHandle StructToRowHandle(const struct FTagQueriesEnum& EnumValue);
	class FName StructToName(const struct FTagQueriesEnum& EnumValue);
	int32 StructToInt(const struct FTagQueriesEnum& EnumValue);
	struct FTagQueriesEnum RowHandleToStruct(const struct FTagQueriesRowHandle& RowHandle);
	void RemoveRowFromTagQueriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTagQueriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTagQueriesEnum& A, const struct FTagQueriesEnum& B);
	struct FTagQueriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTagQueriesRowHandle MakeTagQueriesFromIndex(int32 Index);
	struct FTagQueriesEnum MakeTagQueriesEnum(const struct FTagQueriesEnum& Enum);
	struct FTagQueriesRowHandle MakeTagQueries(class FName RowName);
	struct FTagQueriesRowHandle MakeLiteralTagQueries(const struct FTagQueriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTagQueriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTagQueriesStruct(const struct FTagQueriesRowHandle& RowHandle, struct FTagQueries* TagQueries, enum class EValid* Paths);
	bool EqualEqual_FTagQueriesRowHandleFTagQueriesRowHandle(const struct FTagQueriesRowHandle& RowHandleA, const struct FTagQueriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTagQueriesEnum& A, const struct FTagQueriesEnum& B);
	struct FTagQueriesRowHandle CastToTagQueriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTagQueriesEnum(const struct FTagQueriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTagQueriesTable(class FName Name, const struct FTagQueries& Data, struct FTagQueriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TagQueriesTable
class UTagQueriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTagQueriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentAccolade
class UTalentAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UTalentAccolade* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentArchetypesLibrary
class UTalentArchetypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentArchetypesLibrary* GetDefaultObj();

	struct FTalentArchetypesRowHandle StructToRowHandle(const struct FTalentArchetypesEnum& EnumValue);
	class FName StructToName(const struct FTalentArchetypesEnum& EnumValue);
	int32 StructToInt(const struct FTalentArchetypesEnum& EnumValue);
	struct FTalentArchetypesEnum RowHandleToStruct(const struct FTalentArchetypesRowHandle& RowHandle);
	void RemoveRowFromTalentArchetypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentArchetypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentArchetypesEnum& A, const struct FTalentArchetypesEnum& B);
	struct FTalentArchetypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	TArray<struct FTalentArchetypesRowHandle> MakeTalentArchetypesRowFromModel(struct FTalentModelsRowHandle& InModel);
	struct FTalentArchetypesRowHandle MakeTalentArchetypesFromIndex(int32 Index);
	struct FTalentArchetypesEnum MakeTalentArchetypesEnum(const struct FTalentArchetypesEnum& Enum);
	struct FTalentArchetypesRowHandle MakeTalentArchetypes(class FName RowName);
	struct FTalentArchetypesRowHandle MakeLiteralTalentArchetypes(const struct FTalentArchetypesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentArchetypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentArchetypesStruct(const struct FTalentArchetypesRowHandle& RowHandle, struct FTalentArchetype* TalentArchetypes, enum class EValid* Paths);
	bool EqualEqual_FTalentArchetypesRowHandleFTalentArchetypesRowHandle(const struct FTalentArchetypesRowHandle& RowHandleA, const struct FTalentArchetypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentArchetypesEnum& A, const struct FTalentArchetypesEnum& B);
	struct FTalentArchetypesRowHandle CastToTalentArchetypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentArchetypesEnum(const struct FTalentArchetypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentArchetypesTable(class FName Name, const struct FTalentArchetype& Data, struct FTalentArchetypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentArchetypesTable
class UTalentArchetypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentArchetypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentControllerInterface
class ITalentControllerInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class ITalentControllerInterface* GetDefaultObj();

	bool UnlockNextTalentRank(const struct FTalentsRowHandle& Talent, bool bForceUnlock);
	class UTalentViewInterface* SetView(const struct FTalentViewsRowHandle& InView);
	void SetModelView(const struct FTalentModelViewsRowHandle& InModelView);
	class UTalentModelInterface* SetModel(const struct FTalentModelsRowHandle& InModel);
	void SetIsInteractionEnabled(bool IsEnabled);
	bool RefundTalent(const struct FTalentsRowHandle& Talent);
	bool IsInteractionEnabled();
	bool HasView();
	class UTalentViewInterface* GetView();
	struct FTalentModelViewsRowHandle GetModelViewData();
	class UTalentModelInterface_Const* GetModel_Const();
	class UTalentModelInterface* GetModel();
	void ForceRefresh();
	bool CanRefundTalent(const struct FTalentsRowHandle& Talent, enum class ERefundTalentResponse* SuccessOrFailureReason);
	bool AreAnyFlagsSet(TArray<struct FFlagsMultiRowHandle>& Flags);
	bool AreAllFlagsSet(TArray<struct FFlagsMultiRowHandle>& Flags);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentLibrary
class UTalentLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentLibrary* GetDefaultObj();

	struct FTalentTreesRowHandle GetTalentTree(const struct FTalentsRowHandle& Talent);
	TArray<struct FTalentsRowHandle> GetTalentsForTree(const struct FTalentTreesRowHandle& TalentTree);
	struct FProcessorRecipesRowHandle GetTalentRecipeSlow(const struct FTalentsRowHandle& Talent);
	struct FTalentsRowHandle GetRequiredCharacterTalentForBlueprintUnlock(const struct FTalentsRowHandle& Talent);
	struct FTalentModelViewsRowHandle GetModelView(const struct FTalentModelsRowHandle& Model);
	struct FTalentModelsRowHandle GetModel(const struct FTalentArchetypesRowHandle& Archetype);
	struct FTalentArchetypesRowHandle GetArchetype(const struct FTalentTreesRowHandle& TalentTree);
	class FString GenerateSearchStringForWorkshopTalent(const struct FTalentsRowHandle& Talent);
	class FString GenerateSearchStringForProspectTalent(const struct FTalentsRowHandle& Talent);
	class FString GenerateSearchStringForPlayerTalent(const struct FTalentsRowHandle& Talent);
	class FString GenerateSearchStringForBlueprintTalent(const struct FTalentsRowHandle& Talent);
};

// 0x58 (0x2B8 - 0x260)
// Class Icarus.TalentGraphWidget
class UTalentGraphWidget : public UUserWidget
{
public:
	struct FTalentArchetypesRowHandle            TalentArchetype;                                   // 0x260(0x18)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTalentViewInterface*                  TalentView;                                        // 0x278(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTalentTreeWidget*>             TalentTreeWidgets;                                 // 0x280(0x10)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                        Zoom;                                              // 0x290(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8760[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<class UTalentTooltipWidget*>          TooltipWidgets;                                    // 0x298(0x10)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_8761[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TSubclassOf<class UTalentTooltipWidget>      TooltipWidgetClass;                                // 0x2B0(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UTalentGraphWidget* GetDefaultObj();

	void PostSetup();
	void OnZoomChanged(int32 Level, float Scale);
	void InitializeGraph(class UTalentViewInterface* View, const struct FTalentArchetypesRowHandle& Archetype);
};

// 0x0 (0x260 - 0x260)
// Class Icarus.TalentMenuWidget
class UTalentMenuWidget : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UTalentMenuWidget* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentModelDataStatics
class UTalentModelDataStatics : public UObject
{
public:

	static class UClass* StaticClass();
	static class UTalentModelDataStatics* GetDefaultObj();

	void BreakTalentModelData(struct FTalentModelData& ModelData, int32* Rank, int32* MaxRank, enum class ETalentState* State);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentModelsLibrary
class UTalentModelsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentModelsLibrary* GetDefaultObj();

	struct FTalentModelsRowHandle StructToRowHandle(const struct FTalentModelsEnum& EnumValue);
	class FName StructToName(const struct FTalentModelsEnum& EnumValue);
	int32 StructToInt(const struct FTalentModelsEnum& EnumValue);
	struct FTalentModelsEnum RowHandleToStruct(const struct FTalentModelsRowHandle& RowHandle);
	void RemoveRowFromTalentModelsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentModelsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentModelsEnum& A, const struct FTalentModelsEnum& B);
	struct FTalentModelsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTalentModelsRowHandle MakeTalentModelsFromIndex(int32 Index);
	struct FTalentModelsEnum MakeTalentModelsEnum(const struct FTalentModelsEnum& Enum);
	struct FTalentModelsRowHandle MakeTalentModels(class FName RowName);
	struct FTalentModelsRowHandle MakeLiteralTalentModels(const struct FTalentModelsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentModelsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentModelsStruct(const struct FTalentModelsRowHandle& RowHandle, struct FTalentModel* TalentModels, enum class EValid* Paths);
	bool EqualEqual_FTalentModelsRowHandleFTalentModelsRowHandle(const struct FTalentModelsRowHandle& RowHandleA, const struct FTalentModelsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentModelsEnum& A, const struct FTalentModelsEnum& B);
	struct FTalentModelsRowHandle CastToTalentModelsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentModelsEnum(const struct FTalentModelsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentModelsTable(class FName Name, const struct FTalentModel& Data, struct FTalentModelsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentModelsTable
class UTalentModelsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentModelsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentModelViewsLibrary
class UTalentModelViewsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentModelViewsLibrary* GetDefaultObj();

	struct FTalentModelViewsRowHandle StructToRowHandle(const struct FTalentModelViewsEnum& EnumValue);
	class FName StructToName(const struct FTalentModelViewsEnum& EnumValue);
	int32 StructToInt(const struct FTalentModelViewsEnum& EnumValue);
	struct FTalentModelViewsEnum RowHandleToStruct(const struct FTalentModelViewsRowHandle& RowHandle);
	void RemoveRowFromTalentModelViewsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentModelViewsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentModelViewsEnum& A, const struct FTalentModelViewsEnum& B);
	struct FTalentModelViewsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTalentModelViewsRowHandle MakeTalentModelViewsFromIndex(int32 Index);
	struct FTalentModelViewsEnum MakeTalentModelViewsEnum(const struct FTalentModelViewsEnum& Enum);
	struct FTalentModelViewsRowHandle MakeTalentModelViews(class FName RowName);
	struct FTalentModelViewsRowHandle MakeLiteralTalentModelViews(const struct FTalentModelViewsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentModelViewsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentModelViewsStruct(const struct FTalentModelViewsRowHandle& RowHandle, struct FTalentModelView* TalentModelViews, enum class EValid* Paths);
	bool EqualEqual_FTalentModelViewsRowHandleFTalentModelViewsRowHandle(const struct FTalentModelViewsRowHandle& RowHandleA, const struct FTalentModelViewsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentModelViewsEnum& A, const struct FTalentModelViewsEnum& B);
	struct FTalentModelViewsRowHandle CastToTalentModelViewsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentModelViewsEnum(const struct FTalentModelViewsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentModelViewsTable(class FName Name, const struct FTalentModelView& Data, struct FTalentModelViewsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentModelViewsTable
class UTalentModelViewsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentModelViewsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentRanksFunctionLibrary
class UTalentRanksFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentRanksFunctionLibrary* GetDefaultObj();

	struct FTalentRank GetTalentRank(const struct FTalentRanksRowHandle& Reference, int32 Investment, enum class EValid* Paths);
	struct FTalentRanksRowHandle FindRequiredTalentRank(const struct FTalentsRowHandle& Talent);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentRanksLibrary
class UTalentRanksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentRanksLibrary* GetDefaultObj();

	struct FTalentRanksRowHandle StructToRowHandle(const struct FTalentRanksEnum& EnumValue);
	class FName StructToName(const struct FTalentRanksEnum& EnumValue);
	int32 StructToInt(const struct FTalentRanksEnum& EnumValue);
	struct FTalentRanksEnum RowHandleToStruct(const struct FTalentRanksRowHandle& RowHandle);
	void RemoveRowFromTalentRanksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentRanksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentRanksEnum& A, const struct FTalentRanksEnum& B);
	struct FTalentRanksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTalentRanksRowHandle MakeTalentRanksFromIndex(int32 Index);
	struct FTalentRanksEnum MakeTalentRanksEnum(const struct FTalentRanksEnum& Enum);
	struct FTalentRanksRowHandle MakeTalentRanks(class FName RowName);
	struct FTalentRanksRowHandle MakeLiteralTalentRanks(const struct FTalentRanksRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentRanksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentRanksStruct(const struct FTalentRanksRowHandle& RowHandle, struct FTalentRank* TalentRanks, enum class EValid* Paths);
	bool EqualEqual_FTalentRanksRowHandleFTalentRanksRowHandle(const struct FTalentRanksRowHandle& RowHandleA, const struct FTalentRanksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentRanksEnum& A, const struct FTalentRanksEnum& B);
	struct FTalentRanksRowHandle CastToTalentRanksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentRanksEnum(const struct FTalentRanksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentRanksTable(class FName Name, const struct FTalentRank& Data, struct FTalentRanksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentRanksTable
class UTalentRanksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentRanksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentsLibrary
class UTalentsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentsLibrary* GetDefaultObj();

	struct FTalentsRowHandle StructToRowHandle(const struct FTalentsEnum& EnumValue);
	class FName StructToName(const struct FTalentsEnum& EnumValue);
	int32 StructToInt(const struct FTalentsEnum& EnumValue);
	struct FTalentsEnum RowHandleToStruct(const struct FTalentsRowHandle& RowHandle);
	void RemoveRowFromTalentsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentsEnum& A, const struct FTalentsEnum& B);
	struct FTalentsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	TArray<struct FTalentsRowHandle> MakeTalentsRowFromTalentTree(struct FTalentTreesRowHandle& InTalentTree);
	struct FTalentsRowHandle MakeTalentsFromIndex(int32 Index);
	struct FTalentsEnum MakeTalentsEnum(const struct FTalentsEnum& Enum);
	struct FTalentsRowHandle MakeTalents(class FName RowName);
	struct FTalentsRowHandle MakeLiteralTalents(const struct FTalentsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentsStruct(const struct FTalentsRowHandle& RowHandle, struct FTalent* Talents, enum class EValid* Paths);
	bool EqualEqual_FTalentsRowHandleFTalentsRowHandle(const struct FTalentsRowHandle& RowHandleA, const struct FTalentsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentsEnum& A, const struct FTalentsEnum& B);
	struct FTalentsRowHandle CastToTalentsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentsEnum(const struct FTalentsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentsTable(class FName Name, const struct FTalent& Data, struct FTalentsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x30 (0x60 - 0x30)
// Class Icarus.TalentsSubsystem
class UTalentsSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnBlueprintTalentsUpdatedNotify;                   // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnPlayerTalentsUpdatedNotify;                      // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnProspectTalentsUpdatedNotify;                    // 0x50(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UTalentsSubsystem* GetDefaultObj();

	void BroadcastProspectTalentsUpdatedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastPlayerTalentsUpdatedDelegate(class AIcarusPlayerCharacter* Player);
	void BroadcastBlueprintTalentsUpdatedDelegate(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentsTable
class UTalentsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentsTable* GetDefaultObj();

};

// 0x0 (0x30 - 0x30)
// Class Icarus.TalentSubsystem
class UTalentSubsystem : public UGameInstanceSubsystem
{
public:

	static class UClass* StaticClass();
	static class UTalentSubsystem* GetDefaultObj();

};

// 0x20 (0x280 - 0x260)
// Class Icarus.TalentTooltipWidget
class UTalentTooltipWidget : public UUserWidget
{
public:
	class UTalentModelInterface_Const*           Model;                                             // 0x260(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTalentsRowHandle                     Talent;                                            // 0x268(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UTalentTooltipWidget* GetDefaultObj();

	void SetTalent(class UTalentModelInterface_Const* InModel, const struct FTalentsRowHandle& InTalent);
	void OnTalentSet();
};

// 0x50 (0x2B0 - 0x260)
// Class Icarus.TalentTreeCanvas
class UTalentTreeCanvas : public UUserWidget
{
public:
	uint8                                        Pad_8790[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTalentTreeCanvas* GetDefaultObj();

	void Reset(class UTalentModelInterface_Const* Model);
	void Refresh(class UTalentModelInterface_Const* Model);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentTreesLibrary
class UTalentTreesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentTreesLibrary* GetDefaultObj();

	struct FTalentTreesRowHandle StructToRowHandle(const struct FTalentTreesEnum& EnumValue);
	class FName StructToName(const struct FTalentTreesEnum& EnumValue);
	int32 StructToInt(const struct FTalentTreesEnum& EnumValue);
	struct FTalentTreesEnum RowHandleToStruct(const struct FTalentTreesRowHandle& RowHandle);
	void RemoveRowFromTalentTreesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentTreesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentTreesEnum& A, const struct FTalentTreesEnum& B);
	struct FTalentTreesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	TArray<struct FTalentTreesRowHandle> MakeTalentTreesRowFromArchetype(struct FTalentArchetypesRowHandle& InArchetype);
	struct FTalentTreesRowHandle MakeTalentTreesFromIndex(int32 Index);
	struct FTalentTreesEnum MakeTalentTreesEnum(const struct FTalentTreesEnum& Enum);
	struct FTalentTreesRowHandle MakeTalentTrees(class FName RowName);
	struct FTalentTreesRowHandle MakeLiteralTalentTrees(const struct FTalentTreesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentTreesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentTreesStruct(const struct FTalentTreesRowHandle& RowHandle, struct FTalentTree* TalentTrees, enum class EValid* Paths);
	bool EqualEqual_FTalentTreesRowHandleFTalentTreesRowHandle(const struct FTalentTreesRowHandle& RowHandleA, const struct FTalentTreesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentTreesEnum& A, const struct FTalentTreesEnum& B);
	struct FTalentTreesRowHandle CastToTalentTreesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentTreesEnum(const struct FTalentTreesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentTreesTable(class FName Name, const struct FTalentTree& Data, struct FTalentTreesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentTreesTable
class UTalentTreesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentTreesTable* GetDefaultObj();

};

// 0xD0 (0x330 - 0x260)
// Class Icarus.TalentTreeWidget
class UTalentTreeWidget : public UUserWidget
{
public:
	TMap<struct FTalentsRowHandle, class UTalentWidget*> TalentsWidgetsMap;                                 // 0x260(0x50)(BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UTalentViewInterface*                  TalentView;                                        // 0x2B0(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTalentTreeCanvas*                     TalentTreeCanvas;                                  // 0x2B8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTalentTreesRowHandle                 TalentTree;                                        // 0x2C0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FTalentsRowHandle>               Talents;                                           // 0x2D8(0x50)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_879D[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTalentTreeWidget* GetDefaultObj();

	void SetZoomLevel(int32 Level, float Scale);
	void SetTalentTree(class UTalentViewInterface* View, class UTalentGraphWidget* OwningGraphWidget, struct FTalentTreesRowHandle& NewTalentTree);
	void SetEditorCanvas(class UUserWidget* EditorCanvas);
	void OnTalentTreeCreated();
	void OnTalentRemoved(struct FTalentsRowHandle& Talent);
	void OnTalentChanged(struct FTalentsRowHandle& Talent);
	void OnTalentAdded(struct FTalentsRowHandle& Talent);
	void OnModelStateChanged(class UTalentModelInterface_Const* Model);
	struct FVector2D GetCanvasSize();
	struct FVector2D GetCanvasOffset(bool bAbsolute);
	void ClearTalentTree();
};

// 0x10 (0x270 - 0x260)
// Class Icarus.TalentViewInterface
class UTalentViewInterface : public UUserWidget
{
public:
	uint8                                        Pad_879E[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTalentViewInterface* GetDefaultObj();

	void SetController(TScriptInterface<class ITalentControllerInterface>& InController);
	void OnModelViewChanged(class UTalentModelInterface* InModel, class UTalentViewInterface* InView);
	struct FTalentViewsRowHandle GetViewData();
	TArray<class UTalentTreeWidget*> GetTalentTreeWidgets();
	class UTalentModelInterface_Const* GetModel();
	class UTalentGraphWidget* GetGraphWidget();
	TScriptInterface<class ITalentControllerInterface> GetController();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TalentViewsLibrary
class UTalentViewsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTalentViewsLibrary* GetDefaultObj();

	struct FTalentViewsRowHandle StructToRowHandle(const struct FTalentViewsEnum& EnumValue);
	class FName StructToName(const struct FTalentViewsEnum& EnumValue);
	int32 StructToInt(const struct FTalentViewsEnum& EnumValue);
	struct FTalentViewsEnum RowHandleToStruct(const struct FTalentViewsRowHandle& RowHandle);
	void RemoveRowFromTalentViewsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTalentViewsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTalentViewsEnum& A, const struct FTalentViewsEnum& B);
	struct FTalentViewsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTalentViewsRowHandle MakeTalentViewsFromIndex(int32 Index);
	struct FTalentViewsEnum MakeTalentViewsEnum(const struct FTalentViewsEnum& Enum);
	struct FTalentViewsRowHandle MakeTalentViews(class FName RowName);
	struct FTalentViewsRowHandle MakeLiteralTalentViews(const struct FTalentViewsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTalentViewsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTalentViewsStruct(const struct FTalentViewsRowHandle& RowHandle, struct FTalentView* TalentViews, enum class EValid* Paths);
	bool EqualEqual_FTalentViewsRowHandleFTalentViewsRowHandle(const struct FTalentViewsRowHandle& RowHandleA, const struct FTalentViewsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTalentViewsEnum& A, const struct FTalentViewsEnum& B);
	struct FTalentViewsRowHandle CastToTalentViewsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTalentViewsEnum(const struct FTalentViewsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTalentViewsTable(class FName Name, const struct FTalentView& Data, struct FTalentViewsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TalentViewsTable
class UTalentViewsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTalentViewsTable* GetDefaultObj();

};

// 0x28 (0x288 - 0x260)
// Class Icarus.TalentWidget
class UTalentWidget : public UUserWidget
{
public:
	struct FTalentsRowHandle                     Talent;                                            // 0x260(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UTalentGraphWidget>     CachedOwningGraphWidget;                           // 0x278(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UTalentTooltipWidget>   CachedTooltipWidget;                               // 0x280(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UTalentWidget* GetDefaultObj();

	class UTalentTooltipWidget* TryGetCurrentTooltipWidget();
	void SetTalent(const struct FTalentsRowHandle& InTalent);
	void SetSearchHighlight(bool bHighlighted);
	void OnTalentSet();
	class UWidget* GetTooltip();
	class FString GetStringForFilterSearch();
	void FillTooltip(class UTalentTooltipWidget* NewTooltipWidget);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TamedCreatureModifiersLibrary
class UTamedCreatureModifiersLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTamedCreatureModifiersLibrary* GetDefaultObj();

	struct FTamedCreatureModifiersRowHandle StructToRowHandle(const struct FTamedCreatureModifiersEnum& EnumValue);
	class FName StructToName(const struct FTamedCreatureModifiersEnum& EnumValue);
	int32 StructToInt(const struct FTamedCreatureModifiersEnum& EnumValue);
	struct FTamedCreatureModifiersEnum RowHandleToStruct(const struct FTamedCreatureModifiersRowHandle& RowHandle);
	void RemoveRowFromTamedCreatureModifiersTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTamedCreatureModifiersEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTamedCreatureModifiersEnum& A, const struct FTamedCreatureModifiersEnum& B);
	struct FTamedCreatureModifiersEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTamedCreatureModifiersRowHandle MakeTamedCreatureModifiersFromIndex(int32 Index);
	struct FTamedCreatureModifiersEnum MakeTamedCreatureModifiersEnum(const struct FTamedCreatureModifiersEnum& Enum);
	struct FTamedCreatureModifiersRowHandle MakeTamedCreatureModifiers(class FName RowName);
	struct FTamedCreatureModifiersRowHandle MakeLiteralTamedCreatureModifiers(const struct FTamedCreatureModifiersRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTamedCreatureModifiersEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTamedCreatureModifiersStruct(const struct FTamedCreatureModifiersRowHandle& RowHandle, struct FTamedCreatureModifier* TamedCreatureModifiers, enum class EValid* Paths);
	bool EqualEqual_FTamedCreatureModifiersRowHandleFTamedCreatureModifiersRowHandle(const struct FTamedCreatureModifiersRowHandle& RowHandleA, const struct FTamedCreatureModifiersRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTamedCreatureModifiersEnum& A, const struct FTamedCreatureModifiersEnum& B);
	struct FTamedCreatureModifiersRowHandle CastToTamedCreatureModifiersRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTamedCreatureModifiersEnum(const struct FTamedCreatureModifiersEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTamedCreatureModifiersTable(class FName Name, const struct FTamedCreatureModifier& Data, struct FTamedCreatureModifiersRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TamedCreatureModifiersTable
class UTamedCreatureModifiersTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTamedCreatureModifiersTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TamesLibrary
class UTamesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTamesLibrary* GetDefaultObj();

	struct FTamesRowHandle StructToRowHandle(const struct FTamesEnum& EnumValue);
	class FName StructToName(const struct FTamesEnum& EnumValue);
	int32 StructToInt(const struct FTamesEnum& EnumValue);
	struct FTamesEnum RowHandleToStruct(const struct FTamesRowHandle& RowHandle);
	void RemoveRowFromTamesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTamesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTamesEnum& A, const struct FTamesEnum& B);
	struct FTamesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTamesRowHandle MakeTamesFromIndex(int32 Index);
	struct FTamesEnum MakeTamesEnum(const struct FTamesEnum& Enum);
	struct FTamesRowHandle MakeTames(class FName RowName);
	struct FTamesRowHandle MakeLiteralTames(const struct FTamesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTamesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTamesStruct(const struct FTamesRowHandle& RowHandle, struct FIcarusTamingData* Tames, enum class EValid* Paths);
	bool EqualEqual_FTamesRowHandleFTamesRowHandle(const struct FTamesRowHandle& RowHandleA, const struct FTamesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTamesEnum& A, const struct FTamesEnum& B);
	struct FTamesRowHandle CastToTamesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTamesEnum(const struct FTamesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTamesTable(class FName Name, const struct FIcarusTamingData& Data, struct FTamesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TamesTable
class UTamesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTamesTable* GetDefaultObj();

};

// 0x98 (0x358 - 0x2C0)
// Class Icarus.TargetRangeController
class ATargetRangeController : public AIcarusActor
{
public:
	float                                        CurrentTime;                                       // 0x2C0(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MaxTime;                                           // 0x2C4(0x4)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTargetRangeScore>             Scores;                                            // 0x2C8(0x10)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTargetRangeScore                     HighScore;                                         // 0x2D8(0x28)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	TArray<class ATargetRangeTarget*>            Targets;                                           // 0x300(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ATargetRangeTrigger*>           Triggers;                                          // 0x310(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	enum class ETargetRangeState                 State;                                             // 0x320(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_87C1[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnRoundComplete;                                   // 0x328(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnScoreIncreased;                                  // 0x338(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnNewHighScore;                                    // 0x348(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ATargetRangeController* GetDefaultObj();

	void TriggerStart();
	void RegisterTrigger(class ATargetRangeTrigger* Trigger);
	void RegisterTarget(class ATargetRangeTarget* Target);
	void RegisterScore(class APlayerController* Player, int32 Score);
	void NotifyScoreIncreased();
	void NotifyRoundComplete();
	void NotifyNewHighScore();
};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.TargetRangeControllerRecorderComponent
class UTargetRangeControllerRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FHighScoreRecord                      HighScore;                                         // 0x1A8(0x28)(SaveGame, Protected, NativeAccessSpecifierProtected)
	float                                        RoundTime;                                         // 0x1D0(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_87C2[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTargetRangeControllerRecorderComponent* GetDefaultObj();

};

// 0x8 (0x2C8 - 0x2C0)
// Class Icarus.TargetRangeScoreboard
class ATargetRangeScoreboard : public AIcarusActor
{
public:
	class ATargetRangeController*                RangeController;                                   // 0x2C0(0x8)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ATargetRangeScoreboard* GetDefaultObj();

	void RegisterTargetRangeController(class ATargetRangeController* Controller);
};

// 0x20 (0x2E0 - 0x2C0)
// Class Icarus.TargetRangeTarget
class ATargetRangeTarget : public AIcarusActor
{
public:
	bool                                         bAllowMultipleHits;                                // 0x2C0(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasBeenHit;                                       // 0x2C1(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRoundActive;                                      // 0x2C2(0x1)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_87C4[0x1];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MovementDistance;                                  // 0x2C4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        MovementDelay;                                     // 0x2C8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_87C5[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnTargetHit;                                       // 0x2D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ATargetRangeTarget* GetDefaultObj();

	void OnActorDamagedHandler(const struct FIcarusDamagePacket& DamagePacket);
	void BP_StartRound();
	void BP_ResetTarget();
	void BP_OnHit(const struct FIcarusDamagePacket& DamagePacket);
	int32 BP_GenerateScore(const struct FIcarusDamagePacket& DamagePacket);
	void BP_EndRound();
};

// 0x18 (0x1C0 - 0x1A8)
// Class Icarus.TargetRangeTargetRecorderComponent
class UTargetRangeTargetRecorderComponent : public UActorStateRecorderComponent
{
public:
	bool                                         bAllowMultipleHits;                                // 0x1A8(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_87C6[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        MovementDistance;                                  // 0x1AC(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MovementDelay;                                     // 0x1B0(0x4)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_87C7[0xC];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTargetRangeTargetRecorderComponent* GetDefaultObj();

};

// 0x10 (0x2D0 - 0x2C0)
// Class Icarus.TargetRangeTrigger
class ATargetRangeTrigger : public AIcarusActor
{
public:
	FMulticastInlineDelegateProperty_            OnTriggerRange;                                    // 0x2C0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class ATargetRangeTrigger* GetDefaultObj();

	void OnServer_TriggerRange();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TaskListAccolade
class UTaskListAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UTaskListAccolade* GetDefaultObj();

};

// 0x10 (0x38 - 0x28)
// Class Icarus.TemperatureSingleton
class UTemperatureSingleton : public UObject
{
public:
	class UCurveFloat*                           DefaultTempIncCurve;                               // 0x28(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                           DefaultTempDecCurve;                               // 0x30(0x8)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UTemperatureSingleton* GetDefaultObj();

};

// 0x8 (0xB8 - 0xB0)
// Class Icarus.TerrainAnchorComponent
class UTerrainAnchorComponent : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_            OnTerrainAchorStateChanged;                        // 0xB0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bAutoRegisterSubject;                              // 0xB1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bRegisterIfLoaded;                                 // 0xB2(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsRegisteredSubject;                              // 0xB3(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ETerrainAnchorState               AnchorState;                                       // 0xB4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bInitialised;                                      // 0xB5(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_87C8[0x2];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTerrainAnchorComponent* GetDefaultObj();

	void ReevaluateAnchorState();
	bool IsTerrainAnchorValid();
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.PlayerTerrainAnchorComponent
class UPlayerTerrainAnchorComponent : public UTerrainAnchorComponent
{
public:

	static class UClass* StaticClass();
	static class UPlayerTerrainAnchorComponent* GetDefaultObj();

};

// 0xC8 (0xF8 - 0x30)
// Class Icarus.TerrainAnchorSubsystem
class UTerrainAnchorSubsystem : public UWorldSubsystem
{
public:
	bool                                         bDisabled;                                         // 0x30(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bDisableWithoutWorldData;                          // 0x31(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_87C9[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class ULevelStreamingBinding*, class ULevelStreamingBinding*> HeightmapGeneratedMap;                             // 0x38(0x50)(Edit, EditConst, NativeAccessSpecifierPrivate)
	bool                                         bInitialized;                                      // 0x88(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                         bAsyncRevaluateAnchorsRunning;                     // 0x89(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_87CA[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TMap<class AActor*, class UTerrainAnchorComponent*> RegisteredSubjects;                                // 0x90(0x50)(Edit, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ULevelStreamingBinding*>        StreamingLevelBindings;                            // 0xE0(0x10)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	struct FTimerHandle                          TerrainAnchorsDirtyTimerHandle;                    // 0xF0(0x8)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UTerrainAnchorSubsystem* GetDefaultObj();

};

// 0x28 (0x50 - 0x28)
// Class Icarus.LevelStreamingBinding
class ULevelStreamingBinding : public UObject
{
public:
	class ULevelStreaming*                       StreamingLevel;                                    // 0x28(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALandscapeProxy*                       LevelLandscapeProxy;                               // 0x30(0x8)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                LevelBounds;                                       // 0x38(0x14)(Edit, ZeroConstructor, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                         bLevelAnchorValid;                                 // 0x4C(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsGeneratedLevel;                                 // 0x4D(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_87CB[0x2];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ULevelStreamingBinding* GetDefaultObj();

	void OnStreamingLevelUnloaded();
	void OnStreamingLevelShown();
	void OnStreamingLevelLoaded();
	void OnStreamingLevelHidden();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TerrainsLibrary
class UTerrainsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTerrainsLibrary* GetDefaultObj();

	struct FTerrainsRowHandle StructToRowHandle(const struct FTerrainsEnum& EnumValue);
	class FName StructToName(const struct FTerrainsEnum& EnumValue);
	int32 StructToInt(const struct FTerrainsEnum& EnumValue);
	struct FTerrainsEnum RowHandleToStruct(const struct FTerrainsRowHandle& RowHandle);
	void RemoveRowFromTerrainsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTerrainsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTerrainsEnum& A, const struct FTerrainsEnum& B);
	struct FTerrainsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTerrainsRowHandle MakeTerrainsFromIndex(int32 Index);
	struct FTerrainsEnum MakeTerrainsEnum(const struct FTerrainsEnum& Enum);
	struct FTerrainsRowHandle MakeTerrains(class FName RowName);
	struct FTerrainsRowHandle MakeLiteralTerrains(const struct FTerrainsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTerrainsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTerrainsStruct(const struct FTerrainsRowHandle& RowHandle, struct FIcarusTerrain* Terrains, enum class EValid* Paths);
	bool EqualEqual_FTerrainsRowHandleFTerrainsRowHandle(const struct FTerrainsRowHandle& RowHandleA, const struct FTerrainsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTerrainsEnum& A, const struct FTerrainsEnum& B);
	struct FTerrainsRowHandle CastToTerrainsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTerrainsEnum(const struct FTerrainsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTerrainsTable(class FName Name, const struct FIcarusTerrain& Data, struct FTerrainsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TerrainsTable
class UTerrainsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTerrainsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TerrainZoneAudioDataLibrary
class UTerrainZoneAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTerrainZoneAudioDataLibrary* GetDefaultObj();

	struct FTerrainZoneAudioDataRowHandle StructToRowHandle(const struct FTerrainZoneAudioDataEnum& EnumValue);
	class FName StructToName(const struct FTerrainZoneAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FTerrainZoneAudioDataEnum& EnumValue);
	struct FTerrainZoneAudioDataEnum RowHandleToStruct(const struct FTerrainZoneAudioDataRowHandle& RowHandle);
	void RemoveRowFromTerrainZoneAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTerrainZoneAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTerrainZoneAudioDataEnum& A, const struct FTerrainZoneAudioDataEnum& B);
	struct FTerrainZoneAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTerrainZoneAudioDataRowHandle MakeTerrainZoneAudioDataRowFromColor(struct FColor& InColor);
	struct FTerrainZoneAudioDataRowHandle MakeTerrainZoneAudioDataFromIndex(int32 Index);
	struct FTerrainZoneAudioDataEnum MakeTerrainZoneAudioDataEnum(const struct FTerrainZoneAudioDataEnum& Enum);
	struct FTerrainZoneAudioDataRowHandle MakeTerrainZoneAudioData(class FName RowName);
	struct FTerrainZoneAudioDataRowHandle MakeLiteralTerrainZoneAudioData(const struct FTerrainZoneAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTerrainZoneAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTerrainZoneAudioDataStruct(const struct FTerrainZoneAudioDataRowHandle& RowHandle, struct FTerrainZoneAudioData* TerrainZoneAudioData, enum class EValid* Paths);
	bool EqualEqual_FTerrainZoneAudioDataRowHandleFTerrainZoneAudioDataRowHandle(const struct FTerrainZoneAudioDataRowHandle& RowHandleA, const struct FTerrainZoneAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTerrainZoneAudioDataEnum& A, const struct FTerrainZoneAudioDataEnum& B);
	struct FTerrainZoneAudioDataRowHandle CastToTerrainZoneAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTerrainZoneAudioDataEnum(const struct FTerrainZoneAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTerrainZoneAudioDataTable(class FName Name, const struct FTerrainZoneAudioData& Data, struct FTerrainZoneAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TerrainZoneAudioDataTable
class UTerrainZoneAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTerrainZoneAudioDataTable* GetDefaultObj();

};

// 0x28 (0x50 - 0x28)
// Class Icarus.TextureListItem
class UTextureListItem : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>             ItemTexture;                                       // 0x28(0x28)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UTextureListItem* GetDefaultObj();

};

// 0x10 (0xE0 - 0xD0)
// Class Icarus.ThermalComponent
class UThermalComponent : public UTraitComponent
{
public:
	class AIcarusGameStateSurvival*              GameState;                                         // 0xD0(0x8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                      NavigationModifier;                                // 0xD8(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UThermalComponent* GetDefaultObj();

	bool GetThermalData(struct FThermalData* OutData);
	int32 GetTemperatureEffectAtLocation(const struct FVector& InLocation, bool* bIsAffecting, class AActor* QueryActor, bool bDrawDebug, float DebugDrawDuration, int32 DebugDrawTextOffset);
	void DestroyThermalComponent();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.ThermalLibrary
class UThermalLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UThermalLibrary* GetDefaultObj();

	struct FThermalRowHandle StructToRowHandle(const struct FThermalEnum& EnumValue);
	class FName StructToName(const struct FThermalEnum& EnumValue);
	int32 StructToInt(const struct FThermalEnum& EnumValue);
	struct FThermalEnum RowHandleToStruct(const struct FThermalRowHandle& RowHandle);
	void RemoveRowFromThermalTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FThermalEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FThermalEnum& A, const struct FThermalEnum& B);
	struct FThermalEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FThermalRowHandle MakeThermalFromIndex(int32 Index);
	struct FThermalEnum MakeThermalEnum(const struct FThermalEnum& Enum);
	struct FThermalRowHandle MakeThermal(class FName RowName);
	struct FThermalRowHandle MakeLiteralThermal(const struct FThermalRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FThermalEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetThermalStruct(const struct FThermalRowHandle& RowHandle, struct FThermalData* Thermal, enum class EValid* Paths);
	bool EqualEqual_FThermalRowHandleFThermalRowHandle(const struct FThermalRowHandle& RowHandleA, const struct FThermalRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FThermalEnum& A, const struct FThermalEnum& B);
	struct FThermalRowHandle CastToThermalRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakThermalEnum(const struct FThermalEnum& Enum, class FName* Name, int32* Index);
	void AddRowToThermalTable(class FName Name, const struct FThermalData& Data, struct FThermalRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ThermalTable
class UThermalTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UThermalTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ThreatAudioInterface
class IThreatAudioInterface : public IInterface
{
public:

	static class UClass* StaticClass();
	static class IThreatAudioInterface* GetDefaultObj();

	float GetThreatToPlayer(class AIcarusPlayerCharacter* TargetPlayer);
	enum class EMusicConditionCombatState GetCombatMusicConditionOverride(class AIcarusPlayerCharacter* TargetPlayer, float Threat);
};

// 0x10 (0x40 - 0x30)
// Class Icarus.ThreatAudioSubsystem
class UThreatAudioSubsystem : public UWorldSubsystem
{
public:
	TArray<class UObject*>                       TrackedObjects;                                    // 0x30(0x10)(ZeroConstructor, NativeAccessSpecifierPrivate)

	static class UClass* StaticClass();
	static class UThreatAudioSubsystem* GetDefaultObj();

	void Remove(class UObject* Target);
	struct FThreatAudioResult GetThreatLevel(class AIcarusPlayerCharacter* Player);
	void Add(class UObject* Target);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TimelineRanksLibrary
class UTimelineRanksLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTimelineRanksLibrary* GetDefaultObj();

	struct FTimelineRanksRowHandle StructToRowHandle(const struct FTimelineRanksEnum& EnumValue);
	class FName StructToName(const struct FTimelineRanksEnum& EnumValue);
	int32 StructToInt(const struct FTimelineRanksEnum& EnumValue);
	struct FTimelineRanksEnum RowHandleToStruct(const struct FTimelineRanksRowHandle& RowHandle);
	void RemoveRowFromTimelineRanksTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTimelineRanksEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTimelineRanksEnum& A, const struct FTimelineRanksEnum& B);
	struct FTimelineRanksEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTimelineRanksRowHandle MakeTimelineRanksFromIndex(int32 Index);
	struct FTimelineRanksEnum MakeTimelineRanksEnum(const struct FTimelineRanksEnum& Enum);
	struct FTimelineRanksRowHandle MakeTimelineRanks(class FName RowName);
	struct FTimelineRanksRowHandle MakeLiteralTimelineRanks(const struct FTimelineRanksRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTimelineRanksEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTimelineRanksStruct(const struct FTimelineRanksRowHandle& RowHandle, struct FTimelineRanks* TimelineRanks, enum class EValid* Paths);
	bool EqualEqual_FTimelineRanksRowHandleFTimelineRanksRowHandle(const struct FTimelineRanksRowHandle& RowHandleA, const struct FTimelineRanksRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTimelineRanksEnum& A, const struct FTimelineRanksEnum& B);
	struct FTimelineRanksRowHandle CastToTimelineRanksRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTimelineRanksEnum(const struct FTimelineRanksEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTimelineRanksTable(class FName Name, const struct FTimelineRanks& Data, struct FTimelineRanksRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TimelineRanksTable
class UTimelineRanksTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTimelineRanksTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TimeOfDayLibrary
class UTimeOfDayLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTimeOfDayLibrary* GetDefaultObj();

	struct FTimeOfDayRowHandle StructToRowHandle(const struct FTimeOfDayEnum& EnumValue);
	class FName StructToName(const struct FTimeOfDayEnum& EnumValue);
	int32 StructToInt(const struct FTimeOfDayEnum& EnumValue);
	struct FTimeOfDayEnum RowHandleToStruct(const struct FTimeOfDayRowHandle& RowHandle);
	void RemoveRowFromTimeOfDayTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTimeOfDayEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTimeOfDayEnum& A, const struct FTimeOfDayEnum& B);
	struct FTimeOfDayEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTimeOfDayRowHandle MakeTimeOfDayFromIndex(int32 Index);
	struct FTimeOfDayEnum MakeTimeOfDayEnum(const struct FTimeOfDayEnum& Enum);
	struct FTimeOfDayRowHandle MakeTimeOfDay(class FName RowName);
	struct FTimeOfDayRowHandle MakeLiteralTimeOfDay(const struct FTimeOfDayRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTimeOfDayEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTimeOfDayStruct(const struct FTimeOfDayRowHandle& RowHandle, struct FTimeOfDay* TimeOfDay, enum class EValid* Paths);
	bool EqualEqual_FTimeOfDayRowHandleFTimeOfDayRowHandle(const struct FTimeOfDayRowHandle& RowHandleA, const struct FTimeOfDayRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTimeOfDayEnum& A, const struct FTimeOfDayEnum& B);
	struct FTimeOfDayRowHandle CastToTimeOfDayRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTimeOfDayEnum(const struct FTimeOfDayEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTimeOfDayTable(class FName Name, const struct FTimeOfDay& Data, struct FTimeOfDayRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x40 (0x80 - 0x40)
// Class Icarus.TimeOfDaySubsystem
class UTimeOfDaySubsystem : public UTickableWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnPlayersSleptNotify;                              // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCurveFloat*                           TimeScaleCurve;                                    // 0x50(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        TimeScale;                                         // 0x58(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        MinimumTimeStep;                                   // 0x5C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AIcarusGameStateSurvival*              CachedGameState;                                   // 0x60(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_880A[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTimeOfDaySubsystem* GetDefaultObj();

	void SetTimeScale(float NewScale);
	void SetTimeOfDayHour(int32 Hour);
	void SetTimeOfDay(float Total);
	void SetMinimumTimeStepSeconds(float Step);
	void ProspectInfoFetched();
	bool IsSleeping(class AIcarusPlayerCharacter* Player);
	bool HasRequiredSleepModifier(class AIcarusPlayerCharacter* Player);
	float GetTimeTotal();
	float GetTimeScale();
	float GetTimeRealtime();
	int32 GetTimeOfDayMinutes();
	void GetTimeOfDayHoursMinutesSecs(int32* Hours, int32* Minutes, int32* Seconds);
	int32 GetTimeOfDayHour();
	struct FTimeOfDayEnum GetTimeOfDayEnum();
	void GetTimeOfDay(float* Total, float* Normalized, float* Realtime);
	float GetTimeNormalized();
	TSet<struct FModifierStatesRowHandle> GetSleepAffectingModifiers(class AIcarusPlayerCharacter* Player);
	float GetMinimumTimeStepSeconds();
	TSet<struct FModifierStatesRowHandle> GetAllSleepAffectingModifiers();
	enum class ESleepResult CanSleep();
	void AttemptToSleep();
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TimeOfDayTable
class UTimeOfDayTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTimeOfDayTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ToolDamageLibrary
class UToolDamageLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UToolDamageLibrary* GetDefaultObj();

	struct FToolDamageRowHandle StructToRowHandle(const struct FToolDamageEnum& EnumValue);
	class FName StructToName(const struct FToolDamageEnum& EnumValue);
	int32 StructToInt(const struct FToolDamageEnum& EnumValue);
	struct FToolDamageEnum RowHandleToStruct(const struct FToolDamageRowHandle& RowHandle);
	void RemoveRowFromToolDamageTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FToolDamageEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FToolDamageEnum& A, const struct FToolDamageEnum& B);
	struct FToolDamageEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FToolDamageRowHandle MakeToolDamageFromIndex(int32 Index);
	struct FToolDamageEnum MakeToolDamageEnum(const struct FToolDamageEnum& Enum);
	struct FToolDamageRowHandle MakeToolDamage(class FName RowName);
	struct FToolDamageRowHandle MakeLiteralToolDamage(const struct FToolDamageRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FToolDamageEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetToolDamageStruct(const struct FToolDamageRowHandle& RowHandle, struct FToolDamage* ToolDamage, enum class EValid* Paths);
	bool EqualEqual_FToolDamageRowHandleFToolDamageRowHandle(const struct FToolDamageRowHandle& RowHandleA, const struct FToolDamageRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FToolDamageEnum& A, const struct FToolDamageEnum& B);
	struct FToolDamageRowHandle CastToToolDamageRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakToolDamageEnum(const struct FToolDamageEnum& Enum, class FName* Name, int32* Index);
	void AddRowToToolDamageTable(class FName Name, const struct FToolDamage& Data, struct FToolDamageRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ToolDamageTable
class UToolDamageTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UToolDamageTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ToolTypesLibrary
class UToolTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UToolTypesLibrary* GetDefaultObj();

	struct FToolTypesRowHandle StructToRowHandle(const struct FToolTypesEnum& EnumValue);
	class FName StructToName(const struct FToolTypesEnum& EnumValue);
	int32 StructToInt(const struct FToolTypesEnum& EnumValue);
	struct FToolTypesEnum RowHandleToStruct(const struct FToolTypesRowHandle& RowHandle);
	void RemoveRowFromToolTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FToolTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FToolTypesEnum& A, const struct FToolTypesEnum& B);
	struct FToolTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FToolTypesRowHandle MakeToolTypesFromIndex(int32 Index);
	struct FToolTypesEnum MakeToolTypesEnum(const struct FToolTypesEnum& Enum);
	struct FToolTypesRowHandle MakeToolTypes(class FName RowName);
	struct FToolTypesRowHandle MakeLiteralToolTypes(const struct FToolTypesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FToolTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetToolTypesStruct(const struct FToolTypesRowHandle& RowHandle, struct FIcarusToolType* ToolTypes, enum class EValid* Paths);
	bool EqualEqual_FToolTypesRowHandleFToolTypesRowHandle(const struct FToolTypesRowHandle& RowHandleA, const struct FToolTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FToolTypesEnum& A, const struct FToolTypesEnum& B);
	struct FToolTypesRowHandle CastToToolTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakToolTypesEnum(const struct FToolTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToToolTypesTable(class FName Name, const struct FIcarusToolType& Data, struct FToolTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ToolTypesTable
class UToolTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UToolTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TrackerAccolade
class UTrackerAccolade : public UAccoladeImpl
{
public:

	static class UClass* StaticClass();
	static class UTrackerAccolade* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TraitFunctionLibrary
class UTraitFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UTraitFunctionLibrary* GetDefaultObj();

	class UTraitComponent* GetTrait(class AActor* Actor, TSubclassOf<class UTraitComponent> TraitClass, enum class EValid* Paths);
};

// 0x8 (0xD8 - 0xD0)
// Class Icarus.TransmutableComponent
class UTransmutableComponent : public UTraitComponent
{
public:
	int32                                        TransmutableUnits;                                 // 0xD0(0x4)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8823[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTransmutableComponent* GetDefaultObj();

	void SetTransmutableUnits(int32 NewUnits);
	bool GetTransmutableData(struct FTransmutableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TransmutableLibrary
class UTransmutableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTransmutableLibrary* GetDefaultObj();

	struct FTransmutableRowHandle StructToRowHandle(const struct FTransmutableEnum& EnumValue);
	class FName StructToName(const struct FTransmutableEnum& EnumValue);
	int32 StructToInt(const struct FTransmutableEnum& EnumValue);
	struct FTransmutableEnum RowHandleToStruct(const struct FTransmutableRowHandle& RowHandle);
	void RemoveRowFromTransmutableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTransmutableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTransmutableEnum& A, const struct FTransmutableEnum& B);
	struct FTransmutableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTransmutableRowHandle MakeTransmutableFromIndex(int32 Index);
	struct FTransmutableEnum MakeTransmutableEnum(const struct FTransmutableEnum& Enum);
	struct FTransmutableRowHandle MakeTransmutable(class FName RowName);
	struct FTransmutableRowHandle MakeLiteralTransmutable(const struct FTransmutableRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTransmutableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTransmutableStruct(const struct FTransmutableRowHandle& RowHandle, struct FTransmutableData* Transmutable, enum class EValid* Paths);
	bool EqualEqual_FTransmutableRowHandleFTransmutableRowHandle(const struct FTransmutableRowHandle& RowHandleA, const struct FTransmutableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTransmutableEnum& A, const struct FTransmutableEnum& B);
	struct FTransmutableRowHandle CastToTransmutableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTransmutableEnum(const struct FTransmutableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTransmutableTable(class FName Name, const struct FTransmutableData& Data, struct FTransmutableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TransmutableTable
class UTransmutableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTransmutableTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.TreeAudioDataLibrary
class UTreeAudioDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTreeAudioDataLibrary* GetDefaultObj();

	struct FTreeAudioDataRowHandle StructToRowHandle(const struct FTreeAudioDataEnum& EnumValue);
	class FName StructToName(const struct FTreeAudioDataEnum& EnumValue);
	int32 StructToInt(const struct FTreeAudioDataEnum& EnumValue);
	struct FTreeAudioDataEnum RowHandleToStruct(const struct FTreeAudioDataRowHandle& RowHandle);
	void RemoveRowFromTreeAudioDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTreeAudioDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTreeAudioDataEnum& A, const struct FTreeAudioDataEnum& B);
	struct FTreeAudioDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTreeAudioDataRowHandle MakeTreeAudioDataFromIndex(int32 Index);
	struct FTreeAudioDataEnum MakeTreeAudioDataEnum(const struct FTreeAudioDataEnum& Enum);
	struct FTreeAudioDataRowHandle MakeTreeAudioData(class FName RowName);
	struct FTreeAudioDataRowHandle MakeLiteralTreeAudioData(const struct FTreeAudioDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTreeAudioDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTreeAudioDataStruct(const struct FTreeAudioDataRowHandle& RowHandle, struct FTreeAudioData* TreeAudioData, enum class EValid* Paths);
	bool EqualEqual_FTreeAudioDataRowHandleFTreeAudioDataRowHandle(const struct FTreeAudioDataRowHandle& RowHandleA, const struct FTreeAudioDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTreeAudioDataEnum& A, const struct FTreeAudioDataEnum& B);
	struct FTreeAudioDataRowHandle CastToTreeAudioDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTreeAudioDataEnum(const struct FTreeAudioDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTreeAudioDataTable(class FName Name, const struct FTreeAudioData& Data, struct FTreeAudioDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TreeAudioDataTable
class UTreeAudioDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTreeAudioDataTable* GetDefaultObj();

};

// 0x90 (0x350 - 0x2C0)
// Class Icarus.TreeBase
class ATreeBase : public AIcarusActor
{
public:
	bool                                         bHasBeenConstructed;                               // 0x2C0(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasSpawnArguments;                                // 0x2C1(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bDefferTreeConstruction;                           // 0x2C2(0x1)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bHasBeenModified;                                  // 0x2C3(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8841[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnHasBeenModifiedUpdated;                          // 0x2C8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTreePrimitiveComponent*               RootPrimitive;                                     // 0x2D8(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTreePrimitiveComponent*>       TreePrimitives;                                    // 0x2E0(0x10)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                  ProxyMeshComponent;                                // 0x2F0(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTreeRuntimeConstructArguments        SpawnArguments;                                    // 0x2F8(0x38)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	TArray<int32>                                RuntimeTreePrimitivesMask;                         // 0x330(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	class UFLODActorComponent*                   FLODActorComponent;                                // 0x340(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bIsResolvingTreeCollision;                         // 0x348(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8842[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ATreeBase* GetDefaultObj();

	bool TransferTreePrimitiveHierarchy(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext);
	void TransferTreePrimitive(class UTreePrimitiveComponent* Original, class UTreePrimitiveComponent* New);
	void SetRootPrimitive(class UTreePrimitiveComponent* InRootPrimitive);
	void SetHasBeenModified(bool Modified);
	void ResolveTreeVisibility();
	void ResolveTreeCollision();
	bool OrphanTreePrimitive(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext, bool* bDestroySelf);
	void OnUpdateTreePrimitiveRuntimeMaskState(TArray<class UTreePrimitiveComponent*>& RemovedTreePrimitives);
	void OnTransferTreePrimitiveHierarchy(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext, class ATreeBase* NewTree);
	void OnRep_SpawnArguments();
	void OnRep_RuntimeTreePrimitivesMask();
	void OnRep_HasBeenModified();
	void OnPreConstructedTreePrimitives();
	void OnOrphanTreePrimitive(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext, bool bDestroyingSelf, class AIcarusItem* ReplacementItem);
	void OnHitTree(class UPrimitiveComponent* Primitive, class AActor* DamageCauser, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void OnDetachTreePrimitive(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext);
	void OnConstructedTreePrimitives();
	class ATreePrefab* GetTreePrefab();
	int32 GetPrimitiveCountByType(enum class ETreePrimitiveType Type);
	bool GetAttachedTreePrimitives(class UTreePrimitiveComponent* SourceTreePrimitive, TArray<enum class ETreePrimitiveType>& Types, bool bIncludeSource, bool bIncludeAllDescendants, TArray<class UTreePrimitiveComponent*>* OutTreePrimitives);
	bool DetachTreePrimitive(class UTreePrimitiveComponent* TreePrimitive, struct FTreePrimitiveDetachContext& DetachContext);
	void DebugLogHierarchy();
	void ConsumeHit(struct FIcarusDamagePacket& DamagePacket);
	void AddTreePrimitiveToRuntimeMask(class UTreePrimitiveComponent* TreePrimitive);
};

// 0x130 (0x350 - 0x220)
// Class Icarus.TreePrefab
class ATreePrefab : public AActor
{
public:
	class USceneComponent*                       RootScene;                                         // 0x220(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<enum class ETreePrimitiveType, struct FItemRewardsRowHandle> TreePrimitiveTypesToItemRewards;                   // 0x228(0x50)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ATreeBase>                 RuntimeTreeClass;                                  // 0x278(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTreePrimitiveComponent>   RuntimeTreePrimitiveClass;                         // 0x280(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8845[0xC8];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class ATreePrefab* GetDefaultObj();

	void OnCreatedTreeRuntime(class ATreeBase* TreeBase);
	class ATreeBase* CreateTreeRuntime(struct FTreeRuntimeCreateArguments& Args);
	bool ConstructTreePrimitives(class ATreeBase* TreeRuntime, struct FTreeRuntimeConstructArguments& Args);
};

// 0x40 (0x520 - 0x4E0)
// Class Icarus.TreePrimitiveComponent
class UTreePrimitiveComponent : public UStaticMeshComponent
{
public:
	float                                        CalculatedMass;                                    // 0x4E0(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CalculatedDescendantsMass;                         // 0x4E4(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CalculatedTotalConnectedMass;                      // 0x4E8(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8847[0x4];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FTreePrimitiveReplacementDescription> ReplacementDescriptions;                           // 0x4F0(0x10)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                         bDestroyOnOrphan;                                  // 0x500(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8848[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class FName                                  CollisionProfileWhenActive;                        // 0x504(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTreePrimitivePersistentData          PersistentData;                                    // 0x50C(0x4)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                  TreePrimitiveName;                                 // 0x510(0x8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	enum class ETreePrimitiveType                TreePrimitiveType;                                 // 0x518(0x1)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_8849[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTreePrimitiveComponent* GetDefaultObj();

	void Transfer(class UTreePrimitiveComponent* Source);
	bool ShouldTreePrimivieAffectNavigation();
	void SetVirtualTextureRenderPassType(enum class ERuntimeVirtualTextureMainPassType InType);
	void SetupCollisionProfile(bool bEnabled, bool bIsDynamic);
	bool ReplaceTreePrimitiveWithItem(struct FTreePrimitiveDetachContext& DetachContext, class AIcarusItem** OutItemActor);
	void RecalculateMass();
	void InitializePostConstruction();
	void Construct(class UStaticMeshComponent* MeshComponent);
	bool CanSupportTreeHierarchy();
};

// 0x28 (0x1D0 - 0x1A8)
// Class Icarus.TreeRecorderComponent
class UTreeRecorderComponent : public UActorStateRecorderComponent
{
public:
	class FName                                  TreePrefabClassName;                               // 0x1A8(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                TreePrimitiveMask;                                 // 0x1B0(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	class FName                                  RootName;                                          // 0x1C0(0x8)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bIsPhysicsDynamic;                                 // 0x1C8(0x1)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_884A[0x7];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UTreeRecorderComponent* GetDefaultObj();

};

// 0x20 (0x50 - 0x30)
// Class Icarus.TreeSubsystem
class UTreeSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnTreeFelledNotify;                                // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnTreeResourceCollectedNotify;                     // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UTreeSubsystem* GetDefaultObj();

	void BroadcastTreeResourceCollectedDelegate(class AIcarusPlayerCharacter* Player, const struct FItemData& Item);
	void BroadcastTreeFelledDelegate(class AIcarusPlayerCharacter* Player);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.TurretLibrary
class UTurretLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UTurretLibrary* GetDefaultObj();

	struct FTurretRowHandle StructToRowHandle(const struct FTurretEnum& EnumValue);
	class FName StructToName(const struct FTurretEnum& EnumValue);
	int32 StructToInt(const struct FTurretEnum& EnumValue);
	struct FTurretEnum RowHandleToStruct(const struct FTurretRowHandle& RowHandle);
	void RemoveRowFromTurretTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FTurretEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FTurretEnum& A, const struct FTurretEnum& B);
	struct FTurretEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FTurretRowHandle MakeTurretFromIndex(int32 Index);
	struct FTurretEnum MakeTurretEnum(const struct FTurretEnum& Enum);
	struct FTurretRowHandle MakeTurret(class FName RowName);
	struct FTurretRowHandle MakeLiteralTurret(const struct FTurretRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FTurretEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetTurretStruct(const struct FTurretRowHandle& RowHandle, struct FTurretData* Turret, enum class EValid* Paths);
	bool EqualEqual_FTurretRowHandleFTurretRowHandle(const struct FTurretRowHandle& RowHandleA, const struct FTurretRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FTurretEnum& A, const struct FTurretEnum& B);
	struct FTurretRowHandle CastToTurretRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakTurretEnum(const struct FTurretEnum& Enum, class FName* Name, int32* Index);
	void AddRowToTurretTable(class FName Name, const struct FTurretData& Data, struct FTurretRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.TurretTable
class UTurretTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UTurretTable* GetDefaultObj();

};

// 0x0 (0x48 - 0x48)
// Class Icarus.TutorialRuleset
class UTutorialRuleset : public URuleset
{
public:

	static class UClass* StaticClass();
	static class UTutorialRuleset* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.UMGFunctionLibrary
class UUMGFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UUMGFunctionLibrary* GetDefaultObj();

	class FString PasteFromClipboard();
	class FText GetTextForKeybind(class UObject* WorldContextObject, struct FKeybindingsRowHandle& Keybinding);
	TArray<class FText> FormatTimeLengthDigital(int32 Seconds);
	void CopyToClipboard(const class FString& Text);
	bool AnyChildrenVisible(class UPanelWidget* PanelWidget);
};

// 0x0 (0xD0 - 0xD0)
// Class Icarus.UsableComponent
class UUsableComponent : public UTraitComponent
{
public:

	static class UClass* StaticClass();
	static class UUsableComponent* GetDefaultObj();

	bool GetUsableData(struct FUsableData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.UsableItemLibrary
class UUsableItemLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UUsableItemLibrary* GetDefaultObj();

	bool UseItem(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use, class AIcarusPlayerCharacter* Target);
	bool CanUseInventoryItem(class UInventory* SourceInventory, int32 SourceLocation, const struct FUsesEnum& Use, class AIcarusPlayerCharacter* Target);
	bool CanUse(const struct FUseCondition& UseCondition, class AIcarusPlayerCharacter* Target);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.UsableLibrary
class UUsableLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UUsableLibrary* GetDefaultObj();

	struct FUsableRowHandle StructToRowHandle(const struct FUsableEnum& EnumValue);
	class FName StructToName(const struct FUsableEnum& EnumValue);
	int32 StructToInt(const struct FUsableEnum& EnumValue);
	struct FUsableEnum RowHandleToStruct(const struct FUsableRowHandle& RowHandle);
	void RemoveRowFromUsableTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FUsableEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FUsableEnum& A, const struct FUsableEnum& B);
	struct FUsableEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FUsableRowHandle MakeUsableFromIndex(int32 Index);
	struct FUsableEnum MakeUsableEnum(const struct FUsableEnum& Enum);
	struct FUsableRowHandle MakeUsable(class FName RowName);
	struct FUsableRowHandle MakeLiteralUsable(const struct FUsableRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FUsableEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetUsableStruct(const struct FUsableRowHandle& RowHandle, struct FUsableData* Usable, enum class EValid* Paths);
	bool EqualEqual_FUsableRowHandleFUsableRowHandle(const struct FUsableRowHandle& RowHandleA, const struct FUsableRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FUsableEnum& A, const struct FUsableEnum& B);
	struct FUsableRowHandle CastToUsableRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakUsableEnum(const struct FUsableEnum& Enum, class FName* Name, int32* Index);
	void AddRowToUsableTable(class FName Name, const struct FUsableData& Data, struct FUsableRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.UsableTable
class UUsableTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UUsableTable* GetDefaultObj();

};

// 0x0 (0x260 - 0x260)
// Class Icarus.UserInterfaceBase
class UUserInterfaceBase : public UUserWidget
{
public:

	static class UClass* StaticClass();
	static class UUserInterfaceBase* GetDefaultObj();

	void WidgetFocusLost(class UIcarusWidget* Widget);
	void WidgetFocusGained(class UIcarusWidget* Widget);
	class UConfirmationPopupBase* GetConfirmationPopup();
	void FocusDynamicWidget(class UUserWidget* DynamicWidget);
	void DisplayIcarusError(const struct FErrorCodesEnum& OutgoingError);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.UsesLibrary
class UUsesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UUsesLibrary* GetDefaultObj();

	struct FUsesRowHandle StructToRowHandle(const struct FUsesEnum& EnumValue);
	class FName StructToName(const struct FUsesEnum& EnumValue);
	int32 StructToInt(const struct FUsesEnum& EnumValue);
	struct FUsesEnum RowHandleToStruct(const struct FUsesRowHandle& RowHandle);
	void RemoveRowFromUsesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FUsesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FUsesEnum& A, const struct FUsesEnum& B);
	struct FUsesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FUsesRowHandle MakeUsesFromIndex(int32 Index);
	struct FUsesEnum MakeUsesEnum(const struct FUsesEnum& Enum);
	struct FUsesRowHandle MakeUses(class FName RowName);
	struct FUsesRowHandle MakeLiteralUses(const struct FUsesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FUsesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetUsesStruct(const struct FUsesRowHandle& RowHandle, struct FUses* Uses, enum class EValid* Paths);
	bool EqualEqual_FUsesRowHandleFUsesRowHandle(const struct FUsesRowHandle& RowHandleA, const struct FUsesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FUsesEnum& A, const struct FUsesEnum& B);
	struct FUsesRowHandle CastToUsesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakUsesEnum(const struct FUsesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToUsesTable(class FName Name, const struct FUses& Data, struct FUsesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.UsesTable
class UUsesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UUsesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ValidAmmoTypesLibrary
class UValidAmmoTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UValidAmmoTypesLibrary* GetDefaultObj();

	struct FValidAmmoTypesRowHandle StructToRowHandle(const struct FValidAmmoTypesEnum& EnumValue);
	class FName StructToName(const struct FValidAmmoTypesEnum& EnumValue);
	int32 StructToInt(const struct FValidAmmoTypesEnum& EnumValue);
	struct FValidAmmoTypesEnum RowHandleToStruct(const struct FValidAmmoTypesRowHandle& RowHandle);
	void RemoveRowFromValidAmmoTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FValidAmmoTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FValidAmmoTypesEnum& A, const struct FValidAmmoTypesEnum& B);
	struct FValidAmmoTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FValidAmmoTypesRowHandle MakeValidAmmoTypesFromIndex(int32 Index);
	struct FValidAmmoTypesEnum MakeValidAmmoTypesEnum(const struct FValidAmmoTypesEnum& Enum);
	struct FValidAmmoTypesRowHandle MakeValidAmmoTypes(class FName RowName);
	struct FValidAmmoTypesRowHandle MakeLiteralValidAmmoTypes(const struct FValidAmmoTypesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FValidAmmoTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetValidAmmoTypesStruct(const struct FValidAmmoTypesRowHandle& RowHandle, struct FValidAmmoTypes* ValidAmmoTypes, enum class EValid* Paths);
	bool EqualEqual_FValidAmmoTypesRowHandleFValidAmmoTypesRowHandle(const struct FValidAmmoTypesRowHandle& RowHandleA, const struct FValidAmmoTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FValidAmmoTypesEnum& A, const struct FValidAmmoTypesEnum& B);
	struct FValidAmmoTypesRowHandle CastToValidAmmoTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakValidAmmoTypesEnum(const struct FValidAmmoTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToValidAmmoTypesTable(class FName Name, const struct FValidAmmoTypes& Data, struct FValidAmmoTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ValidAmmoTypesTable
class UValidAmmoTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UValidAmmoTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ValidHitQueriesLibrary
class UValidHitQueriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UValidHitQueriesLibrary* GetDefaultObj();

	struct FValidHitQueriesRowHandle StructToRowHandle(const struct FValidHitQueriesEnum& EnumValue);
	class FName StructToName(const struct FValidHitQueriesEnum& EnumValue);
	int32 StructToInt(const struct FValidHitQueriesEnum& EnumValue);
	struct FValidHitQueriesEnum RowHandleToStruct(const struct FValidHitQueriesRowHandle& RowHandle);
	void RemoveRowFromValidHitQueriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FValidHitQueriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FValidHitQueriesEnum& A, const struct FValidHitQueriesEnum& B);
	struct FValidHitQueriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FValidHitQueriesRowHandle MakeValidHitQueriesFromIndex(int32 Index);
	struct FValidHitQueriesEnum MakeValidHitQueriesEnum(const struct FValidHitQueriesEnum& Enum);
	struct FValidHitQueriesRowHandle MakeValidHitQueries(class FName RowName);
	struct FValidHitQueriesRowHandle MakeLiteralValidHitQueries(const struct FValidHitQueriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FValidHitQueriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetValidHitQueriesStruct(const struct FValidHitQueriesRowHandle& RowHandle, struct FValidHitQuery* ValidHitQueries, enum class EValid* Paths);
	bool EqualEqual_FValidHitQueriesRowHandleFValidHitQueriesRowHandle(const struct FValidHitQueriesRowHandle& RowHandleA, const struct FValidHitQueriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FValidHitQueriesEnum& A, const struct FValidHitQueriesEnum& B);
	struct FValidHitQueriesRowHandle CastToValidHitQueriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakValidHitQueriesEnum(const struct FValidHitQueriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToValidHitQueriesTable(class FName Name, const struct FValidHitQuery& Data, struct FValidHitQueriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ValidHitQueriesTable
class UValidHitQueriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UValidHitQueriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ValidHitTypesLibrary
class UValidHitTypesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UValidHitTypesLibrary* GetDefaultObj();

	struct FValidHitTypesRowHandle StructToRowHandle(const struct FValidHitTypesEnum& EnumValue);
	class FName StructToName(const struct FValidHitTypesEnum& EnumValue);
	int32 StructToInt(const struct FValidHitTypesEnum& EnumValue);
	struct FValidHitTypesEnum RowHandleToStruct(const struct FValidHitTypesRowHandle& RowHandle);
	void RemoveRowFromValidHitTypesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FValidHitTypesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FValidHitTypesEnum& A, const struct FValidHitTypesEnum& B);
	struct FValidHitTypesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FValidHitTypesRowHandle MakeValidHitTypesFromIndex(int32 Index);
	struct FValidHitTypesEnum MakeValidHitTypesEnum(const struct FValidHitTypesEnum& Enum);
	struct FValidHitTypesRowHandle MakeValidHitTypes(class FName RowName);
	struct FValidHitTypesRowHandle MakeLiteralValidHitTypes(const struct FValidHitTypesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FValidHitTypesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetValidHitTypesStruct(const struct FValidHitTypesRowHandle& RowHandle, struct FValidHitType* ValidHitTypes, enum class EValid* Paths);
	bool EqualEqual_FValidHitTypesRowHandleFValidHitTypesRowHandle(const struct FValidHitTypesRowHandle& RowHandleA, const struct FValidHitTypesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FValidHitTypesEnum& A, const struct FValidHitTypesEnum& B);
	struct FValidHitTypesRowHandle CastToValidHitTypesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakValidHitTypesEnum(const struct FValidHitTypesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToValidHitTypesTable(class FName Name, const struct FValidHitType& Data, struct FValidHitTypesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ValidHitTypesTable
class UValidHitTypesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UValidHitTypesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ValidInteractQueriesLibrary
class UValidInteractQueriesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UValidInteractQueriesLibrary* GetDefaultObj();

	struct FValidInteractQueriesRowHandle StructToRowHandle(const struct FValidInteractQueriesEnum& EnumValue);
	class FName StructToName(const struct FValidInteractQueriesEnum& EnumValue);
	int32 StructToInt(const struct FValidInteractQueriesEnum& EnumValue);
	struct FValidInteractQueriesEnum RowHandleToStruct(const struct FValidInteractQueriesRowHandle& RowHandle);
	void RemoveRowFromValidInteractQueriesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FValidInteractQueriesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FValidInteractQueriesEnum& A, const struct FValidInteractQueriesEnum& B);
	struct FValidInteractQueriesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FValidInteractQueriesRowHandle MakeValidInteractQueriesFromIndex(int32 Index);
	struct FValidInteractQueriesEnum MakeValidInteractQueriesEnum(const struct FValidInteractQueriesEnum& Enum);
	struct FValidInteractQueriesRowHandle MakeValidInteractQueries(class FName RowName);
	struct FValidInteractQueriesRowHandle MakeLiteralValidInteractQueries(const struct FValidInteractQueriesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FValidInteractQueriesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetValidInteractQueriesStruct(const struct FValidInteractQueriesRowHandle& RowHandle, struct FValidInteractQuery* ValidInteractQueries, enum class EValid* Paths);
	bool EqualEqual_FValidInteractQueriesRowHandleFValidInteractQueriesRowHandle(const struct FValidInteractQueriesRowHandle& RowHandleA, const struct FValidInteractQueriesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FValidInteractQueriesEnum& A, const struct FValidInteractQueriesEnum& B);
	struct FValidInteractQueriesRowHandle CastToValidInteractQueriesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakValidInteractQueriesEnum(const struct FValidInteractQueriesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToValidInteractQueriesTable(class FName Name, const struct FValidInteractQuery& Data, struct FValidInteractQueriesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.ValidInteractQueriesTable
class UValidInteractQueriesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UValidInteractQueriesTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.ValueScalingFunctionLibrary
class UValueScalingFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UValueScalingFunctionLibrary* GetDefaultObj();

	int32 GetScaledStat(class UObject* WorldContextObject, class UIcarusStatContainer*& StatContainer, const struct FVirtualStatsEnum& Stat, const struct FScalingRulesEnum& ScalingRule, class AActor* Target, enum class EFloatRoundingMode RoundingMode);
	int32 GetScaledIntValue(class UObject* WorldContextObject, int32 InValue, const struct FScalingRulesEnum& ScalingRule, class AActor* Target, enum class EFloatRoundingMode RoundingMode);
	float GetScaledFloatValue(class UObject* WorldContextObject, float InValue, const struct FScalingRulesEnum& ScalingRule, class AActor* Target);
};

// 0x0 (0x30 - 0x30)
// Class Icarus.ValueScalingSubsystem
class UValueScalingSubsystem : public UWorldSubsystem
{
public:

	static class UClass* StaticClass();
	static class UValueScalingSubsystem* GetDefaultObj();

};

// 0x40 (0x70 - 0x30)
// Class Icarus.VersionSubsystem
class UVersionSubsystem : public UGameInstanceSubsystem
{
public:
	struct FIcarusGameVersion                    IcarusVersion;                                     // 0x30(0x30)(Protected, NativeAccessSpecifierProtected)
	struct FIcarusBackendVersion                 BackendVersion;                                    // 0x60(0xC)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_88A7[0x4];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UVersionSubsystem* GetDefaultObj();

	struct FIcarusGameVersion GetIcarusVersion();
	class FString GetFormattedVersionString(struct FIcarusGameVersion& Version, enum class EIcarusGameVersionFlags VersionMask);
	class FString GetFormattedVersion(enum class EIcarusGameVersionFlags VersionMask);
	struct FIcarusBackendVersion GetBackendVersion();
};

// 0x88 (0xB0 - 0x28)
// Class Icarus.VirtualStats
class UVirtualStats : public UObject
{
public:
	uint8                                        Pad_88A8[0x88];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UVirtualStats* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.VirtualStatFunctionLibrary
class UVirtualStatFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UVirtualStatFunctionLibrary* GetDefaultObj();

	bool IsVirtualStat(const struct FStatsEnum& Stat);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.VirtualStatsLibrary
class UVirtualStatsLibrary : public UStatsLibrary
{
public:

	static class UClass* StaticClass();
	static class UVirtualStatsLibrary* GetDefaultObj();

	struct FVirtualStatsEnum MakeVirtualStatsEnum(const struct FVirtualStatsEnum& Enum);
	bool IsVirtualStatLogging();
	bool Filter(int32 Index);
	void EnableVirtualStatsLogging(bool bEnable);
	void BreakVirtualStatsEnum(const struct FVirtualStatsEnum& Enum, class FName* Name, int32* Index);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.VocalisationSettingsLibrary
class UVocalisationSettingsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UVocalisationSettingsLibrary* GetDefaultObj();

	struct FVocalisationSettingsRowHandle StructToRowHandle(const struct FVocalisationSettingsEnum& EnumValue);
	class FName StructToName(const struct FVocalisationSettingsEnum& EnumValue);
	int32 StructToInt(const struct FVocalisationSettingsEnum& EnumValue);
	struct FVocalisationSettingsEnum RowHandleToStruct(const struct FVocalisationSettingsRowHandle& RowHandle);
	void RemoveRowFromVocalisationSettingsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FVocalisationSettingsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FVocalisationSettingsEnum& A, const struct FVocalisationSettingsEnum& B);
	struct FVocalisationSettingsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FVocalisationSettingsRowHandle MakeVocalisationSettingsFromIndex(int32 Index);
	struct FVocalisationSettingsEnum MakeVocalisationSettingsEnum(const struct FVocalisationSettingsEnum& Enum);
	struct FVocalisationSettingsRowHandle MakeVocalisationSettings(class FName RowName);
	struct FVocalisationSettingsRowHandle MakeLiteralVocalisationSettings(const struct FVocalisationSettingsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FVocalisationSettingsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetVocalisationSettingsStruct(const struct FVocalisationSettingsRowHandle& RowHandle, struct FVocalisationSetting* VocalisationSettings, enum class EValid* Paths);
	bool EqualEqual_FVocalisationSettingsRowHandleFVocalisationSettingsRowHandle(const struct FVocalisationSettingsRowHandle& RowHandleA, const struct FVocalisationSettingsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FVocalisationSettingsEnum& A, const struct FVocalisationSettingsEnum& B);
	struct FVocalisationSettingsRowHandle CastToVocalisationSettingsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakVocalisationSettingsEnum(const struct FVocalisationSettingsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToVocalisationSettingsTable(class FName Name, const struct FVocalisationSetting& Data, struct FVocalisationSettingsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.VocalisationSettingsTable
class UVocalisationSettingsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UVocalisationSettingsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.VocalisationsLibrary
class UVocalisationsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UVocalisationsLibrary* GetDefaultObj();

	struct FVocalisationsRowHandle StructToRowHandle(const struct FVocalisationsEnum& EnumValue);
	class FName StructToName(const struct FVocalisationsEnum& EnumValue);
	int32 StructToInt(const struct FVocalisationsEnum& EnumValue);
	struct FVocalisationsEnum RowHandleToStruct(const struct FVocalisationsRowHandle& RowHandle);
	void RemoveRowFromVocalisationsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FVocalisationsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FVocalisationsEnum& A, const struct FVocalisationsEnum& B);
	struct FVocalisationsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FVocalisationsRowHandle MakeVocalisationsFromIndex(int32 Index);
	struct FVocalisationsEnum MakeVocalisationsEnum(const struct FVocalisationsEnum& Enum);
	struct FVocalisationsRowHandle MakeVocalisations(class FName RowName);
	struct FVocalisationsRowHandle MakeLiteralVocalisations(const struct FVocalisationsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FVocalisationsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetVocalisationsStruct(const struct FVocalisationsRowHandle& RowHandle, struct FVocalisationData* Vocalisations, enum class EValid* Paths);
	bool EqualEqual_FVocalisationsRowHandleFVocalisationsRowHandle(const struct FVocalisationsRowHandle& RowHandleA, const struct FVocalisationsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FVocalisationsEnum& A, const struct FVocalisationsEnum& B);
	struct FVocalisationsRowHandle CastToVocalisationsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakVocalisationsEnum(const struct FVocalisationsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToVocalisationsTable(class FName Name, const struct FVocalisationData& Data, struct FVocalisationsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.VocalisationsTable
class UVocalisationsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UVocalisationsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.VoxelDistributionRegionLibrary
class UVoxelDistributionRegionLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UVoxelDistributionRegionLibrary* GetDefaultObj();

	struct FVoxelDistributionRegionRowHandle StructToRowHandle(const struct FVoxelDistributionRegionEnum& EnumValue);
	class FName StructToName(const struct FVoxelDistributionRegionEnum& EnumValue);
	int32 StructToInt(const struct FVoxelDistributionRegionEnum& EnumValue);
	struct FVoxelDistributionRegionEnum RowHandleToStruct(const struct FVoxelDistributionRegionRowHandle& RowHandle);
	void RemoveRowFromVoxelDistributionRegionTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FVoxelDistributionRegionEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FVoxelDistributionRegionEnum& A, const struct FVoxelDistributionRegionEnum& B);
	struct FVoxelDistributionRegionEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FVoxelDistributionRegionRowHandle MakeVoxelDistributionRegionFromIndex(int32 Index);
	struct FVoxelDistributionRegionEnum MakeVoxelDistributionRegionEnum(const struct FVoxelDistributionRegionEnum& Enum);
	struct FVoxelDistributionRegionRowHandle MakeVoxelDistributionRegion(class FName RowName);
	struct FVoxelDistributionRegionRowHandle MakeLiteralVoxelDistributionRegion(const struct FVoxelDistributionRegionRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FVoxelDistributionRegionEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetVoxelDistributionRegionStruct(const struct FVoxelDistributionRegionRowHandle& RowHandle, struct FVoxelDistributionRegion* VoxelDistributionRegion, enum class EValid* Paths);
	bool EqualEqual_FVoxelDistributionRegionRowHandleFVoxelDistributionRegionRowHandle(const struct FVoxelDistributionRegionRowHandle& RowHandleA, const struct FVoxelDistributionRegionRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FVoxelDistributionRegionEnum& A, const struct FVoxelDistributionRegionEnum& B);
	struct FVoxelDistributionRegionRowHandle CastToVoxelDistributionRegionRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakVoxelDistributionRegionEnum(const struct FVoxelDistributionRegionEnum& Enum, class FName* Name, int32* Index);
	void AddRowToVoxelDistributionRegionTable(class FName Name, const struct FVoxelDistributionRegion& Data, struct FVoxelDistributionRegionRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.VoxelDistributionRegionTable
class UVoxelDistributionRegionTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UVoxelDistributionRegionTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.VoxelMaterialMapLibrary
class UVoxelMaterialMapLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UVoxelMaterialMapLibrary* GetDefaultObj();

	struct FVoxelMaterialMapRowHandle StructToRowHandle(const struct FVoxelMaterialMapEnum& EnumValue);
	class FName StructToName(const struct FVoxelMaterialMapEnum& EnumValue);
	int32 StructToInt(const struct FVoxelMaterialMapEnum& EnumValue);
	struct FVoxelMaterialMapEnum RowHandleToStruct(const struct FVoxelMaterialMapRowHandle& RowHandle);
	void RemoveRowFromVoxelMaterialMapTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FVoxelMaterialMapEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FVoxelMaterialMapEnum& A, const struct FVoxelMaterialMapEnum& B);
	struct FVoxelMaterialMapEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FVoxelMaterialMapRowHandle MakeVoxelMaterialMapFromIndex(int32 Index);
	struct FVoxelMaterialMapEnum MakeVoxelMaterialMapEnum(const struct FVoxelMaterialMapEnum& Enum);
	struct FVoxelMaterialMapRowHandle MakeVoxelMaterialMap(class FName RowName);
	struct FVoxelMaterialMapRowHandle MakeLiteralVoxelMaterialMap(const struct FVoxelMaterialMapRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FVoxelMaterialMapEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetVoxelMaterialMapStruct(const struct FVoxelMaterialMapRowHandle& RowHandle, struct FVoxelMaterialMap* VoxelMaterialMap, enum class EValid* Paths);
	bool EqualEqual_FVoxelMaterialMapRowHandleFVoxelMaterialMapRowHandle(const struct FVoxelMaterialMapRowHandle& RowHandleA, const struct FVoxelMaterialMapRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FVoxelMaterialMapEnum& A, const struct FVoxelMaterialMapEnum& B);
	struct FVoxelMaterialMapRowHandle CastToVoxelMaterialMapRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakVoxelMaterialMapEnum(const struct FVoxelMaterialMapEnum& Enum, class FName* Name, int32* Index);
	void AddRowToVoxelMaterialMapTable(class FName Name, const struct FVoxelMaterialMap& Data, struct FVoxelMaterialMapRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.VoxelMaterialMapTable
class UVoxelMaterialMapTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UVoxelMaterialMapTable* GetDefaultObj();

};

// 0x50 (0x80 - 0x30)
// Class Icarus.VoxelMeshLibrarySubsystem
class UVoxelMeshLibrarySubsystem : public UWorldSubsystem
{
public:
	uint8                                        Pad_88D8[0x50];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UVoxelMeshLibrarySubsystem* GetDefaultObj();

};

// 0x38 (0x1E0 - 0x1A8)
// Class Icarus.VoxelRecorderComponent
class UVoxelRecorderComponent : public UActorStateRecorderComponent
{
public:
	struct FVoxelSaveData                        VoxelSaveData;                                     // 0x1A8(0x38)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UVoxelRecorderComponent* GetDefaultObj();

};

// 0x0 (0x1E0 - 0x1E0)
// Class Icarus.SpawnedVoxelRecorderComponent
class USpawnedVoxelRecorderComponent : public UVoxelRecorderComponent
{
public:

	static class UClass* StaticClass();
	static class USpawnedVoxelRecorderComponent* GetDefaultObj();

};

// 0x290 (0x550 - 0x2C0)
// Class Icarus.VoxelResource
class AVoxelResource : public AIcarusActor
{
public:
	bool                                         bSaveToDatabase;                                   // 0x2C0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bAllowReinitialisation;                            // 0x2C1(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_88DA[0x2E];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UProceduralMeshComponent*              GeneratedMeshComponent;                            // 0x2F0(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                       ReferenceMeshContainer;                            // 0x2F8(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                  NavmeshProxyComponent;                             // 0x300(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88DB[0x14];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVoxelDistributionRegionRowHandle     ResourcePool;                                      // 0x31C(0x18)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88DC[0x64];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVoxelSetupDataRowHandle              VoxelSetupRow;                                     // 0x398(0x18)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bUseMaterialFromRow;                               // 0x3B0(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88DD[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVoxelSetupDataRowHandle              NonDeterministicVoxelSetup;                        // 0x3B4(0x18)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88DE[0x8];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        VoxelSize;                                         // 0x3D4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        VoxelSmoothing;                                    // 0x3D8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        ExteriorNormalSmoothing;                           // 0x3DC(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        DebugInfoOutputMode;                               // 0x3E0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        VoxelLife;                                         // 0x3E4(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                        VoxelInstanceSeed;                                 // 0x3E8(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bUseVoxelCache;                                    // 0x3EC(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bUseComplexCache;                                  // 0x3ED(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88DF[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        AutoDestroyPercentage;                             // 0x3F0(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bWasMinedInstantly;                                // 0x3F4(0x1)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                         bCanBeMinedInstantly;                              // 0x3F5(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E0[0xA];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        ResourceVolume;                                    // 0x400(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                        TotalResourceCount;                                // 0x404(0x4)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E1[0x48];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	struct FVoxelState                           VoxelState;                                        // 0x450(0x18)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E2[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UMaterialInterface*                    MiningDecalMaterial;                               // 0x480(0x8)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                       MiningDecal;                                       // 0x488(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E3[0x98];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	bool                                         bUseVertexColourMasks;                             // 0x528(0x1)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E4[0x3];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        UVProjectionIslandDetectionRadius;                 // 0x52C(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_88E5[0x18];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UFLODActorComponent*                   FLODActorComponent;                                // 0x548(0x8)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class AVoxelResource* GetDefaultObj();

	void UpdateExperienceComponent(struct FItemTemplateRowHandle& ForResourceType);
	void SetVoxelMaterial(class UMaterialInterface* Material);
	void SetupResourceMaterials(TSoftObjectPtr<class UMaterialInterface>& Material);
	void SetNonDeterministicVoxelSetup(struct FVoxelSetupDataRowHandle& NewSetup);
	void SetDisableDeterministicGeneration(bool bShouldDisable);
	void ResourcesMined(float ResourceMinedCount, class AIcarusPlayerController* LastHitPlayerController);
	void ResetVoxelMaterial();
	void Reinitialise();
	void ReadOrGenerateVoxelCache();
	void OnVoxelCompleted();
	void OnRep_VoxelState();
	void OnRep_NonDeterministicVoxelSetup();
	void OnAsycMaterialLoadComplete();
	void OnActorDamaged(const struct FIcarusDamagePacket& DamagePacket);
	void Initialise();
	enum class EVoxelMinedState GetVoxelMinedState();
	bool GetVoxelFullyMined();
	int32 GetTotalResourceCount();
	float GetRemainingResources();
	TArray<struct FVoxelMinedSphere> GetMinedSpheres();
	void ChangeDebugCoordinate(const struct FIntVector& Coordinate);
	void AddMinedSpheres(TArray<struct FVoxelMinedSphere>& Spheres);
};

// 0x10 (0xC0 - 0xB0)
// Class Icarus.VoxelResourceDistribution
class UVoxelResourceDistribution : public UActorComponent
{
public:
	uint8                                        Pad_88E6[0xC];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	float                                        VoxelInitMaxTimeMS;                                // 0xBC(0x4)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UVoxelResourceDistribution* GetDefaultObj();

	void SetDistributionSeed(int32 Seed);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.VoxelSetupDataLibrary
class UVoxelSetupDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UVoxelSetupDataLibrary* GetDefaultObj();

	struct FVoxelSetupDataRowHandle StructToRowHandle(const struct FVoxelSetupDataEnum& EnumValue);
	class FName StructToName(const struct FVoxelSetupDataEnum& EnumValue);
	int32 StructToInt(const struct FVoxelSetupDataEnum& EnumValue);
	struct FVoxelSetupDataEnum RowHandleToStruct(const struct FVoxelSetupDataRowHandle& RowHandle);
	void RemoveRowFromVoxelSetupDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FVoxelSetupDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FVoxelSetupDataEnum& A, const struct FVoxelSetupDataEnum& B);
	struct FVoxelSetupDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FVoxelSetupDataRowHandle MakeVoxelSetupDataFromIndex(int32 Index);
	struct FVoxelSetupDataEnum MakeVoxelSetupDataEnum(const struct FVoxelSetupDataEnum& Enum);
	struct FVoxelSetupDataRowHandle MakeVoxelSetupData(class FName RowName);
	struct FVoxelSetupDataRowHandle MakeLiteralVoxelSetupData(const struct FVoxelSetupDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FVoxelSetupDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetVoxelSetupDataStruct(const struct FVoxelSetupDataRowHandle& RowHandle, struct FVoxelSetupData* VoxelSetupData, enum class EValid* Paths);
	bool EqualEqual_FVoxelSetupDataRowHandleFVoxelSetupDataRowHandle(const struct FVoxelSetupDataRowHandle& RowHandleA, const struct FVoxelSetupDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FVoxelSetupDataEnum& A, const struct FVoxelSetupDataEnum& B);
	struct FVoxelSetupDataRowHandle CastToVoxelSetupDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakVoxelSetupDataEnum(const struct FVoxelSetupDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToVoxelSetupDataTable(class FName Name, const struct FVoxelSetupData& Data, struct FVoxelSetupDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.VoxelSetupDataTable
class UVoxelSetupDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UVoxelSetupDataTable* GetDefaultObj();

};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.WaterComponent
class UWaterComponent : public UResourceNetworkComponent
{
public:

	static class UClass* StaticClass();
	static class UWaterComponent* GetDefaultObj();

	bool GetWaterData(struct FWaterData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WaterLibrary
class UWaterLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWaterLibrary* GetDefaultObj();

	struct FWaterRowHandle StructToRowHandle(const struct FWaterEnum& EnumValue);
	class FName StructToName(const struct FWaterEnum& EnumValue);
	int32 StructToInt(const struct FWaterEnum& EnumValue);
	struct FWaterEnum RowHandleToStruct(const struct FWaterRowHandle& RowHandle);
	void RemoveRowFromWaterTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWaterEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWaterEnum& A, const struct FWaterEnum& B);
	struct FWaterEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWaterRowHandle MakeWaterFromIndex(int32 Index);
	struct FWaterEnum MakeWaterEnum(const struct FWaterEnum& Enum);
	struct FWaterRowHandle MakeWater(class FName RowName);
	struct FWaterRowHandle MakeLiteralWater(const struct FWaterRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWaterEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWaterStruct(const struct FWaterRowHandle& RowHandle, struct FWaterData* Water, enum class EValid* Paths);
	bool EqualEqual_FWaterRowHandleFWaterRowHandle(const struct FWaterRowHandle& RowHandleA, const struct FWaterRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWaterEnum& A, const struct FWaterEnum& B);
	struct FWaterRowHandle CastToWaterRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWaterEnum(const struct FWaterEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWaterTable(class FName Name, const struct FWaterData& Data, struct FWaterRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WaterSetupLibrary
class UWaterSetupLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWaterSetupLibrary* GetDefaultObj();

	struct FWaterSetupRowHandle StructToRowHandle(const struct FWaterSetupEnum& EnumValue);
	class FName StructToName(const struct FWaterSetupEnum& EnumValue);
	int32 StructToInt(const struct FWaterSetupEnum& EnumValue);
	struct FWaterSetupEnum RowHandleToStruct(const struct FWaterSetupRowHandle& RowHandle);
	void RemoveRowFromWaterSetupTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWaterSetupEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWaterSetupEnum& A, const struct FWaterSetupEnum& B);
	struct FWaterSetupEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWaterSetupRowHandle MakeWaterSetupFromIndex(int32 Index);
	struct FWaterSetupEnum MakeWaterSetupEnum(const struct FWaterSetupEnum& Enum);
	struct FWaterSetupRowHandle MakeWaterSetup(class FName RowName);
	struct FWaterSetupRowHandle MakeLiteralWaterSetup(const struct FWaterSetupRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWaterSetupEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWaterSetupStruct(const struct FWaterSetupRowHandle& RowHandle, struct FWaterSetup* WaterSetup, enum class EValid* Paths);
	bool EqualEqual_FWaterSetupRowHandleFWaterSetupRowHandle(const struct FWaterSetupRowHandle& RowHandleA, const struct FWaterSetupRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWaterSetupEnum& A, const struct FWaterSetupEnum& B);
	struct FWaterSetupRowHandle CastToWaterSetupRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWaterSetupEnum(const struct FWaterSetupEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWaterSetupTable(class FName Name, const struct FWaterSetup& Data, struct FWaterSetupRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WaterSetupTable
class UWaterSetupTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWaterSetupTable* GetDefaultObj();

};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WaterTable
class UWaterTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWaterTable* GetDefaultObj();

};

// 0x10 (0x40 - 0x30)
// Class Icarus.WeaponSubsystem
class UWeaponSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnProjectileFiredNotify;                           // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UWeaponSubsystem* GetDefaultObj();

	void BroadcastProjectileFiredDelegate(class AIcarusPlayerCharacter* Player, class AIcarusItem* Projectile);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeatherActionsLibrary
class UWeatherActionsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeatherActionsLibrary* GetDefaultObj();

	struct FWeatherActionsRowHandle StructToRowHandle(const struct FWeatherActionsEnum& EnumValue);
	class FName StructToName(const struct FWeatherActionsEnum& EnumValue);
	int32 StructToInt(const struct FWeatherActionsEnum& EnumValue);
	struct FWeatherActionsEnum RowHandleToStruct(const struct FWeatherActionsRowHandle& RowHandle);
	void RemoveRowFromWeatherActionsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeatherActionsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeatherActionsEnum& A, const struct FWeatherActionsEnum& B);
	struct FWeatherActionsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeatherActionsRowHandle MakeWeatherActionsFromIndex(int32 Index);
	struct FWeatherActionsEnum MakeWeatherActionsEnum(const struct FWeatherActionsEnum& Enum);
	struct FWeatherActionsRowHandle MakeWeatherActions(class FName RowName);
	struct FWeatherActionsRowHandle MakeLiteralWeatherActions(const struct FWeatherActionsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeatherActionsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeatherActionsStruct(const struct FWeatherActionsRowHandle& RowHandle, struct FIcarusWeatherActionData* WeatherActions, enum class EValid* Paths);
	bool EqualEqual_FWeatherActionsRowHandleFWeatherActionsRowHandle(const struct FWeatherActionsRowHandle& RowHandleA, const struct FWeatherActionsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeatherActionsEnum& A, const struct FWeatherActionsEnum& B);
	struct FWeatherActionsRowHandle CastToWeatherActionsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeatherActionsEnum(const struct FWeatherActionsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeatherActionsTable(class FName Name, const struct FIcarusWeatherActionData& Data, struct FWeatherActionsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeatherActionsTable
class UWeatherActionsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeatherActionsTable* GetDefaultObj();

};

// 0x8 (0x200 - 0x1F8)
// Class Icarus.WeatherAudioComponent
class UWeatherAudioComponent : public USceneComponent
{
public:
	uint8                                        Pad_8914[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UWeatherAudioComponent* GetDefaultObj();

	void UpdateWeatherAudio(bool bWeatherActive);
};

// 0x60 (0x90 - 0x30)
// Class Icarus.WeatherAudioSubsystem
class UWeatherAudioSubsystem : public UWorldSubsystem
{
public:
	TMap<struct FBiomesRowHandle, struct FWeatherAudioSubsystemBiomeRecord> BiomeRecords;                                      // 0x30(0x50)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AWeatherController*                    WeatherController;                                 // 0x80(0x8)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_8915[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UWeatherAudioSubsystem* GetDefaultObj();

	void SubscribeToWeatherUpdates(class UWeatherAudioComponent* WeatherAudioComponent, const struct FBiomesRowHandle& Biome);
	void OnWeatherUpdated();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeatherBiomeGroupsLibrary
class UWeatherBiomeGroupsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeatherBiomeGroupsLibrary* GetDefaultObj();

	struct FWeatherBiomeGroupsRowHandle StructToRowHandle(const struct FWeatherBiomeGroupsEnum& EnumValue);
	class FName StructToName(const struct FWeatherBiomeGroupsEnum& EnumValue);
	int32 StructToInt(const struct FWeatherBiomeGroupsEnum& EnumValue);
	struct FWeatherBiomeGroupsEnum RowHandleToStruct(const struct FWeatherBiomeGroupsRowHandle& RowHandle);
	void RemoveRowFromWeatherBiomeGroupsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeatherBiomeGroupsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeatherBiomeGroupsEnum& A, const struct FWeatherBiomeGroupsEnum& B);
	struct FWeatherBiomeGroupsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeatherBiomeGroupsRowHandle MakeWeatherBiomeGroupsFromIndex(int32 Index);
	struct FWeatherBiomeGroupsEnum MakeWeatherBiomeGroupsEnum(const struct FWeatherBiomeGroupsEnum& Enum);
	struct FWeatherBiomeGroupsRowHandle MakeWeatherBiomeGroups(class FName RowName);
	struct FWeatherBiomeGroupsRowHandle MakeLiteralWeatherBiomeGroups(const struct FWeatherBiomeGroupsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeatherBiomeGroupsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeatherBiomeGroupsStruct(const struct FWeatherBiomeGroupsRowHandle& RowHandle, struct FIcarusWeatherBiomeGroup* WeatherBiomeGroups, enum class EValid* Paths);
	bool EqualEqual_FWeatherBiomeGroupsRowHandleFWeatherBiomeGroupsRowHandle(const struct FWeatherBiomeGroupsRowHandle& RowHandleA, const struct FWeatherBiomeGroupsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeatherBiomeGroupsEnum& A, const struct FWeatherBiomeGroupsEnum& B);
	struct FWeatherBiomeGroupsRowHandle CastToWeatherBiomeGroupsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeatherBiomeGroupsEnum(const struct FWeatherBiomeGroupsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeatherBiomeGroupsTable(class FName Name, const struct FIcarusWeatherBiomeGroup& Data, struct FWeatherBiomeGroupsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeatherBiomeGroupsTable
class UWeatherBiomeGroupsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeatherBiomeGroupsTable* GetDefaultObj();

};

// 0x118 (0x338 - 0x220)
// Class Icarus.WeatherController
class AWeatherController : public AInfo
{
public:
	FMulticastSparseDelegateProperty_            WeatherUpdated;                                    // 0x220(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8928[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastInlineDelegateProperty_            OnWeatherEventStarted;                             // 0x228(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnWeatherEventCompleted;                           // 0x238(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                        UpdateCycle;                                       // 0x248(0x4)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                        CurrentUpdateTime;                                 // 0x24C(0x4)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FActorCollection>   BiomeToActor;                                      // 0x250(0x50)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FWeatherBiomeGroupsEnum, struct FWeatherBiomeGroupForecast> BiomeGroupForecast;                                // 0x2A0(0x50)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveWeatherInfo>            CurrentWeather;                                    // 0x2F0(0x10)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveWeatherInfo>            WeatherToRemove;                                   // 0x300(0x10)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWeatherControllerRecorderComponent*   Recorder;                                          // 0x310(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIcarusStatContainer*                  StatContainer;                                     // 0x318(0x8)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_8929[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AWeatherController* GetDefaultObj();

	void WeatherEventCompleted(class UIcarusWeatherAction* ActionComplete);
	void UpdateWeather(float Delta);
	bool UnregisterActor(class AIcarusActor* Actor, struct FBiomesRowHandle& Biome);
	void SetWorldStats();
	bool RegisterActor(class AIcarusActor* Actor, struct FBiomesRowHandle& Biome);
	void PostProspectInfoFetched();
	void OnRep_CurrentWeather();
	void NotifyStormWarning(int32 TimeUntilStorm, struct FWeatherEventsRowHandle& StormRow, struct FBiomesEnum& Biome);
	void LowHertzTick();
	bool HasActiveStorm(struct FBiomesRowHandle& BiomeRow);
	struct FWeatherEventsRowHandle GetWeatherEventForBiome(struct FBiomesRowHandle& Biome, bool* bHasWeatherEvent);
	struct FActiveWeatherInfo GetActiveWeatherInfoForBiome(const struct FBiomesRowHandle& Biome, enum class EValid* OutValidity);
	void ForceStopAllWeatherEvents();
	void CheckForStormStart(int32 Now);
	bool AddWeatherEvent(struct FBiomesRowHandle& Biome, struct FWeatherEventsRowHandle& Event, int32 StartTime);
};

// 0x10 (0xE8 - 0xD8)
// Class Icarus.WeatherControllerRecorderComponent
class UWeatherControllerRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	TArray<struct FRecordedForecastWeatherEvent> LatestWeatherEvents;                               // 0xD8(0x10)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UWeatherControllerRecorderComponent* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeatherEventsLibrary
class UWeatherEventsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeatherEventsLibrary* GetDefaultObj();

	struct FWeatherEventsRowHandle StructToRowHandle(const struct FWeatherEventsEnum& EnumValue);
	class FName StructToName(const struct FWeatherEventsEnum& EnumValue);
	int32 StructToInt(const struct FWeatherEventsEnum& EnumValue);
	struct FWeatherEventsEnum RowHandleToStruct(const struct FWeatherEventsRowHandle& RowHandle);
	void RemoveRowFromWeatherEventsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeatherEventsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeatherEventsEnum& A, const struct FWeatherEventsEnum& B);
	struct FWeatherEventsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeatherEventsRowHandle MakeWeatherEventsFromIndex(int32 Index);
	struct FWeatherEventsEnum MakeWeatherEventsEnum(const struct FWeatherEventsEnum& Enum);
	struct FWeatherEventsRowHandle MakeWeatherEvents(class FName RowName);
	struct FWeatherEventsRowHandle MakeLiteralWeatherEvents(const struct FWeatherEventsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeatherEventsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeatherEventsStruct(const struct FWeatherEventsRowHandle& RowHandle, struct FIcarusWeatherEvent* WeatherEvents, enum class EValid* Paths);
	bool EqualEqual_FWeatherEventsRowHandleFWeatherEventsRowHandle(const struct FWeatherEventsRowHandle& RowHandleA, const struct FWeatherEventsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeatherEventsEnum& A, const struct FWeatherEventsEnum& B);
	struct FWeatherEventsRowHandle CastToWeatherEventsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeatherEventsEnum(const struct FWeatherEventsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeatherEventsTable(class FName Name, const struct FIcarusWeatherEvent& Data, struct FWeatherEventsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeatherEventsTable
class UWeatherEventsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeatherEventsTable* GetDefaultObj();

};

// 0x18 (0xC8 - 0xB0)
// Class Icarus.WeatherForecastBarComponent
class UWeatherForecastBarComponent : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_            ForecastItemsUpdated;                              // 0xB0(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            ProspectForecastUpdated;                           // 0xB1(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8937[0x6];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	TArray<struct FWeatherForecastItem>          ForecastItems;                                     // 0xB8(0x10)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UWeatherForecastBarComponent* GetDefaultObj();

	void RemovePastItems(int32 Now);
	void OnRep_ForecastItems();
	void Multicast_ProspectForecastUpdated(struct FProspectForecastRowHandle& NewForecast);
	void ClearItems();
	void AddItems(int32 Begin, TArray<struct FWeatherBlock>& WeatherBlocks, int32 Now);
};

// 0x80 (0x130 - 0xB0)
// Class Icarus.WeatherForecasting
class UWeatherForecasting : public UActorComponent
{
public:
	uint8                                        Pad_8938[0x80];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UWeatherForecasting* GetDefaultObj();

	void Deinitialize();
};

// 0xF0 (0x310 - 0x220)
// Class Icarus.WeatherForecastManager
class AWeatherForecastManager : public AInfo
{
public:
	FMulticastInlineDelegateProperty_            OnForecastRestoredFromDatabase;                    // 0x220(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWeatherForecastRecorderComponent*     ForecastRecorder;                                  // 0x230(0x8)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_893A[0x10];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	class UWeatherForecasting*                   WeatherForecasting;                                // 0x248(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeatherForecastBarComponent*          WeatherForecastBar;                                // 0x250(0x8)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FProspectForecastRowHandle            ForecastRow;                                       // 0x258(0x18)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FProspectForecastRowHandle            InitialForecastRow;                                // 0x270(0x18)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                        Pad_893B[0x88];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AWeatherForecastManager* GetDefaultObj();

	void UpdateForecast(struct FProspectForecastRowHandle& ForecastRowHandle, TMap<struct FWeatherBiomeGroupsEnum, struct FWeatherBiomeGroupForecast>& CurrentBiomeGroupForecast);
	bool ShouldInitProspectSeed();
	void SetInitialForecast(struct FProspectForecastRowHandle& InitialForecastRowHandle, struct FProspectForecastRowHandle& ForecastRowHandle, int32 Now);
	bool RestoreForecastFromDatabase();
	void QueueRestoreForecastFromDatabase(struct FRecordedCurrentWeatherBlock& NowBlock);
	void PostProspectInfoFetched();
	bool IsReady();
	void Initialize(int32 GameStateSeed, int32 InNumDays);
	class UWeatherForecastBarComponent* GetWeatherBar();
	void GetCurrentForecastInfo(struct FRecordedCurrentWeatherBlock* NowBlockOut);
	void EnqueueForecast(TMap<struct FWeatherBiomeGroupsEnum, struct FWeatherBiomeGroupForecast>& OutBiomeGroupForecast);
	bool DoTick(int32 Now);
};

// 0x30 (0x108 - 0xD8)
// Class Icarus.WeatherForecastRecorderComponent
class UWeatherForecastRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	struct FRecordedCurrentWeatherBlock          NowBlock;                                          // 0xD8(0x30)(SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UWeatherForecastRecorderComponent* GetDefaultObj();

};

// 0xB8 (0x168 - 0xB0)
// Class Icarus.WeatherManagerComponent
class UWeatherManagerComponent : public UActorComponent
{
public:
	TArray<struct FWeatherGameplayData>          GameplayWeatherArray;                              // 0xB0(0x10)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                        Pad_8966[0xA0];                                    // Fixing Size After Last Property  [ Dumper-7 ]
	FMulticastSparseDelegateProperty_            WeatherGameplayUpdated;                            // 0x160(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_            WeatherVisualUpdated;                              // 0x161(0x1)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_8967[0x6];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UWeatherManagerComponent* GetDefaultObj();

	void SetWindStrength(struct FBiomesEnum& Biome, float Amount);
	void SetWindSpeed(struct FBiomesEnum& Biome, float Amount);
	void SetWindGust(struct FBiomesEnum& Biome, float WindGust);
	void SetWindForce(struct FBiomesEnum& Biome, float Amount);
	void SetWindDirection(struct FBiomesEnum& Biome, const struct FVector& Direction);
	void SetWeatherWarningMessage(struct FBiomesEnum& Biome, class FText Message);
	void SetVisualWeather(struct FBiomesEnum& Biome, const struct FWeatherVisualData& VisualData);
	void SetThunderAmount(struct FBiomesEnum& Biome, float Amount);
	void SetTemperatureModifier(struct FBiomesEnum& Biome, int32 Amount);
	void SetSnowStormAmount(struct FBiomesEnum& Biome, float Amount);
	void SetSnowAmount(struct FBiomesEnum& Biome, float Amount);
	void SetSmoke(struct FBiomesEnum& Biome, float Amount);
	void SetSandAmount(struct FBiomesEnum& Biome, float Amount);
	void SetRainAmount(struct FBiomesEnum& Biome, float Amount);
	void SetHail(struct FBiomesEnum& Biome, float Amount);
	void SetGameplayWeather(struct FBiomesEnum& Biome, const struct FWeatherGameplayData& GameplayData);
	void SetFogExtinction(struct FBiomesEnum& Biome, float Amount);
	void SetFogDensity(struct FBiomesEnum& Biome, float Amount);
	void SetEmbers(struct FBiomesEnum& Biome, float Amount);
	void SetDebris(struct FBiomesEnum& Biome, float Amount);
	void SetCloudyAmount(struct FBiomesEnum& Biome, float Amount);
	void SetAsh(struct FBiomesEnum& Biome, float Amount);
	void SetAcidRain(struct FBiomesEnum& Biome, float Amount);
	void OnRep_GameplayWeatherArray();
	float GetWindStrength(struct FBiomesEnum& Biome);
	float GetWindSpeed(struct FBiomesEnum& Biome);
	float GetWindGust(struct FBiomesEnum& Biome);
	float GetWindForce(struct FBiomesEnum& Biome);
	struct FVector GetWindDirection(struct FBiomesEnum& Biome);
	class FText GetWeatherWarningMessage(struct FBiomesEnum& Biome);
	struct FWeatherVisualData GetVisualWeather(struct FBiomesEnum& Biome);
	float GetThunderAmount(struct FBiomesEnum& Biome);
	int32 GetTemperatureModifier(struct FBiomesEnum& Biome);
	float GetSnowStormAmount(struct FBiomesEnum& Biome);
	float GetSnowAmount(struct FBiomesEnum& Biome);
	float GetSmoke(struct FBiomesEnum& Biome);
	float GetSandAmount(struct FBiomesEnum& Biome);
	float GetRainAmount(struct FBiomesEnum& Biome);
	float GetHail(struct FBiomesEnum& Biome);
	float GetFogExtinction(struct FBiomesEnum& Biome);
	float GetFogDensity(struct FBiomesEnum& Biome);
	float GetEmbers(struct FBiomesEnum& Biome);
	float GetDebris(struct FBiomesEnum& Biome);
	float GetCloudyAmount(struct FBiomesEnum& Biome);
	float GetAsh(struct FBiomesEnum& Biome);
	float GetAcidRain(struct FBiomesEnum& Biome);
	struct FWeatherGameplayData BP_GetGameplayWeather(struct FBiomesEnum& Biome);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeatherPoolsLibrary
class UWeatherPoolsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeatherPoolsLibrary* GetDefaultObj();

	struct FWeatherPoolsRowHandle StructToRowHandle(const struct FWeatherPoolsEnum& EnumValue);
	class FName StructToName(const struct FWeatherPoolsEnum& EnumValue);
	int32 StructToInt(const struct FWeatherPoolsEnum& EnumValue);
	struct FWeatherPoolsEnum RowHandleToStruct(const struct FWeatherPoolsRowHandle& RowHandle);
	void RemoveRowFromWeatherPoolsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeatherPoolsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeatherPoolsEnum& A, const struct FWeatherPoolsEnum& B);
	struct FWeatherPoolsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeatherPoolsRowHandle MakeWeatherPoolsFromIndex(int32 Index);
	struct FWeatherPoolsEnum MakeWeatherPoolsEnum(const struct FWeatherPoolsEnum& Enum);
	struct FWeatherPoolsRowHandle MakeWeatherPools(class FName RowName);
	struct FWeatherPoolsRowHandle MakeLiteralWeatherPools(const struct FWeatherPoolsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeatherPoolsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeatherPoolsStruct(const struct FWeatherPoolsRowHandle& RowHandle, struct FIcarusWeatherPoolData* WeatherPools, enum class EValid* Paths);
	bool EqualEqual_FWeatherPoolsRowHandleFWeatherPoolsRowHandle(const struct FWeatherPoolsRowHandle& RowHandleA, const struct FWeatherPoolsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeatherPoolsEnum& A, const struct FWeatherPoolsEnum& B);
	struct FWeatherPoolsRowHandle CastToWeatherPoolsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeatherPoolsEnum(const struct FWeatherPoolsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeatherPoolsTable(class FName Name, const struct FIcarusWeatherPoolData& Data, struct FWeatherPoolsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeatherPoolsTable
class UWeatherPoolsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeatherPoolsTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeatherTierIconLibrary
class UWeatherTierIconLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeatherTierIconLibrary* GetDefaultObj();

	struct FWeatherTierIconRowHandle StructToRowHandle(const struct FWeatherTierIconEnum& EnumValue);
	class FName StructToName(const struct FWeatherTierIconEnum& EnumValue);
	int32 StructToInt(const struct FWeatherTierIconEnum& EnumValue);
	struct FWeatherTierIconEnum RowHandleToStruct(const struct FWeatherTierIconRowHandle& RowHandle);
	void RemoveRowFromWeatherTierIconTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeatherTierIconEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeatherTierIconEnum& A, const struct FWeatherTierIconEnum& B);
	struct FWeatherTierIconEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeatherTierIconRowHandle MakeWeatherTierIconFromIndex(int32 Index);
	struct FWeatherTierIconEnum MakeWeatherTierIconEnum(const struct FWeatherTierIconEnum& Enum);
	struct FWeatherTierIconRowHandle MakeWeatherTierIcon(class FName RowName);
	struct FWeatherTierIconRowHandle MakeLiteralWeatherTierIcon(const struct FWeatherTierIconRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeatherTierIconEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeatherTierIconStruct(const struct FWeatherTierIconRowHandle& RowHandle, struct FWeatherTierIcon* WeatherTierIcon, enum class EValid* Paths);
	bool EqualEqual_FWeatherTierIconRowHandleFWeatherTierIconRowHandle(const struct FWeatherTierIconRowHandle& RowHandleA, const struct FWeatherTierIconRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeatherTierIconEnum& A, const struct FWeatherTierIconEnum& B);
	struct FWeatherTierIconRowHandle CastToWeatherTierIconRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeatherTierIconEnum(const struct FWeatherTierIconEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeatherTierIconTable(class FName Name, const struct FWeatherTierIcon& Data, struct FWeatherTierIconRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeatherTierIconTable
class UWeatherTierIconTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeatherTierIconTable* GetDefaultObj();

};

// 0x20 (0xF0 - 0xD0)
// Class Icarus.WeightComponent
class UWeightComponent : public UTraitComponent
{
public:
	TArray<class UShapeComponent*>               WeightSpreadingShapes;                             // 0xD0(0x10)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                        AboveActors;                                       // 0xE0(0x10)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UWeightComponent* GetDefaultObj();

	void Init();
	bool GetWeightData(struct FWeightData* OutData);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeightedListFunctionLibrary
class UWeightedListFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeightedListFunctionLibrary* GetDefaultObj();

	void Roll(int32 UID, float NewAccumulated);
	bool RemoveList(int32 UID);
	struct FRandomStream InitStream();
	TMap<int32, struct FStoredElement> InitListMap();
	struct FWeightedListElement GetSelectedElement(int32 UID);
	float GetRoll(int32 UID);
	int32 CreateNewList(int32& Seed);
	bool ClearList(int32 UID);
	bool AddElement(int32 UID, const struct FWeightedListElement& NewElement);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WeightLibrary
class UWeightLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWeightLibrary* GetDefaultObj();

	struct FWeightRowHandle StructToRowHandle(const struct FWeightEnum& EnumValue);
	class FName StructToName(const struct FWeightEnum& EnumValue);
	int32 StructToInt(const struct FWeightEnum& EnumValue);
	struct FWeightEnum RowHandleToStruct(const struct FWeightRowHandle& RowHandle);
	void RemoveRowFromWeightTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWeightEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWeightEnum& A, const struct FWeightEnum& B);
	struct FWeightEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWeightRowHandle MakeWeightFromIndex(int32 Index);
	struct FWeightEnum MakeWeightEnum(const struct FWeightEnum& Enum);
	struct FWeightRowHandle MakeWeight(class FName RowName);
	struct FWeightRowHandle MakeLiteralWeight(const struct FWeightRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWeightEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWeightStruct(const struct FWeightRowHandle& RowHandle, struct FWeightData* Weight, enum class EValid* Paths);
	bool EqualEqual_FWeightRowHandleFWeightRowHandle(const struct FWeightRowHandle& RowHandleA, const struct FWeightRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWeightEnum& A, const struct FWeightEnum& B);
	struct FWeightRowHandle CastToWeightRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWeightEnum(const struct FWeightEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWeightTable(class FName Name, const struct FWeightData& Data, struct FWeightRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WeightTable
class UWeightTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWeightTable* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.WorkshopItemsLibrary
class UWorkshopItemsLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWorkshopItemsLibrary* GetDefaultObj();

	struct FWorkshopItemsRowHandle StructToRowHandle(const struct FWorkshopItemsEnum& EnumValue);
	class FName StructToName(const struct FWorkshopItemsEnum& EnumValue);
	int32 StructToInt(const struct FWorkshopItemsEnum& EnumValue);
	struct FWorkshopItemsEnum RowHandleToStruct(const struct FWorkshopItemsRowHandle& RowHandle);
	void RemoveRowFromWorkshopItemsTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWorkshopItemsEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWorkshopItemsEnum& A, const struct FWorkshopItemsEnum& B);
	struct FWorkshopItemsEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWorkshopItemsRowHandle MakeWorkshopItemsFromIndex(int32 Index);
	struct FWorkshopItemsEnum MakeWorkshopItemsEnum(const struct FWorkshopItemsEnum& Enum);
	struct FWorkshopItemsRowHandle MakeWorkshopItems(class FName RowName);
	struct FWorkshopItemsRowHandle MakeLiteralWorkshopItems(const struct FWorkshopItemsRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWorkshopItemsEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWorkshopItemsStruct(const struct FWorkshopItemsRowHandle& RowHandle, struct FWorkshopItem* WorkshopItems, enum class EValid* Paths);
	bool EqualEqual_FWorkshopItemsRowHandleFWorkshopItemsRowHandle(const struct FWorkshopItemsRowHandle& RowHandleA, const struct FWorkshopItemsRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWorkshopItemsEnum& A, const struct FWorkshopItemsEnum& B);
	struct FWorkshopItemsRowHandle CastToWorkshopItemsRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWorkshopItemsEnum(const struct FWorkshopItemsEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWorkshopItemsTable(class FName Name, const struct FWorkshopItem& Data, struct FWorkshopItemsRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WorkshopItemsTable
class UWorkshopItemsTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWorkshopItemsTable* GetDefaultObj();

};

// 0x0 (0xF8 - 0xF8)
// Class Icarus.WorkshopTalentControllerComponent
class UWorkshopTalentControllerComponent : public UTalentControllerComponent
{
public:

	static class UClass* StaticClass();
	static class UWorkshopTalentControllerComponent* GetDefaultObj();

};

// 0x0 (0xE8 - 0xE8)
// Class Icarus.WorkshopTalentModel
class UWorkshopTalentModel : public UTalentModelInterface
{
public:

	static class UClass* StaticClass();
	static class UWorkshopTalentModel* GetDefaultObj();

};

// 0x0 (0xB0 - 0xB0)
// Class Icarus.WorldBossBehaviour
class UWorldBossBehaviour : public UActorComponent
{
public:

	static class UClass* StaticClass();
	static class UWorldBossBehaviour* GetDefaultObj();

	void OnAIBecomeRelevant();
	void OnAIBecomeIrrelevant();
	class AActor* GetSpawnedBossActor();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WorldBossesLibrary
class UWorldBossesLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWorldBossesLibrary* GetDefaultObj();

	struct FWorldBossesRowHandle StructToRowHandle(const struct FWorldBossesEnum& EnumValue);
	class FName StructToName(const struct FWorldBossesEnum& EnumValue);
	int32 StructToInt(const struct FWorldBossesEnum& EnumValue);
	struct FWorldBossesEnum RowHandleToStruct(const struct FWorldBossesRowHandle& RowHandle);
	void RemoveRowFromWorldBossesTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWorldBossesEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWorldBossesEnum& A, const struct FWorldBossesEnum& B);
	struct FWorldBossesEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWorldBossesRowHandle MakeWorldBossesFromIndex(int32 Index);
	struct FWorldBossesEnum MakeWorldBossesEnum(const struct FWorldBossesEnum& Enum);
	struct FWorldBossesRowHandle MakeWorldBosses(class FName RowName);
	struct FWorldBossesRowHandle MakeLiteralWorldBosses(const struct FWorldBossesRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWorldBossesEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWorldBossesStruct(const struct FWorldBossesRowHandle& RowHandle, struct FWorldBossData* WorldBosses, enum class EValid* Paths);
	bool EqualEqual_FWorldBossesRowHandleFWorldBossesRowHandle(const struct FWorldBossesRowHandle& RowHandleA, const struct FWorldBossesRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWorldBossesEnum& A, const struct FWorldBossesEnum& B);
	struct FWorldBossesRowHandle CastToWorldBossesRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWorldBossesEnum(const struct FWorldBossesEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWorldBossesTable(class FName Name, const struct FWorldBossData& Data, struct FWorldBossesRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WorldBossesTable
class UWorldBossesTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWorldBossesTable* GetDefaultObj();

};

// 0x40 (0x300 - 0x2C0)
// Class Icarus.WorldBossManager
class AWorldBossManager : public AIcarusActor
{
public:
	TArray<struct FSpawnedWorldBossData>         SpawnedBossConfig;                                 // 0x2C0(0x10)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_            WorldBossKilled;                                   // 0x2D0(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AWorldBossSpawner*>             WorldBossSpawners;                                 // 0x2E0(0x10)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                        Pad_89AB[0x10];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AWorldBossManager* GetDefaultObj();

	void TryRespawnWorldBosses();
	bool SpawnWorldBossOfType(struct FWorldBossesRowHandle& WorldBoss);
	void SpawnRelevantObjectsForBoss(struct FSpawnedWorldBossData& BossConfig);
	void SpawnAllBosses();
	void SetupWorldBossManagerWithData(struct FProspectListRowHandle& Prospect);
	int32 SetupWorldBoss(struct FWorldBossData& BossData, struct FWorldBossesRowHandle& Handle);
	void SetupRespawnTimer();
	void SetupBossManager();
	void SetSpawnedBossData(const TArray<struct FSpawnedWorldBossData>& InData);
	bool RespawnWorldBoss(int32 BossID);
	void ResetWorldBossesToOriginalProspectState();
	void OnWorldBossSpawnerWantsCleanup(class AWorldBossSpawner* Spawner);
	void OnSpawnerTransformUpdated(class AWorldBossSpawner* Spawner);
	void OnSpawnedBossKilled(class AWorldBossSpawner* Spawner);
	TArray<struct FSpawnedWorldBossData> GetSpawnedBossData();
	bool GetRandomSpawnTransform(struct FWorldBossData& BossData, struct FTransform* SpawnTransform);
	void GenerateNewBossesToSpawn(struct FProspectListRowHandle& OptionalProspect);
	bool DoesCurrentProspectSupportRespawning();
	void DestroyExistingWorldBoss(class AWorldBossSpawner* WorldBoss, bool bOnlyDestroyDeadBosses, bool bIgnoreAliveRelevantBosses);
	void CleanupExistingWorldBosses();
};

// 0x20 (0xF8 - 0xD8)
// Class Icarus.WorldBossManagerRecorderComponent
class UWorldBossManagerRecorderComponent : public UIcarusStateRecorderComponent
{
public:
	TArray<struct FSpawnedWorldBossData>         RecordedWorldBossData;                             // 0xD8(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                          RecordedWorldBossTableNames;                       // 0xE8(0x10)(Edit, ZeroConstructor, EditConst, SaveGame, Protected, NativeAccessSpecifierProtected)

	static class UClass* StaticClass();
	static class UWorldBossManagerRecorderComponent* GetDefaultObj();

};

// 0x98 (0x358 - 0x2C0)
// Class Icarus.WorldBossSpawner
class AWorldBossSpawner : public AIcarusActor
{
public:
	struct FWorldBossesRowHandle                 WorldBoss;                                         // 0x2C0(0x18)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnerBecomeRelevant;                             // 0x2D8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnerBecomeIrrelevant;                           // 0x2E8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnedBossKilled;                                 // 0x2F8(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnedBossWantsCleanup;                           // 0x308(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            SpawnerWorldTransformUpdated;                      // 0x318(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                         bIsRelevant;                                       // 0x328(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bHasBossBeenKilled;                                // 0x329(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_89AD[0x2];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	int32                                        BossID;                                            // 0x32C(0x4)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIcarusMapIconComponent*               MapIconComponent;                                  // 0x330(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldBossBehaviour*                   Behaviour;                                         // 0x338(0x8)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                         bKillBossAfterSpawn;                               // 0x340(0x1)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                        Pad_89AE[0x7];                                     // Fixing Size After Last Property  [ Dumper-7 ]
	class AActor*                                SpawnedBossActor;                                  // 0x348(0x8)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                        Pad_89AF[0x8];                                     // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class AWorldBossSpawner* GetDefaultObj();

	void UpdateSpawnerTransform(const struct FTransform& NewTransform);
	class AActor* SpawnBoss();
	void SetAIRelevant(bool bNewRelevancy);
	void OnWorldBossDataUpdated();
	void OnRep_WorldBoss();
	void OnBossKilled(class UActorState* BossActorState);
	void InitialiseSpawner(struct FWorldBossesRowHandle& InWorldBoss, int32 ID, bool bIsBossDead);
	class AActor* GetSpawnedBossActor();
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WorldDataLibrary
class UWorldDataLibrary : public URowLibrary
{
public:

	static class UClass* StaticClass();
	static class UWorldDataLibrary* GetDefaultObj();

	struct FWorldDataRowHandle StructToRowHandle(const struct FWorldDataEnum& EnumValue);
	class FName StructToName(const struct FWorldDataEnum& EnumValue);
	int32 StructToInt(const struct FWorldDataEnum& EnumValue);
	struct FWorldDataEnum RowHandleToStruct(const struct FWorldDataRowHandle& RowHandle);
	void RemoveRowFromWorldDataTable(class FName Name);
	void RefreshConstants();
	int32 NumRows();
	bool NotEqual_EnumName(const struct FWorldDataEnum& A, class FName B);
	bool NotEqual_EnumEnum(const struct FWorldDataEnum& A, const struct FWorldDataEnum& B);
	struct FWorldDataEnum NameToStruct(class FName NameValue);
	int32 NameToInt(class FName NameValue);
	struct FWorldDataRowHandle MakeWorldDataFromIndex(int32 Index);
	struct FWorldDataEnum MakeWorldDataEnum(const struct FWorldDataEnum& Enum);
	struct FWorldDataRowHandle MakeWorldData(class FName RowName);
	struct FWorldDataRowHandle MakeLiteralWorldData(const struct FWorldDataRowHandle& RowHandle);
	bool IsValidName(class FName NameValue);
	struct FWorldDataEnum IntToStruct(int32 IntValue);
	class FName IntToName(int32 IntValue);
	void GetWorldDataStruct(const struct FWorldDataRowHandle& RowHandle, struct FWorldData* WorldData, enum class EValid* Paths);
	bool EqualEqual_FWorldDataRowHandleFWorldDataRowHandle(const struct FWorldDataRowHandle& RowHandleA, const struct FWorldDataRowHandle& RowHandleB);
	bool EqualEqual_EnumEnum(const struct FWorldDataEnum& A, const struct FWorldDataEnum& B);
	struct FWorldDataRowHandle CastToWorldDataRowHandle(const struct FRowHandle& RowHandle, enum class EValid* Paths);
	void BreakWorldDataEnum(const struct FWorldDataEnum& Enum, class FName* Name, int32* Index);
	void AddRowToWorldDataTable(class FName Name, const struct FWorldData& Data, struct FWorldDataRowHandle* NewRow, bool bOverrideExistingRow);
};

// 0x0 (0xB8 - 0xB8)
// Class Icarus.WorldDataTable
class UWorldDataTable : public UIcarusDataTable
{
public:

	static class UClass* StaticClass();
	static class UWorldDataTable* GetDefaultObj();

};

// 0x20 (0x50 - 0x30)
// Class Icarus.WorldObserverSubsystem
class UWorldObserverSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            OnTreeChopped;                                     // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_            OnAnimalKilled;                                    // 0x40(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

	static class UClass* StaticClass();
	static class UWorldObserverSubsystem* GetDefaultObj();

};

// 0x0 (0x28 - 0x28)
// Class Icarus.WorldResourceFunctionLibrary
class UWorldResourceFunctionLibrary : public UBlueprintFunctionLibrary
{
public:

	static class UClass* StaticClass();
	static class UWorldResourceFunctionLibrary* GetDefaultObj();

	void TryGrantInfectedBarkToPlayer(int32 AmountOfWood, class AIcarusPlayerCharacter* TargetPlayer, const struct FItemTemplateRowHandle& InfectedBarkItemTemplate);
	void TryGrantCoalToPlayer(int32 AmountOfWood, class AIcarusPlayerCharacter* TargetPlayer, const struct FItemTemplateRowHandle& CoalOreTemplate);
	void RegenerateVoxelsAroundLocation(class UObject* WorldContextObject, const struct FVector& WorldLocation, float Radius, bool bReRollVoxels);
	int32 GetTotalConsumedVoxelResourceAroundLocation(class UObject* WorldContextObject, const struct FVector& WorldLocation, int32* VoxelNodeCount, float Radius, bool bOnlyVoxelsSupportingReinit);
	bool GetNearbyVoxelResources(class UObject* WorldContextObject, const struct FVector& WorldLocation, TArray<class AVoxelResource*>* FoundVoxels, float Radius, bool bIncludeFullyMined);
	int32 GetMaxVoxelResourceAroundLocation(class UObject* WorldContextObject, const struct FVector& WorldLocation, float Radius, bool bUseInitialResourceValues);
};

// 0x0 (0x28 - 0x28)
// Class Icarus.WorldStatsLibrary
class UWorldStatsLibrary : public UStatsLibrary
{
public:

	static class UClass* StaticClass();
	static class UWorldStatsLibrary* GetDefaultObj();

	struct FWorldStatsEnum MakeWorldStatsEnum(const struct FWorldStatsEnum& Enum);
	bool Filter(int32 Index);
	void BreakWorldStatsEnum(const struct FWorldStatsEnum& Enum, class FName* Name, int32* Index);
};

// 0x28 (0x58 - 0x30)
// Class Icarus.WorldStatsSubsystem
class UWorldStatsSubsystem : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_            WorldStatsUpdated;                                 // 0x30(0x10)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                        Pad_89C7[0x18];                                    // Fixing Size Of Struct [ Dumper-7 ]

	static class UClass* StaticClass();
	static class UWorldStatsSubsystem* GetDefaultObj();

	void UpdateWorldStats(struct FProspectListRowHandle& ProspectRowHandle, enum class EMissionDifficulty Difficulty);
	TMap<struct FStatsRowHandle, int32> GetWorldStats();
	int32 GetWorldStat(struct FStatsRowHandle& Stat);
	void AddWorldStats(struct FProspectListRowHandle& ProspectRowHandle, enum class EMissionDifficulty Difficulty);
};

}


