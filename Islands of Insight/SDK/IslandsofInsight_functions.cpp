#pragma once

// Dumped with Dumper-7!


#include "../SDK.hpp"

namespace SDK
{
//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------


// Class IslandsofInsight.ClickableBase
// (Actor)

class UClass* AClickableBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ClickableBase");

	return Clss;
}


// ClickableBase IslandsofInsight.Default__ClickableBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AClickableBase* AClickableBase::GetDefaultObj()
{
	static class AClickableBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AClickableBase*>(AClickableBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ClickableBase.WouldBeSuccessfulClick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                        RetErrorMsg                                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// enum class EClickSuccess           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EClickSuccess AClickableBase::WouldBeSuccessfulClick(class ASophiaCharacter* Player, struct FHitResult& OutHit, class FText* RetErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ClickableBase", "WouldBeSuccessfulClick");

	Params::AClickableBase_WouldBeSuccessfulClick_Params Parms{};

	Parms.Player = Player;
	Parms.OutHit = OutHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (RetErrorMsg != nullptr)
		*RetErrorMsg = Parms.RetErrorMsg;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ClickableBase.BP_OnClick
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AClickableBase::BP_OnClick(class ASophiaCharacter* Player, struct FHitResult& OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ClickableBase", "BP_OnClick");

	Params::AClickableBase_BP_OnClick_Params Parms{};

	Parms.Player = Player;
	Parms.OutHit = OutHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.SophiaNetActor
// (Actor)

class UClass* ASophiaNetActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaNetActor");

	return Clss;
}


// SophiaNetActor IslandsofInsight.Default__SophiaNetActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaNetActor* ASophiaNetActor::GetDefaultObj()
{
	static class ASophiaNetActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaNetActor*>(ASophiaNetActor::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaNetActor.OnRep_FinishedServerInit
// (Final, Native, Protected)
// Parameters:

void ASophiaNetActor::OnRep_FinishedServerInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaNetActor", "OnRep_FinishedServerInit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaNetActor.BPI_TickActor
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaNetActor::BPI_TickActor(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaNetActor", "BPI_TickActor");

	Params::ASophiaNetActor_BPI_TickActor_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PuzzleBase
// (Actor)

class UClass* APuzzleBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleBase");

	return Clss;
}


// PuzzleBase IslandsofInsight.Default__PuzzleBase
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleBase* APuzzleBase::GetDefaultObj()
{
	static class APuzzleBase* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleBase*>(APuzzleBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleBase.SetSolvedOnClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SolveDuration                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Multiplier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleBase::SetSolvedOnClient(class ASophiaCharacter* Player, float SolveDuration, float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "SetSolvedOnClient");

	Params::APuzzleBase_SetSolvedOnClient_Params Parms{};

	Parms.Player = Player;
	Parms.SolveDuration = SolveDuration;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.SetPuzzleCollision
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               bCollision                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleBase::SetPuzzleCollision(bool bCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "SetPuzzleCollision");

	Params::APuzzleBase_SetPuzzleCollision_Params Parms{};

	Parms.bCollision = bCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.Server_UnlockEncyclopediaEntry
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleBase::Server_UnlockEncyclopediaEntry(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "Server_UnlockEncyclopediaEntry");

	Params::APuzzleBase_Server_UnlockEncyclopediaEntry_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.ResetPuzzle
// (Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SendToServer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleBase::ResetPuzzle(class ASophiaCharacter* Player, bool SendToServer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "ResetPuzzle");

	Params::APuzzleBase_ResetPuzzle_Params Parms{};

	Parms.Player = Player;
	Parms.SendToServer = SendToServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.OnRep_SolverInfo
// (Final, Native, Private)
// Parameters:

void APuzzleBase::OnRep_SolverInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "OnRep_SolverInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.OnRep_SolveInfo
// (Final, Native, Private)
// Parameters:

void APuzzleBase::OnRep_SolveInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "OnRep_SolveInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.OnRep_ReplayableFadeMode
// (Final, Native, Protected)
// Parameters:

void APuzzleBase::OnRep_ReplayableFadeMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "OnRep_ReplayableFadeMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.OnRep_PuzzleData
// (Final, Native, Protected)
// Parameters:

void APuzzleBase::OnRep_PuzzleData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "OnRep_PuzzleData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.OnRep_KrakenId
// (Final, Native, Protected)
// Parameters:

void APuzzleBase::OnRep_KrakenId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "OnRep_KrakenId");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleBase.IsSolved
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APuzzleBase::IsSolved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "IsSolved");

	Params::APuzzleBase_IsSolved_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.HasDynamicCollision
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APuzzleBase::HasDynamicCollision()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "HasDynamicCollision");

	Params::APuzzleBase_HasDynamicCollision_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetZoneType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EMainMapZoneName        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EMainMapZoneName APuzzleBase::GetZoneType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetZoneType");

	Params::APuzzleBase_GetZoneType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetSolverTeam
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 APuzzleBase::GetSolverTeam()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetSolverTeam");

	Params::APuzzleBase_GetSolverTeam_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetSolveDurationBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APuzzleBase::GetSolveDurationBy(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetSolveDurationBy");

	Params::APuzzleBase_GetSolveDurationBy_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetPuzzleReplicationLocations
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FVector>             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> APuzzleBase::GetPuzzleReplicationLocations()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetPuzzleReplicationLocations");

	Params::APuzzleBase_GetPuzzleReplicationLocations_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetNonInstancedBestSolveDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APuzzleBase::GetNonInstancedBestSolveDuration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetNonInstancedBestSolveDuration");

	Params::APuzzleBase_GetNonInstancedBestSolveDuration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.GetBlueOrbCounts
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<bool>                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<bool> APuzzleBase::GetBlueOrbCounts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "GetBlueOrbCounts");

	Params::APuzzleBase_GetBlueOrbCounts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.BPI_ResetPuzzle
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzleBase::BPI_ResetPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BPI_ResetPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BPI_OnClickedSleepingPuzzle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void APuzzleBase::BPI_OnClickedSleepingPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BPI_OnClickedSleepingPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BPI_OnAwakenStateChange
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzleBase::BPI_OnAwakenStateChange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BPI_OnAwakenStateChange");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BPC_getAwakenState
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        OutErrorMsg                                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APuzzleBase::BPC_getAwakenState(class FText* OutErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BPC_getAwakenState");

	Params::APuzzleBase_BPC_getAwakenState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutErrorMsg != nullptr)
		*OutErrorMsg = Parms.OutErrorMsg;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleBase.BP_ReplayableDisappear_Client
// (Event, Protected, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_ReplayableDisappear_Client()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_ReplayableDisappear_Client");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_ReplayableAppear_Client
// (Event, Protected, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_ReplayableAppear_Client()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_ReplayableAppear_Client");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_OnTargeted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               WouldBeSuccessfulClick                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleBase::BP_OnTargeted(bool WouldBeSuccessfulClick)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnTargeted");

	Params::APuzzleBase_BP_OnTargeted_Params Parms{};

	Parms.WouldBeSuccessfulClick = WouldBeSuccessfulClick;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.PuzzleBase.BP_OnSpawned
// (Event, Protected, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_OnSpawned()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnSpawned");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_OnSolved_Server
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_OnSolved_Server()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnSolved_Server");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_OnSolved_Client
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_OnSolved_Client()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnSolved_Client");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_OnDeserialize
// (Event, Protected, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_OnDeserialize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnDeserialize");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzleBase.BP_OnBeforeSerialize
// (Event, Protected, BlueprintEvent)
// Parameters:

void APuzzleBase::BP_OnBeforeSerialize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleBase", "BP_OnBeforeSerialize");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.HiddenCube
// (Actor)

class UClass* AHiddenCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HiddenCube");

	return Clss;
}


// HiddenCube IslandsofInsight.Default__HiddenCube
// (Public, ClassDefaultObject, ArchetypeObject)

class AHiddenCube* AHiddenCube::GetDefaultObj()
{
	static class AHiddenCube* Default = nullptr;

	if (!Default)
		Default = static_cast<AHiddenCube*>(AHiddenCube::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.HiddenCube.BPI_PlayBumpEffect
// (Event, Public, BlueprintEvent)
// Parameters:

void AHiddenCube::BPI_PlayBumpEffect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HiddenCube", "BPI_PlayBumpEffect");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.HiddenCube.BP_NotifyPlayerDistance
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              DistanceToPlayer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHiddenCube::BP_NotifyPlayerDistance(float DistanceToPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HiddenCube", "BP_NotifyPlayerDistance");

	Params::AHiddenCube_BP_NotifyPlayerDistance_Params Parms{};

	Parms.DistanceToPlayer = DistanceToPlayer;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PuzzleContainerBase
// (Actor)

class UClass* APuzzleContainerBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleContainerBase");

	return Clss;
}


// PuzzleContainerBase IslandsofInsight.Default__PuzzleContainerBase
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleContainerBase* APuzzleContainerBase::GetDefaultObj()
{
	static class APuzzleContainerBase* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleContainerBase*>(APuzzleContainerBase::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaRune
// (Actor)

class UClass* ASophiaRune::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaRune");

	return Clss;
}


// SophiaRune IslandsofInsight.Default__SophiaRune
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaRune* ASophiaRune::GetDefaultObj()
{
	static class ASophiaRune* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaRune*>(ASophiaRune::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaRune.UpdateVisibleForLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaRune::UpdateVisibleForLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "UpdateVisibleForLocalPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaRune.UpdateLevelDisplay
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaRune::UpdateLevelDisplay(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "UpdateLevelDisplay");

	Params::ASophiaRune_UpdateLevelDisplay_Params Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaRune.TryGetPuzzleDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASophiaRune::TryGetPuzzleDifficulty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "TryGetPuzzleDifficulty");

	Params::ASophiaRune_TryGetPuzzleDifficulty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaRune.ShouldBeVisibleForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaRune::ShouldBeVisibleForPlayer(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "ShouldBeVisibleForPlayer");

	Params::ASophiaRune_ShouldBeVisibleForPlayer_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaRune.PlaySolveAnimation
// (Final, Native, Public)
// Parameters:

void ASophiaRune::PlaySolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "PlaySolveAnimation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaRune.OnRep_SPLockPlayer
// (Final, Native, Private)
// Parameters:

void ASophiaRune::OnRep_SPLockPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "OnRep_SPLockPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaRune.OnRep_InvitedPlayers
// (Final, Native, Private)
// Parameters:
// TArray<class ASophiaCharacter*>    PrevPlayers                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ASophiaRune::OnRep_InvitedPlayers(const TArray<class ASophiaCharacter*>& PrevPlayers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "OnRep_InvitedPlayers");

	Params::ASophiaRune_OnRep_InvitedPlayers_Params Parms{};

	Parms.PrevPlayers = PrevPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaRune.GetIsLocked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaRune::GetIsLocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "GetIsLocked");

	Params::ASophiaRune_GetIsLocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaRune.BPC_ToggleRuneHelpPing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               TurnOn                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaRune::BPC_ToggleRuneHelpPing(bool TurnOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BPC_ToggleRuneHelpPing");

	Params::ASophiaRune_BPC_ToggleRuneHelpPing_Params Parms{};

	Parms.TurnOn = TurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaRune.BP_SetRuneVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               IsVisible                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaRune::BP_SetRuneVisible(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_SetRuneVisible");

	Params::ASophiaRune_BP_SetRuneVisible_Params Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaRune.BP_OnPrerequisitesSatisfied
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaRune::BP_OnPrerequisitesSatisfied()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_OnPrerequisitesSatisfied");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaRune.BP_OnIsLockedStateUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bIsLocked                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaRune::BP_OnIsLockedStateUpdated(bool bIsLocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_OnIsLockedStateUpdated");

	Params::ASophiaRune_BP_OnIsLockedStateUpdated_Params Parms{};

	Parms.bIsLocked = bIsLocked;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaRune.BP_OnExitRune
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaRune::BP_OnExitRune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_OnExitRune");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaRune.BP_OnEnterRune
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaRune::BP_OnEnterRune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_OnEnterRune");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaRune.BP_NotifyRuneDifficulty
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Difficulty                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaRune::BP_NotifyRuneDifficulty(int32 Difficulty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaRune", "BP_NotifyRuneDifficulty");

	Params::ASophiaRune_BP_NotifyRuneDifficulty_Params Parms{};

	Parms.Difficulty = Difficulty;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.AirDropPuzzle
// (Actor)

class UClass* AAirDropPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AirDropPuzzle");

	return Clss;
}


// AirDropPuzzle IslandsofInsight.Default__AirDropPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AAirDropPuzzle* AAirDropPuzzle::GetDefaultObj()
{
	static class AAirDropPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AAirDropPuzzle*>(AAirDropPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.AirDropPuzzle.MultiCast_SendMessage
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:

void AAirDropPuzzle::MultiCast_SendMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropPuzzle", "MultiCast_SendMessage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropPuzzle.HitBelowAirDrop
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAirDropPuzzle::HitBelowAirDrop(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropPuzzle", "HitBelowAirDrop");

	Params::AAirDropPuzzle_HitBelowAirDrop_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropPuzzle.BP_PuzzleLanded
// (Event, Protected, BlueprintEvent)
// Parameters:

void AAirDropPuzzle::BP_PuzzleLanded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropPuzzle", "BP_PuzzleLanded");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.AirDropPuzzle.BP_PrePuzzleLanded
// (Event, Protected, BlueprintEvent)
// Parameters:

void AAirDropPuzzle::BP_PrePuzzleLanded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropPuzzle", "BP_PrePuzzleLanded");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.AirDropRosaryParty
// (Actor)

class UClass* AAirDropRosaryParty::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AirDropRosaryParty");

	return Clss;
}


// AirDropRosaryParty IslandsofInsight.Default__AirDropRosaryParty
// (Public, ClassDefaultObject, ArchetypeObject)

class AAirDropRosaryParty* AAirDropRosaryParty::GetDefaultObj()
{
	static class AAirDropRosaryParty* Default = nullptr;

	if (!Default)
		Default = static_cast<AAirDropRosaryParty*>(AAirDropRosaryParty::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.AirDropRosaryParty.OnTimeUp
// (Final, Native, Protected)
// Parameters:

void AAirDropRosaryParty::OnTimeUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropRosaryParty", "OnTimeUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropRosaryParty.NetMultiCast_FinishParty
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:

void AAirDropRosaryParty::NetMultiCast_FinishParty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropRosaryParty", "NetMultiCast_FinishParty");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropRosaryParty.NetMultiCast_AwardPartyWinners
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// TArray<class ASophiaCharacter*>    Players                                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AAirDropRosaryParty::NetMultiCast_AwardPartyWinners(TArray<class ASophiaCharacter*>& Players)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropRosaryParty", "NetMultiCast_AwardPartyWinners");

	Params::AAirDropRosaryParty_NetMultiCast_AwardPartyWinners_Params Parms{};

	Parms.Players = Players;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropRosaryParty.MultiCast_SendMessage
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:

void AAirDropRosaryParty::MultiCast_SendMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropRosaryParty", "MultiCast_SendMessage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.AirDropRosaryParty.BP_OnLanded
// (Event, Public, BlueprintEvent)
// Parameters:

void AAirDropRosaryParty::BP_OnLanded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AirDropRosaryParty", "BP_OnLanded");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.AirDropSpawnVolume
// (Actor)

class UClass* AAirDropSpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AirDropSpawnVolume");

	return Clss;
}


// AirDropSpawnVolume IslandsofInsight.Default__AirDropSpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AAirDropSpawnVolume* AAirDropSpawnVolume::GetDefaultObj()
{
	static class AAirDropSpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AAirDropSpawnVolume*>(AAirDropSpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaUserWidget
// (None)

class UClass* USophiaUserWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaUserWidget");

	return Clss;
}


// SophiaUserWidget IslandsofInsight.Default__SophiaUserWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaUserWidget* USophiaUserWidget::GetDefaultObj()
{
	static class USophiaUserWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaUserWidget*>(USophiaUserWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaUserWidget.BP_OnTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaUserWidget::BP_OnTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUserWidget", "BP_OnTick");

	Params::USophiaUserWidget_BP_OnTick_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.AirdropsWidget
// (None)

class UClass* UAirdropsWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AirdropsWidget");

	return Clss;
}


// AirdropsWidget IslandsofInsight.Default__AirdropsWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UAirdropsWidget* UAirdropsWidget::GetDefaultObj()
{
	static class UAirdropsWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UAirdropsWidget*>(UAirdropsWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Clue
// (None)

class UClass* UClue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Clue");

	return Clss;
}


// Clue IslandsofInsight.Default__Clue
// (Public, ClassDefaultObject, ArchetypeObject)

class UClue* UClue::GetDefaultObj()
{
	static class UClue* Default = nullptr;

	if (!Default)
		Default = static_cast<UClue*>(UClue::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Aleph
// (None)

class UClass* UAleph::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Aleph");

	return Clss;
}


// Aleph IslandsofInsight.Default__Aleph
// (Public, ClassDefaultObject, ArchetypeObject)

class UAleph* UAleph::GetDefaultObj()
{
	static class UAleph* Default = nullptr;

	if (!Default)
		Default = static_cast<UAleph*>(UAleph::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AllIslandsAreCongruent
// (None)

class UClass* UAllIslandsAreCongruent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AllIslandsAreCongruent");

	return Clss;
}


// AllIslandsAreCongruent IslandsofInsight.Default__AllIslandsAreCongruent
// (Public, ClassDefaultObject, ArchetypeObject)

class UAllIslandsAreCongruent* UAllIslandsAreCongruent::GetDefaultObj()
{
	static class UAllIslandsAreCongruent* Default = nullptr;

	if (!Default)
		Default = static_cast<UAllIslandsAreCongruent*>(UAllIslandsAreCongruent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AllIslandsHaveOneSize
// (None)

class UClass* UAllIslandsHaveOneSize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AllIslandsHaveOneSize");

	return Clss;
}


// AllIslandsHaveOneSize IslandsofInsight.Default__AllIslandsHaveOneSize
// (Public, ClassDefaultObject, ArchetypeObject)

class UAllIslandsHaveOneSize* UAllIslandsHaveOneSize::GetDefaultObj()
{
	static class UAllIslandsHaveOneSize* Default = nullptr;

	if (!Default)
		Default = static_cast<UAllIslandsHaveOneSize*>(UAllIslandsHaveOneSize::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AutoAimDetectorComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UAutoAimDetectorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AutoAimDetectorComponent");

	return Clss;
}


// AutoAimDetectorComponent IslandsofInsight.Default__AutoAimDetectorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UAutoAimDetectorComponent* UAutoAimDetectorComponent::GetDefaultObj()
{
	static class UAutoAimDetectorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UAutoAimDetectorComponent*>(UAutoAimDetectorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AvoidThisPattern
// (None)

class UClass* UAvoidThisPattern::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AvoidThisPattern");

	return Clss;
}


// AvoidThisPattern IslandsofInsight.Default__AvoidThisPattern
// (Public, ClassDefaultObject, ArchetypeObject)

class UAvoidThisPattern* UAvoidThisPattern::GetDefaultObj()
{
	static class UAvoidThisPattern* Default = nullptr;

	if (!Default)
		Default = static_cast<UAvoidThisPattern*>(UAvoidThisPattern::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.BaseWidget
// (None)

class UClass* UBaseWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BaseWidget");

	return Clss;
}


// BaseWidget IslandsofInsight.Default__BaseWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UBaseWidget* UBaseWidget::GetDefaultObj()
{
	static class UBaseWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UBaseWidget*>(UBaseWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.BaseWidget.SetButtonInteractionSounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UBaseWidget::SetButtonInteractionSounds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "SetButtonInteractionSounds");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.PlayFModSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFMODEvent*                  InEvent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseWidget::PlayFModSound(class UFMODEvent* InEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "PlayFModSound");

	Params::UBaseWidget_PlayFModSound_Params Parms{};

	Parms.InEvent = InEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.InitAndPlayBinkVideo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBinkMediaPlayer*            Video                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseWidget::InitAndPlayBinkVideo(class UBinkMediaPlayer* Video)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "InitAndPlayBinkVideo");

	Params::UBaseWidget_InitAndPlayBinkVideo_Params Parms{};

	Parms.Video = Video;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.GetAllWidgets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>             Widgets                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseWidget::GetAllWidgets(class UObject* WorldContextObject, TArray<class UWidget*>* Widgets)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "GetAllWidgets");

	Params::UBaseWidget_GetAllWidgets_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Widgets != nullptr)
		*Widgets = std::move(Parms.Widgets);

}


// Function IslandsofInsight.BaseWidget.ComboSelectionSound
// (Final, Native, Private)
// Parameters:
// class FString                      SelectedItem                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESelectInfo             SelectionType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseWidget::ComboSelectionSound(const class FString& SelectedItem, enum class ESelectInfo SelectionType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "ComboSelectionSound");

	Params::UBaseWidget_ComboSelectionSound_Params Parms{};

	Parms.SelectedItem = SelectedItem;
	Parms.SelectionType = SelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.CheckBoxSound
// (Final, Native, Private)
// Parameters:
// bool                               InValue                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseWidget::CheckBoxSound(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "CheckBoxSound");

	Params::UBaseWidget_CheckBoxSound_Params Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.ButtonHoveredSound
// (Final, Native, Public)
// Parameters:

void UBaseWidget::ButtonHoveredSound()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "ButtonHoveredSound");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.BaseWidget.ButtonClickedSound
// (Final, Native, Public)
// Parameters:

void UBaseWidget::ButtonClickedSound()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseWidget", "ButtonClickedSound");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.BlueOrbFragmentBeam
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UBlueOrbFragmentBeam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueOrbFragmentBeam");

	return Clss;
}


// BlueOrbFragmentBeam IslandsofInsight.Default__BlueOrbFragmentBeam
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueOrbFragmentBeam* UBlueOrbFragmentBeam::GetDefaultObj()
{
	static class UBlueOrbFragmentBeam* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueOrbFragmentBeam*>(UBlueOrbFragmentBeam::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.BlueOrbFragmentPuzzle
// (Actor)

class UClass* ABlueOrbFragmentPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueOrbFragmentPuzzle");

	return Clss;
}


// BlueOrbFragmentPuzzle IslandsofInsight.Default__BlueOrbFragmentPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ABlueOrbFragmentPuzzle* ABlueOrbFragmentPuzzle::GetDefaultObj()
{
	static class ABlueOrbFragmentPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ABlueOrbFragmentPuzzle*>(ABlueOrbFragmentPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.BlueOrbFragmentPuzzle.NumFound
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABlueOrbFragmentPuzzle::NumFound()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueOrbFragmentPuzzle", "NumFound");

	Params::ABlueOrbFragmentPuzzle_NumFound_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.BlueOrbFragmentPuzzle.BPI_FoundTrinket
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*        Trinket                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLoadingFromPersistence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABlueOrbFragmentPuzzle::BPI_FoundTrinket(class UStaticMeshComponent* Trinket, bool bLoadingFromPersistence)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueOrbFragmentPuzzle", "BPI_FoundTrinket");

	Params::ABlueOrbFragmentPuzzle_BPI_FoundTrinket_Params Parms{};

	Parms.Trinket = Trinket;
	Parms.bLoadingFromPersistence = bLoadingFromPersistence;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.CancelProgressBarWidget
// (None)

class UClass* UCancelProgressBarWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CancelProgressBarWidget");

	return Clss;
}


// CancelProgressBarWidget IslandsofInsight.Default__CancelProgressBarWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCancelProgressBarWidget* UCancelProgressBarWidget::GetDefaultObj()
{
	static class UCancelProgressBarWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCancelProgressBarWidget*>(UCancelProgressBarWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CancelProgressBarWidget.BPI_DisplayAnim
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               Visible                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCancelProgressBarWidget::BPI_DisplayAnim(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CancelProgressBarWidget", "BPI_DisplayAnim");

	Params::UCancelProgressBarWidget_BPI_DisplayAnim_Params Parms{};

	Parms.Visible = Visible;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.NumericalClue
// (None)

class UClass* UNumericalClue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NumericalClue");

	return Clss;
}


// NumericalClue IslandsofInsight.Default__NumericalClue
// (Public, ClassDefaultObject, ArchetypeObject)

class UNumericalClue* UNumericalClue::GetDefaultObj()
{
	static class UNumericalClue* Default = nullptr;

	if (!Default)
		Default = static_cast<UNumericalClue*>(UNumericalClue::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CaveNumber
// (None)

class UClass* UCaveNumber::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CaveNumber");

	return Clss;
}


// CaveNumber IslandsofInsight.Default__CaveNumber
// (Public, ClassDefaultObject, ArchetypeObject)

class UCaveNumber* UCaveNumber::GetDefaultObj()
{
	static class UCaveNumber* Default = nullptr;

	if (!Default)
		Default = static_cast<UCaveNumber*>(UCaveNumber::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.InputWidget
// (None)

class UClass* UInputWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputWidget");

	return Clss;
}


// InputWidget IslandsofInsight.Default__InputWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputWidget* UInputWidget::GetDefaultObj()
{
	static class UInputWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputWidget*>(UInputWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InputWidget.OnExitClicked
// (Event, Protected, BlueprintEvent)
// Parameters:

void UInputWidget::OnExitClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputWidget", "OnExitClicked");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.InputWidget.BP_Init
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UInputWidget::BP_Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputWidget", "BP_Init");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.InputWidget.BP_DoBindings
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USophiaInputComponent*       InputComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EInputDeviceType        E                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputWidget::BP_DoBindings(class USophiaInputComponent* InputComp, enum class EInputDeviceType E)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputWidget", "BP_DoBindings");

	Params::UInputWidget_BP_DoBindings_Params Parms{};

	Parms.InputComp = InputComp;
	Parms.E = E;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.NotificationWidget
// (None)

class UClass* UNotificationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NotificationWidget");

	return Clss;
}


// NotificationWidget IslandsofInsight.Default__NotificationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UNotificationWidget* UNotificationWidget::GetDefaultObj()
{
	static class UNotificationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UNotificationWidget*>(UNotificationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CenterToastCurrencyNotification
// (None)

class UClass* UCenterToastCurrencyNotification::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CenterToastCurrencyNotification");

	return Clss;
}


// CenterToastCurrencyNotification IslandsofInsight.Default__CenterToastCurrencyNotification
// (Public, ClassDefaultObject, ArchetypeObject)

class UCenterToastCurrencyNotification* UCenterToastCurrencyNotification::GetDefaultObj()
{
	static class UCenterToastCurrencyNotification* Default = nullptr;

	if (!Default)
		Default = static_cast<UCenterToastCurrencyNotification*>(UCenterToastCurrencyNotification::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CenterToastCurrencyNotification.BP_SetText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCenterToastCurrencyNotification::BP_SetText(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CenterToastCurrencyNotification", "BP_SetText");

	Params::UCenterToastCurrencyNotification_BP_SetText_Params Parms{};

	Parms.InText = InText;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.NotificationsManagerContainer
// (None)

class UClass* UNotificationsManagerContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NotificationsManagerContainer");

	return Clss;
}


// NotificationsManagerContainer IslandsofInsight.Default__NotificationsManagerContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UNotificationsManagerContainer* UNotificationsManagerContainer::GetDefaultObj()
{
	static class UNotificationsManagerContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UNotificationsManagerContainer*>(UNotificationsManagerContainer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.NotificationsManagerContainer.AddToMessageQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNotificationWidget*         InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationsManagerContainer::AddToMessageQueue(class UNotificationWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NotificationsManagerContainer", "AddToMessageQueue");

	Params::UNotificationsManagerContainer_AddToMessageQueue_Params Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CenterToastNotificationContainer
// (None)

class UClass* UCenterToastNotificationContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CenterToastNotificationContainer");

	return Clss;
}


// CenterToastNotificationContainer IslandsofInsight.Default__CenterToastNotificationContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UCenterToastNotificationContainer* UCenterToastNotificationContainer::GetDefaultObj()
{
	static class UCenterToastNotificationContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UCenterToastNotificationContainer*>(UCenterToastNotificationContainer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CenterToastNotificationContainer.OnBlueOrbAnimFinished
// (Final, Native, Protected)
// Parameters:

void UCenterToastNotificationContainer::OnBlueOrbAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CenterToastNotificationContainer", "OnBlueOrbAnimFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CentralProgressionNotificationContainer
// (None)

class UClass* UCentralProgressionNotificationContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CentralProgressionNotificationContainer");

	return Clss;
}


// CentralProgressionNotificationContainer IslandsofInsight.Default__CentralProgressionNotificationContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UCentralProgressionNotificationContainer* UCentralProgressionNotificationContainer::GetDefaultObj()
{
	static class UCentralProgressionNotificationContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UCentralProgressionNotificationContainer*>(UCentralProgressionNotificationContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CharacterCostumeDataAsset
// (None)

class UClass* UCharacterCostumeDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterCostumeDataAsset");

	return Clss;
}


// CharacterCostumeDataAsset IslandsofInsight.Default__CharacterCostumeDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharacterCostumeDataAsset* UCharacterCostumeDataAsset::GetDefaultObj()
{
	static class UCharacterCostumeDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharacterCostumeDataAsset*>(UCharacterCostumeDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharacterCostumeDataAsset.InitAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCharacterCostumeDataAsset::InitAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCostumeDataAsset", "InitAsset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharacterCostumeDataAsset.GetCostumeDataByQuestName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCostumeSingle              ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCostumeSingle UCharacterCostumeDataAsset::GetCostumeDataByQuestName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCostumeDataAsset", "GetCostumeDataByQuestName");

	Params::UCharacterCostumeDataAsset_GetCostumeDataByQuestName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCostumeDataAsset.GetCostumeDataByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCostumeSingle              ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCostumeSingle UCharacterCostumeDataAsset::GetCostumeDataByName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCostumeDataAsset", "GetCostumeDataByName");

	Params::UCharacterCostumeDataAsset_GetCostumeDataByName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCostumeDataAsset.GetCostumeDataByMasteryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCostumeSingle              ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCostumeSingle UCharacterCostumeDataAsset::GetCostumeDataByMasteryName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCostumeDataAsset", "GetCostumeDataByMasteryName");

	Params::UCharacterCostumeDataAsset_GetCostumeDataByMasteryName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.UnisexCharacterCostumeDataAsset
// (None)

class UClass* UUnisexCharacterCostumeDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UnisexCharacterCostumeDataAsset");

	return Clss;
}


// UnisexCharacterCostumeDataAsset IslandsofInsight.Default__UnisexCharacterCostumeDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UUnisexCharacterCostumeDataAsset* UUnisexCharacterCostumeDataAsset::GetDefaultObj()
{
	static class UUnisexCharacterCostumeDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UUnisexCharacterCostumeDataAsset*>(UUnisexCharacterCostumeDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaCosmetic
// (None)

class UClass* USophiaCosmetic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaCosmetic");

	return Clss;
}


// SophiaCosmetic IslandsofInsight.Default__SophiaCosmetic
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaCosmetic* USophiaCosmetic::GetDefaultObj()
{
	static class USophiaCosmetic* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaCosmetic*>(USophiaCosmetic::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaCosmetic.Select
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaCosmetic::Select()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCosmetic", "Select");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCosmetic.Purchase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaCosmetic::Purchase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCosmetic", "Purchase");

	Params::USophiaCosmetic_Purchase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCosmetic.GetIsUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaCosmetic::GetIsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCosmetic", "GetIsUnlocked");

	Params::USophiaCosmetic_GetIsUnlocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCosmetic.GetIsSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaCosmetic::GetIsSelected()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCosmetic", "GetIsSelected");

	Params::USophiaCosmetic_GetIsSelected_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCosmetic.Deselect
// (Final, Native, Public)
// Parameters:

void USophiaCosmetic::Deselect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCosmetic", "Deselect");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaCostumeInfo
// (None)

class UClass* USophiaCostumeInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaCostumeInfo");

	return Clss;
}


// SophiaCostumeInfo IslandsofInsight.Default__SophiaCostumeInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaCostumeInfo* USophiaCostumeInfo::GetDefaultObj()
{
	static class USophiaCostumeInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaCostumeInfo*>(USophiaCostumeInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CharacterCustomizationData
// (None)

class UClass* UCharacterCustomizationData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterCustomizationData");

	return Clss;
}


// CharacterCustomizationData IslandsofInsight.Default__CharacterCustomizationData
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharacterCustomizationData* UCharacterCustomizationData::GetDefaultObj()
{
	static class UCharacterCustomizationData* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharacterCustomizationData*>(UCharacterCustomizationData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CharacterCustomizationDataAsset
// (None)

class UClass* UCharacterCustomizationDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterCustomizationDataAsset");

	return Clss;
}


// CharacterCustomizationDataAsset IslandsofInsight.Default__CharacterCustomizationDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharacterCustomizationDataAsset* UCharacterCustomizationDataAsset::GetDefaultObj()
{
	static class UCharacterCustomizationDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharacterCustomizationDataAsset*>(UCharacterCustomizationDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharacterCustomizationDataAsset.InvertIndexRemapping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECustomizationTypes     Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCustomizationDataAsset::InvertIndexRemapping(int32 Index, enum class ECustomizationTypes Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "InvertIndexRemapping");

	Params::UCharacterCustomizationDataAsset_InvertIndexRemapping_Params Parms{};

	Parms.Index = Index;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.InitAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCharacterCustomizationDataAsset::InitAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "InitAsset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.IndexRemapping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECustomizationTypes     Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCustomizationDataAsset::IndexRemapping(int32 Index, enum class ECustomizationTypes Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "IndexRemapping");

	Params::UCharacterCustomizationDataAsset_IndexRemapping_Params Parms{};

	Parms.Index = Index;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ECustomizationTypes     Types                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsValid                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaxIndex                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowLocked                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCharacterCustomizationDataAsset::GetNames(enum class ECustomizationTypes Types, int32 Index, bool* bIsValid, int32* MaxIndex, bool bShowLocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetNames");

	Params::UCharacterCustomizationDataAsset_GetNames_Params Parms{};

	Parms.Types = Types;
	Parms.Index = Index;
	Parms.bShowLocked = bShowLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bIsValid != nullptr)
		*bIsValid = Parms.bIsValid;

	if (MaxIndex != nullptr)
		*MaxIndex = Parms.MaxIndex;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetItemEquipIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ECustomizationTypes     Types                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCustomizationDataAsset::GetItemEquipIndex(enum class ECustomizationTypes Types, const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetItemEquipIndex");

	Params::UCharacterCustomizationDataAsset_GetItemEquipIndex_Params Parms{};

	Parms.Types = Types;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetCustomizationDataByQuestName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationSingle        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationSingle UCharacterCustomizationDataAsset::GetCustomizationDataByQuestName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetCustomizationDataByQuestName");

	Params::UCharacterCustomizationDataAsset_GetCustomizationDataByQuestName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetCustomizationDataByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationSingle        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationSingle UCharacterCustomizationDataAsset::GetCustomizationDataByName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetCustomizationDataByName");

	Params::UCharacterCustomizationDataAsset_GetCustomizationDataByName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetCustomizationDataByMasteryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationSingle        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationSingle UCharacterCustomizationDataAsset::GetCustomizationDataByMasteryName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetCustomizationDataByMasteryName");

	Params::UCharacterCustomizationDataAsset_GetCustomizationDataByMasteryName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetCustomizationDataByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECustomizationTypes     Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationSingle        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationSingle UCharacterCustomizationDataAsset::GetCustomizationDataByIndex(int32 Index, enum class ECustomizationTypes Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetCustomizationDataByIndex");

	Params::UCharacterCustomizationDataAsset_GetCustomizationDataByIndex_Params Parms{};

	Parms.Index = Index;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharacterCustomizationDataAsset.GetCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterCustomizationDataAsset::GetCost(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizationDataAsset", "GetCost");

	Params::UCharacterCustomizationDataAsset_GetCost_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.UnisexCharacterCustomizationDataAsset
// (None)

class UClass* UUnisexCharacterCustomizationDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UnisexCharacterCustomizationDataAsset");

	return Clss;
}


// UnisexCharacterCustomizationDataAsset IslandsofInsight.Default__UnisexCharacterCustomizationDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UUnisexCharacterCustomizationDataAsset* UUnisexCharacterCustomizationDataAsset::GetDefaultObj()
{
	static class UUnisexCharacterCustomizationDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UUnisexCharacterCustomizationDataAsset*>(UUnisexCharacterCustomizationDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CharacterCustomizerCamera
// (Actor)

class UClass* ACharacterCustomizerCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterCustomizerCamera");

	return Clss;
}


// CharacterCustomizerCamera IslandsofInsight.Default__CharacterCustomizerCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class ACharacterCustomizerCamera* ACharacterCustomizerCamera::GetDefaultObj()
{
	static class ACharacterCustomizerCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<ACharacterCustomizerCamera*>(ACharacterCustomizerCamera::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharacterCustomizerCamera.ResizeSceneCapture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*    SceneCapture                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterCustomizerCamera::ResizeSceneCapture(class USceneCaptureComponent2D* SceneCapture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterCustomizerCamera", "ResizeSceneCapture");

	Params::ACharacterCustomizerCamera_ResizeSceneCapture_Params Parms{};

	Parms.SceneCapture = SceneCapture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CharacterTitleDataAsset
// (None)

class UClass* UCharacterTitleDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterTitleDataAsset");

	return Clss;
}


// CharacterTitleDataAsset IslandsofInsight.Default__CharacterTitleDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharacterTitleDataAsset* UCharacterTitleDataAsset::GetDefaultObj()
{
	static class UCharacterTitleDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharacterTitleDataAsset*>(UCharacterTitleDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaInputBoundActorComponent
// (None)

class UClass* USophiaInputBoundActorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaInputBoundActorComponent");

	return Clss;
}


// SophiaInputBoundActorComponent IslandsofInsight.Default__SophiaInputBoundActorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaInputBoundActorComponent* USophiaInputBoundActorComponent::GetDefaultObj()
{
	static class USophiaInputBoundActorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaInputBoundActorComponent*>(USophiaInputBoundActorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CharCutsceneComponent
// (None)

class UClass* UCharCutsceneComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharCutsceneComponent");

	return Clss;
}


// CharCutsceneComponent IslandsofInsight.Default__CharCutsceneComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharCutsceneComponent* UCharCutsceneComponent::GetDefaultObj()
{
	static class UCharCutsceneComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharCutsceneComponent*>(UCharCutsceneComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharCutsceneComponent.StopCutscene
// (Final, Native, Private)
// Parameters:

void UCharCutsceneComponent::StopCutscene()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharCutsceneComponent", "StopCutscene");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharCutsceneComponent.PlayCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*         Cutscene                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Delay                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharCutsceneComponent::PlayCutscene(class ALevelSequenceActor* Cutscene, float Delay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharCutsceneComponent", "PlayCutscene");

	Params::UCharCutsceneComponent_PlayCutscene_Params Parms{};

	Parms.Cutscene = Cutscene;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharCutsceneComponent.ForceEndCutscene
// (Final, Native, Public)
// Parameters:
// class UWorld*                      World                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharCutsceneComponent::ForceEndCutscene(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharCutsceneComponent", "ForceEndCutscene");

	Params::UCharCutsceneComponent_ForceEndCutscene_Params Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CharGridComponent
// (None)

class UClass* UCharGridComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharGridComponent");

	return Clss;
}


// CharGridComponent IslandsofInsight.Default__CharGridComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharGridComponent* UCharGridComponent::GetDefaultObj()
{
	static class UCharGridComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharGridComponent*>(UCharGridComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharGridComponent.Server_SendGridPuzzleChange
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UPuzzleGrid*                 Puzzle                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaRune*                 Rune                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSingleGridCellEdit         Move                                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCharGridComponent::Server_SendGridPuzzleChange(class UPuzzleGrid* Puzzle, class ASophiaRune* Rune, const struct FSingleGridCellEdit& Move)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharGridComponent", "Server_SendGridPuzzleChange");

	Params::UCharGridComponent_Server_SendGridPuzzleChange_Params Parms{};

	Parms.Puzzle = Puzzle;
	Parms.Rune = Rune;
	Parms.Move = Move;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharGridComponent.Server_CloseRune
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class ASophiaRune*                 Rune                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharGridComponent::Server_CloseRune(class ASophiaRune* Rune)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharGridComponent", "Server_CloseRune");

	Params::UCharGridComponent_Server_CloseRune_Params Parms{};

	Parms.Rune = Rune;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharGridComponent.GetMaxHints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharGridComponent::GetMaxHints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharGridComponent", "GetMaxHints");

	Params::UCharGridComponent_GetMaxHints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharGridComponent.GetHintRechargeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharGridComponent::GetHintRechargeRate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharGridComponent", "GetHintRechargeRate");

	Params::UCharGridComponent_GetHintRechargeRate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.CharItemComponent
// (None)

class UClass* UCharItemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharItemComponent");

	return Clss;
}


// CharItemComponent IslandsofInsight.Default__CharItemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharItemComponent* UCharItemComponent::GetDefaultObj()
{
	static class UCharItemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharItemComponent*>(UCharItemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharItemComponent.OnRep_inventory
// (Final, Native, Protected)
// Parameters:

void UCharItemComponent::OnRep_inventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "OnRep_inventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharItemComponent.ItemEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EItemType               Type                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharItemComponent::ItemEnabled(enum class EItemType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "ItemEnabled");

	Params::UCharItemComponent_ItemEnabled_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharItemComponent.ItemAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EItemType               Type                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharItemComponent::ItemAvailable(enum class EItemType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "ItemAvailable");

	Params::UCharItemComponent_ItemAvailable_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharItemComponent.GetItemMagnitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EItemType               Type                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharItemComponent::GetItemMagnitude(enum class EItemType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "GetItemMagnitude");

	Params::UCharItemComponent_GetItemMagnitude_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharItemComponent.GetItemCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EItemType               Type                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharItemComponent::GetItemCount(enum class EItemType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "GetItemCount");

	Params::UCharItemComponent_GetItemCount_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharItemComponent.Client_ResetItems
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                               Death                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharItemComponent::Client_ResetItems(bool Death)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "Client_ResetItems");

	Params::UCharItemComponent_Client_ResetItems_Params Parms{};

	Parms.Death = Death;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharItemComponent.Client_ProcessPickupByType
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// enum class EItemType               ItemType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               PlayEffects                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               DisplayPickupMessage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SwitchTo                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CheatVariant                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharItemComponent::Client_ProcessPickupByType(enum class EItemType ItemType, bool PlayEffects, bool DisplayPickupMessage, bool SwitchTo, bool CheatVariant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "Client_ProcessPickupByType");

	Params::UCharItemComponent_Client_ProcessPickupByType_Params Parms{};

	Parms.ItemType = ItemType;
	Parms.PlayEffects = PlayEffects;
	Parms.DisplayPickupMessage = DisplayPickupMessage;
	Parms.SwitchTo = SwitchTo;
	Parms.CheatVariant = CheatVariant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharItemComponent.Client_ProcessPickup
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UItem*                       Item                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               PlayEffects                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               DisplayPickupMessage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SwitchTo                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharItemComponent::Client_ProcessPickup(class UItem* Item, bool PlayEffects, bool DisplayPickupMessage, bool SwitchTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "Client_ProcessPickup");

	Params::UCharItemComponent_Client_ProcessPickup_Params Parms{};

	Parms.Item = Item;
	Parms.PlayEffects = PlayEffects;
	Parms.DisplayPickupMessage = DisplayPickupMessage;
	Parms.SwitchTo = SwitchTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharItemComponent.Client_DeActivateItem
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// enum class EItemType               ItemTpye                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharItemComponent::Client_DeActivateItem(enum class EItemType ItemTpye)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "Client_DeActivateItem");

	Params::UCharItemComponent_Client_DeActivateItem_Params Parms{};

	Parms.ItemTpye = ItemTpye;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharItemComponent.Client_ActivateItem
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// enum class EItemType               ItemType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharItemComponent::Client_ActivateItem(enum class EItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharItemComponent", "Client_ActivateItem");

	Params::UCharItemComponent_Client_ActivateItem_Params Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CharMapComponent
// (None)

class UClass* UCharMapComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharMapComponent");

	return Clss;
}


// CharMapComponent IslandsofInsight.Default__CharMapComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharMapComponent* UCharMapComponent::GetDefaultObj()
{
	static class UCharMapComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharMapComponent*>(UCharMapComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharMapComponent.LocalPlayerExclusive_SetHideMinimap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               MapMode                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharMapComponent::LocalPlayerExclusive_SetHideMinimap(bool MapMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "LocalPlayerExclusive_SetHideMinimap");

	Params::UCharMapComponent_LocalPlayerExclusive_SetHideMinimap_Params Parms{};

	Parms.MapMode = MapMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharMapComponent.IsHidingMinimap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharMapComponent::IsHidingMinimap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "IsHidingMinimap");

	Params::UCharMapComponent_IsHidingMinimap_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetZoneUnlockStateByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<bool>                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<bool> UCharMapComponent::GetZoneUnlockStateByIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetZoneUnlockStateByIndex");

	Params::UCharMapComponent_GetZoneUnlockStateByIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetLoreUnlockCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              ZoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PickupNumerator                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PickupDenominator                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SandboxNumerator                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SandboxDenominator                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharMapComponent::GetLoreUnlockCounts(int32 ZoneIndex, int32* PickupNumerator, int32* PickupDenominator, int32* SandboxNumerator, int32* SandboxDenominator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetLoreUnlockCounts");

	Params::UCharMapComponent_GetLoreUnlockCounts_Params Parms{};

	Parms.ZoneIndex = ZoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PickupNumerator != nullptr)
		*PickupNumerator = Parms.PickupNumerator;

	if (PickupDenominator != nullptr)
		*PickupDenominator = Parms.PickupDenominator;

	if (SandboxNumerator != nullptr)
		*SandboxNumerator = Parms.SandboxNumerator;

	if (SandboxDenominator != nullptr)
		*SandboxDenominator = Parms.SandboxDenominator;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetLatestLargeMapWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULargeMapViewWidget*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULargeMapViewWidget* UCharMapComponent::GetLatestLargeMapWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetLatestLargeMapWidget");

	Params::UCharMapComponent_GetLatestLargeMapWidget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetDungeons
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              ZoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADungeon*>            Dungeons                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharMapComponent::GetDungeons(int32 ZoneIndex, TArray<class ADungeon*>* Dungeons)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetDungeons");

	Params::UCharMapComponent_GetDungeons_Params Parms{};

	Parms.ZoneIndex = ZoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Dungeons != nullptr)
		*Dungeons = std::move(Parms.Dungeons);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetDungeonCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              ZoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MainNumerator                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MainDenominator                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OptionalNumerator                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OptionalDenominator                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharMapComponent::GetDungeonCounts(int32 ZoneIndex, int32* MainNumerator, int32* MainDenominator, int32* OptionalNumerator, int32* OptionalDenominator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetDungeonCounts");

	Params::UCharMapComponent_GetDungeonCounts_Params Parms{};

	Parms.ZoneIndex = ZoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (MainNumerator != nullptr)
		*MainNumerator = Parms.MainNumerator;

	if (MainDenominator != nullptr)
		*MainDenominator = Parms.MainDenominator;

	if (OptionalNumerator != nullptr)
		*OptionalNumerator = Parms.OptionalNumerator;

	if (OptionalDenominator != nullptr)
		*OptionalDenominator = Parms.OptionalDenominator;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharMapComponent.GetBlueOrbCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              ZoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CampaignNumerator                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CampaignDenominator                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SideQuestNumerator                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SideQuestDenominator                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PuzzleNumerator                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PuzzleDenominator                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharMapComponent::GetBlueOrbCounts(int32 ZoneIndex, int32* CampaignNumerator, int32* CampaignDenominator, int32* SideQuestNumerator, int32* SideQuestDenominator, int32* PuzzleNumerator, int32* PuzzleDenominator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharMapComponent", "GetBlueOrbCounts");

	Params::UCharMapComponent_GetBlueOrbCounts_Params Parms{};

	Parms.ZoneIndex = ZoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CampaignNumerator != nullptr)
		*CampaignNumerator = Parms.CampaignNumerator;

	if (CampaignDenominator != nullptr)
		*CampaignDenominator = Parms.CampaignDenominator;

	if (SideQuestNumerator != nullptr)
		*SideQuestNumerator = Parms.SideQuestNumerator;

	if (SideQuestDenominator != nullptr)
		*SideQuestDenominator = Parms.SideQuestDenominator;

	if (PuzzleNumerator != nullptr)
		*PuzzleNumerator = Parms.PuzzleNumerator;

	if (PuzzleDenominator != nullptr)
		*PuzzleDenominator = Parms.PuzzleDenominator;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.CharPowerComponent
// (None)

class UClass* UCharPowerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharPowerComponent");

	return Clss;
}


// CharPowerComponent IslandsofInsight.Default__CharPowerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharPowerComponent* UCharPowerComponent::GetDefaultObj()
{
	static class UCharPowerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharPowerComponent*>(UCharPowerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharPowerComponent.Server_ShowNode
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:

void UCharPowerComponent::Server_ShowNode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "Server_ShowNode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPowerComponent.Server_PlaceNode
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FVector                     Loc                                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPowerComponent::Server_PlaceNode(struct FVector& Loc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "Server_PlaceNode");

	Params::UCharPowerComponent_Server_PlaceNode_Params Parms{};

	Parms.Loc = Loc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPowerComponent.Server_Cancel
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:

void UCharPowerComponent::Server_Cancel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "Server_Cancel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPowerComponent.Server_addLaser
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class AActor*                      Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UseImpactPoint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactPoint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               PrioritizeImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         TargetComponent                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPowerComponent::Server_addLaser(class AActor* Target, bool UseImpactPoint, const struct FVector& ImpactPoint, bool PrioritizeImpactPoint, class UPrimitiveComponent* TargetComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "Server_addLaser");

	Params::UCharPowerComponent_Server_addLaser_Params Parms{};

	Parms.Target = Target;
	Parms.UseImpactPoint = UseImpactPoint;
	Parms.ImpactPoint = ImpactPoint;
	Parms.PrioritizeImpactPoint = PrioritizeImpactPoint;
	Parms.TargetComponent = TargetComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPowerComponent.OnRep_PowerPole
// (Final, Native, Private)
// Parameters:
// class APowerPole*                  Old                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPowerComponent::OnRep_PowerPole(class APowerPole* Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "OnRep_PowerPole");

	Params::UCharPowerComponent_OnRep_PowerPole_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPowerComponent.inPowerMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharPowerComponent::InPowerMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "inPowerMode");

	Params::UCharPowerComponent_InPowerMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPowerComponent.CheatAddLaser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         Comp                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPowerComponent::CheatAddLaser(class AActor* Puzzle, class UPrimitiveComponent* Comp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPowerComponent", "CheatAddLaser");

	Params::UCharPowerComponent_CheatAddLaser_Params Parms{};

	Parms.Puzzle = Puzzle;
	Parms.Comp = Comp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CharPuzzleComponent
// (None)

class UClass* UCharPuzzleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharPuzzleComponent");

	return Clss;
}


// CharPuzzleComponent IslandsofInsight.Default__CharPuzzleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharPuzzleComponent* UCharPuzzleComponent::GetDefaultObj()
{
	static class UCharPuzzleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharPuzzleComponent*>(UCharPuzzleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharPuzzleComponent.Server_UpdatePuzzleProgress
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APuzzleBase*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SolverKrakenId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SerializedProgress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_UpdatePuzzleProgress(class APuzzleBase* Puzzle, const class FString& SolverKrakenId, const class FString& SerializedProgress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_UpdatePuzzleProgress");

	Params::UCharPuzzleComponent_Server_UpdatePuzzleProgress_Params Parms{};

	Parms.Puzzle = Puzzle;
	Parms.SolverKrakenId = SolverKrakenId;
	Parms.SerializedProgress = SerializedProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_ToggleMultiplayerLaserPuzzleTarget
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UMultiplayerLaserTarget*     T                                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_ToggleMultiplayerLaserPuzzleTarget(class UMultiplayerLaserTarget* T)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_ToggleMultiplayerLaserPuzzleTarget");

	Params::UCharPuzzleComponent_Server_ToggleMultiplayerLaserPuzzleTarget_Params Parms{};

	Parms.T = T;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SpawnGravProjectiles
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AGravityBallBase*            PuzzleActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SpawnGravProjectiles(struct FVector& Location, struct FRotator& Rotation, class AGravityBallBase* PuzzleActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SpawnGravProjectiles");

	Params::UCharPuzzleComponent_Server_SpawnGravProjectiles_Params Parms{};

	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.PuzzleActor = PuzzleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SetRyoanjiLastSolveLoc
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class ARyoanjiPuzzle*              P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Loc                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SetRyoanjiLastSolveLoc(class ARyoanjiPuzzle* P, const struct FVector2D& Loc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SetRyoanjiLastSolveLoc");

	Params::UCharPuzzleComponent_Server_SetRyoanjiLastSolveLoc_Params Parms{};

	Parms.P = P;
	Parms.Loc = Loc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SetRosaryTeam
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARosary*                     P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Team                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SetRosaryTeam(class ARosary* P, int32 Team)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SetRosaryTeam");

	Params::UCharPuzzleComponent_Server_SetRosaryTeam_Params Parms{};

	Parms.P = P;
	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SendSolved
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APuzzleBase*                 P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SolveTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Multiplier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    EventData                                                        (Parm, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SendSolved(class APuzzleBase* P, float SolveTime, float Multiplier, const struct FBhvrAnalyticsEvent_Base& EventData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SendSolved");

	Params::UCharPuzzleComponent_Server_SendSolved_Params Parms{};

	Parms.P = P;
	Parms.SolveTime = SolveTime;
	Parms.Multiplier = Multiplier;
	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SendReset
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APuzzleBase*                 P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SendReset(class APuzzleBase* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SendReset");

	Params::UCharPuzzleComponent_Server_SendReset_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_SendFractalJigsawMove
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AFractalJigsaw*              FractalJigsaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFractalJigsawMove          Move                                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_SendFractalJigsawMove(class AFractalJigsaw* FractalJigsaw, struct FFractalJigsawMove& Move)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_SendFractalJigsawMove");

	Params::UCharPuzzleComponent_Server_SendFractalJigsawMove_Params Parms{};

	Parms.FractalJigsaw = FractalJigsaw;
	Parms.Move = Move;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_RollCube
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARollingCubeGridBase*        P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Direction                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_RollCube(class ARollingCubeGridBase* P, int32 Direction, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_RollCube");

	Params::UCharPuzzleComponent_Server_RollCube_Params Parms{};

	Parms.P = P;
	Parms.Direction = Direction;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_MoveKlotskiBlock
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class AKlotskiPuzzle*              P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                   Direction                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_MoveKlotskiBlock(class AKlotskiPuzzle* P, const struct FIntPoint& Direction, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_MoveKlotskiBlock");

	Params::UCharPuzzleComponent_Server_MoveKlotskiBlock_Params Parms{};

	Parms.P = P;
	Parms.Direction = Direction;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_ClaimFocusablePuzzle
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AFocusablePuzzle*            P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SeatingDown                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SeatIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_ClaimFocusablePuzzle(class AFocusablePuzzle* P, bool SeatingDown, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_ClaimFocusablePuzzle");

	Params::UCharPuzzleComponent_Server_ClaimFocusablePuzzle_Params Parms{};

	Parms.P = P;
	Parms.SeatingDown = SeatingDown;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_ClaimCube
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARollingCubeGridBase*        P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CLAIM                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SOLVED                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_ClaimCube(class ARollingCubeGridBase* P, int32 Index, bool CLAIM, bool SOLVED)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_ClaimCube");

	Params::UCharPuzzleComponent_Server_ClaimCube_Params Parms{};

	Parms.P = P;
	Parms.Index = Index;
	Parms.CLAIM = CLAIM;
	Parms.SOLVED = SOLVED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Server_AddRemovePuzzleWorker
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AMultiplayerPuzzleBase*      P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Add                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Server_AddRemovePuzzleWorker(class AMultiplayerPuzzleBase* P, bool Add)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Server_AddRemovePuzzleWorker");

	Params::UCharPuzzleComponent_Server_AddRemovePuzzleWorker_Params Parms{};

	Parms.P = P;
	Parms.Add = Add;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Multicast_SpawnGravProjectiles
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AGravityBallBase*            PuzzleActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Multicast_SpawnGravProjectiles(struct FVector& Location, struct FRotator& Rotation, class AGravityBallBase* PuzzleActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Multicast_SpawnGravProjectiles");

	Params::UCharPuzzleComponent_Multicast_SpawnGravProjectiles_Params Parms{};

	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.PuzzleActor = PuzzleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.GetCurrentSeek5
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASeek5*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASeek5* UCharPuzzleComponent::GetCurrentSeek5()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "GetCurrentSeek5");

	Params::UCharPuzzleComponent_GetCurrentSeek5_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPuzzleComponent.GetCurrentRacingPuzzles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARacingPuzzle*>       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARacingPuzzle*> UCharPuzzleComponent::GetCurrentRacingPuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "GetCurrentRacingPuzzles");

	Params::UCharPuzzleComponent_GetCurrentRacingPuzzles_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPuzzleComponent.GetCurrentRacingBalls
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARacingBalls*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARacingBalls* UCharPuzzleComponent::GetCurrentRacingBalls()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "GetCurrentRacingBalls");

	Params::UCharPuzzleComponent_GetCurrentRacingBalls_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPuzzleComponent.GetCurrentMirrorMaze
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMirrorMazePuzzle*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMirrorMazePuzzle* UCharPuzzleComponent::GetCurrentMirrorMaze()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "GetCurrentMirrorMaze");

	Params::UCharPuzzleComponent_GetCurrentMirrorMaze_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPuzzleComponent.GetAllActiveSeek5s
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ASeek5*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASeek5*> UCharPuzzleComponent::GetAllActiveSeek5s()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "GetAllActiveSeek5s");

	Params::UCharPuzzleComponent_GetAllActiveSeek5s_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.CharPuzzleComponent.Client_OnSolveMultiplayerPuzzle
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APuzzleBase*                 Mp                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Client_OnSolveMultiplayerPuzzle(class APuzzleBase* Mp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Client_OnSolveMultiplayerPuzzle");

	Params::UCharPuzzleComponent_Client_OnSolveMultiplayerPuzzle_Params Parms{};

	Parms.Mp = Mp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.Client_OnReceivePartyReward
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APuzzleBase*                 Pb                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Reward                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharPuzzleComponent::Client_OnReceivePartyReward(class APuzzleBase* Pb, int32 Reward)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "Client_OnReceivePartyReward");

	Params::UCharPuzzleComponent_Client_OnReceivePartyReward_Params Parms{};

	Parms.Pb = Pb;
	Parms.Reward = Reward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharPuzzleComponent.CancelRaceAndPathPuzzles
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCharPuzzleComponent::CancelRaceAndPathPuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharPuzzleComponent", "CancelRaceAndPathPuzzles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.CharSpiritComponent
// (None)

class UClass* UCharSpiritComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharSpiritComponent");

	return Clss;
}


// CharSpiritComponent IslandsofInsight.Default__CharSpiritComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharSpiritComponent* UCharSpiritComponent::GetDefaultObj()
{
	static class UCharSpiritComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharSpiritComponent*>(UCharSpiritComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CharSpiritComponent.Server_TurnOnSpiritMode
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                     PlayerLoc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharSpiritComponent::Server_TurnOnSpiritMode(const struct FVector& PlayerLoc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharSpiritComponent", "Server_TurnOnSpiritMode");

	Params::UCharSpiritComponent_Server_TurnOnSpiritMode_Params Parms{};

	Parms.PlayerLoc = PlayerLoc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharSpiritComponent.Server_GemOverlap
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ASpiritGem*                  Gem                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharSpiritComponent::Server_GemOverlap(class ASpiritGem* Gem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharSpiritComponent", "Server_GemOverlap");

	Params::UCharSpiritComponent_Server_GemOverlap_Params Parms{};

	Parms.Gem = Gem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.CharSpiritComponent.OnRep_inSpiritMode
// (Final, Native, Protected)
// Parameters:
// bool                               Old                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharSpiritComponent::OnRep_inSpiritMode(bool Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharSpiritComponent", "OnRep_inSpiritMode");

	Params::UCharSpiritComponent_OnRep_inSpiritMode_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.ItemPickup
// (Actor)

class UClass* AItemPickup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ItemPickup");

	return Clss;
}


// ItemPickup IslandsofInsight.Default__ItemPickup
// (Public, ClassDefaultObject, ArchetypeObject)

class AItemPickup* AItemPickup::GetDefaultObj()
{
	static class AItemPickup* Default = nullptr;

	if (!Default)
		Default = static_cast<AItemPickup*>(AItemPickup::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Chest
// (Actor)

class UClass* AChest::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Chest");

	return Clss;
}


// Chest IslandsofInsight.Default__Chest
// (Public, ClassDefaultObject, ArchetypeObject)

class AChest* AChest::GetDefaultObj()
{
	static class AChest* Default = nullptr;

	if (!Default)
		Default = static_cast<AChest*>(AChest::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ClickableThroughWallBase
// (Actor)

class UClass* AClickableThroughWallBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ClickableThroughWallBase");

	return Clss;
}


// ClickableThroughWallBase IslandsofInsight.Default__ClickableThroughWallBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AClickableThroughWallBase* AClickableThroughWallBase::GetDefaultObj()
{
	static class AClickableThroughWallBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AClickableThroughWallBase*>(AClickableThroughWallBase::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ClueUtil
// (None)

class UClass* UClueUtil::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ClueUtil");

	return Clss;
}


// ClueUtil IslandsofInsight.Default__ClueUtil
// (Public, ClassDefaultObject, ArchetypeObject)

class UClueUtil* UClueUtil::GetDefaultObj()
{
	static class UClueUtil* Default = nullptr;

	if (!Default)
		Default = static_cast<UClueUtil*>(UClueUtil::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CoinAccessWidget
// (None)

class UClass* UCoinAccessWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CoinAccessWidget");

	return Clss;
}


// CoinAccessWidget IslandsofInsight.Default__CoinAccessWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCoinAccessWidget* UCoinAccessWidget::GetDefaultObj()
{
	static class UCoinAccessWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCoinAccessWidget*>(UCoinAccessWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CoinAccessWidget.BPC_GetCoinsInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              AdditionalCoins                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TotalCoins                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoinAccessWidget::BPC_GetCoinsInfo(int32* AdditionalCoins, int32* TotalCoins)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CoinAccessWidget", "BPC_GetCoinsInfo");

	Params::UCoinAccessWidget_BPC_GetCoinsInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (AdditionalCoins != nullptr)
		*AdditionalCoins = Parms.AdditionalCoins;

	if (TotalCoins != nullptr)
		*TotalCoins = Parms.TotalCoins;

}


// Class IslandsofInsight.CompleteThePatternGenerator
// (None)

class UClass* UCompleteThePatternGenerator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CompleteThePatternGenerator");

	return Clss;
}


// CompleteThePatternGenerator IslandsofInsight.Default__CompleteThePatternGenerator
// (Public, ClassDefaultObject, ArchetypeObject)

class UCompleteThePatternGenerator* UCompleteThePatternGenerator::GetDefaultObj()
{
	static class UCompleteThePatternGenerator* Default = nullptr;

	if (!Default)
		Default = static_cast<UCompleteThePatternGenerator*>(UCompleteThePatternGenerator::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.CompleteThePatternGenerator.GenerateManyAndWriteToFiles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Num                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompleteThePatternGenerator::GenerateManyAndWriteToFiles(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CompleteThePatternGenerator", "GenerateManyAndWriteToFiles");

	Params::UCompleteThePatternGenerator_GenerateManyAndWriteToFiles_Params Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.Connected
// (None)

class UClass* UConnected::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Connected");

	return Clss;
}


// Connected IslandsofInsight.Default__Connected
// (Public, ClassDefaultObject, ArchetypeObject)

class UConnected* UConnected::GetDefaultObj()
{
	static class UConnected* Default = nullptr;

	if (!Default)
		Default = static_cast<UConnected*>(UConnected::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaGameMode
// (Actor)

class UClass* ASophiaGameMode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaGameMode");

	return Clss;
}


// SophiaGameMode IslandsofInsight.Default__SophiaGameMode
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaGameMode* ASophiaGameMode::GetDefaultObj()
{
	static class ASophiaGameMode* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaGameMode*>(ASophiaGameMode::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaGameMode.SpawnAirDrop
// (Final, Native, Public)
// Parameters:
// int8                               Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaGameMode::SpawnAirDrop(int8 Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameMode", "SpawnAirDrop");

	Params::ASophiaGameMode_SpawnAirDrop_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameMode.GetGameStartType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EGameStartType          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EGameStartType ASophiaGameMode::GetGameStartType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameMode", "GetGameStartType");

	Params::ASophiaGameMode_GetGameStartType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameMode.GetAverageFPS
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASophiaGameMode::GetAverageFPS()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameMode", "GetAverageFPS");

	Params::ASophiaGameMode_GetAverageFPS_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameMode.CreateHostBeacon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameMode::CreateHostBeacon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameMode", "CreateHostBeacon");

	Params::ASophiaGameMode_CreateHostBeacon_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameMode.BlockTillLevelStreamingCompleted
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:

void ASophiaGameMode::BlockTillLevelStreamingCompleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameMode", "BlockTillLevelStreamingCompleted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.ConquestGameMode
// (Actor)

class UClass* AConquestGameMode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestGameMode");

	return Clss;
}


// ConquestGameMode IslandsofInsight.Default__ConquestGameMode
// (Public, ClassDefaultObject, ArchetypeObject)

class AConquestGameMode* AConquestGameMode::GetDefaultObj()
{
	static class AConquestGameMode* Default = nullptr;

	if (!Default)
		Default = static_cast<AConquestGameMode*>(AConquestGameMode::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaGameState
// (Actor)

class UClass* ASophiaGameState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaGameState");

	return Clss;
}


// SophiaGameState IslandsofInsight.Default__SophiaGameState
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaGameState* ASophiaGameState::GetDefaultObj()
{
	static class ASophiaGameState* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaGameState*>(ASophiaGameState::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaGameState.ServerExclusive_SendAllFeedMessages
// (Final, Native, Protected)
// Parameters:

void ASophiaGameState::ServerExclusive_SendAllFeedMessages()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "ServerExclusive_SendAllFeedMessages");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.ServerExclusive_AddGlobalFeedMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FFeedMessage                Msg                                                              (Parm, NativeAccessSpecifierPublic)

void ASophiaGameState::ServerExclusive_AddGlobalFeedMessage(const struct FFeedMessage& Msg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "ServerExclusive_AddGlobalFeedMessage");

	Params::ASophiaGameState_ServerExclusive_AddGlobalFeedMessage_Params Parms{};

	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.RestartServer
// (Native, Public, BlueprintCallable)
// Parameters:

void ASophiaGameState::RestartServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "RestartServer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.OnRep_PuzzleSetupComplete
// (Final, Native, Public)
// Parameters:

void ASophiaGameState::OnRep_PuzzleSetupComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "OnRep_PuzzleSetupComplete");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.NetMultiCast_AddFeedMessage
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// TArray<struct FFeedMessage>        FeedMessages                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaGameState::NetMultiCast_AddFeedMessage(TArray<struct FFeedMessage>& FeedMessages)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "NetMultiCast_AddFeedMessage");

	Params::ASophiaGameState_NetMultiCast_AddFeedMessage_Params Parms{};

	Parms.FeedMessages = FeedMessages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.InitDungeonsAfterSpawn
// (Final, Native, Protected)
// Parameters:

void ASophiaGameState::InitDungeonsAfterSpawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "InitDungeonsAfterSpawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.InitDungeons
// (Final, Native, Protected)
// Parameters:

void ASophiaGameState::InitDungeons()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "InitDungeons");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.GetSpiritModeEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameState::GetSpiritModeEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetSpiritModeEnabled");

	Params::ASophiaGameState_GetSpiritModeEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetSecretForEntryId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      EntryId                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASecretSignifier*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASecretSignifier* ASophiaGameState::GetSecretForEntryId(const class FString& EntryId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetSecretForEntryId");

	Params::ASophiaGameState_GetSecretForEntryId_Params Parms{};

	Parms.EntryId = EntryId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetPolesEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameState::GetPolesEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetPolesEnabled");

	Params::ASophiaGameState_GetPolesEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetPoleGivesSolverPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameState::GetPoleGivesSolverPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetPoleGivesSolverPoints");

	Params::ASophiaGameState_GetPoleGivesSolverPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetPlayerByKrakenId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      KrakenUserId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaPlayerState*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASophiaPlayerState* ASophiaGameState::GetPlayerByKrakenId(const class FString& KrakenUserId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetPlayerByKrakenId");

	Params::ASophiaGameState_GetPlayerByKrakenId_Params Parms{};

	Parms.KrakenUserId = KrakenUserId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetPlacePoweredPolesOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameState::GetPlacePoweredPolesOnly()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetPlacePoweredPolesOnly");

	Params::ASophiaGameState_GetPlacePoweredPolesOnly_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetMapCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMapCamera*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMapCamera* ASophiaGameState::GetMapCamera()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetMapCamera");

	Params::ASophiaGameState_GetMapCamera_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetGameStartType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EGameStartType          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EGameStartType ASophiaGameState::GetGameStartType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetGameStartType");

	Params::ASophiaGameState_GetGameStartType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetGameModeType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EGameModeType           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EGameModeType ASophiaGameState::GetGameModeType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetGameModeType");

	Params::ASophiaGameState_GetGameModeType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetForbidPowerCycles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaGameState::GetForbidPowerCycles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetForbidPowerCycles");

	Params::ASophiaGameState_GetForbidPowerCycles_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.GetConquestVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpawnOverrideVolume*        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpawnOverrideVolume* ASophiaGameState::GetConquestVolume(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "GetConquestVolume");

	Params::ASophiaGameState_GetConquestVolume_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.ForceStartMatch
// (Native, Public, BlueprintCallable)
// Parameters:

void ASophiaGameState::ForceStartMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "ForceStartMatch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameState.BPC_getActivePuzzlesInMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      KrakenType                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APuzzleBase*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APuzzleBase*> ASophiaGameState::BPC_getActivePuzzlesInMap(const class FString& KrakenType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "BPC_getActivePuzzlesInMap");

	Params::ASophiaGameState_BPC_getActivePuzzlesInMap_Params Parms{};

	Parms.KrakenType = KrakenType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameState.BP_OnGameEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASophiaCharacter*            Victor                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaGameState::BP_OnGameEnd(class ASophiaCharacter* Victor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameState", "BP_OnGameEnd");

	Params::ASophiaGameState_BP_OnGameEnd_Params Parms{};

	Parms.Victor = Victor;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.ConquestGameState
// (Actor)

class UClass* AConquestGameState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestGameState");

	return Clss;
}


// ConquestGameState IslandsofInsight.Default__ConquestGameState
// (Public, ClassDefaultObject, ArchetypeObject)

class AConquestGameState* AConquestGameState::GetDefaultObj()
{
	static class AConquestGameState* Default = nullptr;

	if (!Default)
		Default = static_cast<AConquestGameState*>(AConquestGameState::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ConquestGameState.ProcessWinningTeamInEachAreaChanges
// (Final, Native, Protected)
// Parameters:

void AConquestGameState::ProcessWinningTeamInEachAreaChanges()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "ProcessWinningTeamInEachAreaChanges");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.OnRep_TeamRedScore
// (Final, Native, Protected)
// Parameters:
// int32                              PrevScore                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConquestGameState::OnRep_TeamRedScore(int32 PrevScore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "OnRep_TeamRedScore");

	Params::AConquestGameState_OnRep_TeamRedScore_Params Parms{};

	Parms.PrevScore = PrevScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.OnRep_TeamBlueScore
// (Final, Native, Protected)
// Parameters:
// int32                              PrevScore                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConquestGameState::OnRep_TeamBlueScore(int32 PrevScore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "OnRep_TeamBlueScore");

	Params::AConquestGameState_OnRep_TeamBlueScore_Params Parms{};

	Parms.PrevScore = PrevScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.OnRep_MatchStarted
// (Native, Protected)
// Parameters:

void AConquestGameState::OnRep_MatchStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "OnRep_MatchStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.OnRep_GameOver
// (Native, Protected)
// Parameters:

void AConquestGameState::OnRep_GameOver()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "OnRep_GameOver");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.NetMulticast_ShowCore
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class APowerCore*                  Core                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConquestGameState::NetMulticast_ShowCore(class APowerCore* Core)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "NetMulticast_ShowCore");

	Params::AConquestGameState_NetMulticast_ShowCore_Params Parms{};

	Parms.Core = Core;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestGameState.GetWinningTeamInEachArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> AConquestGameState::GetWinningTeamInEachArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetWinningTeamInEachArea");

	Params::AConquestGameState_GetWinningTeamInEachArea_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetTeamScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              TeamIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetTeamScore(int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetTeamScore");

	Params::AConquestGameState_GetTeamScore_Params Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetNumZonesTeamRed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AConquestGameState::GetNumZonesTeamRed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetNumZonesTeamRed");

	Params::AConquestGameState_GetNumZonesTeamRed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetNumZonesTeamBlue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AConquestGameState::GetNumZonesTeamBlue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetNumZonesTeamBlue");

	Params::AConquestGameState_GetNumZonesTeamBlue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetMatchStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConquestGameState::GetMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetMatchStarted");

	Params::AConquestGameState_GetMatchStarted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetIsGameOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConquestGameState::GetIsGameOver()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetIsGameOver");

	Params::AConquestGameState_GetIsGameOver_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetGameOverTimerInSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetGameOverTimerInSeconds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetGameOverTimerInSeconds");

	Params::AConquestGameState_GetGameOverTimerInSeconds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetCountDownTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetCountDownTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetCountDownTime");

	Params::AConquestGameState_GetCountDownTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetCountdownStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConquestGameState::GetCountdownStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetCountdownStarted");

	Params::AConquestGameState_GetCountdownStarted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetCoopTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetCoopTimeLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetCoopTimeLeft");

	Params::AConquestGameState_GetCoopTimeLeft_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetCoopScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetCoopScore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetCoopScore");

	Params::AConquestGameState_GetCoopScore_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetConquestScoreType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EConquestScoreType      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EConquestScoreType AConquestGameState::GetConquestScoreType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetConquestScoreType");

	Params::AConquestGameState_GetConquestScoreType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetConquestScoreNeededToWin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetConquestScoreNeededToWin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetConquestScoreNeededToWin");

	Params::AConquestGameState_GetConquestScoreNeededToWin_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetConquestPoleEnableTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AConquestGameState::GetConquestPoleEnableTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetConquestPoleEnableTimer");

	Params::AConquestGameState_GetConquestPoleEnableTimer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetConquestItemsEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConquestGameState::GetConquestItemsEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetConquestItemsEnabled");

	Params::AConquestGameState_GetConquestItemsEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestGameState.GetAllPowerCores
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APowerCore*>          ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class APowerCore*> AConquestGameState::GetAllPowerCores()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestGameState", "GetAllPowerCores");

	Params::AConquestGameState_GetAllPowerCores_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.ConquestGlobalProgressBar
// (None)

class UClass* UConquestGlobalProgressBar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestGlobalProgressBar");

	return Clss;
}


// ConquestGlobalProgressBar IslandsofInsight.Default__ConquestGlobalProgressBar
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestGlobalProgressBar* UConquestGlobalProgressBar::GetDefaultObj()
{
	static class UConquestGlobalProgressBar* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestGlobalProgressBar*>(UConquestGlobalProgressBar::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ConquestHUDInformationWidget
// (None)

class UClass* UConquestHUDInformationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestHUDInformationWidget");

	return Clss;
}


// ConquestHUDInformationWidget IslandsofInsight.Default__ConquestHUDInformationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestHUDInformationWidget* UConquestHUDInformationWidget::GetDefaultObj()
{
	static class UConquestHUDInformationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestHUDInformationWidget*>(UConquestHUDInformationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeZoneWithIndex
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RedProgress                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              blueProgress                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                CaptureColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ZoneShortName                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               CompletedFully                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeZoneWithIndex(int32 Index, bool bShow, float RedProgress, float blueProgress, const struct FLinearColor& CaptureColor, class FText& ZoneShortName, bool CompletedFully)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeZoneWithIndex");

	Params::UConquestHUDInformationWidget_BP_VisualizeZoneWithIndex_Params Parms{};

	Parms.Index = Index;
	Parms.bShow = bShow;
	Parms.RedProgress = RedProgress;
	Parms.blueProgress = blueProgress;
	Parms.CaptureColor = CaptureColor;
	Parms.ZoneShortName = ZoneShortName;
	Parms.CompletedFully = CompletedFully;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeLocalZone
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// bool                               Show                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RedProgress                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              blueProgress                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                CaptureColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ZoneShortName                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               CompletedFully                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeLocalZone(bool Show, float RedProgress, float blueProgress, const struct FLinearColor& CaptureColor, class FText& ZoneShortName, bool CompletedFully)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeLocalZone");

	Params::UConquestHUDInformationWidget_BP_VisualizeLocalZone_Params Parms{};

	Parms.Show = Show;
	Parms.RedProgress = RedProgress;
	Parms.blueProgress = blueProgress;
	Parms.CaptureColor = CaptureColor;
	Parms.ZoneShortName = ZoneShortName;
	Parms.CompletedFully = CompletedFully;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeLocalPlayerTeam
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               IsRedTeam                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeLocalPlayerTeam(bool IsRedTeam)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeLocalPlayerTeam");

	Params::UConquestHUDInformationWidget_BP_VisualizeLocalPlayerTeam_Params Parms{};

	Parms.IsRedTeam = IsRedTeam;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeGlobalScore
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              RedPercentage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BluePercentage                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeGlobalScore(float RedPercentage, float BluePercentage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeGlobalScore");

	Params::UConquestHUDInformationWidget_BP_VisualizeGlobalScore_Params Parms{};

	Parms.RedPercentage = RedPercentage;
	Parms.BluePercentage = BluePercentage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeCoopScore
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                              Score                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              RedSolvedNum                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              blueSolvedNum                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeCoopScore(int32 Score, int32 Time, int32 RedSolvedNum, int32 blueSolvedNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeCoopScore");

	Params::UConquestHUDInformationWidget_BP_VisualizeCoopScore_Params Parms{};

	Parms.Score = Score;
	Parms.Time = Time;
	Parms.RedSolvedNum = RedSolvedNum;
	Parms.blueSolvedNum = blueSolvedNum;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ConquestHUDInformationWidget.BP_VisualizeCoopClosestPeople
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FConquestPersonPerformanceInformation>SortedInfos                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UConquestHUDInformationWidget::BP_VisualizeCoopClosestPeople(TArray<struct FConquestPersonPerformanceInformation>& SortedInfos)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestHUDInformationWidget", "BP_VisualizeCoopClosestPeople");

	Params::UConquestHUDInformationWidget_BP_VisualizeCoopClosestPeople_Params Parms{};

	Parms.SortedInfos = SortedInfos;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.ConquestLeaderboardWidget
// (None)

class UClass* UConquestLeaderboardWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestLeaderboardWidget");

	return Clss;
}


// ConquestLeaderboardWidget IslandsofInsight.Default__ConquestLeaderboardWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestLeaderboardWidget* UConquestLeaderboardWidget::GetDefaultObj()
{
	static class UConquestLeaderboardWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestLeaderboardWidget*>(UConquestLeaderboardWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ConquestLocalProgressBar
// (None)

class UClass* UConquestLocalProgressBar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestLocalProgressBar");

	return Clss;
}


// ConquestLocalProgressBar IslandsofInsight.Default__ConquestLocalProgressBar
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestLocalProgressBar* UConquestLocalProgressBar::GetDefaultObj()
{
	static class UConquestLocalProgressBar* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestLocalProgressBar*>(UConquestLocalProgressBar::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ConquestNotificationWidget
// (None)

class UClass* UConquestNotificationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestNotificationWidget");

	return Clss;
}


// ConquestNotificationWidget IslandsofInsight.Default__ConquestNotificationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestNotificationWidget* UConquestNotificationWidget::GetDefaultObj()
{
	static class UConquestNotificationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestNotificationWidget*>(UConquestNotificationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ConquestRecordComponent
// (None)

class UClass* UConquestRecordComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestRecordComponent");

	return Clss;
}


// ConquestRecordComponent IslandsofInsight.Default__ConquestRecordComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UConquestRecordComponent* UConquestRecordComponent::GetDefaultObj()
{
	static class UConquestRecordComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UConquestRecordComponent*>(UConquestRecordComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ConquestRecordComponent.ResetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UConquestRecordComponent::ResetData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "ResetData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestRecordComponent.RandomSelectAwards
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FConquestAwardInfo>  Awards                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              DesiredMin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              DesiredMax                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FConquestAwardInfo>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FConquestAwardInfo> UConquestRecordComponent::RandomSelectAwards(TArray<struct FConquestAwardInfo>& Awards, int32 DesiredMin, int32 DesiredMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "RandomSelectAwards");

	Params::UConquestRecordComponent_RandomSelectAwards_Params Parms{};

	Parms.Awards = Awards;
	Parms.DesiredMin = DesiredMin;
	Parms.DesiredMax = DesiredMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestRecordComponent.PreprocessAwards
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FConquestAwardInfo>  Raws                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FConquestAwardInfo>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FConquestAwardInfo> UConquestRecordComponent::PreprocessAwards(TArray<struct FConquestAwardInfo>& Raws)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "PreprocessAwards");

	Params::UConquestRecordComponent_PreprocessAwards_Params Parms{};

	Parms.Raws = Raws;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestRecordComponent.NotifyPuzzleSolved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APuzzleBase*                 ThePuzzle                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestRecordComponent::NotifyPuzzleSolved(class APuzzleBase* ThePuzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "NotifyPuzzleSolved");

	Params::UConquestRecordComponent_NotifyPuzzleSolved_Params Parms{};

	Parms.ThePuzzle = ThePuzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestRecordComponent.NotifyPlayerMoved
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaPosition                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestRecordComponent::NotifyPlayerMoved(const struct FVector& DeltaPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "NotifyPlayerMoved");

	Params::UConquestRecordComponent_NotifyPlayerMoved_Params Parms{};

	Parms.DeltaPosition = DeltaPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestRecordComponent.NotifyMasteryBeforeUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlayerMastery*              TheMastery                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestRecordComponent::NotifyMasteryBeforeUpdate(class UPlayerMastery* TheMastery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "NotifyMasteryBeforeUpdate");

	Params::UConquestRecordComponent_NotifyMasteryBeforeUpdate_Params Parms{};

	Parms.TheMastery = TheMastery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestRecordComponent.NotifyMasteryAfterUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlayerMastery*              TheMastery                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConquestRecordComponent::NotifyMasteryAfterUpdate(class UPlayerMastery* TheMastery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "NotifyMasteryAfterUpdate");

	Params::UConquestRecordComponent_NotifyMasteryAfterUpdate_Params Parms{};

	Parms.TheMastery = TheMastery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ConquestRecordComponent.GetOwnerClientside
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASophiaCharacter* UConquestRecordComponent::GetOwnerClientside()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "GetOwnerClientside");

	Params::UConquestRecordComponent_GetOwnerClientside_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestRecordComponent.GetMasterySnapshots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FMasterySnapshot>    ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<struct FMasterySnapshot> UConquestRecordComponent::GetMasterySnapshots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "GetMasterySnapshots");

	Params::UConquestRecordComponent_GetMasterySnapshots_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ConquestRecordComponent.GenerateAwardsRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FConquestAwardInfo>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FConquestAwardInfo> UConquestRecordComponent::GenerateAwardsRaw()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ConquestRecordComponent", "GenerateAwardsRaw");

	Params::UConquestRecordComponent_GenerateAwardsRaw_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.COWYCVolume
// (Actor)

class UClass* ACOWYCVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("COWYCVolume");

	return Clss;
}


// COWYCVolume IslandsofInsight.Default__COWYCVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACOWYCVolume* ACOWYCVolume::GetDefaultObj()
{
	static class ACOWYCVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACOWYCVolume*>(ACOWYCVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Crosshair
// (None)

class UClass* UCrosshair::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Crosshair");

	return Clss;
}


// Crosshair IslandsofInsight.Default__Crosshair
// (Public, ClassDefaultObject, ArchetypeObject)

class UCrosshair* UCrosshair::GetDefaultObj()
{
	static class UCrosshair* Default = nullptr;

	if (!Default)
		Default = static_cast<UCrosshair*>(UCrosshair::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Crosshair.HasLookTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrosshair::HasLookTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crosshair", "HasLookTarget");

	Params::UCrosshair_HasLookTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.CustomRichTextBlockImageDecorator
// (None)

class UClass* UCustomRichTextBlockImageDecorator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CustomRichTextBlockImageDecorator");

	return Clss;
}


// CustomRichTextBlockImageDecorator IslandsofInsight.Default__CustomRichTextBlockImageDecorator
// (Public, ClassDefaultObject, ArchetypeObject)

class UCustomRichTextBlockImageDecorator* UCustomRichTextBlockImageDecorator::GetDefaultObj()
{
	static class UCustomRichTextBlockImageDecorator* Default = nullptr;

	if (!Default)
		Default = static_cast<UCustomRichTextBlockImageDecorator*>(UCustomRichTextBlockImageDecorator::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzlePanel
// (Actor)

class UClass* APuzzlePanel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzlePanel");

	return Clss;
}


// PuzzlePanel IslandsofInsight.Default__PuzzlePanel
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzlePanel* APuzzlePanel::GetDefaultObj()
{
	static class APuzzlePanel* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzlePanel*>(APuzzlePanel::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzlePanel.PuzzleRCToScreenXY
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   PuzzleRC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bApplyInverseDPI                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bGray                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D APuzzlePanel::PuzzleRCToScreenXY(const struct FVector2D& PuzzleRC, bool bApplyInverseDPI, bool bGray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "PuzzleRCToScreenXY");

	Params::APuzzlePanel_PuzzleRCToScreenXY_Params Parms{};

	Parms.PuzzleRC = PuzzleRC;
	Parms.bApplyInverseDPI = bApplyInverseDPI;
	Parms.bGray = bGray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzlePanel.OnRep_Rune
// (Final, Native, Private)
// Parameters:

void APuzzlePanel::OnRep_Rune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "OnRep_Rune");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzlePanel.HighlightsFromGridPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGridHighlightInfo>  GPHighlights                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FGridHighlightInfo>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGridHighlightInfo> APuzzlePanel::HighlightsFromGridPoints(const TArray<struct FGridHighlightInfo>& GPHighlights)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "HighlightsFromGridPoints");

	Params::APuzzlePanel_HighlightsFromGridPoints_Params Parms{};

	Parms.GPHighlights = GPHighlights;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzlePanel.HighlightFromGridPointSingle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGridHighlightInfo          GPHighlight                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGridHighlightInfo          ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGridHighlightInfo APuzzlePanel::HighlightFromGridPointSingle(const struct FGridHighlightInfo& GPHighlight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "HighlightFromGridPointSingle");

	Params::APuzzlePanel_HighlightFromGridPointSingle_Params Parms{};

	Parms.GPHighlight = GPHighlight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzlePanel.GetRune
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaRune*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASophiaRune* APuzzlePanel::GetRune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "GetRune");

	Params::APuzzlePanel_GetRune_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzlePanel.BPI_PuzzleFullyOpened
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzlePanel::BPI_PuzzleFullyOpened()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "BPI_PuzzleFullyOpened");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzlePanel.BPI_PuzzleClosed
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzlePanel::BPI_PuzzleClosed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "BPI_PuzzleClosed");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzlePanel.BP_SetBackgroundColorToSolved
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzlePanel::BP_SetBackgroundColorToSolved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "BP_SetBackgroundColorToSolved");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzlePanel.BP_PlayBackgroundSolveAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzlePanel::BP_PlayBackgroundSolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "BP_PlayBackgroundSolveAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PuzzlePanel.BP_PlayBackgroundDoppelSolveAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void APuzzlePanel::BP_PlayBackgroundDoppelSolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzlePanel", "BP_PlayBackgroundDoppelSolveAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.CylindricalPuzzlePanel
// (Actor)

class UClass* ACylindricalPuzzlePanel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CylindricalPuzzlePanel");

	return Clss;
}


// CylindricalPuzzlePanel IslandsofInsight.Default__CylindricalPuzzlePanel
// (Public, ClassDefaultObject, ArchetypeObject)

class ACylindricalPuzzlePanel* ACylindricalPuzzlePanel::GetDefaultObj()
{
	static class ACylindricalPuzzlePanel* Default = nullptr;

	if (!Default)
		Default = static_cast<ACylindricalPuzzlePanel*>(ACylindricalPuzzlePanel::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DeathOverlayWidget
// (None)

class UClass* UDeathOverlayWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DeathOverlayWidget");

	return Clss;
}


// DeathOverlayWidget IslandsofInsight.Default__DeathOverlayWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UDeathOverlayWidget* UDeathOverlayWidget::GetDefaultObj()
{
	static class UDeathOverlayWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UDeathOverlayWidget*>(UDeathOverlayWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DefaultItems
// (None)

class UClass* UDefaultItems::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DefaultItems");

	return Clss;
}


// DefaultItems IslandsofInsight.Default__DefaultItems
// (Public, ClassDefaultObject, ArchetypeObject)

class UDefaultItems* UDefaultItems::GetDefaultObj()
{
	static class UDefaultItems* Default = nullptr;

	if (!Default)
		Default = static_cast<UDefaultItems*>(UDefaultItems::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DelayedWidgetGenerator
// (None)

class UClass* UDelayedWidgetGenerator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DelayedWidgetGenerator");

	return Clss;
}


// DelayedWidgetGenerator IslandsofInsight.Default__DelayedWidgetGenerator
// (Public, ClassDefaultObject, ArchetypeObject)

class UDelayedWidgetGenerator* UDelayedWidgetGenerator::GetDefaultObj()
{
	static class UDelayedWidgetGenerator* Default = nullptr;

	if (!Default)
		Default = static_cast<UDelayedWidgetGenerator*>(UDelayedWidgetGenerator::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.DelayedWidgetGenerator.ForceCreation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDelayedWidgetGenerator::ForceCreation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DelayedWidgetGenerator", "ForceCreation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.DelayedWidgetGenerator.ChildIsGenerated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelayedWidgetGenerator::ChildIsGenerated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DelayedWidgetGenerator", "ChildIsGenerated");

	Params::UDelayedWidgetGenerator_ChildIsGenerated_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.DestinationLightPillar
// (Actor)

class UClass* ADestinationLightPillar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DestinationLightPillar");

	return Clss;
}


// DestinationLightPillar IslandsofInsight.Default__DestinationLightPillar
// (Public, ClassDefaultObject, ArchetypeObject)

class ADestinationLightPillar* ADestinationLightPillar::GetDefaultObj()
{
	static class ADestinationLightPillar* Default = nullptr;

	if (!Default)
		Default = static_cast<ADestinationLightPillar*>(ADestinationLightPillar::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DifficultyIndicator
// (None)

class UClass* UDifficultyIndicator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DifficultyIndicator");

	return Clss;
}


// DifficultyIndicator IslandsofInsight.Default__DifficultyIndicator
// (Public, ClassDefaultObject, ArchetypeObject)

class UDifficultyIndicator* UDifficultyIndicator::GetDefaultObj()
{
	static class UDifficultyIndicator* Default = nullptr;

	if (!Default)
		Default = static_cast<UDifficultyIndicator*>(UDifficultyIndicator::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.DifficultyIndicator.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InDiff                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDifficultyIndicatorStateState                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultyIndicator::Init(int32 InDiff, enum class EDifficultyIndicatorState State)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyIndicator", "Init");

	Params::UDifficultyIndicator_Init_Params Parms{};

	Parms.InDiff = InDiff;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.DifficultyIndicator.GetWidgetVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UDifficultyIndicator::GetWidgetVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyIndicator", "GetWidgetVisibility");

	Params::UDifficultyIndicator_GetWidgetVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.DifficultyIndicator.GetDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDifficultyIndicator::GetDifficulty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyIndicator", "GetDifficulty");

	Params::UDifficultyIndicator_GetDifficulty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.DifficultyIndicator.GetCircleVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UDifficultyIndicator::GetCircleVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyIndicator", "GetCircleVisibility");

	Params::UDifficultyIndicator_GetCircleVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.DifficultyIndicatorActor
// (Actor)

class UClass* ADifficultyIndicatorActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DifficultyIndicatorActor");

	return Clss;
}


// DifficultyIndicatorActor IslandsofInsight.Default__DifficultyIndicatorActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ADifficultyIndicatorActor* ADifficultyIndicatorActor::GetDefaultObj()
{
	static class ADifficultyIndicatorActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ADifficultyIndicatorActor*>(ADifficultyIndicatorActor::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DifficultyPanel
// (None)

class UClass* UDifficultyPanel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DifficultyPanel");

	return Clss;
}


// DifficultyPanel IslandsofInsight.Default__DifficultyPanel
// (Public, ClassDefaultObject, ArchetypeObject)

class UDifficultyPanel* UDifficultyPanel::GetDefaultObj()
{
	static class UDifficultyPanel* Default = nullptr;

	if (!Default)
		Default = static_cast<UDifficultyPanel*>(UDifficultyPanel::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.DifficultyPanel.BP_SetupDifficultyPanel
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              DifficultyNum                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultyPanel::BP_SetupDifficultyPanel(int32 DifficultyNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyPanel", "BP_SetupDifficultyPanel");

	Params::UDifficultyPanel_BP_SetupDifficultyPanel_Params Parms{};

	Parms.DifficultyNum = DifficultyNum;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.DifficultyPanel.BP_Initialize
// (Event, Public, BlueprintEvent)
// Parameters:

void UDifficultyPanel::BP_Initialize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DifficultyPanel", "BP_Initialize");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.DisplayProgress
// (None)

class UClass* IDisplayProgress::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DisplayProgress");

	return Clss;
}


// DisplayProgress IslandsofInsight.Default__DisplayProgress
// (Public, ClassDefaultObject, ArchetypeObject)

class IDisplayProgress* IDisplayProgress::GetDefaultObj()
{
	static class IDisplayProgress* Default = nullptr;

	if (!Default)
		Default = static_cast<IDisplayProgress*>(IDisplayProgress::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DistinctColorPicker
// (None)

class UClass* UDistinctColorPicker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistinctColorPicker");

	return Clss;
}


// DistinctColorPicker IslandsofInsight.Default__DistinctColorPicker
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistinctColorPicker* UDistinctColorPicker::GetDefaultObj()
{
	static class UDistinctColorPicker* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistinctColorPicker*>(UDistinctColorPicker::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.DominionSymbol
// (None)

class UClass* UDominionSymbol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DominionSymbol");

	return Clss;
}


// DominionSymbol IslandsofInsight.Default__DominionSymbol
// (Public, ClassDefaultObject, ArchetypeObject)

class UDominionSymbol* UDominionSymbol::GetDefaultObj()
{
	static class UDominionSymbol* Default = nullptr;

	if (!Default)
		Default = static_cast<UDominionSymbol*>(UDominionSymbol::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ConquestMastery
// (Actor)

class UClass* AConquestMastery::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ConquestMastery");

	return Clss;
}


// ConquestMastery IslandsofInsight.Default__ConquestMastery
// (Public, ClassDefaultObject, ArchetypeObject)

class AConquestMastery* AConquestMastery::GetDefaultObj()
{
	static class AConquestMastery* Default = nullptr;

	if (!Default)
		Default = static_cast<AConquestMastery*>(AConquestMastery::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.mbassadorMastery
// (Actor)

class UClass* AMbassadorMastery::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("mbassadorMastery");

	return Clss;
}


// mbassadorMastery IslandsofInsight.Default__mbassadorMastery
// (Public, ClassDefaultObject, ArchetypeObject)

class AMbassadorMastery* AMbassadorMastery::GetDefaultObj()
{
	static class AMbassadorMastery* Default = nullptr;

	if (!Default)
		Default = static_cast<AMbassadorMastery*>(AMbassadorMastery::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Dungeon
// (Actor)

class UClass* ADungeon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Dungeon");

	return Clss;
}


// Dungeon IslandsofInsight.Default__Dungeon
// (Public, ClassDefaultObject, ArchetypeObject)

class ADungeon* ADungeon::GetDefaultObj()
{
	static class ADungeon* Default = nullptr;

	if (!Default)
		Default = static_cast<ADungeon*>(ADungeon::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Dungeon.SetSolvedForPlayersInDungeon
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaCharacter*            SolvedPlayer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeon::SetSolvedForPlayersInDungeon(class ASophiaCharacter* SolvedPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "SetSolvedForPlayersInDungeon");

	Params::ADungeon_SetSolvedForPlayersInDungeon_Params Parms{};

	Parms.SolvedPlayer = SolvedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Dungeon.GetTagline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ADungeon::GetTagline()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetTagline");

	Params::ADungeon_GetTagline_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Dungeon.GetOwnedPuzzleCompletionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              TotalPuzzles                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SolvedPuzzles                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeon::GetOwnedPuzzleCompletionData(int32* TotalPuzzles, int32* SolvedPuzzles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetOwnedPuzzleCompletionData");

	Params::ADungeon_GetOwnedPuzzleCompletionData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (TotalPuzzles != nullptr)
		*TotalPuzzles = Parms.TotalPuzzles;

	if (SolvedPuzzles != nullptr)
		*SolvedPuzzles = Parms.SolvedPuzzles;

}


// Function IslandsofInsight.Dungeon.GetLore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ADungeon::GetLore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetLore");

	Params::ADungeon_GetLore_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Dungeon.GetImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateBrush                 ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush ADungeon::GetImage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetImage");

	Params::ADungeon_GetImage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Dungeon.GetDungeonCompletionPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADungeon::GetDungeonCompletionPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetDungeonCompletionPercentage");

	Params::ADungeon_GetDungeonCompletionPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Dungeon.GetCompletionPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADungeon::GetCompletionPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "GetCompletionPercentage");

	Params::ADungeon_GetCompletionPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Dungeon.BPI_ShowPillar
// (Event, Public, BlueprintEvent)
// Parameters:

void ADungeon::BPI_ShowPillar()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPI_ShowPillar");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Dungeon.BPI_PlaySubtitles
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeon::BPI_PlaySubtitles(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPI_PlaySubtitles");

	Params::ADungeon_BPI_PlaySubtitles_Params Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Dungeon.BPI_AddWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// TSubclassOf<class UUserWidget>     WidgetClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeon::BPI_AddWidget(TSubclassOf<class UUserWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPI_AddWidget");

	Params::ADungeon_BPI_AddWidget_Params Parms{};

	Parms.WidgetClass = WidgetClass;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Dungeon.BPI_AddTutorialWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// TSubclassOf<class UTutorialWidget> TutorialWidgetClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeon::BPI_AddTutorialWidget(TSubclassOf<class UTutorialWidget> TutorialWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPI_AddTutorialWidget");

	Params::ADungeon_BPI_AddTutorialWidget_Params Parms{};

	Parms.TutorialWidgetClass = TutorialWidgetClass;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Dungeon.BPC_UpdateAwakenPuzzles
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ADungeon::BPC_UpdateAwakenPuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPC_UpdateAwakenPuzzles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Dungeon.BPC_ShowTooEarlyMessage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ADungeon::BPC_ShowTooEarlyMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BPC_ShowTooEarlyMessage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Dungeon.BP_OnFullyComplete_Server
// (Event, Protected, BlueprintEvent)
// Parameters:

void ADungeon::BP_OnFullyComplete_Server()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Dungeon", "BP_OnFullyComplete_Server");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.DungeonEntrance
// (Actor)

class UClass* ADungeonEntrance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DungeonEntrance");

	return Clss;
}


// DungeonEntrance IslandsofInsight.Default__DungeonEntrance
// (Public, ClassDefaultObject, ArchetypeObject)

class ADungeonEntrance* ADungeonEntrance::GetDefaultObj()
{
	static class ADungeonEntrance* Default = nullptr;

	if (!Default)
		Default = static_cast<ADungeonEntrance*>(ADungeonEntrance::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.DungeonEntrance.BPI_BeaconTypeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:

void ADungeonEntrance::BPI_BeaconTypeChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DungeonEntrance", "BPI_BeaconTypeChanged");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.DungeonInfoWidget
// (None)

class UClass* UDungeonInfoWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DungeonInfoWidget");

	return Clss;
}


// DungeonInfoWidget IslandsofInsight.Default__DungeonInfoWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UDungeonInfoWidget* UDungeonInfoWidget::GetDefaultObj()
{
	static class UDungeonInfoWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UDungeonInfoWidget*>(UDungeonInfoWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.DungeonInfoWidget.Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADungeon*                    Dungeon                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               WasHidden                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonInfoWidget::Show(class ADungeon* Dungeon, bool WasHidden)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DungeonInfoWidget", "Show");

	Params::UDungeonInfoWidget_Show_Params Parms{};

	Parms.Dungeon = Dungeon;
	Parms.WasHidden = WasHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.DungeonInfoWidget.SetValues
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                    Dungeon                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonInfoWidget::SetValues(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DungeonInfoWidget", "SetValues");

	Params::UDungeonInfoWidget_SetValues_Params Parms{};

	Parms.Dungeon = Dungeon;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.DungeonInfoWidget.InCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADungeon*                    Dungeon                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonInfoWidget::InCooldown(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DungeonInfoWidget", "InCooldown");

	Params::UDungeonInfoWidget_InCooldown_Params Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.DungeonInfoWidget.BP_Show
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADungeon*                    Dungeon                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonInfoWidget::BP_Show(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DungeonInfoWidget", "BP_Show");

	Params::UDungeonInfoWidget_BP_Show_Params Parms{};

	Parms.Dungeon = Dungeon;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.Quest
// (None)

class UClass* UQuest::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Quest");

	return Clss;
}


// Quest IslandsofInsight.Default__Quest
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuest* UQuest::GetDefaultObj()
{
	static class UQuest* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuest*>(UQuest::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Quest.ShouldUpdate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuest::ShouldUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "ShouldUpdate");

	Params::UQuest_ShouldUpdate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.IsFullyComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuest::IsFullyComplete(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "IsFullyComplete");

	Params::UQuest_IsFullyComplete_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.IsComplete
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuest::IsComplete(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "IsComplete");

	Params::UQuest_IsComplete_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.IsAllowedByThisVendor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AQuestVendor*                Vendor                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuest::IsAllowedByThisVendor(class AQuestVendor* Vendor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "IsAllowedByThisVendor");

	Params::UQuest_IsAllowedByThisVendor_Params Parms{};

	Parms.Vendor = Vendor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetXPReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UQuest::GetXPReward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetXPReward");

	Params::UQuest_GetXPReward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetQuestTitle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UQuest::GetQuestTitle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetQuestTitle");

	Params::UQuest_GetQuestTitle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetQuestState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EQuestState             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EQuestState UQuest::GetQuestState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetQuestState");

	Params::UQuest_GetQuestState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetObjectives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UQuestObjective*>     ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class UQuestObjective*> UQuest::GetObjectives()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetObjectives");

	Params::UQuest_GetObjectives_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetGoldReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UQuest::GetGoldReward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetGoldReward");

	Params::UQuest_GetGoldReward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetFlavorText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UQuest::GetFlavorText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetFlavorText");

	Params::UQuest_GetFlavorText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetEncyclopediaReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UQuest::GetEncyclopediaReward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetEncyclopediaReward");

	Params::UQuest_GetEncyclopediaReward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetDebugName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UQuest::GetDebugName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetDebugName");

	Params::UQuest_GetDebugName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetCompletionProgressTargetBorb
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               CoerceToInterval                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UQuest::GetCompletionProgressTargetBorb(bool CoerceToInterval)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetCompletionProgressTargetBorb");

	Params::UQuest_GetCompletionProgressTargetBorb_Params Parms{};

	Parms.CoerceToInterval = CoerceToInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetCompletionProgressTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               CoerceToInterval                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UQuest::GetCompletionProgressTarget(bool CoerceToInterval)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetCompletionProgressTarget");

	Params::UQuest_GetCompletionProgressTarget_Params Parms{};

	Parms.CoerceToInterval = CoerceToInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Quest.GetBlueOrbReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UQuest::GetBlueOrbReward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Quest", "GetBlueOrbReward");

	Params::UQuest_GetBlueOrbReward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.DungeonQuest2
// (None)

class UClass* UDungeonQuest2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DungeonQuest2");

	return Clss;
}


// DungeonQuest2 IslandsofInsight.Default__DungeonQuest2
// (Public, ClassDefaultObject, ArchetypeObject)

class UDungeonQuest2* UDungeonQuest2::GetDefaultObj()
{
	static class UDungeonQuest2* Default = nullptr;

	if (!Default)
		Default = static_cast<UDungeonQuest2*>(UDungeonQuest2::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EditorTimeData
// (None)

class UClass* UEditorTimeData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EditorTimeData");

	return Clss;
}


// EditorTimeData IslandsofInsight.Default__EditorTimeData
// (Public, ClassDefaultObject, ArchetypeObject)

class UEditorTimeData* UEditorTimeData::GetDefaultObj()
{
	static class UEditorTimeData* Default = nullptr;

	if (!Default)
		Default = static_cast<UEditorTimeData*>(UEditorTimeData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Email
// (None)

class UClass* UEmail::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Email");

	return Clss;
}


// Email IslandsofInsight.Default__Email
// (Public, ClassDefaultObject, ArchetypeObject)

class UEmail* UEmail::GetDefaultObj()
{
	static class UEmail* Default = nullptr;

	if (!Default)
		Default = static_cast<UEmail*>(UEmail::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Email.SetSubject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetSubject(const class FString& Subject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetSubject");

	Params::UEmail_SetSubject_Params Parms{};

	Parms.Subject = Subject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetServerType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ESmtpServerType         Server                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetServerType(enum class ESmtpServerType Server)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetServerType");

	Params::UEmail_SetServerType_Params Parms{};

	Parms.Server = Server;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetServerPort
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Port                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetServerPort(int32 Port)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetServerPort");

	Params::UEmail_SetServerPort_Params Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetServerAddress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Address                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetServerAddress(const class FString& Address)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetServerAddress");

	Params::UEmail_SetServerAddress_Params Parms{};

	Parms.Address = Address;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetSender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EmailSender                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetSender(const class FString& EmailSender)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetSender");

	Params::UEmail_SetSender_Params Parms{};

	Parms.EmailSender = EmailSender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetHeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      HeaderName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      HeaderValue                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetHeader(const class FString& HeaderName, const class FString& HeaderValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetHeader");

	Params::UEmail_SetHeader_Params Parms{};

	Parms.HeaderName = HeaderName;
	Parms.HeaderValue = HeaderValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetCredentials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      InUsername                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InPassword                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetCredentials(const class FString& InUsername, const class FString& InPassword)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetCredentials");

	Params::UEmail_SetCredentials_Params Parms{};

	Parms.InUsername = InUsername;
	Parms.InPassword = InPassword;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetContentCharset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEmailCharset           Charset                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetContentCharset(enum class EEmailCharset Charset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetContentCharset");

	Params::UEmail_SetContentCharset_Params Parms{};

	Parms.Charset = Charset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EmailContent                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      MimeType                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetContent(const class FString& EmailContent, const class FString& MimeType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetContent");

	Params::UEmail_SetContent_Params Parms{};

	Parms.EmailContent = EmailContent;
	Parms.MimeType = MimeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetConnectionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ESmtpConnectionType     Connection                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetConnectionType(enum class ESmtpConnectionType Connection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetConnectionType");

	Params::UEmail_SetConnectionType_Params Parms{};

	Parms.Connection = Connection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.SetClientDomain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Domain                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::SetClientDomain(const class FString& Domain)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "SetClientDomain");

	Params::UEmail_SetClientDomain_Params Parms{};

	Parms.Domain = Domain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.Send
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UEmail::Send()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "Send");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.RemoveAttachmentFromCache
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      DisplayName                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::RemoveAttachmentFromCache(const class FString& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "RemoveAttachmentFromCache");

	Params::UEmail_RemoveAttachmentFromCache_Params Parms{};

	Parms.DisplayName = DisplayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.RemoveAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      DisplayName                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::RemoveAttachment(const class FString& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "RemoveAttachment");

	Params::UEmail_RemoveAttachment_Params Parms{};

	Parms.DisplayName = DisplayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.IsEmailSending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmail::IsEmailSending()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "IsEmailSending");

	Params::UEmail_IsEmailSending_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Email.CreateInitializedEmail
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESmtpServerType         ServerType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESmtpConnectionType     Connection                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ServerAddress                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Port                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmail*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmail* UEmail::CreateInitializedEmail(enum class ESmtpServerType ServerType, enum class ESmtpConnectionType Connection, const class FString& ServerAddress, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "CreateInitializedEmail");

	Params::UEmail_CreateInitializedEmail_Params Parms{};

	Parms.ServerType = ServerType;
	Parms.Connection = Connection;
	Parms.ServerAddress = ServerAddress;
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Email.CreateEmail
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEmail*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmail* UEmail::CreateEmail()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "CreateEmail");

	Params::UEmail_CreateEmail_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Email.AddReceiver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EmailReceiver                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::AddReceiver(const class FString& EmailReceiver)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddReceiver");

	Params::UEmail_AddReceiver_Params Parms{};

	Parms.EmailReceiver = EmailReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.AddFileAsAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      DisplayName                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Path                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      MimeType                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmail::AddFileAsAttachment(const class FString& DisplayName, const class FString& Path, const class FString& MimeType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddFileAsAttachment");

	Params::UEmail_AddFileAsAttachment_Params Parms{};

	Parms.DisplayName = DisplayName;
	Parms.Path = Path;
	Parms.MimeType = MimeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Email.AddDataAsAttachmentWithoutEncode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      DisplayName                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      MimeType                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                      Data                                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// enum class EContentTransfertEncodingEncoding                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::AddDataAsAttachmentWithoutEncode(const class FString& DisplayName, const class FString& MimeType, const TArray<uint8>& Data, enum class EContentTransfertEncoding Encoding)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddDataAsAttachmentWithoutEncode");

	Params::UEmail_AddDataAsAttachmentWithoutEncode_Params Parms{};

	Parms.DisplayName = DisplayName;
	Parms.MimeType = MimeType;
	Parms.Data = Data;
	Parms.Encoding = Encoding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.AddDataAsAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      DisplayName                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      MimeType                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Data                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EContentTransfertEncodingEncoding                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::AddDataAsAttachment(const class FString& DisplayName, const class FString& MimeType, const class FString& Data, enum class EContentTransfertEncoding Encoding)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddDataAsAttachment");

	Params::UEmail_AddDataAsAttachment_Params Parms{};

	Parms.DisplayName = DisplayName;
	Parms.MimeType = MimeType;
	Parms.Data = Data;
	Parms.Encoding = Encoding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.AddCopyCarbon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EmailAddress                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::AddCopyCarbon(const class FString& EmailAddress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddCopyCarbon");

	Params::UEmail_AddCopyCarbon_Params Parms{};

	Parms.EmailAddress = EmailAddress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Email.AddBlindCopyCarbon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EmailAddress                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmail::AddBlindCopyCarbon(const class FString& EmailAddress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Email", "AddBlindCopyCarbon");

	Params::UEmail_AddBlindCopyCarbon_Params Parms{};

	Parms.EmailAddress = EmailAddress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.EmailLibrary
// (None)

class UClass* UEmailLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EmailLibrary");

	return Clss;
}


// EmailLibrary IslandsofInsight.Default__EmailLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UEmailLibrary* UEmailLibrary::GetDefaultObj()
{
	static class UEmailLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UEmailLibrary*>(UEmailLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.EmailLibrary.GetYahooEmailSmtpAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetYahooEmailSmtpAddress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetYahooEmailSmtpAddress");

	Params::UEmailLibrary_GetYahooEmailSmtpAddress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetOutlookSmtpAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetOutlookSmtpAddress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetOutlookSmtpAddress");

	Params::UEmailLibrary_GetOutlookSmtpAddress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetOffice365SmtpAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetOffice365SmtpAddress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetOffice365SmtpAddress");

	Params::UEmailLibrary_GetOffice365SmtpAddress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetMimeTypeFromFileName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetMimeTypeFromFileName(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetMimeTypeFromFileName");

	Params::UEmailLibrary_GetMimeTypeFromFileName_Params Parms{};

	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetHotmailSmtpAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetHotmailSmtpAddress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetHotmailSmtpAddress");

	Params::UEmailLibrary_GetHotmailSmtpAddress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetGmailSmtpAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEmailLibrary::GetGmailSmtpAddress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetGmailSmtpAddress");

	Params::UEmailLibrary_GetGmailSmtpAddress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EmailLibrary.GetDefaultPortForConnection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESmtpConnectionType     Connection                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEmailLibrary::GetDefaultPortForConnection(enum class ESmtpConnectionType Connection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmailLibrary", "GetDefaultPortForConnection");

	Params::UEmailLibrary_GetDefaultPortForConnection_Params Parms{};

	Parms.Connection = Connection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SendEmailProxy
// (None)

class UClass* USendEmailProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailProxy");

	return Clss;
}


// SendEmailProxy IslandsofInsight.Default__SendEmailProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailProxy* USendEmailProxy::GetDefaultObj()
{
	static class USendEmailProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailProxy*>(USendEmailProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailProxy.SendEmail
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class ESmtpServerType         ServerType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESmtpConnectionType     ConnectionType                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ServerAddress                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ServerPort                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Password                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Sender                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              Receivers                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              CopyCarbon                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              BlindCopyCarbon                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      MessageContent                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              AttachedFiles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                      AttachedFilesData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USendEmailProxy*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendEmailProxy* USendEmailProxy::SendEmail(enum class ESmtpServerType ServerType, enum class ESmtpConnectionType ConnectionType, const class FString& ServerAddress, int32 ServerPort, const class FString& UserName, const class FString& Password, const class FString& Subject, const class FString& Sender, TArray<class FString>& Receivers, TArray<class FString>& CopyCarbon, TArray<class FString>& BlindCopyCarbon, const class FString& MessageContent, TArray<class FString>& AttachedFiles, TArray<uint8>& AttachedFilesData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailProxy", "SendEmail");

	Params::USendEmailProxy_SendEmail_Params Parms{};

	Parms.ServerType = ServerType;
	Parms.ConnectionType = ConnectionType;
	Parms.ServerAddress = ServerAddress;
	Parms.ServerPort = ServerPort;
	Parms.UserName = UserName;
	Parms.Password = Password;
	Parms.Subject = Subject;
	Parms.Sender = Sender;
	Parms.Receivers = Receivers;
	Parms.CopyCarbon = CopyCarbon;
	Parms.BlindCopyCarbon = BlindCopyCarbon;
	Parms.MessageContent = MessageContent;
	Parms.AttachedFiles = AttachedFiles;
	Parms.AttachedFilesData = AttachedFilesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SendEmailProxy.InternalOnEmailSent
// (Final, Native, Private)
// Parameters:

void USendEmailProxy::InternalOnEmailSent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailProxy", "InternalOnEmailSent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SendEmailProxy.InternalOnEmailError
// (Final, Native, Private)
// Parameters:
// int32                              ErrorCode                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USendEmailProxy::InternalOnEmailError(int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailProxy", "InternalOnEmailError");

	Params::USendEmailProxy_InternalOnEmailError_Params Parms{};

	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SimpleSendEmailProxy
// (None)

class UClass* USimpleSendEmailProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SimpleSendEmailProxy");

	return Clss;
}


// SimpleSendEmailProxy IslandsofInsight.Default__SimpleSendEmailProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USimpleSendEmailProxy* USimpleSendEmailProxy::GetDefaultObj()
{
	static class USimpleSendEmailProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USimpleSendEmailProxy*>(USimpleSendEmailProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SimpleSendEmailProxy.SendEmail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEmail*                      Email                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USimpleSendEmailProxy*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USimpleSendEmailProxy* USimpleSendEmailProxy::SendEmail(class UEmail* Email)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SimpleSendEmailProxy", "SendEmail");

	Params::USimpleSendEmailProxy_SendEmail_Params Parms{};

	Parms.Email = Email;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SimpleSendEmailProxy.InternalOnEmailSent
// (Final, Native, Private)
// Parameters:

void USimpleSendEmailProxy::InternalOnEmailSent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SimpleSendEmailProxy", "InternalOnEmailSent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SimpleSendEmailProxy.InternalOnEmailError
// (Final, Native, Private)
// Parameters:
// int32                              ErrorCode                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleSendEmailProxy::InternalOnEmailError(int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SimpleSendEmailProxy", "InternalOnEmailError");

	Params::USimpleSendEmailProxy_InternalOnEmailError_Params Parms{};

	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SendEmailWithServerProxy
// (None)

class UClass* USendEmailWithServerProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailWithServerProxy");

	return Clss;
}


// SendEmailWithServerProxy IslandsofInsight.Default__SendEmailWithServerProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailWithServerProxy* USendEmailWithServerProxy::GetDefaultObj()
{
	static class USendEmailWithServerProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailWithServerProxy*>(USendEmailWithServerProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailWithServerProxy.OnEmailSent
// (Final, Native, Private)
// Parameters:

void USendEmailWithServerProxy::OnEmailSent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithServerProxy", "OnEmailSent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SendEmailWithServerProxy.OnEmailFailedToSend
// (Final, Native, Private)
// Parameters:
// int32                              Error                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USendEmailWithServerProxy::OnEmailFailedToSend(int32 Error)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithServerProxy", "OnEmailFailedToSend");

	Params::USendEmailWithServerProxy_OnEmailFailedToSend_Params Parms{};

	Parms.Error = Error;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SendEmailWithGmailProxy
// (None)

class UClass* USendEmailWithGmailProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailWithGmailProxy");

	return Clss;
}


// SendEmailWithGmailProxy IslandsofInsight.Default__SendEmailWithGmailProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailWithGmailProxy* USendEmailWithGmailProxy::GetDefaultObj()
{
	static class USendEmailWithGmailProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailWithGmailProxy*>(USendEmailWithGmailProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailWithGmailProxy.SendEmailWithGmail
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      SenderEmailAddress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Password                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              To                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              CC                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              BCC                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Content                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              AttachedFiles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                      AttachedFilesData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USendEmailWithGmailProxy*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendEmailWithGmailProxy* USendEmailWithGmailProxy::SendEmailWithGmail(const class FString& SenderEmailAddress, const class FString& UserName, const class FString& Password, TArray<class FString>& To, TArray<class FString>& CC, TArray<class FString>& BCC, const class FString& Subject, const class FString& Content, TArray<class FString>& AttachedFiles, TArray<uint8>& AttachedFilesData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithGmailProxy", "SendEmailWithGmail");

	Params::USendEmailWithGmailProxy_SendEmailWithGmail_Params Parms{};

	Parms.SenderEmailAddress = SenderEmailAddress;
	Parms.UserName = UserName;
	Parms.Password = Password;
	Parms.To = To;
	Parms.CC = CC;
	Parms.BCC = BCC;
	Parms.Subject = Subject;
	Parms.Content = Content;
	Parms.AttachedFiles = AttachedFiles;
	Parms.AttachedFilesData = AttachedFilesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SendEmailWithYahooProxy
// (None)

class UClass* USendEmailWithYahooProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailWithYahooProxy");

	return Clss;
}


// SendEmailWithYahooProxy IslandsofInsight.Default__SendEmailWithYahooProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailWithYahooProxy* USendEmailWithYahooProxy::GetDefaultObj()
{
	static class USendEmailWithYahooProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailWithYahooProxy*>(USendEmailWithYahooProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailWithYahooProxy.SendEmailWithYahoo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      SenderEmailAddress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Password                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              To                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              CC                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              BCC                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Content                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              AttachedFiles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                      AttachedFilesData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USendEmailWithYahooProxy*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendEmailWithYahooProxy* USendEmailWithYahooProxy::SendEmailWithYahoo(const class FString& SenderEmailAddress, const class FString& UserName, const class FString& Password, TArray<class FString>& To, TArray<class FString>& CC, TArray<class FString>& BCC, const class FString& Subject, const class FString& Content, TArray<class FString>& AttachedFiles, TArray<uint8>& AttachedFilesData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithYahooProxy", "SendEmailWithYahoo");

	Params::USendEmailWithYahooProxy_SendEmailWithYahoo_Params Parms{};

	Parms.SenderEmailAddress = SenderEmailAddress;
	Parms.UserName = UserName;
	Parms.Password = Password;
	Parms.To = To;
	Parms.CC = CC;
	Parms.BCC = BCC;
	Parms.Subject = Subject;
	Parms.Content = Content;
	Parms.AttachedFiles = AttachedFiles;
	Parms.AttachedFilesData = AttachedFilesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SendEmailWithOutlookProxy
// (None)

class UClass* USendEmailWithOutlookProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailWithOutlookProxy");

	return Clss;
}


// SendEmailWithOutlookProxy IslandsofInsight.Default__SendEmailWithOutlookProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailWithOutlookProxy* USendEmailWithOutlookProxy::GetDefaultObj()
{
	static class USendEmailWithOutlookProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailWithOutlookProxy*>(USendEmailWithOutlookProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailWithOutlookProxy.SendEmailWithOutlook
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      SenderEmailAddress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Password                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              To                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              CC                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              BCC                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Content                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              AttachedFiles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                      AttachedFilesData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USendEmailWithOutlookProxy*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendEmailWithOutlookProxy* USendEmailWithOutlookProxy::SendEmailWithOutlook(const class FString& SenderEmailAddress, const class FString& UserName, const class FString& Password, TArray<class FString>& To, TArray<class FString>& CC, TArray<class FString>& BCC, const class FString& Subject, const class FString& Content, TArray<class FString>& AttachedFiles, TArray<uint8>& AttachedFilesData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithOutlookProxy", "SendEmailWithOutlook");

	Params::USendEmailWithOutlookProxy_SendEmailWithOutlook_Params Parms{};

	Parms.SenderEmailAddress = SenderEmailAddress;
	Parms.UserName = UserName;
	Parms.Password = Password;
	Parms.To = To;
	Parms.CC = CC;
	Parms.BCC = BCC;
	Parms.Subject = Subject;
	Parms.Content = Content;
	Parms.AttachedFiles = AttachedFiles;
	Parms.AttachedFilesData = AttachedFilesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SendEmailWithHotmailProxy
// (None)

class UClass* USendEmailWithHotmailProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SendEmailWithHotmailProxy");

	return Clss;
}


// SendEmailWithHotmailProxy IslandsofInsight.Default__SendEmailWithHotmailProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class USendEmailWithHotmailProxy* USendEmailWithHotmailProxy::GetDefaultObj()
{
	static class USendEmailWithHotmailProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<USendEmailWithHotmailProxy*>(USendEmailWithHotmailProxy::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SendEmailWithHotmailProxy.SendEmailWithHotmail
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      SenderEmailAddress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Password                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              To                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              CC                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              BCC                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      Subject                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Content                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              AttachedFiles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                      AttachedFilesData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USendEmailWithHotmailProxy*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendEmailWithHotmailProxy* USendEmailWithHotmailProxy::SendEmailWithHotmail(const class FString& SenderEmailAddress, const class FString& UserName, const class FString& Password, TArray<class FString>& To, TArray<class FString>& CC, TArray<class FString>& BCC, const class FString& Subject, const class FString& Content, TArray<class FString>& AttachedFiles, TArray<uint8>& AttachedFilesData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SendEmailWithHotmailProxy", "SendEmailWithHotmail");

	Params::USendEmailWithHotmailProxy_SendEmailWithHotmail_Params Parms{};

	Parms.SenderEmailAddress = SenderEmailAddress;
	Parms.UserName = UserName;
	Parms.Password = Password;
	Parms.To = To;
	Parms.CC = CC;
	Parms.BCC = BCC;
	Parms.Subject = Subject;
	Parms.Content = Content;
	Parms.AttachedFiles = AttachedFiles;
	Parms.AttachedFilesData = AttachedFilesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.EmoteWheelWidget
// (None)

class UClass* UEmoteWheelWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EmoteWheelWidget");

	return Clss;
}


// EmoteWheelWidget IslandsofInsight.Default__EmoteWheelWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UEmoteWheelWidget* UEmoteWheelWidget::GetDefaultObj()
{
	static class UEmoteWheelWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UEmoteWheelWidget*>(UEmoteWheelWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.EmoteWheelWidget.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UEmoteWheelWidget::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EmoteWheelWidget", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.EncyclopediaData
// (None)

class UClass* UEncyclopediaData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaData");

	return Clss;
}


// EncyclopediaData IslandsofInsight.Default__EncyclopediaData
// (Public, ClassDefaultObject, ArchetypeObject)

class UEncyclopediaData* UEncyclopediaData::GetDefaultObj()
{
	static class UEncyclopediaData* Default = nullptr;

	if (!Default)
		Default = static_cast<UEncyclopediaData*>(UEncyclopediaData::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.EncyclopediaData.GetLoreImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULore*                       Lore                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                 ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UEncyclopediaData::GetLoreImage(class ULore* Lore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EncyclopediaData", "GetLoreImage");

	Params::UEncyclopediaData_GetLoreImage_Params Parms{};

	Parms.Lore = Lore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EncyclopediaData.FindLoreFromID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULore*                       ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULore* UEncyclopediaData::FindLoreFromID(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EncyclopediaData", "FindLoreFromID");

	Params::UEncyclopediaData_FindLoreFromID_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.EncyclopediaData.FindClueFromID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USecretClue*                 ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USecretClue* UEncyclopediaData::FindClueFromID(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EncyclopediaData", "FindClueFromID");

	Params::UEncyclopediaData_FindClueFromID_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.EncyclopediaEntry
// (None)

class UClass* UEncyclopediaEntry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaEntry");

	return Clss;
}


// EncyclopediaEntry IslandsofInsight.Default__EncyclopediaEntry
// (Public, ClassDefaultObject, ArchetypeObject)

class UEncyclopediaEntry* UEncyclopediaEntry::GetDefaultObj()
{
	static class UEncyclopediaEntry* Default = nullptr;

	if (!Default)
		Default = static_cast<UEncyclopediaEntry*>(UEncyclopediaEntry::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EncyclopediaPuzzle
// (None)

class UClass* UEncyclopediaPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaPuzzle");

	return Clss;
}


// EncyclopediaPuzzle IslandsofInsight.Default__EncyclopediaPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class UEncyclopediaPuzzle* UEncyclopediaPuzzle::GetDefaultObj()
{
	static class UEncyclopediaPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<UEncyclopediaPuzzle*>(UEncyclopediaPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EncyclopediaRule
// (None)

class UClass* UEncyclopediaRule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaRule");

	return Clss;
}


// EncyclopediaRule IslandsofInsight.Default__EncyclopediaRule
// (Public, ClassDefaultObject, ArchetypeObject)

class UEncyclopediaRule* UEncyclopediaRule::GetDefaultObj()
{
	static class UEncyclopediaRule* Default = nullptr;

	if (!Default)
		Default = static_cast<UEncyclopediaRule*>(UEncyclopediaRule::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Insight
// (None)

class UClass* UInsight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Insight");

	return Clss;
}


// Insight IslandsofInsight.Default__Insight
// (Public, ClassDefaultObject, ArchetypeObject)

class UInsight* UInsight::GetDefaultObj()
{
	static class UInsight* Default = nullptr;

	if (!Default)
		Default = static_cast<UInsight*>(UInsight::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Lore
// (None)

class UClass* ULore::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Lore");

	return Clss;
}


// Lore IslandsofInsight.Default__Lore
// (Public, ClassDefaultObject, ArchetypeObject)

class ULore* ULore::GetDefaultObj()
{
	static class ULore* Default = nullptr;

	if (!Default)
		Default = static_cast<ULore*>(ULore::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SecretClue
// (None)

class UClass* USecretClue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SecretClue");

	return Clss;
}


// SecretClue IslandsofInsight.Default__SecretClue
// (Public, ClassDefaultObject, ArchetypeObject)

class USecretClue* USecretClue::GetDefaultObj()
{
	static class USecretClue* Default = nullptr;

	if (!Default)
		Default = static_cast<USecretClue*>(USecretClue::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EncyclopediaPreview
// (Actor)

class UClass* AEncyclopediaPreview::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaPreview");

	return Clss;
}


// EncyclopediaPreview IslandsofInsight.Default__EncyclopediaPreview
// (Public, ClassDefaultObject, ArchetypeObject)

class AEncyclopediaPreview* AEncyclopediaPreview::GetDefaultObj()
{
	static class AEncyclopediaPreview* Default = nullptr;

	if (!Default)
		Default = static_cast<AEncyclopediaPreview*>(AEncyclopediaPreview::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EncyclopediaPreviewWidget
// (None)

class UClass* UEncyclopediaPreviewWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EncyclopediaPreviewWidget");

	return Clss;
}


// EncyclopediaPreviewWidget IslandsofInsight.Default__EncyclopediaPreviewWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UEncyclopediaPreviewWidget* UEncyclopediaPreviewWidget::GetDefaultObj()
{
	static class UEncyclopediaPreviewWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UEncyclopediaPreviewWidget*>(UEncyclopediaPreviewWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.EncyclopediaPreviewWidget.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UEncyclopediaPreviewWidget::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EncyclopediaPreviewWidget", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.EscortPuzzleSplineComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UEscortPuzzleSplineComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EscortPuzzleSplineComponent");

	return Clss;
}


// EscortPuzzleSplineComponent IslandsofInsight.Default__EscortPuzzleSplineComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UEscortPuzzleSplineComponent* UEscortPuzzleSplineComponent::GetDefaultObj()
{
	static class UEscortPuzzleSplineComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UEscortPuzzleSplineComponent*>(UEscortPuzzleSplineComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EventPromptWidget
// (None)

class UClass* UEventPromptWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EventPromptWidget");

	return Clss;
}


// EventPromptWidget IslandsofInsight.Default__EventPromptWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UEventPromptWidget* UEventPromptWidget::GetDefaultObj()
{
	static class UEventPromptWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UEventPromptWidget*>(UEventPromptWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.EventPromptWidget.BP_Hide
// (Event, Public, BlueprintEvent)
// Parameters:

void UEventPromptWidget::BP_Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventPromptWidget", "BP_Hide");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SophiaPostProcessBlendable
// (None)

class UClass* USophiaPostProcessBlendable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaPostProcessBlendable");

	return Clss;
}


// SophiaPostProcessBlendable IslandsofInsight.Default__SophiaPostProcessBlendable
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaPostProcessBlendable* USophiaPostProcessBlendable::GetDefaultObj()
{
	static class USophiaPostProcessBlendable* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaPostProcessBlendable*>(USophiaPostProcessBlendable::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ExponentialFogBlendable
// (None)

class UClass* UExponentialFogBlendable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ExponentialFogBlendable");

	return Clss;
}


// ExponentialFogBlendable IslandsofInsight.Default__ExponentialFogBlendable
// (Public, ClassDefaultObject, ArchetypeObject)

class UExponentialFogBlendable* UExponentialFogBlendable::GetDefaultObj()
{
	static class UExponentialFogBlendable* Default = nullptr;

	if (!Default)
		Default = static_cast<UExponentialFogBlendable*>(UExponentialFogBlendable::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ExtendedMovementComponent
// (None)

class UClass* UExtendedMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ExtendedMovementComponent");

	return Clss;
}


// ExtendedMovementComponent IslandsofInsight.Default__ExtendedMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UExtendedMovementComponent* UExtendedMovementComponent::GetDefaultObj()
{
	static class UExtendedMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UExtendedMovementComponent*>(UExtendedMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ExtendedMovementComponent.SetTeleport
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                               NewWantsToTeleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Destination                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               PlayEffect                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetTeleport(bool NewWantsToTeleport, const struct FVector& Destination, bool PlayEffect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetTeleport");

	Params::UExtendedMovementComponent_SetTeleport_Params Parms{};

	Parms.NewWantsToTeleport = NewWantsToTeleport;
	Parms.Destination = Destination;
	Parms.PlayEffect = PlayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetRecall
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                               NewWantsToTeleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Destination                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsResetting                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetRecall(bool NewWantsToTeleport, const struct FVector& Destination, bool IsResetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetRecall");

	Params::UExtendedMovementComponent_SetRecall_Params Parms{};

	Parms.NewWantsToTeleport = NewWantsToTeleport;
	Parms.Destination = Destination;
	Parms.IsResetting = IsResetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetNetworkNoSmoothUpdateDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InValue                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetNetworkNoSmoothUpdateDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetNetworkNoSmoothUpdateDistance");

	Params::UExtendedMovementComponent_SetNetworkNoSmoothUpdateDistance_Params Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetNetworkMaxSmoothUpdateDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InValue                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetNetworkMaxSmoothUpdateDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetNetworkMaxSmoothUpdateDistance");

	Params::UExtendedMovementComponent_SetNetworkMaxSmoothUpdateDistance_Params Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetMovementModeRep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EMovementMode           NewMovementMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              NewCustomMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetMovementModeRep(enum class EMovementMode NewMovementMode, uint8 NewCustomMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetMovementModeRep");

	Params::UExtendedMovementComponent_SetMovementModeRep_Params Parms{};

	Parms.NewMovementMode = NewMovementMode;
	Parms.NewCustomMovementMode = NewCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetLaunchVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLaunchVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bXYOverride                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bZOverride                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetLaunchVelocity(const struct FVector& NewLaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetLaunchVelocity");

	Params::UExtendedMovementComponent_SetLaunchVelocity_Params Parms{};

	Parms.NewLaunchVelocity = NewLaunchVelocity;
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetJumpZValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InValue                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetJumpZValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetJumpZValue");

	Params::UExtendedMovementComponent_SetJumpZValue_Params Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetDefaultMovementModeRep
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UExtendedMovementComponent::SetDefaultMovementModeRep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetDefaultMovementModeRep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.SetCustomMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECustomMovementMode     MovementMode_                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedMovementComponent::SetCustomMovement(enum class ECustomMovementMode MovementMode_, bool Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "SetCustomMovement");

	Params::UExtendedMovementComponent_SetCustomMovement_Params Parms{};

	Parms.MovementMode_ = MovementMode_;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetWantsToSprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedMovementComponent::GetWantsToSprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetWantsToSprint");

	Params::UExtendedMovementComponent_GetWantsToSprint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetWantsToDive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedMovementComponent::GetWantsToDive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetWantsToDive");

	Params::UExtendedMovementComponent_GetWantsToDive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetRespawnPointDungeon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADungeon*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADungeon* UExtendedMovementComponent::GetRespawnPointDungeon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetRespawnPointDungeon");

	Params::UExtendedMovementComponent_GetRespawnPointDungeon_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetRespawnPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UExtendedMovementComponent::GetRespawnPoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetRespawnPoint");

	Params::UExtendedMovementComponent_GetRespawnPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetRecallInMovingState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedMovementComponent::GetRecallInMovingState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetRecallInMovingState");

	Params::UExtendedMovementComponent_GetRecallInMovingState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.GetMaxGlideSpeedForThisPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UExtendedMovementComponent::GetMaxGlideSpeedForThisPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "GetMaxGlideSpeedForThisPlayer");

	Params::UExtendedMovementComponent_GetMaxGlideSpeedForThisPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ExtendedMovementComponent.CheckCustomMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECustomMovementMode     CustomMode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedMovementComponent::CheckCustomMovement(enum class ECustomMovementMode CustomMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExtendedMovementComponent", "CheckCustomMovement");

	Params::UExtendedMovementComponent_CheckCustomMovement_Params Parms{};

	Parms.CustomMode = CustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.FadingText
// (None)

class UClass* UFadingText::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FadingText");

	return Clss;
}


// FadingText IslandsofInsight.Default__FadingText
// (Public, ClassDefaultObject, ArchetypeObject)

class UFadingText* UFadingText::GetDefaultObj()
{
	static class UFadingText* Default = nullptr;

	if (!Default)
		Default = static_cast<UFadingText*>(UFadingText::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FakeConquestEndFlag
// (Actor)

class UClass* AFakeConquestEndFlag::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FakeConquestEndFlag");

	return Clss;
}


// FakeConquestEndFlag IslandsofInsight.Default__FakeConquestEndFlag
// (Public, ClassDefaultObject, ArchetypeObject)

class AFakeConquestEndFlag* AFakeConquestEndFlag::GetDefaultObj()
{
	static class AFakeConquestEndFlag* Default = nullptr;

	if (!Default)
		Default = static_cast<AFakeConquestEndFlag*>(AFakeConquestEndFlag::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FeedMessageWidget
// (None)

class UClass* UFeedMessageWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FeedMessageWidget");

	return Clss;
}


// FeedMessageWidget IslandsofInsight.Default__FeedMessageWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UFeedMessageWidget* UFeedMessageWidget::GetDefaultObj()
{
	static class UFeedMessageWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UFeedMessageWidget*>(UFeedMessageWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FeedWidget
// (None)

class UClass* UFeedWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FeedWidget");

	return Clss;
}


// FeedWidget IslandsofInsight.Default__FeedWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UFeedWidget* UFeedWidget::GetDefaultObj()
{
	static class UFeedWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UFeedWidget*>(UFeedWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FeedWidget.AddFeedMessage
// (Final, Native, Public)
// Parameters:
// struct FTimedMessage               Message                                                          (Parm, NativeAccessSpecifierPublic)

void UFeedWidget::AddFeedMessage(const struct FTimedMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FeedWidget", "AddFeedMessage");

	Params::UFeedWidget_AddFeedMessage_Params Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.FindChord
// (Actor)

class UClass* AFindChord::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FindChord");

	return Clss;
}


// FindChord IslandsofInsight.Default__FindChord
// (Public, ClassDefaultObject, ArchetypeObject)

class AFindChord* AFindChord::GetDefaultObj()
{
	static class AFindChord* Default = nullptr;

	if (!Default)
		Default = static_cast<AFindChord*>(AFindChord::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FindChordAudioPlayer
// (Actor)

class UClass* AFindChordAudioPlayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FindChordAudioPlayer");

	return Clss;
}


// FindChordAudioPlayer IslandsofInsight.Default__FindChordAudioPlayer
// (Public, ClassDefaultObject, ArchetypeObject)

class AFindChordAudioPlayer* AFindChordAudioPlayer::GetDefaultObj()
{
	static class AFindChordAudioPlayer* Default = nullptr;

	if (!Default)
		Default = static_cast<AFindChordAudioPlayer*>(AFindChordAudioPlayer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FindChordAudioPlayer.SetGlow
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               Solo                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFindChordAudioPlayer::SetGlow(bool Solo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FindChordAudioPlayer", "SetGlow");

	Params::AFindChordAudioPlayer_SetGlow_Params Parms{};

	Parms.Solo = Solo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.Fireworks
// (Actor)

class UClass* AFireworks::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Fireworks");

	return Clss;
}


// Fireworks IslandsofInsight.Default__Fireworks
// (Public, ClassDefaultObject, ArchetypeObject)

class AFireworks* AFireworks::GetDefaultObj()
{
	static class AFireworks* Default = nullptr;

	if (!Default)
		Default = static_cast<AFireworks*>(AFireworks::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FireworksPuzzle
// (Actor)

class UClass* AFireworksPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FireworksPuzzle");

	return Clss;
}


// FireworksPuzzle IslandsofInsight.Default__FireworksPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AFireworksPuzzle* AFireworksPuzzle::GetDefaultObj()
{
	static class AFireworksPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AFireworksPuzzle*>(AFireworksPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FloorSocket
// (Actor)

class UClass* AFloorSocket::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FloorSocket");

	return Clss;
}


// FloorSocket IslandsofInsight.Default__FloorSocket
// (Public, ClassDefaultObject, ArchetypeObject)

class AFloorSocket* AFloorSocket::GetDefaultObj()
{
	static class AFloorSocket* Default = nullptr;

	if (!Default)
		Default = static_cast<AFloorSocket*>(AFloorSocket::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FocusablePuzzle
// (Actor)

class UClass* AFocusablePuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FocusablePuzzle");

	return Clss;
}


// FocusablePuzzle IslandsofInsight.Default__FocusablePuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AFocusablePuzzle* AFocusablePuzzle::GetDefaultObj()
{
	static class AFocusablePuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AFocusablePuzzle*>(AFocusablePuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FocusablePuzzle.SetFocusToFalse
// (Final, Native, Public)
// Parameters:

void AFocusablePuzzle::SetFocusToFalse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FocusablePuzzle", "SetFocusToFalse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FocusablePuzzle.NetMultiCast_ClaimSeat
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASophiaCharacter*            SophiaChar                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SeatingDown                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SeatIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFocusablePuzzle::NetMultiCast_ClaimSeat(class ASophiaCharacter* SophiaChar, bool SeatingDown, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FocusablePuzzle", "NetMultiCast_ClaimSeat");

	Params::AFocusablePuzzle_NetMultiCast_ClaimSeat_Params Parms{};

	Parms.SophiaChar = SophiaChar;
	Parms.SeatingDown = SeatingDown;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FocusablePuzzle.GetIndexOfPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            SophiaChar                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFocusablePuzzle::GetIndexOfPlayer(class ASophiaCharacter* SophiaChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FocusablePuzzle", "GetIndexOfPlayer");

	Params::AFocusablePuzzle_GetIndexOfPlayer_Params Parms{};

	Parms.SophiaChar = SophiaChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.ScreenMarkerWidgetBase
// (None)

class UClass* UScreenMarkerWidgetBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ScreenMarkerWidgetBase");

	return Clss;
}


// ScreenMarkerWidgetBase IslandsofInsight.Default__ScreenMarkerWidgetBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UScreenMarkerWidgetBase* UScreenMarkerWidgetBase::GetDefaultObj()
{
	static class UScreenMarkerWidgetBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UScreenMarkerWidgetBase*>(UScreenMarkerWidgetBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ScreenMarkerWidgetBase.BP_Tick
// (Event, Protected, BlueprintEvent)
// Parameters:

void UScreenMarkerWidgetBase::BP_Tick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScreenMarkerWidgetBase", "BP_Tick");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.ScreenMarkerWidgetBase.BP_Init
// (Event, Protected, BlueprintEvent)
// Parameters:

void UScreenMarkerWidgetBase::BP_Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScreenMarkerWidgetBase", "BP_Init");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.PlayerInfoWidget
// (None)

class UClass* UPlayerInfoWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerInfoWidget");

	return Clss;
}


// PlayerInfoWidget IslandsofInsight.Default__PlayerInfoWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerInfoWidget* UPlayerInfoWidget::GetDefaultObj()
{
	static class UPlayerInfoWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerInfoWidget*>(UPlayerInfoWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerInfoWidget.GetPlayerNameColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UPlayerInfoWidget::GetPlayerNameColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInfoWidget", "GetPlayerNameColor");

	Params::UPlayerInfoWidget_GetPlayerNameColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.FocusedPlayerInfoWidget
// (None)

class UClass* UFocusedPlayerInfoWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FocusedPlayerInfoWidget");

	return Clss;
}


// FocusedPlayerInfoWidget IslandsofInsight.Default__FocusedPlayerInfoWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UFocusedPlayerInfoWidget* UFocusedPlayerInfoWidget::GetDefaultObj()
{
	static class UFocusedPlayerInfoWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UFocusedPlayerInfoWidget*>(UFocusedPlayerInfoWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FogManager
// (Actor)

class UClass* AFogManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FogManager");

	return Clss;
}


// FogManager IslandsofInsight.Default__FogManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AFogManager* AFogManager::GetDefaultObj()
{
	static class AFogManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AFogManager*>(AFogManager::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FogManager.InBox
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     HitLoc                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Axis                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFogManager::InBox(const struct FVector& HitLoc, const struct FVector& B1, const struct FVector& B2, int32 Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FogManager", "InBox");

	Params::AFogManager_InBox_Params Parms{};

	Parms.HitLoc = HitLoc;
	Parms.B1 = B1;
	Parms.B2 = B2;
	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.FogManager.GetLineBoundsIntersectionPoint
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     B1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     L1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     L2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AFogManager::GetLineBoundsIntersectionPoint(const struct FVector& B1, const struct FVector& B2, const struct FVector& L1, const struct FVector& L2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FogManager", "GetLineBoundsIntersectionPoint");

	Params::AFogManager_GetLineBoundsIntersectionPoint_Params Parms{};

	Parms.B1 = B1;
	Parms.B2 = B2;
	Parms.L1 = L1;
	Parms.L2 = L2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.FogManager.GetIntersection
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                              FDst1                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FDst2                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     P1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     P2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLoc                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFogManager::GetIntersection(float FDst1, float FDst2, const struct FVector& P1, const struct FVector& P2, struct FVector* HitLoc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FogManager", "GetIntersection");

	Params::AFogManager_GetIntersection_Params Parms{};

	Parms.FDst1 = FDst1;
	Parms.FDst2 = FDst2;
	Parms.P1 = P1;
	Parms.P2 = P2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLoc != nullptr)
		*HitLoc = std::move(Parms.HitLoc);

	return Parms.ReturnValue;

}


// Class IslandsofInsight.FogSphere
// (Actor)

class UClass* AFogSphere::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FogSphere");

	return Clss;
}


// FogSphere IslandsofInsight.Default__FogSphere
// (Public, ClassDefaultObject, ArchetypeObject)

class AFogSphere* AFogSphere::GetDefaultObj()
{
	static class AFogSphere* Default = nullptr;

	if (!Default)
		Default = static_cast<AFogSphere*>(AFogSphere::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FollowTheShiny
// (Actor)

class UClass* AFollowTheShiny::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FollowTheShiny");

	return Clss;
}


// FollowTheShiny IslandsofInsight.Default__FollowTheShiny
// (Public, ClassDefaultObject, ArchetypeObject)

class AFollowTheShiny* AFollowTheShiny::GetDefaultObj()
{
	static class AFollowTheShiny* Default = nullptr;

	if (!Default)
		Default = static_cast<AFollowTheShiny*>(AFollowTheShiny::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FollowTheShiny.OnBallOverlap
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFollowTheShiny::OnBallOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "OnBallOverlap");

	Params::AFollowTheShiny_OnBallOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FollowTheShiny.OnBallExitOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFollowTheShiny::OnBallExitOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "OnBallExitOverlap");

	Params::AFollowTheShiny_OnBallExitOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FollowTheShiny.BPI_StartEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               Started                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFollowTheShiny::BPI_StartEndPlay(bool Started)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "BPI_StartEndPlay");

	Params::AFollowTheShiny_BPI_StartEndPlay_Params Parms{};

	Parms.Started = Started;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.FollowTheShiny.BPI_ReachedDestination
// (Event, Protected, BlueprintEvent)
// Parameters:

void AFollowTheShiny::BPI_ReachedDestination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "BPI_ReachedDestination");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.FollowTheShiny.BPI_AboutToExpire
// (Event, Protected, BlueprintEvent)
// Parameters:

void AFollowTheShiny::BPI_AboutToExpire()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "BPI_AboutToExpire");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.FollowTheShiny.BP_BallOverlap
// (Event, Protected, BlueprintEvent)
// Parameters:

void AFollowTheShiny::BP_BallOverlap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FollowTheShiny", "BP_BallOverlap");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SophiaSplineComponent
// (SceneComponent, PrimitiveComponent)

class UClass* USophiaSplineComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaSplineComponent");

	return Clss;
}


// SophiaSplineComponent IslandsofInsight.Default__SophiaSplineComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaSplineComponent* USophiaSplineComponent::GetDefaultObj()
{
	static class USophiaSplineComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaSplineComponent*>(USophiaSplineComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FollowTheShinySplineComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UFollowTheShinySplineComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FollowTheShinySplineComponent");

	return Clss;
}


// FollowTheShinySplineComponent IslandsofInsight.Default__FollowTheShinySplineComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UFollowTheShinySplineComponent* UFollowTheShinySplineComponent::GetDefaultObj()
{
	static class UFollowTheShinySplineComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UFollowTheShinySplineComponent*>(UFollowTheShinySplineComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FollowTheShinyStaticMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UFollowTheShinyStaticMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FollowTheShinyStaticMeshComponent");

	return Clss;
}


// FollowTheShinyStaticMeshComponent IslandsofInsight.Default__FollowTheShinyStaticMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UFollowTheShinyStaticMeshComponent* UFollowTheShinyStaticMeshComponent::GetDefaultObj()
{
	static class UFollowTheShinyStaticMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UFollowTheShinyStaticMeshComponent*>(UFollowTheShinyStaticMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ForesightController
// (None)

class UClass* UForesightController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ForesightController");

	return Clss;
}


// ForesightController IslandsofInsight.Default__ForesightController
// (Public, ClassDefaultObject, ArchetypeObject)

class UForesightController* UForesightController::GetDefaultObj()
{
	static class UForesightController* Default = nullptr;

	if (!Default)
		Default = static_cast<UForesightController*>(UForesightController::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ForesightController.GetBarVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UForesightController::GetBarVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "GetBarVisibility");

	Params::UForesightController_GetBarVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ForesightController.BP_UpdateHints
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              HintCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ChargeProgress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaxHints                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForesightController::BP_UpdateHints(int32 HintCount, float ChargeProgress, int32 MaxHints)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "BP_UpdateHints");

	Params::UForesightController_BP_UpdateHints_Params Parms{};

	Parms.HintCount = HintCount;
	Parms.ChargeProgress = ChargeProgress;
	Parms.MaxHints = MaxHints;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ForesightController.BP_ShowSparkleAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForesightController::BP_ShowSparkleAnim(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "BP_ShowSparkleAnim");

	Params::UForesightController_BP_ShowSparkleAnim_Params Parms{};

	Parms.Index = Index;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ForesightController.BP_ShowBorderAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForesightController::BP_ShowBorderAnim(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "BP_ShowBorderAnim");

	Params::UForesightController_BP_ShowBorderAnim_Params Parms{};

	Parms.Index = Index;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.ForesightController.BP_Init
// (Event, Public, BlueprintEvent)
// Parameters:

void UForesightController::BP_Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "BP_Init");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.ForesightController.BP_HideBorderAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForesightController::BP_HideBorderAnim(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForesightController", "BP_HideBorderAnim");

	Params::UForesightController_BP_HideBorderAnim_Params Parms{};

	Parms.Index = Index;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.FractalJigsaw
// (Actor)

class UClass* AFractalJigsaw::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalJigsaw");

	return Clss;
}


// FractalJigsaw IslandsofInsight.Default__FractalJigsaw
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalJigsaw* AFractalJigsaw::GetDefaultObj()
{
	static class AFractalJigsaw* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalJigsaw*>(AFractalJigsaw::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FractalJigsaw.OnRep_Tiles
// (Final, Native, Private)
// Parameters:

void AFractalJigsaw::OnRep_Tiles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalJigsaw", "OnRep_Tiles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FractalJigsaw.OnRep_ServerState
// (Final, Native, Private)
// Parameters:

void AFractalJigsaw::OnRep_ServerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalJigsaw", "OnRep_ServerState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.FractalMatch
// (Actor)

class UClass* AFractalMatch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalMatch");

	return Clss;
}


// FractalMatch IslandsofInsight.Default__FractalMatch
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalMatch* AFractalMatch::GetDefaultObj()
{
	static class AFractalMatch* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalMatch*>(AFractalMatch::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FractalMatch_ClickIn
// (Actor)

class UClass* AFractalMatch_ClickIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalMatch_ClickIn");

	return Clss;
}


// FractalMatch_ClickIn IslandsofInsight.Default__FractalMatch_ClickIn
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalMatch_ClickIn* AFractalMatch_ClickIn::GetDefaultObj()
{
	static class AFractalMatch_ClickIn* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalMatch_ClickIn*>(AFractalMatch_ClickIn::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FractalMatch_ClickIn.refreshMeshes
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:

void AFractalMatch_ClickIn::RefreshMeshes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalMatch_ClickIn", "refreshMeshes");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.FractalMatch_ClickIn.InitFractalPuzzle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FFractalType2D              FractalTypeInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                   TargetParameters                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFractalMatch_ClickIn::InitFractalPuzzle(struct FFractalType2D& FractalTypeInfo, const struct FVector2D& TargetParameters)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalMatch_ClickIn", "InitFractalPuzzle");

	Params::AFractalMatch_ClickIn_InitFractalPuzzle_Params Parms{};

	Parms.FractalTypeInfo = FractalTypeInfo;
	Parms.TargetParameters = TargetParameters;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.FractalMatch_ClickIn.BP_LeaveFocus
// (Event, Public, BlueprintEvent)
// Parameters:

void AFractalMatch_ClickIn::BP_LeaveFocus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalMatch_ClickIn", "BP_LeaveFocus");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.FractalMatch_ClickIn.BP_HasFocus
// (Event, Public, BlueprintEvent)
// Parameters:

void AFractalMatch_ClickIn::BP_HasFocus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FractalMatch_ClickIn", "BP_HasFocus");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.FractalMatchWithSlider
// (Actor)

class UClass* AFractalMatchWithSlider::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalMatchWithSlider");

	return Clss;
}


// FractalMatchWithSlider IslandsofInsight.Default__FractalMatchWithSlider
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalMatchWithSlider* AFractalMatchWithSlider::GetDefaultObj()
{
	static class AFractalMatchWithSlider* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalMatchWithSlider*>(AFractalMatchWithSlider::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FractalTree
// (Actor)

class UClass* AFractalTree::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalTree");

	return Clss;
}


// FractalTree IslandsofInsight.Default__FractalTree
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalTree* AFractalTree::GetDefaultObj()
{
	static class AFractalTree* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalTree*>(AFractalTree::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FractalTreePuzzle
// (Actor)

class UClass* AFractalTreePuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FractalTreePuzzle");

	return Clss;
}


// FractalTreePuzzle IslandsofInsight.Default__FractalTreePuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AFractalTreePuzzle* AFractalTreePuzzle::GetDefaultObj()
{
	static class AFractalTreePuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AFractalTreePuzzle*>(AFractalTreePuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.FriendListWidget
// (None)

class UClass* UFriendListWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FriendListWidget");

	return Clss;
}


// FriendListWidget IslandsofInsight.Default__FriendListWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UFriendListWidget* UFriendListWidget::GetDefaultObj()
{
	static class UFriendListWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UFriendListWidget*>(UFriendListWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.FriendListWidget.GetOnlineFriendCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFriendListWidget::GetOnlineFriendCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FriendListWidget", "GetOnlineFriendCount");

	Params::UFriendListWidget_GetOnlineFriendCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.FriendListWidget.GetLocalPlayerSteamName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFriendListWidget::GetLocalPlayerSteamName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FriendListWidget", "GetLocalPlayerSteamName");

	Params::UFriendListWidget_GetLocalPlayerSteamName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.FriendListWidget.GetLocalPlayersAvatarTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  DefaultTexture                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UFriendListWidget::GetLocalPlayersAvatarTexture(class UTexture2D* DefaultTexture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FriendListWidget", "GetLocalPlayersAvatarTexture");

	Params::UFriendListWidget_GetLocalPlayersAvatarTexture_Params Parms{};

	Parms.DefaultTexture = DefaultTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GA_TargetDataOverlap
// (Actor)

class UClass* AGA_TargetDataOverlap::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GA_TargetDataOverlap");

	return Clss;
}


// GA_TargetDataOverlap IslandsofInsight.Default__GA_TargetDataOverlap
// (Public, ClassDefaultObject, ArchetypeObject)

class AGA_TargetDataOverlap* AGA_TargetDataOverlap::GetDefaultObj()
{
	static class AGA_TargetDataOverlap* Default = nullptr;

	if (!Default)
		Default = static_cast<AGA_TargetDataOverlap*>(AGA_TargetDataOverlap::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GameHUDBase
// (None)

class UClass* UGameHUDBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameHUDBase");

	return Clss;
}


// GameHUDBase IslandsofInsight.Default__GameHUDBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameHUDBase* UGameHUDBase::GetDefaultObj()
{
	static class UGameHUDBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameHUDBase*>(UGameHUDBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GameHUDBase.IndependentTick
// (Final, Native, Private)
// Parameters:

void UGameHUDBase::IndependentTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameHUDBase", "IndependentTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GamepadDetection
// (None)

class UClass* UGamepadDetection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GamepadDetection");

	return Clss;
}


// GamepadDetection IslandsofInsight.Default__GamepadDetection
// (Public, ClassDefaultObject, ArchetypeObject)

class UGamepadDetection* UGamepadDetection::GetDefaultObj()
{
	static class UGamepadDetection* Default = nullptr;

	if (!Default)
		Default = static_cast<UGamepadDetection*>(UGamepadDetection::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GamepadDetection.IsGamePadConnected
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGamepadDetection::IsGamePadConnected()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GamepadDetection", "IsGamePadConnected");

	Params::UGamepadDetection_IsGamePadConnected_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GeneralNotification
// (None)

class UClass* UGeneralNotification::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GeneralNotification");

	return Clss;
}


// GeneralNotification IslandsofInsight.Default__GeneralNotification
// (Public, ClassDefaultObject, ArchetypeObject)

class UGeneralNotification* UGeneralNotification::GetDefaultObj()
{
	static class UGeneralNotification* Default = nullptr;

	if (!Default)
		Default = static_cast<UGeneralNotification*>(UGeneralNotification::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GeneralNotification.BP_OnAdded
// (Event, Public, BlueprintEvent)
// Parameters:

void UGeneralNotification::BP_OnAdded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GeneralNotification", "BP_OnAdded");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.GenericGridButton
// (None)

class UClass* UGenericGridButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GenericGridButton");

	return Clss;
}


// GenericGridButton IslandsofInsight.Default__GenericGridButton
// (Public, ClassDefaultObject, ArchetypeObject)

class UGenericGridButton* UGenericGridButton::GetDefaultObj()
{
	static class UGenericGridButton* Default = nullptr;

	if (!Default)
		Default = static_cast<UGenericGridButton*>(UGenericGridButton::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GenericGridButton.IsButtonInteractable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGenericGridButton::IsButtonInteractable(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "IsButtonInteractable");

	Params::UGenericGridButton_IsButtonInteractable_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GenericGridButton.GetCorrespondingVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UGenericGridButton::GetCorrespondingVisibility(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "GetCorrespondingVisibility");

	Params::UGenericGridButton_GetCorrespondingVisibility_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GenericGridButton.GetCorrespondingText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGenericGridButton::GetCorrespondingText(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "GetCorrespondingText");

	Params::UGenericGridButton_GetCorrespondingText_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GenericGridButton.GetCorrespondingRenderOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGenericGridButton::GetCorrespondingRenderOpacity(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "GetCorrespondingRenderOpacity");

	Params::UGenericGridButton_GetCorrespondingRenderOpacity_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GenericGridButton.DoButtonRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EGenericGridButtonType  behaviour                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericGridButton::DoButtonRelease(enum class EGenericGridButtonType behaviour)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "DoButtonRelease");

	Params::UGenericGridButton_DoButtonRelease_Params Parms{};

	Parms.behaviour = behaviour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GenericGridButton.DoButtonPress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EGenericGridButtonType  behaviour                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericGridButton::DoButtonPress(enum class EGenericGridButtonType behaviour)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "DoButtonPress");

	Params::UGenericGridButton_DoButtonPress_Params Parms{};

	Parms.behaviour = behaviour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GenericGridButton.DoButtonAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EGenericGridButtonType  behaviour                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericGridButton::DoButtonAction(enum class EGenericGridButtonType behaviour)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "DoButtonAction");

	Params::UGenericGridButton_DoButtonAction_Params Parms{};

	Parms.behaviour = behaviour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GenericGridButton.BPI_GetButtons
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UButton*>             Buttons                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGenericGridButton::BPI_GetButtons(TArray<class UButton*>* Buttons)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "BPI_GetButtons");

	Params::UGenericGridButton_BPI_GetButtons_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	if (Buttons != nullptr)
		*Buttons = std::move(Parms.Buttons);

}


// Function IslandsofInsight.GenericGridButton.BP_UpdateButtonDimState
// (Event, Public, BlueprintEvent)
// Parameters:

void UGenericGridButton::BP_UpdateButtonDimState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "BP_UpdateButtonDimState");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GenericGridButton.BP_PerformClickAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericGridButton::BP_PerformClickAnimation(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "BP_PerformClickAnimation");

	Params::UGenericGridButton_BP_PerformClickAnimation_Params Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GenericGridButton.BP_PerformButtonAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericGridButton::BP_PerformButtonAction(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "BP_PerformButtonAction");

	Params::UGenericGridButton_BP_PerformButtonAction_Params Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GenericGridButton.BP_Activate
// (Event, Public, BlueprintEvent)
// Parameters:

void UGenericGridButton::BP_Activate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GenericGridButton", "BP_Activate");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.GhostHiddenObject
// (Actor)

class UClass* AGhostHiddenObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GhostHiddenObject");

	return Clss;
}


// GhostHiddenObject IslandsofInsight.Default__GhostHiddenObject
// (Public, ClassDefaultObject, ArchetypeObject)

class AGhostHiddenObject* AGhostHiddenObject::GetDefaultObj()
{
	static class AGhostHiddenObject* Default = nullptr;

	if (!Default)
		Default = static_cast<AGhostHiddenObject*>(AGhostHiddenObject::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GhostHiddenObject.BP_Reveal
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void AGhostHiddenObject::BP_Reveal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GhostHiddenObject", "BP_Reveal");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GhostHiddenObject.BP_Hide
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void AGhostHiddenObject::BP_Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GhostHiddenObject", "BP_Hide");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.GigaPuzzle
// (Actor)

class UClass* AGigaPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GigaPuzzle");

	return Clss;
}


// GigaPuzzle IslandsofInsight.Default__GigaPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AGigaPuzzle* AGigaPuzzle::GetDefaultObj()
{
	static class AGigaPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AGigaPuzzle*>(AGigaPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GISEos
// (None)

class UClass* UGISEos::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISEos");

	return Clss;
}


// GISEos IslandsofInsight.Default__GISEos
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISEos* UGISEos::GetDefaultObj()
{
	static class UGISEos* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISEos*>(UGISEos::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISEos.LoginToEos
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISEos::LoginToEos()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISEos", "LoginToEos");

	Params::UGISEos_LoginToEos_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISEos.InitializeEOS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISEos::InitializeEOS(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISEos", "InitializeEOS");

	Params::UGISEos_InitializeEOS_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISEos.InitializedPlatformHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISEos::InitializedPlatformHandle(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISEos", "InitializedPlatformHandle");

	Params::UGISEos_InitializedPlatformHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISEos.EOSPlatformTick
// (Final, Native, Private, Const)
// Parameters:

void UGISEos::EOSPlatformTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISEos", "EOSPlatformTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GISFeedback
// (None)

class UClass* UGISFeedback::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISFeedback");

	return Clss;
}


// GISFeedback IslandsofInsight.Default__GISFeedback
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISFeedback* UGISFeedback::GetDefaultObj()
{
	static class UGISFeedback* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISFeedback*>(UGISFeedback::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISFeedback.TriggerLaunchSurvey
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISFeedback::TriggerLaunchSurvey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISFeedback", "TriggerLaunchSurvey");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISFeedback.RequestSurveyOnce
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                        PromptText                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UParameterizedUrl*           URL                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowEvenInEditor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISFeedback::RequestSurveyOnce(class FText& PromptText, class UParameterizedUrl* URL, bool ShowEvenInEditor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISFeedback", "RequestSurveyOnce");

	Params::UGISFeedback_RequestSurveyOnce_Params Parms{};

	Parms.PromptText = PromptText;
	Parms.URL = URL;
	Parms.ShowEvenInEditor = ShowEvenInEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISFeedback.RemoveSurvey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      BaseUrl                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISFeedback::RemoveSurvey(const class FString& BaseUrl)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISFeedback", "RemoveSurvey");

	Params::UGISFeedback_RemoveSurvey_Params Parms{};

	Parms.BaseUrl = BaseUrl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISFeedback.GetPendingSurveys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UParameterizedUrl*>   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UParameterizedUrl*> UGISFeedback::GetPendingSurveys()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISFeedback", "GetPendingSurveys");

	Params::UGISFeedback_GetPendingSurveys_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GISKraken
// (None)

class UClass* UGISKraken::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISKraken");

	return Clss;
}


// GISKraken IslandsofInsight.Default__GISKraken
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISKraken* UGISKraken::GetDefaultObj()
{
	static class UGISKraken* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISKraken*>(UGISKraken::StaticClass()->DefaultObject);

	return Default;
}


// DelegateFunction IslandsofInsight.GISKraken.PlayerUnbanReceivedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:

void UGISKraken::PlayerUnbanReceivedEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "PlayerUnbanReceivedEvent__DelegateSignature");



	UObject::ProcessEvent(Func, nullptr);

}


// DelegateFunction IslandsofInsight.GISKraken.PlayerBanReceivedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FKrakenBanInfo              BanInfo                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGISKraken::PlayerBanReceivedEvent__DelegateSignature(struct FKrakenBanInfo& BanInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "PlayerBanReceivedEvent__DelegateSignature");

	Params::UGISKraken_PlayerBanReceivedEvent__DelegateSignature_Params Parms{};

	Parms.BanInfo = BanInfo;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GISKraken.OnContentVersionSelected
// (Final, Native, Private)
// Parameters:

void UGISKraken::OnContentVersionSelected()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "OnContentVersionSelected");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.IsPlayerBanned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGISKraken::IsPlayerBanned()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "IsPlayerBanned");

	Params::UGISKraken_IsPlayerBanned_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISKraken.Init
// (Final, Native, Private)
// Parameters:

void UGISKraken::Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "Init");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.GetPlayerBanInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKrakenBanInfo              ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

struct FKrakenBanInfo UGISKraken::GetPlayerBanInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "GetPlayerBanInfo");

	Params::UGISKraken_GetPlayerBanInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISKraken.GetLastPlayerBanInfoTimestamp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGISKraken::GetLastPlayerBanInfoTimestamp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "GetLastPlayerBanInfoTimestamp");

	Params::UGISKraken_GetLastPlayerBanInfoTimestamp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISKraken.GetCatalog
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FString, struct FKrakenItem>ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TMap<class FString, struct FKrakenItem> UGISKraken::GetCatalog()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "GetCatalog");

	Params::UGISKraken_GetCatalog_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISKraken.BPC_VerifyAgeRequirement
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISKraken::BPC_VerifyAgeRequirement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_VerifyAgeRequirement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.BPC_TryInitKraken
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISKraken::BPC_TryInitKraken()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_TryInitKraken");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.BPC_SaveAgeConsentConfirmation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISKraken::BPC_SaveAgeConsentConfirmation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_SaveAgeConsentConfirmation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.BPC_GetAgeConsentConfirmation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISKraken::BPC_GetAgeConsentConfirmation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_GetAgeConsentConfirmation");

	Params::UGISKraken_BPC_GetAgeConsentConfirmation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISKraken.BPC_ConfirmBanMessageSeen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FDelegateProperty_                 FailureCallback                                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UGISKraken::BPC_ConfirmBanMessageSeen(FDelegateProperty_ FailureCallback)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_ConfirmBanMessageSeen");

	Params::UGISKraken_BPC_ConfirmBanMessageSeen_Params Parms{};

	Parms.FailureCallback = FailureCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.BPC_CheckMyBanStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FDelegateProperty_                 FailureCallback                                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UGISKraken::BPC_CheckMyBanStatus(FDelegateProperty_ FailureCallback)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "BPC_CheckMyBanStatus");

	Params::UGISKraken_BPC_CheckMyBanStatus_Params Parms{};

	Parms.FailureCallback = FailureCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISKraken.Authenticate
// (Final, Native, Private)
// Parameters:

void UGISKraken::Authenticate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISKraken", "Authenticate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PooledObject
// (None)

class UClass* UPooledObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PooledObject");

	return Clss;
}


// PooledObject IslandsofInsight.Default__PooledObject
// (Public, ClassDefaultObject, ArchetypeObject)

class UPooledObject* UPooledObject::GetDefaultObj()
{
	static class UPooledObject* Default = nullptr;

	if (!Default)
		Default = static_cast<UPooledObject*>(UPooledObject::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GISPooler
// (None)

class UClass* UGISPooler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISPooler");

	return Clss;
}


// GISPooler IslandsofInsight.Default__GISPooler
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISPooler* UGISPooler::GetDefaultObj()
{
	static class UGISPooler* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISPooler*>(UGISPooler::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GISProgression
// (None)

class UClass* UGISProgression::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISProgression");

	return Clss;
}


// GISProgression IslandsofInsight.Default__GISProgression
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISProgression* UGISProgression::GetDefaultObj()
{
	static class UGISProgression* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISProgression*>(UGISProgression::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISProgression.UpgradeSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldCheckValid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::UpgradeSkill(class ASophiaCharacter* Player, const class FString& SkillName, bool bShouldCheckValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "UpgradeSkill");

	Params::UGISProgression_UpgradeSkill_Params Parms{};

	Parms.Player = Player;
	Parms.SkillName = SkillName;
	Parms.bShouldCheckValid = bShouldCheckValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.UpdateSeenEntries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      EntryId                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::UpdateSeenEntries(class ASophiaCharacter* Player, const class FString& EntryId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "UpdateSeenEntries");

	Params::UGISProgression_UpdateSeenEntries_Params Parms{};

	Parms.Player = Player;
	Parms.EntryId = EntryId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.UnlockSecretsAndClues
// (Final, Native, Private, BlueprintCallable)
// Parameters:

void UGISProgression::UnlockSecretsAndClues()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "UnlockSecretsAndClues");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.UnlockMasteryRewards
// (Final, Native, Public, HasOutParams)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerMastery*              PlayerMastery                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGISProgression::UnlockMasteryRewards(class ASophiaCharacter* Player, class UPlayerMastery* PlayerMastery, struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "UnlockMasteryRewards");

	Params::UGISProgression_UnlockMasteryRewards_Params Parms{};

	Parms.Player = Player;
	Parms.PlayerMastery = PlayerMastery;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.SetTutorialTipSeen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETutorialTip            TipType                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSeen                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::SetTutorialTipSeen(enum class ETutorialTip TipType, bool bSeen)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "SetTutorialTipSeen");

	Params::UGISProgression_SetTutorialTipSeen_Params Parms{};

	Parms.TipType = TipType;
	Parms.bSeen = bSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.SetOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      OptionId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Value                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::SetOption(const class FString& OptionId, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "SetOption");

	Params::UGISProgression_SetOption_Params Parms{};

	Parms.OptionId = OptionId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.RequestProgressionSurvey
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                        PromptText                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      BaseUrl                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::RequestProgressionSurvey(class FText& PromptText, const class FString& BaseUrl)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "RequestProgressionSurvey");

	Params::UGISProgression_RequestProgressionSurvey_Params Parms{};

	Parms.PromptText = PromptText;
	Parms.BaseUrl = BaseUrl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.GetTutorialTipSeen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETutorialTip            TipType                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISProgression::GetTutorialTipSeen(enum class ETutorialTip TipType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetTutorialTipSeen");

	Params::UGISProgression_GetTutorialTipSeen_Params Parms{};

	Parms.TipType = TipType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetPuzzleSolveStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              KrakenId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LocalID                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      HackID                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPuzzleSolveData            ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPuzzleSolveData UGISProgression::GetPuzzleSolveStatus(class ASophiaCharacter* Player, int32 KrakenId, const class FString& LocalID, const class FString& HackID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetPuzzleSolveStatus");

	Params::UGISProgression_GetPuzzleSolveStatus_Params Parms{};

	Parms.Player = Player;
	Parms.KrakenId = KrakenId;
	Parms.LocalID = LocalID;
	Parms.HackID = HackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetProgressionData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerProgressionData      ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerProgressionData UGISProgression::GetProgressionData(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetProgressionData");

	Params::UGISProgression_GetProgressionData_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetEarnedRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, bool>          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, bool> UGISProgression::GetEarnedRules(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetEarnedRules");

	Params::UGISProgression_GetEarnedRules_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetEarnedPuzzleTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, bool>          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, bool> UGISProgression::GetEarnedPuzzleTypes(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetEarnedPuzzleTypes");

	Params::UGISProgression_GetEarnedPuzzleTypes_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetEarnedLore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, bool>          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, bool> UGISProgression::GetEarnedLore(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetEarnedLore");

	Params::UGISProgression_GetEarnedLore_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetEarnedInsights
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, bool>          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, bool> UGISProgression::GetEarnedInsights(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetEarnedInsights");

	Params::UGISProgression_GetEarnedInsights_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.GetEarnedClues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, bool>          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, bool> UGISProgression::GetEarnedClues(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "GetEarnedClues");

	Params::UGISProgression_GetEarnedClues_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.DisplayInsight
// (Final, Native, Public)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      EncyclopediaID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::DisplayInsight(class ASophiaCharacter* Player, const class FString& EncyclopediaID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "DisplayInsight");

	Params::UGISProgression_DisplayInsight_Params Parms{};

	Parms.Player = Player;
	Parms.EncyclopediaID = EncyclopediaID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.DisplayClue
// (Final, Native, Public)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      EncyclopediaID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::DisplayClue(class ASophiaCharacter* Player, const class FString& EncyclopediaID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "DisplayClue");

	Params::UGISProgression_DisplayClue_Params Parms{};

	Parms.Player = Player;
	Parms.EncyclopediaID = EncyclopediaID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.ClaimSandboxProgressionRewards
// (Final, Native, Public, HasOutParams)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGISProgression::ClaimSandboxProgressionRewards(class ASophiaCharacter* Player, enum class EMainMapZoneName ZONE, enum class EPuzzleCategory PuzzleCategory, struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "ClaimSandboxProgressionRewards");

	Params::UGISProgression_ClaimSandboxProgressionRewards_Params Parms{};

	Parms.Player = Player;
	Parms.ZONE = ZONE;
	Parms.PuzzleCategory = PuzzleCategory;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.Cheat_UnlockChapter100
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISProgression::Cheat_UnlockChapter100()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "Cheat_UnlockChapter100");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.Cheat_SetCheatValueOnSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::Cheat_SetCheatValueOnSkill(class ASophiaCharacter* Player, const class FString& SkillName, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "Cheat_SetCheatValueOnSkill");

	Params::UGISProgression_Cheat_SetCheatValueOnSkill_Params Parms{};

	Parms.Player = Player;
	Parms.SkillName = SkillName;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.Cheat_SetCheatEnabledOnSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::Cheat_SetCheatEnabledOnSkill(class ASophiaCharacter* Player, const class FString& SkillName, bool Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "Cheat_SetCheatEnabledOnSkill");

	Params::UGISProgression_Cheat_SetCheatEnabledOnSkill_Params Parms{};

	Parms.Player = Player;
	Parms.SkillName = SkillName;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.BPC_UnlockMasteryRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerMastery*              PlayerMastery                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::BPC_UnlockMasteryRewards(class ASophiaCharacter* Player, class UPlayerMastery* PlayerMastery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_UnlockMasteryRewards");

	Params::UGISProgression_BPC_UnlockMasteryRewards_Params Parms{};

	Parms.Player = Player;
	Parms.PlayerMastery = PlayerMastery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.BPC_GetTotalMasteryLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGISProgression::BPC_GetTotalMasteryLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetTotalMasteryLevel");

	Params::UGISProgression_BPC_GetTotalMasteryLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetPlayerXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlayerXP                   ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPlayerXP UGISProgression::BPC_GetPlayerXP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetPlayerXP");

	Params::UGISProgression_BPC_GetPlayerXP_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetPlayerLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGISProgression::BPC_GetPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetPlayerLevel");

	Params::UGISProgression_BPC_GetPlayerLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetMasteriesPerPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGISProgression::BPC_GetMasteriesPerPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetMasteriesPerPlayerLevel");

	Params::UGISProgression_BPC_GetMasteriesPerPlayerLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetLocalMasteryLevels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPlayerMastery*>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPlayerMastery*> UGISProgression::BPC_GetLocalMasteryLevels()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetLocalMasteryLevels");

	Params::UGISProgression_BPC_GetLocalMasteryLevels_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetLocalMasteryLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      KrakenTypeIdentifier                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerMastery*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerMastery* UGISProgression::BPC_GetLocalMasteryLevel(const class FString& KrakenTypeIdentifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetLocalMasteryLevel");

	Params::UGISProgression_BPC_GetLocalMasteryLevel_Params Parms{};

	Parms.KrakenTypeIdentifier = KrakenTypeIdentifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_GetFractionalPlayerLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGISProgression::BPC_GetFractionalPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_GetFractionalPlayerLevel");

	Params::UGISProgression_BPC_GetFractionalPlayerLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISProgression.BPC_ClaimSandboxProgressionRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::BPC_ClaimSandboxProgressionRewards(class ASophiaCharacter* Player, enum class EMainMapZoneName ZONE, enum class EPuzzleCategory PuzzleCategory)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_ClaimSandboxProgressionRewards");

	Params::UGISProgression_BPC_ClaimSandboxProgressionRewards_Params Parms{};

	Parms.Player = Player;
	Parms.ZONE = ZONE;
	Parms.PuzzleCategory = PuzzleCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISProgression.BPC_ClaimGlobalMasteryReward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              RewardIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISProgression::BPC_ClaimGlobalMasteryReward(class ASophiaCharacter* Player, int32 RewardIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISProgression", "BPC_ClaimGlobalMasteryReward");

	Params::UGISProgression_BPC_ClaimGlobalMasteryReward_Params Parms{};

	Parms.Player = Player;
	Parms.RewardIndex = RewardIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GISSettings
// (None)

class UClass* UGISSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISSettings");

	return Clss;
}


// GISSettings IslandsofInsight.Default__GISSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISSettings* UGISSettings::GetDefaultObj()
{
	static class UGISSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISSettings*>(UGISSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISSettings.SetKrakenOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Value                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISSettings::SetKrakenOption(class UObject* WorldContextObject, const class FString& Name, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSettings", "SetKrakenOption");

	Params::UGISSettings_SetKrakenOption_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name = Name;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GISSocial
// (None)

class UClass* UGISSocial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISSocial");

	return Clss;
}


// GISSocial IslandsofInsight.Default__GISSocial
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISSocial* UGISSocial::GetDefaultObj()
{
	static class UGISSocial* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISSocial*>(UGISSocial::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISSocial.TryJoinFriendGame
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                      Friend                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGISSocial::TryJoinFriendGame(const class FString& Friend)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSocial", "TryJoinFriendGame");

	Params::UGISSocial_TryJoinFriendGame_Params Parms{};

	Parms.Friend = Friend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISSocial.SyncAndRetrieveFriends
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISSocial::SyncAndRetrieveFriends()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSocial", "SyncAndRetrieveFriends");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISSocial.RefreshMessageCenter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISSocial::RefreshMessageCenter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSocial", "RefreshMessageCenter");

	Params::UGISSocial_RefreshMessageCenter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISSocial.FetchNextMessageCenterPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISSocial::FetchNextMessageCenterPage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSocial", "FetchNextMessageCenterPage");

	Params::UGISSocial_FetchNextMessageCenterPage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISSocial.ClaimMessageAttachments
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKrakenMessageGet           Message                                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FDelegateProperty_                 FailureEvent                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISSocial::ClaimMessageAttachments(struct FKrakenMessageGet& Message, FDelegateProperty_& FailureEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSocial", "ClaimMessageAttachments");

	Params::UGISSocial_ClaimMessageAttachments_Params Parms{};

	Parms.Message = Message;
	Parms.FailureEvent = FailureEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GISSteam
// (None)

class UClass* UGISSteam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GISSteam");

	return Clss;
}


// GISSteam IslandsofInsight.Default__GISSteam
// (Public, ClassDefaultObject, ArchetypeObject)

class UGISSteam* UGISSteam::GetDefaultObj()
{
	static class UGISSteam* Default = nullptr;

	if (!Default)
		Default = static_cast<UGISSteam*>(UGISSteam::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GISSteam.SteamCallbackTick
// (Final, Native, Protected)
// Parameters:

void UGISSteam::SteamCallbackTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSteam", "SteamCallbackTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GISSteam.HasDLC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              AppId                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISSteam::HasDLC(int32 AppId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSteam", "HasDLC");

	Params::UGISSteam_HasDLC_Params Parms{};

	Parms.AppId = AppId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISSteam.HasDeluxe
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGISSteam::HasDeluxe()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSteam", "HasDeluxe");

	Params::UGISSteam_HasDeluxe_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GISSteam.CheatEnableAllDLC
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGISSteam::CheatEnableAllDLC()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GISSteam", "CheatEnableAllDLC");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.Given
// (None)

class UClass* UGiven::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Given");

	return Clss;
}


// Given IslandsofInsight.Default__Given
// (Public, ClassDefaultObject, ArchetypeObject)

class UGiven* UGiven::GetDefaultObj()
{
	static class UGiven* Default = nullptr;

	if (!Default)
		Default = static_cast<UGiven*>(UGiven::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GoddessBeacon
// (Actor)

class UClass* AGoddessBeacon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GoddessBeacon");

	return Clss;
}


// GoddessBeacon IslandsofInsight.Default__GoddessBeacon
// (Public, ClassDefaultObject, ArchetypeObject)

class AGoddessBeacon* AGoddessBeacon::GetDefaultObj()
{
	static class AGoddessBeacon* Default = nullptr;

	if (!Default)
		Default = static_cast<AGoddessBeacon*>(AGoddessBeacon::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GoddessBeacon.BP_GetDestination
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AGoddessBeacon::BP_GetDestination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GoddessBeacon", "BP_GetDestination");

	Params::AGoddessBeacon_BP_GetDestination_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Class IslandsofInsight.Rosary
// (Actor)

class UClass* ARosary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Rosary");

	return Clss;
}


// Rosary IslandsofInsight.Default__Rosary
// (Public, ClassDefaultObject, ArchetypeObject)

class ARosary* ARosary::GetDefaultObj()
{
	static class ARosary* Default = nullptr;

	if (!Default)
		Default = static_cast<ARosary*>(ARosary::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Rosary.OnClickFire
// (Native, Public, HasOutParams)
// Parameters:
// struct FClickEventContext          Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARosary::OnClickFire(struct FClickEventContext& Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Rosary", "OnClickFire");

	Params::ARosary_OnClickFire_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Rosary.NetMultiCast_SetTeam
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// uint8                              Team                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARosary::NetMultiCast_SetTeam(uint8 Team)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Rosary", "NetMultiCast_SetTeam");

	Params::ARosary_NetMultiCast_SetTeam_Params Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Rosary.InitializeConsistentRandomStream
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                              Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARosary::InitializeConsistentRandomStream(int32 Offset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Rosary", "InitializeConsistentRandomStream");

	Params::ARosary_InitializeConsistentRandomStream_Params Parms{};

	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.Rosary.GetFRandRange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARosary::GetFRandRange(float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Rosary", "GetFRandRange");

	Params::ARosary_GetFRandRange_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Rosary.GetFRand
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARosary::GetFRand()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Rosary", "GetFRand");

	Params::ARosary_GetFRand_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GoldenRosary
// (Actor)

class UClass* AGoldenRosary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GoldenRosary");

	return Clss;
}


// GoldenRosary IslandsofInsight.Default__GoldenRosary
// (Public, ClassDefaultObject, ArchetypeObject)

class AGoldenRosary* AGoldenRosary::GetDefaultObj()
{
	static class AGoldenRosary* Default = nullptr;

	if (!Default)
		Default = static_cast<AGoldenRosary*>(AGoldenRosary::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GoldenRosaryBeacon
// (Actor)

class UClass* AGoldenRosaryBeacon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GoldenRosaryBeacon");

	return Clss;
}


// GoldenRosaryBeacon IslandsofInsight.Default__GoldenRosaryBeacon
// (Public, ClassDefaultObject, ArchetypeObject)

class AGoldenRosaryBeacon* AGoldenRosaryBeacon::GetDefaultObj()
{
	static class AGoldenRosaryBeacon* Default = nullptr;

	if (!Default)
		Default = static_cast<AGoldenRosaryBeacon*>(AGoldenRosaryBeacon::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RosarySpawnVolume
// (Actor)

class UClass* ARosarySpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosarySpawnVolume");

	return Clss;
}


// RosarySpawnVolume IslandsofInsight.Default__RosarySpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ARosarySpawnVolume* ARosarySpawnVolume::GetDefaultObj()
{
	static class ARosarySpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ARosarySpawnVolume*>(ARosarySpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GoldenRosarySpawnVolume
// (Actor)

class UClass* AGoldenRosarySpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GoldenRosarySpawnVolume");

	return Clss;
}


// GoldenRosarySpawnVolume IslandsofInsight.Default__GoldenRosarySpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AGoldenRosarySpawnVolume* AGoldenRosarySpawnVolume::GetDefaultObj()
{
	static class AGoldenRosarySpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AGoldenRosarySpawnVolume*>(AGoldenRosarySpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GoldPickup
// (Actor)

class UClass* AGoldPickup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GoldPickup");

	return Clss;
}


// GoldPickup IslandsofInsight.Default__GoldPickup
// (Public, ClassDefaultObject, ArchetypeObject)

class AGoldPickup* AGoldPickup::GetDefaultObj()
{
	static class AGoldPickup* Default = nullptr;

	if (!Default)
		Default = static_cast<AGoldPickup*>(AGoldPickup::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GoldPickup.BPI_OnStartAnimation
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FLinearColor                Col                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGoldPickup::BPI_OnStartAnimation(struct FLinearColor& Col)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GoldPickup", "BPI_OnStartAnimation");

	Params::AGoldPickup_BPI_OnStartAnimation_Params Parms{};

	Parms.Col = Col;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GoldPickup.BPI_OnPickup
// (Event, Protected, BlueprintEvent)
// Parameters:

void AGoldPickup::BPI_OnPickup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GoldPickup", "BPI_OnPickup");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.GravityBallBase
// (Actor)

class UClass* AGravityBallBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GravityBallBase");

	return Clss;
}


// GravityBallBase IslandsofInsight.Default__GravityBallBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AGravityBallBase* AGravityBallBase::GetDefaultObj()
{
	static class AGravityBallBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AGravityBallBase*>(AGravityBallBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GravityBallBase.ResetPuzzleCooldown
// (Final, Native, Protected)
// Parameters:

void AGravityBallBase::ResetPuzzleCooldown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "ResetPuzzleCooldown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GravityBallBase.OnEndPuzzleOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravityBallBase::OnEndPuzzleOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "OnEndPuzzleOverlap");

	Params::AGravityBallBase_OnEndPuzzleOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GravityBallBase.GetUnmarkedColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AGravityBallBase::GetUnmarkedColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "GetUnmarkedColor");

	Params::AGravityBallBase_GetUnmarkedColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GravityBallBase.BP_SetSolvedColor
// (Event, Public, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*        Mesh                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravityBallBase::BP_SetSolvedColor(class UStaticMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "BP_SetSolvedColor");

	Params::AGravityBallBase_BP_SetSolvedColor_Params Parms{};

	Parms.Mesh = Mesh;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GravityBallBase.BP_SetColor
// (Event, Public, BlueprintEvent)
// Parameters:

void AGravityBallBase::BP_SetColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "BP_SetColor");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GravityBallBase.BP_ResetPuzzle
// (Event, Public, BlueprintEvent)
// Parameters:

void AGravityBallBase::BP_ResetPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "BP_ResetPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GravityBallBase.BP_OnProjectileVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               NewVisibility                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravityBallBase::BP_OnProjectileVisibilityChanged(bool NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallBase", "BP_OnProjectileVisibilityChanged");

	Params::AGravityBallBase_BP_OnProjectileVisibilityChanged_Params Parms{};

	Parms.NewVisibility = NewVisibility;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.GravityBallProjectile
// (Actor)

class UClass* AGravityBallProjectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GravityBallProjectile");

	return Clss;
}


// GravityBallProjectile IslandsofInsight.Default__GravityBallProjectile
// (Public, ClassDefaultObject, ArchetypeObject)

class AGravityBallProjectile* AGravityBallProjectile::GetDefaultObj()
{
	static class AGravityBallProjectile* Default = nullptr;

	if (!Default)
		Default = static_cast<AGravityBallProjectile*>(AGravityBallProjectile::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GravityBallProjectile.BP_StopTrail
// (Event, Public, BlueprintEvent)
// Parameters:

void AGravityBallProjectile::BP_StopTrail()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallProjectile", "BP_StopTrail");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GravityBallProjectile.BP_StartVFX
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               IsSolved                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravityBallProjectile::BP_StartVFX(bool IsSolved)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallProjectile", "BP_StartVFX");

	Params::AGravityBallProjectile_BP_StartVFX_Params Parms{};

	Parms.IsSolved = IsSolved;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GravityBallProjectile.BP_ImpactedObstacle
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     ImpactLoc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravityBallProjectile::BP_ImpactedObstacle(const struct FVector& ImpactLoc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GravityBallProjectile", "BP_ImpactedObstacle");

	Params::AGravityBallProjectile_BP_ImpactedObstacle_Params Parms{};

	Parms.ImpactLoc = ImpactLoc;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.GravitySphereComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UGravitySphereComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GravitySphereComponent");

	return Clss;
}


// GravitySphereComponent IslandsofInsight.Default__GravitySphereComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UGravitySphereComponent* UGravitySphereComponent::GetDefaultObj()
{
	static class UGravitySphereComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UGravitySphereComponent*>(UGravitySphereComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GravitySpline
// (Actor)

class UClass* AGravitySpline::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GravitySpline");

	return Clss;
}


// GravitySpline IslandsofInsight.Default__GravitySpline
// (Public, ClassDefaultObject, ArchetypeObject)

class AGravitySpline* AGravitySpline::GetDefaultObj()
{
	static class AGravitySpline* Default = nullptr;

	if (!Default)
		Default = static_cast<AGravitySpline*>(AGravitySpline::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GridButton
// (None)

class UClass* UGridButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridButton");

	return Clss;
}


// GridButton IslandsofInsight.Default__GridButton
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridButton* UGridButton::GetDefaultObj()
{
	static class UGridButton* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridButton*>(UGridButton::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GridButton_DEPRECATED
// (Actor)

class UClass* AGridButton_DEPRECATED::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridButton_DEPRECATED");

	return Clss;
}


// GridButton_DEPRECATED IslandsofInsight.Default__GridButton_DEPRECATED
// (Public, ClassDefaultObject, ArchetypeObject)

class AGridButton_DEPRECATED* AGridButton_DEPRECATED::GetDefaultObj()
{
	static class AGridButton_DEPRECATED* Default = nullptr;

	if (!Default)
		Default = static_cast<AGridButton_DEPRECATED*>(AGridButton_DEPRECATED::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.HasGridInput
// (None)

class UClass* IHasGridInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HasGridInput");

	return Clss;
}


// HasGridInput IslandsofInsight.Default__HasGridInput
// (Public, ClassDefaultObject, ArchetypeObject)

class IHasGridInput* IHasGridInput::GetDefaultObj()
{
	static class IHasGridInput* Default = nullptr;

	if (!Default)
		Default = static_cast<IHasGridInput*>(IHasGridInput::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GridInputComponent
// (None)

class UClass* UGridInputComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridInputComponent");

	return Clss;
}


// GridInputComponent IslandsofInsight.Default__GridInputComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridInputComponent* UGridInputComponent::GetDefaultObj()
{
	static class UGridInputComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridInputComponent*>(UGridInputComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GridInvitePromptWidget
// (None)

class UClass* UGridInvitePromptWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridInvitePromptWidget");

	return Clss;
}


// GridInvitePromptWidget IslandsofInsight.Default__GridInvitePromptWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridInvitePromptWidget* UGridInvitePromptWidget::GetDefaultObj()
{
	static class UGridInvitePromptWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridInvitePromptWidget*>(UGridInvitePromptWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GridInvitePromptWidget.ReplyToGridInvite
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               Response                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridInvitePromptWidget::ReplyToGridInvite(bool Response)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridInvitePromptWidget", "ReplyToGridInvite");

	Params::UGridInvitePromptWidget_ReplyToGridInvite_Params Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridInvitePromptWidget.BP_HandleNonInviterMember
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASophiaPlayerState*          PlayerState                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridInvitePromptWidget::BP_HandleNonInviterMember(class ASophiaPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridInvitePromptWidget", "BP_HandleNonInviterMember");

	Params::UGridInvitePromptWidget_BP_HandleNonInviterMember_Params Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.GridInviteWidget
// (None)

class UClass* UGridInviteWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridInviteWidget");

	return Clss;
}


// GridInviteWidget IslandsofInsight.Default__GridInviteWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridInviteWidget* UGridInviteWidget::GetDefaultObj()
{
	static class UGridInviteWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridInviteWidget*>(UGridInviteWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GridInviteWidget.GetLocalPlayerSteamName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGridInviteWidget::GetLocalPlayerSteamName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridInviteWidget", "GetLocalPlayerSteamName");

	Params::UGridInviteWidget_GetLocalPlayerSteamName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GridInviteWidget.GetLocalPlayersAvatarTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  DefaultTexture                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UGridInviteWidget::GetLocalPlayersAvatarTexture(class UTexture2D* DefaultTexture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridInviteWidget", "GetLocalPlayersAvatarTexture");

	Params::UGridInviteWidget_GetLocalPlayersAvatarTexture_Params Parms{};

	Parms.DefaultTexture = DefaultTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GridTip
// (None)

class UClass* UGridTip::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridTip");

	return Clss;
}


// GridTip IslandsofInsight.Default__GridTip
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridTip* UGridTip::GetDefaultObj()
{
	static class UGridTip* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridTip*>(UGridTip::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GridTip.OnClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridTip::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridTip", "OnClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GridTotemPipWidget
// (None)

class UClass* UGridTotemPipWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridTotemPipWidget");

	return Clss;
}


// GridTotemPipWidget IslandsofInsight.Default__GridTotemPipWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridTotemPipWidget* UGridTotemPipWidget::GetDefaultObj()
{
	static class UGridTotemPipWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridTotemPipWidget*>(UGridTotemPipWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GridTotemPipWidget.OnClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridTotemPipWidget::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridTotemPipWidget", "OnClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.GridTutorialPopUp
// (None)

class UClass* UGridTutorialPopUp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridTutorialPopUp");

	return Clss;
}


// GridTutorialPopUp IslandsofInsight.Default__GridTutorialPopUp
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridTutorialPopUp* UGridTutorialPopUp::GetDefaultObj()
{
	static class UGridTutorialPopUp* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridTutorialPopUp*>(UGridTutorialPopUp::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.GridUI
// (None)

class UClass* UGridUI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GridUI");

	return Clss;
}


// GridUI IslandsofInsight.Default__GridUI
// (Public, ClassDefaultObject, ArchetypeObject)

class UGridUI* UGridUI::GetDefaultObj()
{
	static class UGridUI* Default = nullptr;

	if (!Default)
		Default = static_cast<UGridUI*>(UGridUI::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GridUI.ViewPuzzle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::ViewPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "ViewPuzzle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.UndoReleased
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::UndoReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "UndoReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.UndoPressed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::UndoPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "UndoPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.ShowTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::ShowTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "ShowTutorial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.ShowMistakePopup
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::ShowMistakePopup(const struct FVector2D& ScreenPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "ShowMistakePopup");

	Params::UGridUI_ShowMistakePopup_Params Parms{};

	Parms.ScreenPosition = ScreenPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.Restart
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::Restart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Restart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.Previous
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::Previous()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Previous");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.OnPlayGridClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::OnPlayGridClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "OnPlayGridClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.OnPlayAnswerKeyClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::OnPlayAnswerKeyClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "OnPlayAnswerKeyClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.NextOrClose
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::NextOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "NextOrClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.Invite
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::Invite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Invite");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.Hint
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::Hint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Hint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.HideMistakePopup
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGridUI::HideMistakePopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "HideMistakePopup");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.Glimpse
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::Glimpse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Glimpse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.GetTutorialBoxVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UGridUI::GetTutorialBoxVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "GetTutorialBoxVisible");

	Params::UGridUI_GetTutorialBoxVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GridUI.GetTextForTutorialMessage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGridUI::GetTextForTutorialMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "GetTextForTutorialMessage");

	Params::UGridUI_GetTextForTutorialMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GridUI.Exit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UGridUI::Exit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "Exit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GridUI.BP_UpdateProgressCounter
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              NewCounter                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_UpdateProgressCounter(int32 NewCounter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_UpdateProgressCounter");

	Params::UGridUI_BP_UpdateProgressCounter_Params Parms{};

	Parms.NewCounter = NewCounter;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_UpdateMistakesCounter
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              NewCounter                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_UpdateMistakesCounter(int32 NewCounter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_UpdateMistakesCounter");

	Params::UGridUI_BP_UpdateMistakesCounter_Params Parms{};

	Parms.NewCounter = NewCounter;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_UpdateHintCounterV2
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              NewCounter                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewMax                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_UpdateHintCounterV2(float NewCounter, int32 NewMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_UpdateHintCounterV2");

	Params::UGridUI_BP_UpdateHintCounterV2_Params Parms{};

	Parms.NewCounter = NewCounter;
	Parms.NewMax = NewMax;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_UpdateDifficulty
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Difficulty                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_UpdateDifficulty(int32 Difficulty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_UpdateDifficulty");

	Params::UGridUI_BP_UpdateDifficulty_Params Parms{};

	Parms.Difficulty = Difficulty;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_PlaySolveAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void UGridUI::BP_PlaySolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_PlaySolveAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GridUI.BP_NotifyCaveHoverV3
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGridCaveHighlightInfo      Info                                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_NotifyCaveHoverV3(const struct FGridCaveHighlightInfo& Info, bool bShow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_NotifyCaveHoverV3");

	Params::UGridUI_BP_NotifyCaveHoverV3_Params Parms{};

	Parms.Info = Info;
	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_NotifyAreaHoverV2
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                   ScreenCursorLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGridHighlightInfo>  HighlightTiles                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bIsLight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridUI::BP_NotifyAreaHoverV2(const struct FVector2D& ScreenCursorLocation, TArray<struct FGridHighlightInfo>& HighlightTiles, bool bIsLight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_NotifyAreaHoverV2");

	Params::UGridUI_BP_NotifyAreaHoverV2_Params Parms{};

	Parms.ScreenCursorLocation = ScreenCursorLocation;
	Parms.HighlightTiles = HighlightTiles;
	Parms.bIsLight = bIsLight;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.GridUI.BP_NextOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UGridUI::BP_NextOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GridUI", "BP_NextOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.GyroPuzzle
// (Actor)

class UClass* AGyroPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GyroPuzzle");

	return Clss;
}


// GyroPuzzle IslandsofInsight.Default__GyroPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AGyroPuzzle* AGyroPuzzle::GetDefaultObj()
{
	static class AGyroPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AGyroPuzzle*>(AGyroPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.GyroPuzzle.OnRep_SolveTime
// (Final, Native, Protected)
// Parameters:

void AGyroPuzzle::OnRep_SolveTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GyroPuzzle", "OnRep_SolveTime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.GyroPuzzle.GetTeamTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor AGyroPuzzle::GetTeamTint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GyroPuzzle", "GetTeamTint");

	Params::AGyroPuzzle_GetTeamTint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.GyroPuzzle.BP_SolveVisualUpdate
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AGyroPuzzle::BP_SolveVisualUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GyroPuzzle", "BP_SolveVisualUpdate");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.GyroPuzzle.BP_OnPuzzleHovered
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bHovered                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGyroPuzzle::BP_OnPuzzleHovered(bool bHovered)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GyroPuzzle", "BP_OnPuzzleHovered");

	Params::AGyroPuzzle_BP_OnPuzzleHovered_Params Parms{};

	Parms.bHovered = bHovered;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.GyroSpawnVolume
// (Actor)

class UClass* AGyroSpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GyroSpawnVolume");

	return Clss;
}


// GyroSpawnVolume IslandsofInsight.Default__GyroSpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AGyroSpawnVolume* AGyroSpawnVolume::GetDefaultObj()
{
	static class AGyroSpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AGyroSpawnVolume*>(AGyroSpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MirrorMazePuzzle
// (Actor)

class UClass* AMirrorMazePuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MirrorMazePuzzle");

	return Clss;
}


// MirrorMazePuzzle IslandsofInsight.Default__MirrorMazePuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AMirrorMazePuzzle* AMirrorMazePuzzle::GetDefaultObj()
{
	static class AMirrorMazePuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AMirrorMazePuzzle*>(AMirrorMazePuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MirrorMazePuzzle.setParams
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMirrorMazeParams           Params                                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::SetParams(struct FMirrorMazeParams& Params)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "setParams");

	Params::AMirrorMazePuzzle_SetParams_Params Parms{};

	Parms.Params = Params;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.ServerExclusive_CheckEndDetectVolume
// (Final, Native, Public)
// Parameters:

void AMirrorMazePuzzle::ServerExclusive_CheckEndDetectVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "ServerExclusive_CheckEndDetectVolume");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.RegisterEndingMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        Comp                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::RegisterEndingMesh(class UStaticMeshComponent* Comp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "RegisterEndingMesh");

	Params::AMirrorMazePuzzle_RegisterEndingMesh_Params Parms{};

	Parms.Comp = Comp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.RegenerateMaze
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMirrorMazePuzzle::RegenerateMaze()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "RegenerateMaze");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnWallCollision
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         HitComponent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnWallCollision(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnWallCollision");

	Params::AMirrorMazePuzzle_OnWallCollision_Params Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnStartingCellColliderOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnStartingCellColliderOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnStartingCellColliderOverlap");

	Params::AMirrorMazePuzzle_OnStartingCellColliderOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnStartingCellColliderExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnStartingCellColliderExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnStartingCellColliderExit");

	Params::AMirrorMazePuzzle_OnStartingCellColliderExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnEndDetectVolumeOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnEndDetectVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnEndDetectVolumeOverlap");

	Params::AMirrorMazePuzzle_OnEndDetectVolumeOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnEndDetectVolumeExit
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnEndDetectVolumeExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnEndDetectVolumeExit");

	Params::AMirrorMazePuzzle_OnEndDetectVolumeExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnBoundingVolumeOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnBoundingVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnBoundingVolumeOverlap");

	Params::AMirrorMazePuzzle_OnBoundingVolumeOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.OnBoundingVolumeExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::OnBoundingVolumeExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "OnBoundingVolumeExit");

	Params::AMirrorMazePuzzle_OnBoundingVolumeExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.NotifySolved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMirrorMazePuzzle::NotifySolved(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "NotifySolved");

	Params::AMirrorMazePuzzle_NotifySolved_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MirrorMazePuzzle.getParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMirrorMazeParams           ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMirrorMazeParams AMirrorMazePuzzle::GetParams()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazePuzzle", "getParams");

	Params::AMirrorMazePuzzle_GetParams_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.HandmadeMirrorMazePuzzle
// (Actor)

class UClass* AHandmadeMirrorMazePuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HandmadeMirrorMazePuzzle");

	return Clss;
}


// HandmadeMirrorMazePuzzle IslandsofInsight.Default__HandmadeMirrorMazePuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AHandmadeMirrorMazePuzzle* AHandmadeMirrorMazePuzzle::GetDefaultObj()
{
	static class AHandmadeMirrorMazePuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AHandmadeMirrorMazePuzzle*>(AHandmadeMirrorMazePuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.HintBox
// (None)

class UClass* UHintBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HintBox");

	return Clss;
}


// HintBox IslandsofInsight.Default__HintBox
// (Public, ClassDefaultObject, ArchetypeObject)

class UHintBox* UHintBox::GetDefaultObj()
{
	static class UHintBox* Default = nullptr;

	if (!Default)
		Default = static_cast<UHintBox*>(UHintBox::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.HintBox.BP_PlayShowAnim
// (Event, Protected, BlueprintEvent)
// Parameters:

void UHintBox::BP_PlayShowAnim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HintBox", "BP_PlayShowAnim");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.HintBox.BP_PlayHideAnim
// (Event, Protected, BlueprintEvent)
// Parameters:

void UHintBox::BP_PlayHideAnim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HintBox", "BP_PlayHideAnim");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.HintTooltip
// (None)

class UClass* UHintTooltip::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HintTooltip");

	return Clss;
}


// HintTooltip IslandsofInsight.Default__HintTooltip
// (Public, ClassDefaultObject, ArchetypeObject)

class UHintTooltip* UHintTooltip::GetDefaultObj()
{
	static class UHintTooltip* Default = nullptr;

	if (!Default)
		Default = static_cast<UHintTooltip*>(UHintTooltip::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.HintWidget
// (None)

class UClass* UHintWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HintWidget");

	return Clss;
}


// HintWidget IslandsofInsight.Default__HintWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UHintWidget* UHintWidget::GetDefaultObj()
{
	static class UHintWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UHintWidget*>(UHintWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.HintWidget.BP_SetHintText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        AggregateHintText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHintWidget::BP_SetHintText(class FText& AggregateHintText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HintWidget", "BP_SetHintText");

	Params::UHintWidget_BP_SetHintText_Params Parms{};

	Parms.AggregateHintText = AggregateHintText;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.InsightModalWidget
// (None)

class UClass* UInsightModalWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InsightModalWidget");

	return Clss;
}


// InsightModalWidget IslandsofInsight.Default__InsightModalWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UInsightModalWidget* UInsightModalWidget::GetDefaultObj()
{
	static class UInsightModalWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UInsightModalWidget*>(UInsightModalWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InsightModalWidget.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEncyclopediaEntry*          Entry                                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInsightModalWidget::Init(class UEncyclopediaEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightModalWidget", "Init");

	Params::UInsightModalWidget_Init_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.InsightModalWidget.Build
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UInsightModalWidget::Build()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightModalWidget", "Build");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.InsightModalWidget.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInsightModalWidget::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightModalWidget", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PuzzleTotem
// (Actor)

class UClass* APuzzleTotem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleTotem");

	return Clss;
}


// PuzzleTotem IslandsofInsight.Default__PuzzleTotem
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleTotem* APuzzleTotem::GetDefaultObj()
{
	static class APuzzleTotem* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleTotem*>(APuzzleTotem::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.InsightTotem
// (Actor)

class UClass* AInsightTotem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InsightTotem");

	return Clss;
}


// InsightTotem IslandsofInsight.Default__InsightTotem
// (Public, ClassDefaultObject, ArchetypeObject)

class AInsightTotem* AInsightTotem::GetDefaultObj()
{
	static class AInsightTotem* Default = nullptr;

	if (!Default)
		Default = static_cast<AInsightTotem*>(AInsightTotem::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.InsightTotemWidget
// (None)

class UClass* UInsightTotemWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InsightTotemWidget");

	return Clss;
}


// InsightTotemWidget IslandsofInsight.Default__InsightTotemWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UInsightTotemWidget* UInsightTotemWidget::GetDefaultObj()
{
	static class UInsightTotemWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UInsightTotemWidget*>(UInsightTotemWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InsightTotemWidget.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInsightTotemWidget::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightTotemWidget", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.InsightWidget
// (None)

class UClass* UInsightWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InsightWidget");

	return Clss;
}


// InsightWidget IslandsofInsight.Default__InsightWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UInsightWidget* UInsightWidget::GetDefaultObj()
{
	static class UInsightWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UInsightWidget*>(UInsightWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InsightWidget.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInsightWidget::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightWidget", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.InsightWidgetGrid
// (None)

class UClass* UInsightWidgetGrid::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InsightWidgetGrid");

	return Clss;
}


// InsightWidgetGrid IslandsofInsight.Default__InsightWidgetGrid
// (Public, ClassDefaultObject, ArchetypeObject)

class UInsightWidgetGrid* UInsightWidgetGrid::GetDefaultObj()
{
	static class UInsightWidgetGrid* Default = nullptr;

	if (!Default)
		Default = static_cast<UInsightWidgetGrid*>(UInsightWidgetGrid::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InsightWidgetGrid.BP_Reveal
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInsightWidgetGrid::BP_Reveal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightWidgetGrid", "BP_Reveal");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.InsightWidgetGrid.BP_Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInsightWidgetGrid::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InsightWidgetGrid", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.InvisibleWall
// (Actor)

class UClass* AInvisibleWall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InvisibleWall");

	return Clss;
}


// InvisibleWall IslandsofInsight.Default__InvisibleWall
// (Public, ClassDefaultObject, ArchetypeObject)

class AInvisibleWall* AInvisibleWall::GetDefaultObj()
{
	static class AInvisibleWall* Default = nullptr;

	if (!Default)
		Default = static_cast<AInvisibleWall*>(AInvisibleWall::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.InvisibleWall.SetCollisionMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        Mesh                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvisibleWall::SetCollisionMask(class UStaticMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InvisibleWall", "SetCollisionMask");

	Params::AInvisibleWall_SetCollisionMask_Params Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.IslandNumber
// (None)

class UClass* UIslandNumber::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("IslandNumber");

	return Clss;
}


// IslandNumber IslandsofInsight.Default__IslandNumber
// (Public, ClassDefaultObject, ArchetypeObject)

class UIslandNumber* UIslandNumber::GetDefaultObj()
{
	static class UIslandNumber* Default = nullptr;

	if (!Default)
		Default = static_cast<UIslandNumber*>(UIslandNumber::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Item
// (None)

class UClass* UItem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Item");

	return Clss;
}


// Item IslandsofInsight.Default__Item
// (Public, ClassDefaultObject, ArchetypeObject)

class UItem* UItem::GetDefaultObj()
{
	static class UItem* Default = nullptr;

	if (!Default)
		Default = static_cast<UItem*>(UItem::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ItemData
// (None)

class UClass* UItemData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ItemData");

	return Clss;
}


// ItemData IslandsofInsight.Default__ItemData
// (Public, ClassDefaultObject, ArchetypeObject)

class UItemData* UItemData::GetDefaultObj()
{
	static class UItemData* Default = nullptr;

	if (!Default)
		Default = static_cast<UItemData*>(UItemData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.JumpingPad
// (Actor)

class UClass* AJumpingPad::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("JumpingPad");

	return Clss;
}


// JumpingPad IslandsofInsight.Default__JumpingPad
// (Public, ClassDefaultObject, ArchetypeObject)

class AJumpingPad* AJumpingPad::GetDefaultObj()
{
	static class AJumpingPad* Default = nullptr;

	if (!Default)
		Default = static_cast<AJumpingPad*>(AJumpingPad::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.JumpingPad.UpdateJumpHeightVisuals
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AJumpingPad::UpdateJumpHeightVisuals()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "UpdateJumpHeightVisuals");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.JumpingPad.Tick
// (Native, Public)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJumpingPad::Tick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "Tick");

	Params::AJumpingPad_Tick_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.JumpingPad.OnOverlapExit
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJumpingPad::OnOverlapExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "OnOverlapExit");

	Params::AJumpingPad_OnOverlapExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.JumpingPad.OnOverlapEnter
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AJumpingPad::OnOverlapEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "OnOverlapEnter");

	Params::AJumpingPad_OnOverlapEnter_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.JumpingPad.CalculateVelocityVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InVelocity                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AJumpingPad::CalculateVelocityVector(const struct FVector& InVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "CalculateVelocityVector");

	Params::AJumpingPad_CalculateVelocityVector_Params Parms{};

	Parms.InVelocity = InVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.JumpingPad.CalculateVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            SophiaChar                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AJumpingPad::CalculateVelocity(class ASophiaCharacter* SophiaChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("JumpingPad", "CalculateVelocity");

	Params::AJumpingPad_CalculateVelocity_Params Parms{};

	Parms.SophiaChar = SophiaChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.ItemJumpingPad
// (Actor)

class UClass* AItemJumpingPad::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ItemJumpingPad");

	return Clss;
}


// ItemJumpingPad IslandsofInsight.Default__ItemJumpingPad
// (Public, ClassDefaultObject, ArchetypeObject)

class AItemJumpingPad* AItemJumpingPad::GetDefaultObj()
{
	static class AItemJumpingPad* Default = nullptr;

	if (!Default)
		Default = static_cast<AItemJumpingPad*>(AItemJumpingPad::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ItemTeleportPortal
// (Actor)

class UClass* AItemTeleportPortal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ItemTeleportPortal");

	return Clss;
}


// ItemTeleportPortal IslandsofInsight.Default__ItemTeleportPortal
// (Public, ClassDefaultObject, ArchetypeObject)

class AItemTeleportPortal* AItemTeleportPortal::GetDefaultObj()
{
	static class AItemTeleportPortal* Default = nullptr;

	if (!Default)
		Default = static_cast<AItemTeleportPortal*>(AItemTeleportPortal::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.KlotskiPuzzle
// (Actor)

class UClass* AKlotskiPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KlotskiPuzzle");

	return Clss;
}


// KlotskiPuzzle IslandsofInsight.Default__KlotskiPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AKlotskiPuzzle* AKlotskiPuzzle::GetDefaultObj()
{
	static class AKlotskiPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AKlotskiPuzzle*>(AKlotskiPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.KlotskiPuzzle.NetMultiCast_MoveKlotskiBlock
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FIntPoint                   Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              blockIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TargetPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                   TargetOffset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaCharacter*            Sender                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKlotskiPuzzle::NetMultiCast_MoveKlotskiBlock(const struct FIntPoint& Direction, int32 blockIndex, const struct FVector& TargetPosition, const struct FIntPoint& TargetOffset, class ASophiaCharacter* Sender)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KlotskiPuzzle", "NetMultiCast_MoveKlotskiBlock");

	Params::AKlotskiPuzzle_NetMultiCast_MoveKlotskiBlock_Params Parms{};

	Parms.Direction = Direction;
	Parms.blockIndex = blockIndex;
	Parms.TargetPosition = TargetPosition;
	Parms.TargetOffset = TargetOffset;
	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.KlotskiPuzzle.BPI_SetUpBorder
// (Event, Protected, BlueprintEvent)
// Parameters:

void AKlotskiPuzzle::BPI_SetUpBorder()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KlotskiPuzzle", "BPI_SetUpBorder");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.KlotskiPuzzle.BPI_HighlightOnClick
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FInstanceData>       InstData                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               Highlight                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKlotskiPuzzle::BPI_HighlightOnClick(TArray<struct FInstanceData>& InstData, bool Highlight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KlotskiPuzzle", "BPI_HighlightOnClick");

	Params::AKlotskiPuzzle_BPI_HighlightOnClick_Params Parms{};

	Parms.InstData = InstData;
	Parms.Highlight = Highlight;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.LargeMapViewWidget
// (None)

class UClass* ULargeMapViewWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LargeMapViewWidget");

	return Clss;
}


// LargeMapViewWidget IslandsofInsight.Default__LargeMapViewWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class ULargeMapViewWidget* ULargeMapViewWidget::GetDefaultObj()
{
	static class ULargeMapViewWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<ULargeMapViewWidget*>(ULargeMapViewWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LargeMapViewWidget.CloseMapMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ULargeMapViewWidget::CloseMapMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LargeMapViewWidget", "CloseMapMenu");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LargeMapViewWidget.BPI_HideUIPanels
// (Event, Public, BlueprintEvent)
// Parameters:

void ULargeMapViewWidget::BPI_HideUIPanels()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LargeMapViewWidget", "BPI_HideUIPanels");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.LeaderboardMonolith
// (Actor)

class UClass* ALeaderboardMonolith::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LeaderboardMonolith");

	return Clss;
}


// LeaderboardMonolith IslandsofInsight.Default__LeaderboardMonolith
// (Public, ClassDefaultObject, ArchetypeObject)

class ALeaderboardMonolith* ALeaderboardMonolith::GetDefaultObj()
{
	static class ALeaderboardMonolith* Default = nullptr;

	if (!Default)
		Default = static_cast<ALeaderboardMonolith*>(ALeaderboardMonolith::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LeaderboardMonolith.OnRep_TextSet
// (Final, Native, Protected)
// Parameters:

void ALeaderboardMonolith::OnRep_TextSet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LeaderboardMonolith", "OnRep_TextSet");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.LetterboxingUIScalingRule
// (None)

class UClass* ULetterboxingUIScalingRule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LetterboxingUIScalingRule");

	return Clss;
}


// LetterboxingUIScalingRule IslandsofInsight.Default__LetterboxingUIScalingRule
// (Public, ClassDefaultObject, ArchetypeObject)

class ULetterboxingUIScalingRule* ULetterboxingUIScalingRule::GetDefaultObj()
{
	static class ULetterboxingUIScalingRule* Default = nullptr;

	if (!Default)
		Default = static_cast<ULetterboxingUIScalingRule*>(ULetterboxingUIScalingRule::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LevelAndCoinsWidget
// (None)

class UClass* ULevelAndCoinsWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelAndCoinsWidget");

	return Clss;
}


// LevelAndCoinsWidget IslandsofInsight.Default__LevelAndCoinsWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelAndCoinsWidget* ULevelAndCoinsWidget::GetDefaultObj()
{
	static class ULevelAndCoinsWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelAndCoinsWidget*>(ULevelAndCoinsWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LevelAndCoinsWidget.PlayExitAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void ULevelAndCoinsWidget::PlayExitAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "PlayExitAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.LevelAndCoinsWidget.PlayEnterAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void ULevelAndCoinsWidget::PlayEnterAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "PlayEnterAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.LevelAndCoinsWidget.PlayCoinAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void ULevelAndCoinsWidget::PlayCoinAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "PlayCoinAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.LevelAndCoinsWidget.PlayBorbAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void ULevelAndCoinsWidget::PlayBorbAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "PlayBorbAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.LevelAndCoinsWidget.FinishCoinAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ULevelAndCoinsWidget::FinishCoinAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "FinishCoinAnimation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelAndCoinsWidget.FinishBorbAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ULevelAndCoinsWidget::FinishBorbAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelAndCoinsWidget", "FinishBorbAnimation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.LevelGateWidget
// (None)

class UClass* ULevelGateWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelGateWidget");

	return Clss;
}


// LevelGateWidget IslandsofInsight.Default__LevelGateWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelGateWidget* ULevelGateWidget::GetDefaultObj()
{
	static class ULevelGateWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelGateWidget*>(ULevelGateWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LevelGateWidget.ShouldShowStore
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelGateWidget::ShouldShowStore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "ShouldShowStore");

	Params::ULevelGateWidget_ShouldShowStore_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelGateWidget.OnInputUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ULevelGateWidget::OnInputUnlock()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "OnInputUnlock");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelGateWidget.OnInputStore
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ULevelGateWidget::OnInputStore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "OnInputStore");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelGateWidget.OnInputCancel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ULevelGateWidget::OnInputCancel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "OnInputCancel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelGateWidget.GetLastSeenGate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALevelRestrictionVolume*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelRestrictionVolume* ULevelGateWidget::GetLastSeenGate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "GetLastSeenGate");

	Params::ULevelGateWidget_GetLastSeenGate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelGateWidget.BP_NotifyCurrentGate
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASophiaCharacter*            LocalPlayer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelRestrictionVolume*     Gate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelGateWidget::BP_NotifyCurrentGate(class ASophiaCharacter* LocalPlayer, class ALevelRestrictionVolume* Gate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelGateWidget", "BP_NotifyCurrentGate");

	Params::ULevelGateWidget_BP_NotifyCurrentGate_Params Parms{};

	Parms.LocalPlayer = LocalPlayer;
	Parms.Gate = Gate;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.LevelRestrictionVolume
// (Actor)

class UClass* ALevelRestrictionVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelRestrictionVolume");

	return Clss;
}


// LevelRestrictionVolume IslandsofInsight.Default__LevelRestrictionVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ALevelRestrictionVolume* ALevelRestrictionVolume::GetDefaultObj()
{
	static class ALevelRestrictionVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ALevelRestrictionVolume*>(ALevelRestrictionVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LevelRestrictionVolume.TryUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelRestrictionVolume::TryUnlock(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "TryUnlock");

	Params::ALevelRestrictionVolume_TryUnlock_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelRestrictionVolume.IsZoneUnlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelRestrictionVolume::IsZoneUnlocked(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "IsZoneUnlocked");

	Params::ALevelRestrictionVolume_IsZoneUnlocked_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelRestrictionVolume.HideBlocker
// (Final, Native, Private)
// Parameters:

void ALevelRestrictionVolume::HideBlocker()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "HideBlocker");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelRestrictionVolume.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALevelRestrictionVolume::GetTitle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "GetTitle");

	Params::ALevelRestrictionVolume_GetTitle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelRestrictionVolume.GetProgressFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLevelRestrictionItem>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLevelRestrictionItem> ALevelRestrictionVolume::GetProgressFor(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "GetProgressFor");

	Params::ALevelRestrictionVolume_GetProgressFor_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelRestrictionVolume.GetOwnedPuzzleCompletionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              TotalPuzzles                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SolvedPuzzles                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelRestrictionVolume::GetOwnedPuzzleCompletionData(int32* TotalPuzzles, int32* SolvedPuzzles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "GetOwnedPuzzleCompletionData");

	Params::ALevelRestrictionVolume_GetOwnedPuzzleCompletionData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (TotalPuzzles != nullptr)
		*TotalPuzzles = Parms.TotalPuzzles;

	if (SolvedPuzzles != nullptr)
		*SolvedPuzzles = Parms.SolvedPuzzles;

}


// Function IslandsofInsight.LevelRestrictionVolume.GetMissingZoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            ThePlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALevelRestrictionVolume::GetMissingZoneName(class ASophiaCharacter* ThePlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "GetMissingZoneName");

	Params::ALevelRestrictionVolume_GetMissingZoneName_Params Parms{};

	Parms.ThePlayer = ThePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelRestrictionVolume.GetCompletionPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALevelRestrictionVolume::GetCompletionPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "GetCompletionPercentage");

	Params::ALevelRestrictionVolume_GetCompletionPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LevelRestrictionVolume.BPC_SetSolved
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ALevelRestrictionVolume::BPC_SetSolved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "BPC_SetSolved");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LevelRestrictionVolume.BP_OnOpen
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ALevelRestrictionVolume::BP_OnOpen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelRestrictionVolume", "BP_OnOpen");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.LightBlendable
// (None)

class UClass* ULightBlendable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightBlendable");

	return Clss;
}


// LightBlendable IslandsofInsight.Default__LightBlendable
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightBlendable* ULightBlendable::GetDefaultObj()
{
	static class ULightBlendable* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightBlendable*>(ULightBlendable::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LightPillar
// (Actor)

class UClass* ALightPillar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightPillar");

	return Clss;
}


// LightPillar IslandsofInsight.Default__LightPillar
// (Public, ClassDefaultObject, ArchetypeObject)

class ALightPillar* ALightPillar::GetDefaultObj()
{
	static class ALightPillar* Default = nullptr;

	if (!Default)
		Default = static_cast<ALightPillar*>(ALightPillar::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LightPillar.Respawn
// (Final, Native, Private)
// Parameters:

void ALightPillar::Respawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightPillar", "Respawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LightPillar.OnRep_SolveOrder
// (Final, Native, Private)
// Parameters:

void ALightPillar::OnRep_SolveOrder()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightPillar", "OnRep_SolveOrder");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.LightPillarTablet
// (Actor)

class UClass* ALightPillarTablet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightPillarTablet");

	return Clss;
}


// LightPillarTablet IslandsofInsight.Default__LightPillarTablet
// (Public, ClassDefaultObject, ArchetypeObject)

class ALightPillarTablet* ALightPillarTablet::GetDefaultObj()
{
	static class ALightPillarTablet* Default = nullptr;

	if (!Default)
		Default = static_cast<ALightPillarTablet*>(ALightPillarTablet::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LocalSavedData
// (None)

class UClass* ULocalSavedData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocalSavedData");

	return Clss;
}


// LocalSavedData IslandsofInsight.Default__LocalSavedData
// (Public, ClassDefaultObject, ArchetypeObject)

class ULocalSavedData* ULocalSavedData::GetDefaultObj()
{
	static class ULocalSavedData* Default = nullptr;

	if (!Default)
		Default = static_cast<ULocalSavedData*>(ULocalSavedData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LocationPing
// (Actor)

class UClass* ALocationPing::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocationPing");

	return Clss;
}


// LocationPing IslandsofInsight.Default__LocationPing
// (Public, ClassDefaultObject, ArchetypeObject)

class ALocationPing* ALocationPing::GetDefaultObj()
{
	static class ALocationPing* Default = nullptr;

	if (!Default)
		Default = static_cast<ALocationPing*>(ALocationPing::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockedJumpingPad
// (Actor)

class UClass* ALockedJumpingPad::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockedJumpingPad");

	return Clss;
}


// LockedJumpingPad IslandsofInsight.Default__LockedJumpingPad
// (Public, ClassDefaultObject, ArchetypeObject)

class ALockedJumpingPad* ALockedJumpingPad::GetDefaultObj()
{
	static class ALockedJumpingPad* Default = nullptr;

	if (!Default)
		Default = static_cast<ALockedJumpingPad*>(ALockedJumpingPad::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LockedJumpingPad.OnRep_WisdomUpdated
// (Final, Native, Private)
// Parameters:

void ALockedJumpingPad::OnRep_WisdomUpdated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LockedJumpingPad", "OnRep_WisdomUpdated");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LockedJumpingPad.OnRep_UnlockedPlayer
// (Final, Native, Protected)
// Parameters:
// TArray<class ASophiaCharacter*>    Old                                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALockedJumpingPad::OnRep_UnlockedPlayer(const TArray<class ASophiaCharacter*>& Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LockedJumpingPad", "OnRep_UnlockedPlayer");

	Params::ALockedJumpingPad_OnRep_UnlockedPlayer_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.LockedJumpingPad.NM_LaunchPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ASophiaCharacter*            SophiaChar                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALockedJumpingPad::NM_LaunchPlayer(class ASophiaCharacter* SophiaChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LockedJumpingPad", "NM_LaunchPlayer");

	Params::ALockedJumpingPad_NM_LaunchPlayer_Params Parms{};

	Parms.SophiaChar = SophiaChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.Lockpick
// (Actor)

class UClass* ALockpick::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Lockpick");

	return Clss;
}


// Lockpick IslandsofInsight.Default__Lockpick
// (Public, ClassDefaultObject, ArchetypeObject)

class ALockpick* ALockpick::GetDefaultObj()
{
	static class ALockpick* Default = nullptr;

	if (!Default)
		Default = static_cast<ALockpick*>(ALockpick::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Lockpick.GetWireComponents
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralMeshComponent*>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UProceduralMeshComponent*> ALockpick::GetWireComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetWireComponents");

	Params::ALockpick_GetWireComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.GetSymbolComponents
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UStaticMeshComponent*>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStaticMeshComponent*> ALockpick::GetSymbolComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetSymbolComponents");

	Params::ALockpick_GetSymbolComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.GetNumConnections
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALockpick::GetNumConnections()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetNumConnections");

	Params::ALockpick_GetNumConnections_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.GetNumClocks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALockpick::GetNumClocks()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetNumClocks");

	Params::ALockpick_GetNumClocks_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.GetNumButtons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALockpick::GetNumButtons()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetNumButtons");

	Params::ALockpick_GetNumButtons_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.GetHandComponents
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UStaticMeshComponent*>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStaticMeshComponent*> ALockpick::GetHandComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "GetHandComponents");

	Params::ALockpick_GetHandComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Lockpick.BP_UpdateSymbolMaterials
// (Event, Protected, BlueprintEvent)
// Parameters:

void ALockpick::BP_UpdateSymbolMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_UpdateSymbolMaterials");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Lockpick.BP_SymbolRefresh
// (Event, Public, BlueprintEvent)
// Parameters:

void ALockpick::BP_SymbolRefresh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_SymbolRefresh");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Lockpick.BP_SymbolJoined
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Symbol                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALockpick::BP_SymbolJoined(int32 Symbol)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_SymbolJoined");

	Params::ALockpick_BP_SymbolJoined_Params Parms{};

	Parms.Symbol = Symbol;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Lockpick.BP_Solved
// (Event, Public, BlueprintEvent)
// Parameters:

void ALockpick::BP_Solved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_Solved");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Lockpick.BP_OnFocus
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               Focus                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALockpick::BP_OnFocus(bool Focus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_OnFocus");

	Params::ALockpick_BP_OnFocus_Params Parms{};

	Parms.Focus = Focus;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Lockpick.BP_DotIncrement
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              TurnCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALockpick::BP_DotIncrement(int32 TurnCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Lockpick", "BP_DotIncrement");

	Params::ALockpick_BP_DotIncrement_Params Parms{};

	Parms.TurnCount = TurnCount;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.LockpickButtonImageA
// (None)

class UClass* ULockpickButtonImageA::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickButtonImageA");

	return Clss;
}


// LockpickButtonImageA IslandsofInsight.Default__LockpickButtonImageA
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickButtonImageA* ULockpickButtonImageA::GetDefaultObj()
{
	static class ULockpickButtonImageA* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickButtonImageA*>(ULockpickButtonImageA::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockpickButtonImageB
// (None)

class UClass* ULockpickButtonImageB::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickButtonImageB");

	return Clss;
}


// LockpickButtonImageB IslandsofInsight.Default__LockpickButtonImageB
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickButtonImageB* ULockpickButtonImageB::GetDefaultObj()
{
	static class ULockpickButtonImageB* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickButtonImageB*>(ULockpickButtonImageB::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockpickButtonWidget
// (None)

class UClass* ULockpickButtonWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickButtonWidget");

	return Clss;
}


// LockpickButtonWidget IslandsofInsight.Default__LockpickButtonWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickButtonWidget* ULockpickButtonWidget::GetDefaultObj()
{
	static class ULockpickButtonWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickButtonWidget*>(ULockpickButtonWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LockpickButtonWidget.OnClick
// (Final, Native, Protected)
// Parameters:

void ULockpickButtonWidget::OnClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LockpickButtonWidget", "OnClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.LockpickButtonWidgetA
// (None)

class UClass* ULockpickButtonWidgetA::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickButtonWidgetA");

	return Clss;
}


// LockpickButtonWidgetA IslandsofInsight.Default__LockpickButtonWidgetA
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickButtonWidgetA* ULockpickButtonWidgetA::GetDefaultObj()
{
	static class ULockpickButtonWidgetA* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickButtonWidgetA*>(ULockpickButtonWidgetA::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockpickButtonWidgetB
// (None)

class UClass* ULockpickButtonWidgetB::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickButtonWidgetB");

	return Clss;
}


// LockpickButtonWidgetB IslandsofInsight.Default__LockpickButtonWidgetB
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickButtonWidgetB* ULockpickButtonWidgetB::GetDefaultObj()
{
	static class ULockpickButtonWidgetB* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickButtonWidgetB*>(ULockpickButtonWidgetB::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockpickPlaytest
// (Actor)

class UClass* ALockpickPlaytest::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickPlaytest");

	return Clss;
}


// LockpickPlaytest IslandsofInsight.Default__LockpickPlaytest
// (Public, ClassDefaultObject, ArchetypeObject)

class ALockpickPlaytest* ALockpickPlaytest::GetDefaultObj()
{
	static class ALockpickPlaytest* Default = nullptr;

	if (!Default)
		Default = static_cast<ALockpickPlaytest*>(ALockpickPlaytest::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LockpickWidget
// (None)

class UClass* ULockpickWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LockpickWidget");

	return Clss;
}


// LockpickWidget IslandsofInsight.Default__LockpickWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class ULockpickWidget* ULockpickWidget::GetDefaultObj()
{
	static class ULockpickWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<ULockpickWidget*>(ULockpickWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LorenzSystemBall
// (Actor)

class UClass* ALorenzSystemBall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LorenzSystemBall");

	return Clss;
}


// LorenzSystemBall IslandsofInsight.Default__LorenzSystemBall
// (Public, ClassDefaultObject, ArchetypeObject)

class ALorenzSystemBall* ALorenzSystemBall::GetDefaultObj()
{
	static class ALorenzSystemBall* Default = nullptr;

	if (!Default)
		Default = static_cast<ALorenzSystemBall*>(ALorenzSystemBall::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.LorePickup
// (Actor)

class UClass* ALorePickup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LorePickup");

	return Clss;
}


// LorePickup IslandsofInsight.Default__LorePickup
// (Public, ClassDefaultObject, ArchetypeObject)

class ALorePickup* ALorePickup::GetDefaultObj()
{
	static class ALorePickup* Default = nullptr;

	if (!Default)
		Default = static_cast<ALorePickup*>(ALorePickup::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.LorePickup.OnPickedUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEncyclopediaEntry*          ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEncyclopediaEntry* ALorePickup::OnPickedUp(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LorePickup", "OnPickedUp");

	Params::ALorePickup_OnPickedUp_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LorePickup.HasBeenPickedUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALorePickup::HasBeenPickedUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LorePickup", "HasBeenPickedUp");

	Params::ALorePickup_HasBeenPickedUp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.LorePickup.BP_OnClose
// (Event, Protected, BlueprintEvent)
// Parameters:

void ALorePickup::BP_OnClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LorePickup", "BP_OnClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.LorePickup.BP_OnAdvance
// (Event, Protected, BlueprintEvent)
// Parameters:

void ALorePickup::BP_OnAdvance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LorePickup", "BP_OnAdvance");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.MainMenu
// (None)

class UClass* UMainMenu::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MainMenu");

	return Clss;
}


// MainMenu IslandsofInsight.Default__MainMenu
// (Public, ClassDefaultObject, ArchetypeObject)

class UMainMenu* UMainMenu::GetDefaultObj()
{
	static class UMainMenu* Default = nullptr;

	if (!Default)
		Default = static_cast<UMainMenu*>(UMainMenu::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MainMenu.SetUserName
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::SetUserName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "SetUserName");

	Params::UMainMenu_SetUserName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.Setup
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMainMenu::Setup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "Setup");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.SetNicknameFailed
// (Final, Native, Protected)
// Parameters:
// struct FOnlineServiceError         InError                                                          (Parm, NativeAccessSpecifierPublic)
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::SetNicknameFailed(const struct FOnlineServiceError& InError, const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "SetNicknameFailed");

	Params::UMainMenu_SetNicknameFailed_Params Parms{};

	Parms.InError = InError;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.ReceivedPlayerKrakenName
// (Final, Native, Protected)
// Parameters:
// class FString                      InName                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::ReceivedPlayerKrakenName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "ReceivedPlayerKrakenName");

	Params::UMainMenu_ReceivedPlayerKrakenName_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.GetPlayerKrakenName
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class APlayerController*           Controller                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::GetPlayerKrakenName(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "GetPlayerKrakenName");

	Params::UMainMenu_GetPlayerKrakenName_Params Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.GetParentalConsentRequirement
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMainMenu::GetParentalConsentRequirement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "GetParentalConsentRequirement");

	Params::UMainMenu_GetParentalConsentRequirement_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MainMenu.GetParentalConsentAge
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMainMenu::GetParentalConsentAge()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "GetParentalConsentAge");

	Params::UMainMenu_GetParentalConsentAge_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MainMenu.GetKrakenNameFailed
// (Final, Native, Protected)
// Parameters:
// struct FOnlineServiceError         InError                                                          (Parm, NativeAccessSpecifierPublic)

void UMainMenu::GetKrakenNameFailed(const struct FOnlineServiceError& InError)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "GetKrakenNameFailed");

	Params::UMainMenu_GetKrakenNameFailed_Params Parms{};

	Parms.InError = InError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MainMenu.BPI_SetNickNamedFailed
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::BPI_SetNickNamedFailed(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BPI_SetNickNamedFailed");

	Params::UMainMenu_BPI_SetNickNamedFailed_Params Parms{};

	Parms.String = String;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.MainMenu.BPI_ReceivedPlayerKrakenName
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenu::BPI_ReceivedPlayerKrakenName(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BPI_ReceivedPlayerKrakenName");

	Params::UMainMenu_BPI_ReceivedPlayerKrakenName_Params Parms{};

	Parms.String = String;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.MainMenu.BPI_OnUnbanReceived
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BPI_OnUnbanReceived()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BPI_OnUnbanReceived");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MainMenu.BPI_OnBanReceived
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FKrakenBanInfo              BanInfo                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMainMenu::BPI_OnBanReceived(struct FKrakenBanInfo& BanInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BPI_OnBanReceived");

	Params::UMainMenu_BPI_OnBanReceived_Params Parms{};

	Parms.BanInfo = BanInfo;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.MainMenu.BPI_FailedToGetNickname
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BPI_FailedToGetNickname()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BPI_FailedToGetNickname");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MainMenu.BP_OpenSettings
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BP_OpenSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BP_OpenSettings");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MainMenu.BP_OpenMail
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BP_OpenMail()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BP_OpenMail");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MainMenu.BP_OpenFriends
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BP_OpenFriends()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BP_OpenFriends");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MainMenu.BP_CloseSubmenus
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMainMenu::BP_CloseSubmenus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainMenu", "BP_CloseSubmenus");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.MapCamera
// (Actor)

class UClass* AMapCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapCamera");

	return Clss;
}


// MapCamera IslandsofInsight.Default__MapCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class AMapCamera* AMapCamera::GetDefaultObj()
{
	static class AMapCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<AMapCamera*>(AMapCamera::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MapCamera.OnRep_ServerCaptured
// (Final, Native, Protected)
// Parameters:

void AMapCamera::OnRep_ServerCaptured()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapCamera", "OnRep_ServerCaptured");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapCamera.AddShowOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      IgnoreActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapCamera::AddShowOnly(class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapCamera", "AddShowOnly");

	Params::AMapCamera_AddShowOnly_Params Parms{};

	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapCamera.AddIgnoredComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         IgnoreComp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapCamera::AddIgnoredComponents(class UPrimitiveComponent* IgnoreComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapCamera", "AddIgnoredComponents");

	Params::AMapCamera_AddIgnoredComponents_Params Parms{};

	Parms.IgnoreComp = IgnoreComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapCamera.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      IgnoreActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapCamera::AddIgnoredActor(class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapCamera", "AddIgnoredActor");

	Params::AMapCamera_AddIgnoredActor_Params Parms{};

	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MapColCoordWidget
// (None)

class UClass* UMapColCoordWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapColCoordWidget");

	return Clss;
}


// MapColCoordWidget IslandsofInsight.Default__MapColCoordWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMapColCoordWidget* UMapColCoordWidget::GetDefaultObj()
{
	static class UMapColCoordWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMapColCoordWidget*>(UMapColCoordWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MapMarker
// (Actor)

class UClass* AMapMarker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapMarker");

	return Clss;
}


// MapMarker IslandsofInsight.Default__MapMarker
// (Public, ClassDefaultObject, ArchetypeObject)

class AMapMarker* AMapMarker::GetDefaultObj()
{
	static class AMapMarker* Default = nullptr;

	if (!Default)
		Default = static_cast<AMapMarker*>(AMapMarker::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MapMenu
// (None)

class UClass* UMapMenu::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapMenu");

	return Clss;
}


// MapMenu IslandsofInsight.Default__MapMenu
// (Public, ClassDefaultObject, ArchetypeObject)

class UMapMenu* UMapMenu::GetDefaultObj()
{
	static class UMapMenu* Default = nullptr;

	if (!Default)
		Default = static_cast<UMapMenu*>(UMapMenu::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MapMenu.SwapToWardrobeOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToWardrobeOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToWardrobeOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToWardrobe
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToWardrobe()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToWardrobe");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToUpgradesOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToUpgradesOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToUpgradesOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToUpgrades
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToUpgrades()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToUpgrades");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToMasteriesOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToMasteriesOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToMasteriesOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToMasteries
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToMasteries()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToMasteries");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToMapOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToMapOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToMapOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToMap
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToMap");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToEncyclopediaOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToEncyclopediaOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToEncyclopediaOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.SwapToEncyclopedia
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::SwapToEncyclopedia()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "SwapToEncyclopedia");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.RefreshSandboxModal
// (Event, Public, BlueprintEvent)
// Parameters:

void UMapMenu::RefreshSandboxModal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "RefreshSandboxModal");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.OnMapMenuClose
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void UMapMenu::OnMapMenuClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "OnMapMenuClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MapMenu.CheatAddSandboxSolves
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMapMenu::CheatAddSandboxSolves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "CheatAddSandboxSolves");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapMenu.BP_Close
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UMapMenu::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapMenu", "BP_Close");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MapRowCoordWidget
// (None)

class UClass* UMapRowCoordWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapRowCoordWidget");

	return Clss;
}


// MapRowCoordWidget IslandsofInsight.Default__MapRowCoordWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMapRowCoordWidget* UMapRowCoordWidget::GetDefaultObj()
{
	static class UMapRowCoordWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMapRowCoordWidget*>(UMapRowCoordWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MapWidget
// (None)

class UClass* UMapWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapWidget");

	return Clss;
}


// MapWidget IslandsofInsight.Default__MapWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMapWidget* UMapWidget::GetDefaultObj()
{
	static class UMapWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMapWidget*>(UMapWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MapWidget.ZoneSample
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   WorldCoord                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UMapWidget::ZoneSample(const struct FVector2D& WorldCoord)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "ZoneSample");

	Params::UMapWidget_ZoneSample_Params Parms{};

	Parms.WorldCoord = WorldCoord;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.SwitchToPreviousZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               SkipIntroZone                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWidget::SwitchToPreviousZone(bool SkipIntroZone)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "SwitchToPreviousZone");

	Params::UMapWidget_SwitchToPreviousZone_Params Parms{};

	Parms.SkipIntroZone = SkipIntroZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapWidget.SwitchToNextZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               SkipIntroZone                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWidget::SwitchToNextZone(bool SkipIntroZone)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "SwitchToNextZone");

	Params::UMapWidget_SwitchToNextZone_Params Parms{};

	Parms.SkipIntroZone = SkipIntroZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapWidget.GetZoomCenterReal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMapWidget::GetZoomCenterReal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetZoomCenterReal");

	Params::UMapWidget_GetZoomCenterReal_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetZoneIndex
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   WorldCoord                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapWidget::GetZoneIndex(const struct FVector2D& WorldCoord)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetZoneIndex");

	Params::UMapWidget_GetZoneIndex_Params Parms{};

	Parms.WorldCoord = WorldCoord;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetSelectedZoneIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapWidget::GetSelectedZoneIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetSelectedZoneIndex");

	Params::UMapWidget_GetSelectedZoneIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetMouseWorldPos
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMapWidget::GetMouseWorldPos()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetMouseWorldPos");

	Params::UMapWidget_GetMouseWorldPos_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetLastHoveredMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLocationMarkerData         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLocationMarkerData UMapWidget::GetLastHoveredMarker()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetLastHoveredMarker");

	Params::UMapWidget_GetLastHoveredMarker_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetLastClickedMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLocationMarkerData         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLocationMarkerData UMapWidget::GetLastClickedMarker()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetLastClickedMarker");

	Params::UMapWidget_GetLastClickedMarker_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.GetConquestZoneIndex
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   WorldCoord                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapWidget::GetConquestZoneIndex(const struct FVector2D& WorldCoord)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "GetConquestZoneIndex");

	Params::UMapWidget_GetConquestZoneIndex_Params Parms{};

	Parms.WorldCoord = WorldCoord;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MapWidget.EnableInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMapWidget::EnableInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "EnableInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapWidget.DisableInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMapWidget::DisableInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "DisableInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MapWidget.CenterOnPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Instant                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWidget::CenterOnPlayer(bool Instant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MapWidget", "CenterOnPlayer");

	Params::UMapWidget_CenterOnPlayer_Params Parms{};

	Parms.Instant = Instant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MarkerComponent
// (None)

class UClass* UMarkerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MarkerComponent");

	return Clss;
}


// MarkerComponent IslandsofInsight.Default__MarkerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMarkerComponent* UMarkerComponent::GetDefaultObj()
{
	static class UMarkerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMarkerComponent*>(UMarkerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MarkerComponent.OnAnyPuzzleSolve
// (Final, Native, Protected)
// Parameters:
// class APuzzleBase*                 Pb                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarkerComponent::OnAnyPuzzleSolve(class APuzzleBase* Pb)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MarkerComponent", "OnAnyPuzzleSolve");

	Params::UMarkerComponent_OnAnyPuzzleSolve_Params Parms{};

	Parms.Pb = Pb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MarkerEmitter
// (None)

class UClass* UMarkerEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MarkerEmitter");

	return Clss;
}


// MarkerEmitter IslandsofInsight.Default__MarkerEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMarkerEmitter* UMarkerEmitter::GetDefaultObj()
{
	static class UMarkerEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMarkerEmitter*>(UMarkerEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MarkerFunction
// (None)

class UClass* IMarkerFunction::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MarkerFunction");

	return Clss;
}


// MarkerFunction IslandsofInsight.Default__MarkerFunction
// (Public, ClassDefaultObject, ArchetypeObject)

class IMarkerFunction* IMarkerFunction::GetDefaultObj()
{
	static class IMarkerFunction* Default = nullptr;

	if (!Default)
		Default = static_cast<IMarkerFunction*>(IMarkerFunction::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MarkerFunction.MarkerFunction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMapWidget*                  MapWidget                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMarkerFunction::MarkerFunction(class UMapWidget* MapWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MarkerFunction", "MarkerFunction");

	Params::IMarkerFunction_MarkerFunction_Params Parms{};

	Parms.MapWidget = MapWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.MarkerTextures
// (None)

class UClass* UMarkerTextures::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MarkerTextures");

	return Clss;
}


// MarkerTextures IslandsofInsight.Default__MarkerTextures
// (Public, ClassDefaultObject, ArchetypeObject)

class UMarkerTextures* UMarkerTextures::GetDefaultObj()
{
	static class UMarkerTextures* Default = nullptr;

	if (!Default)
		Default = static_cast<UMarkerTextures*>(UMarkerTextures::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MasteryItem
// (None)

class UClass* UMasteryItem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MasteryItem");

	return Clss;
}


// MasteryItem IslandsofInsight.Default__MasteryItem
// (Public, ClassDefaultObject, ArchetypeObject)

class UMasteryItem* UMasteryItem::GetDefaultObj()
{
	static class UMasteryItem* Default = nullptr;

	if (!Default)
		Default = static_cast<UMasteryItem*>(UMasteryItem::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MasteryItem.UpdateLastSeenMasteryProgress
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UMasteryItem::UpdateLastSeenMasteryProgress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "UpdateLastSeenMasteryProgress");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MasteryItem.ShouldHideMastery
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMasteryItem::ShouldHideMastery()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "ShouldHideMastery");

	Params::UMasteryItem_ShouldHideMastery_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.IsMasteryEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMasteryItem::IsMasteryEquipped()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "IsMasteryEquipped");

	Params::UMasteryItem_IsMasteryEquipped_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.IsDoneAnimating
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMasteryItem::IsDoneAnimating()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "IsDoneAnimating");

	Params::UMasteryItem_IsDoneAnimating_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.GetRankNumber
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMasteryItem::GetRankNumber()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "GetRankNumber");

	Params::UMasteryItem_GetRankNumber_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.GetMasteryValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMasteryItem::GetMasteryValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "GetMasteryValue");

	Params::UMasteryItem_GetMasteryValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.GetMasteryRankName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMasteryItem::GetMasteryRankName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "GetMasteryRankName");

	Params::UMasteryItem_GetMasteryRankName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.GetMasteryProgress
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMasteryItem::GetMasteryProgress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "GetMasteryProgress");

	Params::UMasteryItem_GetMasteryProgress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.GetAnimMasteryProgress
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMasteryItem::GetAnimMasteryProgress(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "GetAnimMasteryProgress");

	Params::UMasteryItem_GetAnimMasteryProgress_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryItem.BPI_PlayLevelUpAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               PlayBorderAnimation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMasteryItem::BPI_PlayLevelUpAnimation(bool PlayBorderAnimation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "BPI_PlayLevelUpAnimation");

	Params::UMasteryItem_BPI_PlayLevelUpAnimation_Params Parms{};

	Parms.PlayBorderAnimation = PlayBorderAnimation;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.MasteryItem.AreMasteryRewardsUnclaimed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMasteryItem::AreMasteryRewardsUnclaimed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryItem", "AreMasteryRewardsUnclaimed");

	Params::UMasteryItem_AreMasteryRewardsUnclaimed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.MasteryProgressNotification
// (None)

class UClass* UMasteryProgressNotification::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MasteryProgressNotification");

	return Clss;
}


// MasteryProgressNotification IslandsofInsight.Default__MasteryProgressNotification
// (Public, ClassDefaultObject, ArchetypeObject)

class UMasteryProgressNotification* UMasteryProgressNotification::GetDefaultObj()
{
	static class UMasteryProgressNotification* Default = nullptr;

	if (!Default)
		Default = static_cast<UMasteryProgressNotification*>(UMasteryProgressNotification::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MasteryProgressNotification.StartTimer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UMasteryProgressNotification::StartTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "StartTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MasteryProgressNotification.OnMasteryNotificationEnd
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMasteryProgressNotification::OnMasteryNotificationEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "OnMasteryNotificationEnd");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MasteryProgressNotification.GetOverallCurrentGain
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMasteryProgressNotification::GetOverallCurrentGain()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "GetOverallCurrentGain");

	Params::UMasteryProgressNotification_GetOverallCurrentGain_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MasteryProgressNotification.BPI_UpdateMasteryValue
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              NewEndValue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMasteryProgressNotification::BPI_UpdateMasteryValue(float NewEndValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BPI_UpdateMasteryValue");

	Params::UMasteryProgressNotification_BPI_UpdateMasteryValue_Params Parms{};

	Parms.NewEndValue = NewEndValue;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.MasteryProgressNotification.BPI_PlayCoinAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMasteryProgressNotification::BPI_PlayCoinAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BPI_PlayCoinAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MasteryProgressNotification.BPC_ResetIncrement
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:

void UMasteryProgressNotification::BPC_ResetIncrement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BPC_ResetIncrement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MasteryProgressNotification.BPC_ResetAmount
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:

void UMasteryProgressNotification::BPC_ResetAmount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BPC_ResetAmount");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MasteryProgressNotification.BPC_GetCoinsInfo
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              AdditionalCoins                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TotalCoins                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMasteryProgressNotification::BPC_GetCoinsInfo(int32* AdditionalCoins, int32* TotalCoins)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BPC_GetCoinsInfo");

	Params::UMasteryProgressNotification_BPC_GetCoinsInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (AdditionalCoins != nullptr)
		*AdditionalCoins = Parms.AdditionalCoins;

	if (TotalCoins != nullptr)
		*TotalCoins = Parms.TotalCoins;

}


// Function IslandsofInsight.MasteryProgressNotification.BP_UpdateWidget
// (Event, Public, BlueprintEvent)
// Parameters:

void UMasteryProgressNotification::BP_UpdateWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BP_UpdateWidget");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.MasteryProgressNotification.BP_UpdateAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:

void UMasteryProgressNotification::BP_UpdateAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MasteryProgressNotification", "BP_UpdateAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.MasteryUnlockNotificationWidget
// (None)

class UClass* UMasteryUnlockNotificationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MasteryUnlockNotificationWidget");

	return Clss;
}


// MasteryUnlockNotificationWidget IslandsofInsight.Default__MasteryUnlockNotificationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMasteryUnlockNotificationWidget* UMasteryUnlockNotificationWidget::GetDefaultObj()
{
	static class UMasteryUnlockNotificationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMasteryUnlockNotificationWidget*>(UMasteryUnlockNotificationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Match3Button
// (Actor)

class UClass* AMatch3Button::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Match3Button");

	return Clss;
}


// Match3Button IslandsofInsight.Default__Match3Button
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatch3Button* AMatch3Button::GetDefaultObj()
{
	static class AMatch3Button* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatch3Button*>(AMatch3Button::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Match3Puzzle
// (Actor)

class UClass* AMatch3Puzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Match3Puzzle");

	return Clss;
}


// Match3Puzzle IslandsofInsight.Default__Match3Puzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatch3Puzzle* AMatch3Puzzle::GetDefaultObj()
{
	static class AMatch3Puzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatch3Puzzle*>(AMatch3Puzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Match3Puzzle.IsSpeedDungeon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatch3Puzzle::IsSpeedDungeon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "IsSpeedDungeon");

	Params::AMatch3Puzzle_IsSpeedDungeon_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Match3Puzzle.BPI_SetUpBorder
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BPI_SetUpBorder()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_SetUpBorder");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BPI_Selected
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                              IsmIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Selected                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatch3Puzzle::BPI_Selected(int32 IsmIndex, bool Selected)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_Selected");

	Params::AMatch3Puzzle_BPI_Selected_Params Parms{};

	Parms.IsmIndex = IsmIndex;
	Parms.Selected = Selected;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Match3Puzzle.BPI_PlaySpeedDungeonMusic
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BPI_PlaySpeedDungeonMusic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_PlaySpeedDungeonMusic");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BPI_PauseSpeedDungeonMusic
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BPI_PauseSpeedDungeonMusic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_PauseSpeedDungeonMusic");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BPI_ChangeTilesToGrey
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BPI_ChangeTilesToGrey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_ChangeTilesToGrey");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BPI_AfterPuzzleInit
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BPI_AfterPuzzleInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BPI_AfterPuzzleInit");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BP_OnExitPuzzle
// (Event, Public, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BP_OnExitPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BP_OnExitPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Match3Puzzle.BP_OnEnterPuzzle
// (Event, Public, BlueprintEvent)
// Parameters:

void AMatch3Puzzle::BP_OnEnterPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3Puzzle", "BP_OnEnterPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.Match3UI
// (None)

class UClass* UMatch3UI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Match3UI");

	return Clss;
}


// Match3UI IslandsofInsight.Default__Match3UI
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatch3UI* UMatch3UI::GetDefaultObj()
{
	static class UMatch3UI* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatch3UI*>(UMatch3UI::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Match3UI.GetMovesTextVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UMatch3UI::GetMovesTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3UI", "GetMovesTextVisibility");

	Params::UMatch3UI_GetMovesTextVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Match3UI.GetMovesTextMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMatch3UI::GetMovesTextMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3UI", "GetMovesTextMessage");

	Params::UMatch3UI_GetMovesTextMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Match3UI.BPI_UpdateMovesText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Message                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatch3UI::BPI_UpdateMovesText(class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3UI", "BPI_UpdateMovesText");

	Params::UMatch3UI_BPI_UpdateMovesText_Params Parms{};

	Parms.Message = Message;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Match3UI.BPI_PlayResultsAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               Reverse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatch3UI::BPI_PlayResultsAnimation(bool Reverse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3UI", "BPI_PlayResultsAnimation");

	Params::UMatch3UI_BPI_PlayResultsAnimation_Params Parms{};

	Parms.Reverse = Reverse;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Match3UI.BPI_ForceResultsOffscreen
// (Event, Public, BlueprintEvent)
// Parameters:

void UMatch3UI::BPI_ForceResultsOffscreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Match3UI", "BPI_ForceResultsOffscreen");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.Matchbox
// (Actor)

class UClass* AMatchbox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Matchbox");

	return Clss;
}


// Matchbox IslandsofInsight.Default__Matchbox
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatchbox* AMatchbox::GetDefaultObj()
{
	static class AMatchbox* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatchbox*>(AMatchbox::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxGenerationSettings
// (None)

class UClass* UMatchboxGenerationSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxGenerationSettings");

	return Clss;
}


// MatchboxGenerationSettings IslandsofInsight.Default__MatchboxGenerationSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxGenerationSettings* UMatchboxGenerationSettings::GetDefaultObj()
{
	static class UMatchboxGenerationSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxGenerationSettings*>(UMatchboxGenerationSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.CookedMatchboxSpawningContextContainer
// (None)

class UClass* UCookedMatchboxSpawningContextContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CookedMatchboxSpawningContextContainer");

	return Clss;
}


// CookedMatchboxSpawningContextContainer IslandsofInsight.Default__CookedMatchboxSpawningContextContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UCookedMatchboxSpawningContextContainer* UCookedMatchboxSpawningContextContainer::GetDefaultObj()
{
	static class UCookedMatchboxSpawningContextContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UCookedMatchboxSpawningContextContainer*>(UCookedMatchboxSpawningContextContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AutoDeletionRespawningPuzzleInfo
// (None)

class UClass* UAutoDeletionRespawningPuzzleInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AutoDeletionRespawningPuzzleInfo");

	return Clss;
}


// AutoDeletionRespawningPuzzleInfo IslandsofInsight.Default__AutoDeletionRespawningPuzzleInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class UAutoDeletionRespawningPuzzleInfo* UAutoDeletionRespawningPuzzleInfo::GetDefaultObj()
{
	static class UAutoDeletionRespawningPuzzleInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<UAutoDeletionRespawningPuzzleInfo*>(UAutoDeletionRespawningPuzzleInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxData
// (None)

class UClass* UMatchboxData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxData");

	return Clss;
}


// MatchboxData IslandsofInsight.Default__MatchboxData
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxData* UMatchboxData::GetDefaultObj()
{
	static class UMatchboxData* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxData*>(UMatchboxData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleSpawningComponentBase
// (SceneComponent)

class UClass* UPuzzleSpawningComponentBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleSpawningComponentBase");

	return Clss;
}


// PuzzleSpawningComponentBase IslandsofInsight.Default__PuzzleSpawningComponentBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleSpawningComponentBase* UPuzzleSpawningComponentBase::GetDefaultObj()
{
	static class UPuzzleSpawningComponentBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleSpawningComponentBase*>(UPuzzleSpawningComponentBase::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleSpawningComponentWithAutoDeletion
// (SceneComponent)

class UClass* UPuzzleSpawningComponentWithAutoDeletion::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleSpawningComponentWithAutoDeletion");

	return Clss;
}


// PuzzleSpawningComponentWithAutoDeletion IslandsofInsight.Default__PuzzleSpawningComponentWithAutoDeletion
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleSpawningComponentWithAutoDeletion* UPuzzleSpawningComponentWithAutoDeletion::GetDefaultObj()
{
	static class UPuzzleSpawningComponentWithAutoDeletion* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleSpawningComponentWithAutoDeletion*>(UPuzzleSpawningComponentWithAutoDeletion::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxEditorSpawningComponent
// (SceneComponent)

class UClass* UMatchboxEditorSpawningComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxEditorSpawningComponent");

	return Clss;
}


// MatchboxEditorSpawningComponent IslandsofInsight.Default__MatchboxEditorSpawningComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxEditorSpawningComponent* UMatchboxEditorSpawningComponent::GetDefaultObj()
{
	static class UMatchboxEditorSpawningComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxEditorSpawningComponent*>(UMatchboxEditorSpawningComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MatchboxEditorSpawningComponent.Cook_SuperExpensive
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMatchboxEditorSpawningComponent::Cook_SuperExpensive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatchboxEditorSpawningComponent", "Cook_SuperExpensive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MatchboxExternal
// (Actor)

class UClass* AMatchboxExternal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxExternal");

	return Clss;
}


// MatchboxExternal IslandsofInsight.Default__MatchboxExternal
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatchboxExternal* AMatchboxExternal::GetDefaultObj()
{
	static class AMatchboxExternal* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatchboxExternal*>(AMatchboxExternal::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxRadarComponent
// (None)

class UClass* UMatchboxRadarComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxRadarComponent");

	return Clss;
}


// MatchboxRadarComponent IslandsofInsight.Default__MatchboxRadarComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxRadarComponent* UMatchboxRadarComponent::GetDefaultObj()
{
	static class UMatchboxRadarComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxRadarComponent*>(UMatchboxRadarComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxSymbolWidget
// (None)

class UClass* UMatchboxSymbolWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxSymbolWidget");

	return Clss;
}


// MatchboxSymbolWidget IslandsofInsight.Default__MatchboxSymbolWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxSymbolWidget* UMatchboxSymbolWidget::GetDefaultObj()
{
	static class UMatchboxSymbolWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxSymbolWidget*>(UMatchboxSymbolWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MatchboxVisualData
// (None)

class UClass* UMatchboxVisualData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatchboxVisualData");

	return Clss;
}


// MatchboxVisualData IslandsofInsight.Default__MatchboxVisualData
// (Public, ClassDefaultObject, ArchetypeObject)

class UMatchboxVisualData* UMatchboxVisualData::GetDefaultObj()
{
	static class UMatchboxVisualData* Default = nullptr;

	if (!Default)
		Default = static_cast<UMatchboxVisualData*>(UMatchboxVisualData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MegaRosary
// (Actor)

class UClass* AMegaRosary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MegaRosary");

	return Clss;
}


// MegaRosary IslandsofInsight.Default__MegaRosary
// (Public, ClassDefaultObject, ArchetypeObject)

class AMegaRosary* AMegaRosary::GetDefaultObj()
{
	static class AMegaRosary* Default = nullptr;

	if (!Default)
		Default = static_cast<AMegaRosary*>(AMegaRosary::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MegaRosary.OnClickFire
// (Native, Public, HasOutParams)
// Parameters:
// struct FClickEventContext          Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMegaRosary::OnClickFire(struct FClickEventContext& Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MegaRosary", "OnClickFire");

	Params::AMegaRosary_OnClickFire_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.MeshMergeFunctionLibrary
// (None)

class UClass* UMeshMergeFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MeshMergeFunctionLibrary");

	return Clss;
}


// MeshMergeFunctionLibrary IslandsofInsight.Default__MeshMergeFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UMeshMergeFunctionLibrary* UMeshMergeFunctionLibrary::GetDefaultObj()
{
	static class UMeshMergeFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UMeshMergeFunctionLibrary*>(UMeshMergeFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MeshMergeFunctionLibrary.MergeMeshes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSkeletalMeshMergeParams    Params                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UMeshMergeFunctionLibrary::MergeMeshes(struct FSkeletalMeshMergeParams& Params)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshMergeFunctionLibrary", "MergeMeshes");

	Params::UMeshMergeFunctionLibrary_MergeMeshes_Params Parms{};

	Parms.Params = Params;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.GameMessage
// (None)

class UClass* UGameMessage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameMessage");

	return Clss;
}


// GameMessage IslandsofInsight.Default__GameMessage
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameMessage* UGameMessage::GetDefaultObj()
{
	static class UGameMessage* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameMessage*>(UGameMessage::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MessageQueueWidget
// (None)

class UClass* UMessageQueueWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MessageQueueWidget");

	return Clss;
}


// MessageQueueWidget IslandsofInsight.Default__MessageQueueWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMessageQueueWidget* UMessageQueueWidget::GetDefaultObj()
{
	static class UMessageQueueWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMessageQueueWidget*>(UMessageQueueWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MessageQueueWidget.AddMessage
// (Final, Native, Public)
// Parameters:
// class UGameMessage*                MessageObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MessagePriority                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageQueueWidget::AddMessage(class UGameMessage* MessageObject, float Time, int32 MessagePriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MessageQueueWidget", "AddMessage");

	Params::UMessageQueueWidget_AddMessage_Params Parms{};

	Parms.MessageObject = MessageObject;
	Parms.Time = Time;
	Parms.MessagePriority = MessagePriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MessageWidget
// (None)

class UClass* UMessageWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MessageWidget");

	return Clss;
}


// MessageWidget IslandsofInsight.Default__MessageWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMessageWidget* UMessageWidget::GetDefaultObj()
{
	static class UMessageWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMessageWidget*>(UMessageWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MicrophoneSpeakComponent
// (None)

class UClass* UMicrophoneSpeakComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MicrophoneSpeakComponent");

	return Clss;
}


// MicrophoneSpeakComponent IslandsofInsight.Default__MicrophoneSpeakComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMicrophoneSpeakComponent* UMicrophoneSpeakComponent::GetDefaultObj()
{
	static class UMicrophoneSpeakComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMicrophoneSpeakComponent*>(UMicrophoneSpeakComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MicrophoneSpeakComponent.startSpeaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               _shouldHearMyOwnVoice                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsGlobal                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              RadioChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UseRange                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxRange                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMicrophoneSpeakComponent::StartSpeaking(bool _shouldHearMyOwnVoice, bool IsGlobal, int32 RadioChannel, bool UseRange, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "startSpeaking");

	Params::UMicrophoneSpeakComponent_StartSpeaking_Params Parms{};

	Parms._shouldHearMyOwnVoice = _shouldHearMyOwnVoice;
	Parms.IsGlobal = IsGlobal;
	Parms.RadioChannel = RadioChannel;
	Parms.UseRange = UseRange;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.SetVoiceVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::SetVoiceVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "SetVoiceVolume");

	Params::UMicrophoneSpeakComponent_SetVoiceVolume_Params Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.setAttenuationAssetPath
// (Final, Native, Public)
// Parameters:
// bool                               EnableAttenuation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      _pathToAttenuationAsset                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::SetAttenuationAssetPath(bool EnableAttenuation, const class FString& _pathToAttenuationAsset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "setAttenuationAssetPath");

	Params::UMicrophoneSpeakComponent_SetAttenuationAssetPath_Params Parms{};

	Parms.EnableAttenuation = EnableAttenuation;
	Parms._pathToAttenuationAsset = _pathToAttenuationAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.RPCServerBroadcastVoiceData
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<uint8>                      Data                                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              SampleRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumChannels                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PCMSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::RPCServerBroadcastVoiceData(TArray<uint8>& Data, int32 SampleRate, int32 NumChannels, int32 PCMSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "RPCServerBroadcastVoiceData");

	Params::UMicrophoneSpeakComponent_RPCServerBroadcastVoiceData_Params Parms{};

	Parms.Data = Data;
	Parms.SampleRate = SampleRate;
	Parms.NumChannels = NumChannels;
	Parms.PCMSize = PCMSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.RPCReceiveVoiceFromServer
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UMicrophoneSpeakComponent*   CompToOutputVoice                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                      DataEncoded                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              SampleRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumChannels                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PCMSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::RPCReceiveVoiceFromServer(class UMicrophoneSpeakComponent* CompToOutputVoice, TArray<uint8>& DataEncoded, int32 SampleRate, int32 NumChannels, int32 PCMSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "RPCReceiveVoiceFromServer");

	Params::UMicrophoneSpeakComponent_RPCReceiveVoiceFromServer_Params Parms{};

	Parms.CompToOutputVoice = CompToOutputVoice;
	Parms.DataEncoded = DataEncoded;
	Parms.SampleRate = SampleRate;
	Parms.NumChannels = NumChannels;
	Parms.PCMSize = PCMSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.RPCClientTransmitVoiceData
// (Net, Native, Event, Public, NetServer)
// Parameters:
// TArray<uint8>                      Data                                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              SampleRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumChannels                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PCMSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               _isGlobal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              _radioChannel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               _useRange                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              _maxRange                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::RPCClientTransmitVoiceData(TArray<uint8>& Data, int32 SampleRate, int32 NumChannels, int32 PCMSize, bool _isGlobal, int32 _radioChannel, bool _useRange, float _maxRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "RPCClientTransmitVoiceData");

	Params::UMicrophoneSpeakComponent_RPCClientTransmitVoiceData_Params Parms{};

	Parms.Data = Data;
	Parms.SampleRate = SampleRate;
	Parms.NumChannels = NumChannels;
	Parms.PCMSize = PCMSize;
	Parms._isGlobal = _isGlobal;
	Parms._radioChannel = _radioChannel;
	Parms._useRange = _useRange;
	Parms._maxRange = _maxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.payloadReceivedVoiceData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                      DataEncoded                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              SampleRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumChannels                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PCMSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::PayloadReceivedVoiceData(TArray<uint8>& DataEncoded, int32 SampleRate, int32 NumChannels, int32 PCMSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "payloadReceivedVoiceData");

	Params::UMicrophoneSpeakComponent_PayloadReceivedVoiceData_Params Parms{};

	Parms.DataEncoded = DataEncoded;
	Parms.SampleRate = SampleRate;
	Parms.NumChannels = NumChannels;
	Parms.PCMSize = PCMSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.muteAudio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               _isMuted                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::MuteAudio(bool _isMuted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "muteAudio");

	Params::UMicrophoneSpeakComponent_MuteAudio_Params Parms{};

	Parms._isMuted = _isMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.isPlayingAudioVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMicrophoneSpeakComponent::IsPlayingAudioVoice()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "isPlayingAudioVoice");

	Params::UMicrophoneSpeakComponent_IsPlayingAudioVoice_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.initAudioResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              VoiceSampleRate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              _voiceNumChannels                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMicrophoneSpeakComponent::InitAudioResources(int32 VoiceSampleRate, int32 _voiceNumChannels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "initAudioResources");

	Params::UMicrophoneSpeakComponent_InitAudioResources_Params Parms{};

	Parms.VoiceSampleRate = VoiceSampleRate;
	Parms._voiceNumChannels = _voiceNumChannels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MicrophoneSpeakComponent.endSpeaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMicrophoneSpeakComponent::EndSpeaking()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "endSpeaking");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction IslandsofInsight.MicrophoneSpeakComponent.DataMicrophoneReceived__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// TArray<uint8>                      Data                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMicrophoneSpeakComponent::DataMicrophoneReceived__DelegateSignature(TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MicrophoneSpeakComponent", "DataMicrophoneReceived__DelegateSignature");

	Params::UMicrophoneSpeakComponent_DataMicrophoneReceived__DelegateSignature_Params Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.Minimap
// (None)

class UClass* UMinimap::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Minimap");

	return Clss;
}


// Minimap IslandsofInsight.Default__Minimap
// (Public, ClassDefaultObject, ArchetypeObject)

class UMinimap* UMinimap::GetDefaultObj()
{
	static class UMinimap* Default = nullptr;

	if (!Default)
		Default = static_cast<UMinimap*>(UMinimap::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MirrorMazeTeleportPlatform
// (Actor)

class UClass* AMirrorMazeTeleportPlatform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MirrorMazeTeleportPlatform");

	return Clss;
}


// MirrorMazeTeleportPlatform IslandsofInsight.Default__MirrorMazeTeleportPlatform
// (Public, ClassDefaultObject, ArchetypeObject)

class AMirrorMazeTeleportPlatform* AMirrorMazeTeleportPlatform::GetDefaultObj()
{
	static class AMirrorMazeTeleportPlatform* Default = nullptr;

	if (!Default)
		Default = static_cast<AMirrorMazeTeleportPlatform*>(AMirrorMazeTeleportPlatform::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MirrorMazeWidget
// (None)

class UClass* UMirrorMazeWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MirrorMazeWidget");

	return Clss;
}


// MirrorMazeWidget IslandsofInsight.Default__MirrorMazeWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMirrorMazeWidget* UMirrorMazeWidget::GetDefaultObj()
{
	static class UMirrorMazeWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMirrorMazeWidget*>(UMirrorMazeWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MirrorMazeWidget.IsWidgetVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UMirrorMazeWidget::IsWidgetVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazeWidget", "IsWidgetVisible");

	Params::UMirrorMazeWidget_IsWidgetVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.MirrorMazeWidget.BP_VisualizeMilestones
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               AdeptReached                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ExpertReached                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               MasterReached                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorMazeWidget::BP_VisualizeMilestones(bool AdeptReached, bool ExpertReached, bool MasterReached)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MirrorMazeWidget", "BP_VisualizeMilestones");

	Params::UMirrorMazeWidget_BP_VisualizeMilestones_Params Parms{};

	Parms.AdeptReached = AdeptReached;
	Parms.ExpertReached = ExpertReached;
	Parms.MasterReached = MasterReached;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.MirrorSymmetrySymbol
// (None)

class UClass* UMirrorSymmetrySymbol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MirrorSymmetrySymbol");

	return Clss;
}


// MirrorSymmetrySymbol IslandsofInsight.Default__MirrorSymmetrySymbol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMirrorSymmetrySymbol* UMirrorSymmetrySymbol::GetDefaultObj()
{
	static class UMirrorSymmetrySymbol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMirrorSymmetrySymbol*>(UMirrorSymmetrySymbol::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MonolithMatch
// (Actor)

class UClass* AMonolithMatch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MonolithMatch");

	return Clss;
}


// MonolithMatch IslandsofInsight.Default__MonolithMatch
// (Public, ClassDefaultObject, ArchetypeObject)

class AMonolithMatch* AMonolithMatch::GetDefaultObj()
{
	static class AMonolithMatch* Default = nullptr;

	if (!Default)
		Default = static_cast<AMonolithMatch*>(AMonolithMatch::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Monument
// (Actor)

class UClass* AMonument::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Monument");

	return Clss;
}


// Monument IslandsofInsight.Default__Monument
// (Public, ClassDefaultObject, ArchetypeObject)

class AMonument* AMonument::GetDefaultObj()
{
	static class AMonument* Default = nullptr;

	if (!Default)
		Default = static_cast<AMonument*>(AMonument::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleContainerData
// (None)

class UClass* UPuzzleContainerData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleContainerData");

	return Clss;
}


// PuzzleContainerData IslandsofInsight.Default__PuzzleContainerData
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleContainerData* UPuzzleContainerData::GetDefaultObj()
{
	static class UPuzzleContainerData* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleContainerData*>(UPuzzleContainerData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MonumentPuzzleContainer
// (None)

class UClass* UMonumentPuzzleContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MonumentPuzzleContainer");

	return Clss;
}


// MonumentPuzzleContainer IslandsofInsight.Default__MonumentPuzzleContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UMonumentPuzzleContainer* UMonumentPuzzleContainer::GetDefaultObj()
{
	static class UMonumentPuzzleContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UMonumentPuzzleContainer*>(UMonumentPuzzleContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MouseControlledRaymarchFractal
// (Actor)

class UClass* AMouseControlledRaymarchFractal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MouseControlledRaymarchFractal");

	return Clss;
}


// MouseControlledRaymarchFractal IslandsofInsight.Default__MouseControlledRaymarchFractal
// (Public, ClassDefaultObject, ArchetypeObject)

class AMouseControlledRaymarchFractal* AMouseControlledRaymarchFractal::GetDefaultObj()
{
	static class AMouseControlledRaymarchFractal* Default = nullptr;

	if (!Default)
		Default = static_cast<AMouseControlledRaymarchFractal*>(AMouseControlledRaymarchFractal::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MovementSpeedWidget
// (None)

class UClass* UMovementSpeedWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MovementSpeedWidget");

	return Clss;
}


// MovementSpeedWidget IslandsofInsight.Default__MovementSpeedWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMovementSpeedWidget* UMovementSpeedWidget::GetDefaultObj()
{
	static class UMovementSpeedWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMovementSpeedWidget*>(UMovementSpeedWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MultiplayerPuzzleBase
// (Actor)

class UClass* AMultiplayerPuzzleBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerPuzzleBase");

	return Clss;
}


// MultiplayerPuzzleBase IslandsofInsight.Default__MultiplayerPuzzleBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AMultiplayerPuzzleBase* AMultiplayerPuzzleBase::GetDefaultObj()
{
	static class AMultiplayerPuzzleBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AMultiplayerPuzzleBase*>(AMultiplayerPuzzleBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MultiplayerPuzzleBase.OnRep_workerInfos
// (Final, Native, Private)
// Parameters:

void AMultiplayerPuzzleBase::OnRep_workerInfos()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerPuzzleBase", "OnRep_workerInfos");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MultiplayerPuzzleBase.GetWorkerPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ASophiaCharacter*>    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASophiaCharacter*> AMultiplayerPuzzleBase::GetWorkerPlayers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerPuzzleBase", "GetWorkerPlayers");

	Params::AMultiplayerPuzzleBase_GetWorkerPlayers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.MultiplayerLaserPuzzleBase
// (Actor)

class UClass* AMultiplayerLaserPuzzleBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserPuzzleBase");

	return Clss;
}


// MultiplayerLaserPuzzleBase IslandsofInsight.Default__MultiplayerLaserPuzzleBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AMultiplayerLaserPuzzleBase* AMultiplayerLaserPuzzleBase::GetDefaultObj()
{
	static class AMultiplayerLaserPuzzleBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AMultiplayerLaserPuzzleBase*>(AMultiplayerLaserPuzzleBase::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MultiplayerEscortPuzzle
// (Actor)

class UClass* AMultiplayerEscortPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerEscortPuzzle");

	return Clss;
}


// MultiplayerEscortPuzzle IslandsofInsight.Default__MultiplayerEscortPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AMultiplayerEscortPuzzle* AMultiplayerEscortPuzzle::GetDefaultObj()
{
	static class AMultiplayerEscortPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AMultiplayerEscortPuzzle*>(AMultiplayerEscortPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MultiplayerEscortPuzzle.OnRep_targets
// (Final, Native, Protected)
// Parameters:

void AMultiplayerEscortPuzzle::OnRep_targets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerEscortPuzzle", "OnRep_targets");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MultiplayerEscortPuzzle.OnRep_failureInfo
// (Final, Native, Protected)
// Parameters:

void AMultiplayerEscortPuzzle::OnRep_failureInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerEscortPuzzle", "OnRep_failureInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MultiplayerEscortPuzzle.BP_VisualizeSplines
// (Event, Protected, BlueprintEvent)
// Parameters:

void AMultiplayerEscortPuzzle::BP_VisualizeSplines()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerEscortPuzzle", "BP_VisualizeSplines");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.MultiplayerEscortWidget
// (None)

class UClass* UMultiplayerEscortWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerEscortWidget");

	return Clss;
}


// MultiplayerEscortWidget IslandsofInsight.Default__MultiplayerEscortWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMultiplayerEscortWidget* UMultiplayerEscortWidget::GetDefaultObj()
{
	static class UMultiplayerEscortWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMultiplayerEscortWidget*>(UMultiplayerEscortWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MultiplayerLaserPuzzle
// (Actor)

class UClass* AMultiplayerLaserPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserPuzzle");

	return Clss;
}


// MultiplayerLaserPuzzle IslandsofInsight.Default__MultiplayerLaserPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AMultiplayerLaserPuzzle* AMultiplayerLaserPuzzle::GetDefaultObj()
{
	static class AMultiplayerLaserPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AMultiplayerLaserPuzzle*>(AMultiplayerLaserPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MultiplayerLaserPuzzle.OnRep_Hidden
// (Final, Native, Protected)
// Parameters:

void AMultiplayerLaserPuzzle::OnRep_Hidden()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerLaserPuzzle", "OnRep_Hidden");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MultiplayerLaserPuzzle.BP_InitializeTargets
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UMultiplayerLaserTarget*>Targets                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMultiplayerLaserPuzzle::BP_InitializeTargets(TArray<class UMultiplayerLaserTarget*>& Targets)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MultiplayerLaserPuzzle", "BP_InitializeTargets");

	Params::AMultiplayerLaserPuzzle_BP_InitializeTargets_Params Parms{};

	Parms.Targets = Targets;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.MultiplayerLaserPuzzleClickDetector
// (Actor)

class UClass* AMultiplayerLaserPuzzleClickDetector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserPuzzleClickDetector");

	return Clss;
}


// MultiplayerLaserPuzzleClickDetector IslandsofInsight.Default__MultiplayerLaserPuzzleClickDetector
// (Public, ClassDefaultObject, ArchetypeObject)

class AMultiplayerLaserPuzzleClickDetector* AMultiplayerLaserPuzzleClickDetector::GetDefaultObj()
{
	static class AMultiplayerLaserPuzzleClickDetector* Default = nullptr;

	if (!Default)
		Default = static_cast<AMultiplayerLaserPuzzleClickDetector*>(AMultiplayerLaserPuzzleClickDetector::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MultiplayerLaserRegisterWidget
// (None)

class UClass* UMultiplayerLaserRegisterWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserRegisterWidget");

	return Clss;
}


// MultiplayerLaserRegisterWidget IslandsofInsight.Default__MultiplayerLaserRegisterWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMultiplayerLaserRegisterWidget* UMultiplayerLaserRegisterWidget::GetDefaultObj()
{
	static class UMultiplayerLaserRegisterWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMultiplayerLaserRegisterWidget*>(UMultiplayerLaserRegisterWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PoweredMesh
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UPoweredMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoweredMesh");

	return Clss;
}


// PoweredMesh IslandsofInsight.Default__PoweredMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class UPoweredMesh* UPoweredMesh::GetDefaultObj()
{
	static class UPoweredMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<UPoweredMesh*>(UPoweredMesh::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PoweredMesh.OnRep_isPowered
// (Final, Native, Protected)
// Parameters:

void UPoweredMesh::OnRep_isPowered()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoweredMesh", "OnRep_isPowered");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PoweredMesh.OnRep_isActivated
// (Final, Native, Protected)
// Parameters:

void UPoweredMesh::OnRep_isActivated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoweredMesh", "OnRep_isActivated");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MultiplayerLaserTarget
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UMultiplayerLaserTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserTarget");

	return Clss;
}


// MultiplayerLaserTarget IslandsofInsight.Default__MultiplayerLaserTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMultiplayerLaserTarget* UMultiplayerLaserTarget::GetDefaultObj()
{
	static class UMultiplayerLaserTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMultiplayerLaserTarget*>(UMultiplayerLaserTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MultiplayerLaserWidget
// (None)

class UClass* UMultiplayerLaserWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MultiplayerLaserWidget");

	return Clss;
}


// MultiplayerLaserWidget IslandsofInsight.Default__MultiplayerLaserWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMultiplayerLaserWidget* UMultiplayerLaserWidget::GetDefaultObj()
{
	static class UMultiplayerLaserWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMultiplayerLaserWidget*>(UMultiplayerLaserWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MusicComponent
// (None)

class UClass* UMusicComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MusicComponent");

	return Clss;
}


// MusicComponent IslandsofInsight.Default__MusicComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMusicComponent* UMusicComponent::GetDefaultObj()
{
	static class UMusicComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMusicComponent*>(UMusicComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.MusicComponent.RemoveMusicEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Priority                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFMODEvent*>          EventsToRemove                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMusicComponent::RemoveMusicEvents(int32 Priority, const TArray<class UFMODEvent*>& EventsToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MusicComponent", "RemoveMusicEvents");

	Params::UMusicComponent_RemoveMusicEvents_Params Parms{};

	Parms.Priority = Priority;
	Parms.EventsToRemove = EventsToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.MusicComponent.AddMusicEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Priority                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFMODEvent*>          Events                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMusicComponent::AddMusicEvents(int32 Priority, const TArray<class UFMODEvent*>& Events)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MusicComponent", "AddMusicEvents");

	Params::UMusicComponent_AddMusicEvents_Params Parms{};

	Parms.Priority = Priority;
	Parms.Events = Events;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.MusicVolume
// (Actor)

class UClass* AMusicVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MusicVolume");

	return Clss;
}


// MusicVolume IslandsofInsight.Default__MusicVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AMusicVolume* AMusicVolume::GetDefaultObj()
{
	static class AMusicVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AMusicVolume*>(AMusicVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.MyopiaSymbol
// (None)

class UClass* UMyopiaSymbol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MyopiaSymbol");

	return Clss;
}


// MyopiaSymbol IslandsofInsight.Default__MyopiaSymbol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMyopiaSymbol* UMyopiaSymbol::GetDefaultObj()
{
	static class UMyopiaSymbol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMyopiaSymbol*>(UMyopiaSymbol::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.NavmeshAI
// (Actor)

class UClass* ANavmeshAI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavmeshAI");

	return Clss;
}


// NavmeshAI IslandsofInsight.Default__NavmeshAI
// (Public, ClassDefaultObject, ArchetypeObject)

class ANavmeshAI* ANavmeshAI::GetDefaultObj()
{
	static class ANavmeshAI* Default = nullptr;

	if (!Default)
		Default = static_cast<ANavmeshAI*>(ANavmeshAI::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.NavmeshAI.GoToRandomWaypoint
// (Final, Native, Private)
// Parameters:

void ANavmeshAI::GoToRandomWaypoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavmeshAI", "GoToRandomWaypoint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.NavmeshAISpawner
// (Actor)

class UClass* ANavmeshAISpawner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavmeshAISpawner");

	return Clss;
}


// NavmeshAISpawner IslandsofInsight.Default__NavmeshAISpawner
// (Public, ClassDefaultObject, ArchetypeObject)

class ANavmeshAISpawner* ANavmeshAISpawner::GetDefaultObj()
{
	static class ANavmeshAISpawner* Default = nullptr;

	if (!Default)
		Default = static_cast<ANavmeshAISpawner*>(ANavmeshAISpawner::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.NewGridUI
// (None)

class UClass* UNewGridUI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NewGridUI");

	return Clss;
}


// NewGridUI IslandsofInsight.Default__NewGridUI
// (Public, ClassDefaultObject, ArchetypeObject)

class UNewGridUI* UNewGridUI::GetDefaultObj()
{
	static class UNewGridUI* Default = nullptr;

	if (!Default)
		Default = static_cast<UNewGridUI*>(UNewGridUI::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.NewGridUI.ViewPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::ViewPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "ViewPuzzle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.UndoReleased
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::UndoReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "UndoReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.UndoPressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::UndoPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "UndoPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.ShowTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::ShowTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "ShowTutorial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.ShowMistakePopup
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNewGridUI::ShowMistakePopup(const struct FVector2D& ScreenPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "ShowMistakePopup");

	Params::UNewGridUI_ShowMistakePopup_Params Parms{};

	Parms.ScreenPosition = ScreenPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.Restart
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Restart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Restart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.Previous
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Previous()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Previous");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.OnPlayGridClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::OnPlayGridClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "OnPlayGridClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.OnPlayAnswerKeyClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::OnPlayAnswerKeyClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "OnPlayAnswerKeyClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.NextOrClose
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::NextOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "NextOrClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.Invite
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Invite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Invite");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.Hint
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Hint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Hint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.HideMistakePopup
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::HideMistakePopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "HideMistakePopup");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.Glimpse
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Glimpse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Glimpse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.GetIsInSolvedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNewGridUI::GetIsInSolvedState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "GetIsInSolvedState");

	Params::UNewGridUI_GetIsInSolvedState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.NewGridUI.FOMIsTierBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNewGridUI::FOMIsTierBreak()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "FOMIsTierBreak");

	Params::UNewGridUI_FOMIsTierBreak_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.NewGridUI.Exit
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNewGridUI::Exit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "Exit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.NewGridUI.BPI_ShowStarDifficultyTutorial
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_ShowStarDifficultyTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowStarDifficultyTutorial");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_ShowRegularDifficultyTutorial
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_ShowRegularDifficultyTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowRegularDifficultyTutorial");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_ShowQFPInfinitePopup
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_ShowQFPInfinitePopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowQFPInfinitePopup");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_ShowQFPFirstTierSolvePopup
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_ShowQFPFirstTierSolvePopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowQFPFirstTierSolvePopup");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_ShowQFPAllTierSolvePopup
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_ShowQFPAllTierSolvePopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowQFPAllTierSolvePopup");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_ShowMultiplayerMessage
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        Message                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNewGridUI::BPI_ShowMultiplayerMessage(class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_ShowMultiplayerMessage");

	Params::UNewGridUI_BPI_ShowMultiplayerMessage_Params Parms{};

	Parms.Message = Message;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.NewGridUI.BPI_OnExitRune
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_OnExitRune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_OnExitRune");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPI_OnEnterRune
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BPI_OnEnterRune()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPI_OnEnterRune");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BPC_GetPanel
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APuzzlePanel*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APuzzlePanel* UNewGridUI::BPC_GetPanel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BPC_GetPanel");

	Params::UNewGridUI_BPC_GetPanel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.NewGridUI.BP_PlayQFPDamageAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BP_PlayQFPDamageAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_PlayQFPDamageAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BP_PlayOpeningAnimations
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BP_PlayOpeningAnimations()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_PlayOpeningAnimations");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BP_PlayHintAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:

void UNewGridUI::BP_PlayHintAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_PlayHintAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.NewGridUI.BP_NotifyCaveHoverV3
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGridCaveHighlightInfo      Info                                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNewGridUI::BP_NotifyCaveHoverV3(const struct FGridCaveHighlightInfo& Info, bool bShow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_NotifyCaveHoverV3");

	Params::UNewGridUI_BP_NotifyCaveHoverV3_Params Parms{};

	Parms.Info = Info;
	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.NewGridUI.BP_NotifyAreaHoverV2
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                   ScreenCursorLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGridHighlightInfo>  HighlightTiles                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bIsLight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNewGridUI::BP_NotifyAreaHoverV2(const struct FVector2D& ScreenCursorLocation, TArray<struct FGridHighlightInfo>& HighlightTiles, bool bIsLight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_NotifyAreaHoverV2");

	Params::UNewGridUI_BP_NotifyAreaHoverV2_Params Parms{};

	Parms.ScreenCursorLocation = ScreenCursorLocation;
	Parms.HighlightTiles = HighlightTiles;
	Parms.bIsLight = bIsLight;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.NewGridUI.BP_NextOrClose
// (Event, Public, BlueprintEvent)
// Parameters:

void UNewGridUI::BP_NextOrClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NewGridUI", "BP_NextOrClose");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.NoTwoIslandsAreCongruent
// (None)

class UClass* UNoTwoIslandsAreCongruent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NoTwoIslandsAreCongruent");

	return Clss;
}


// NoTwoIslandsAreCongruent IslandsofInsight.Default__NoTwoIslandsAreCongruent
// (Public, ClassDefaultObject, ArchetypeObject)

class UNoTwoIslandsAreCongruent* UNoTwoIslandsAreCongruent::GetDefaultObj()
{
	static class UNoTwoIslandsAreCongruent* Default = nullptr;

	if (!Default)
		Default = static_cast<UNoTwoIslandsAreCongruent*>(UNoTwoIslandsAreCongruent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ObeliskLightbeam
// (Actor)

class UClass* AObeliskLightbeam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ObeliskLightbeam");

	return Clss;
}


// ObeliskLightbeam IslandsofInsight.Default__ObeliskLightbeam
// (Public, ClassDefaultObject, ArchetypeObject)

class AObeliskLightbeam* AObeliskLightbeam::GetDefaultObj()
{
	static class AObeliskLightbeam* Default = nullptr;

	if (!Default)
		Default = static_cast<AObeliskLightbeam*>(AObeliskLightbeam::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ObeliskPuzzle
// (Actor)

class UClass* AObeliskPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ObeliskPuzzle");

	return Clss;
}


// ObeliskPuzzle IslandsofInsight.Default__ObeliskPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class AObeliskPuzzle* AObeliskPuzzle::GetDefaultObj()
{
	static class AObeliskPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<AObeliskPuzzle*>(AObeliskPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ObeliskPuzzle.OnRep_numSolvedTablets
// (Final, Native, Private)
// Parameters:

void AObeliskPuzzle::OnRep_numSolvedTablets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ObeliskPuzzle", "OnRep_numSolvedTablets");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.ObeliskTablet
// (Actor)

class UClass* AObeliskTablet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ObeliskTablet");

	return Clss;
}


// ObeliskTablet IslandsofInsight.Default__ObeliskTablet
// (Public, ClassDefaultObject, ArchetypeObject)

class AObeliskTablet* AObeliskTablet::GetDefaultObj()
{
	static class AObeliskTablet* Default = nullptr;

	if (!Default)
		Default = static_cast<AObeliskTablet*>(AObeliskTablet::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ObeliskTablet.BP_Solved
// (Event, Protected, BlueprintEvent)
// Parameters:

void AObeliskTablet::BP_Solved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ObeliskTablet", "BP_Solved");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.OneSymbolPerIsland
// (None)

class UClass* UOneSymbolPerIsland::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OneSymbolPerIsland");

	return Clss;
}


// OneSymbolPerIsland IslandsofInsight.Default__OneSymbolPerIsland
// (Public, ClassDefaultObject, ArchetypeObject)

class UOneSymbolPerIsland* UOneSymbolPerIsland::GetDefaultObj()
{
	static class UOneSymbolPerIsland* Default = nullptr;

	if (!Default)
		Default = static_cast<UOneSymbolPerIsland*>(UOneSymbolPerIsland::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.OnlineServicesAuthHandler
// (None)

class UClass* UOnlineServicesAuthHandler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineServicesAuthHandler");

	return Clss;
}


// OnlineServicesAuthHandler IslandsofInsight.Default__OnlineServicesAuthHandler
// (Public, ClassDefaultObject, ArchetypeObject)

class UOnlineServicesAuthHandler* UOnlineServicesAuthHandler::GetDefaultObj()
{
	static class UOnlineServicesAuthHandler* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineServicesAuthHandler*>(UOnlineServicesAuthHandler::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.OnlineServicesAuthHandler_Kraken
// (None)

class UClass* UOnlineServicesAuthHandler_Kraken::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineServicesAuthHandler_Kraken");

	return Clss;
}


// OnlineServicesAuthHandler_Kraken IslandsofInsight.Default__OnlineServicesAuthHandler_Kraken
// (Public, ClassDefaultObject, ArchetypeObject)

class UOnlineServicesAuthHandler_Kraken* UOnlineServicesAuthHandler_Kraken::GetDefaultObj()
{
	static class UOnlineServicesAuthHandler_Kraken* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineServicesAuthHandler_Kraken*>(UOnlineServicesAuthHandler_Kraken::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.OnlineServicesAuthHandler_Platform
// (None)

class UClass* UOnlineServicesAuthHandler_Platform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineServicesAuthHandler_Platform");

	return Clss;
}


// OnlineServicesAuthHandler_Platform IslandsofInsight.Default__OnlineServicesAuthHandler_Platform
// (Public, ClassDefaultObject, ArchetypeObject)

class UOnlineServicesAuthHandler_Platform* UOnlineServicesAuthHandler_Platform::GetDefaultObj()
{
	static class UOnlineServicesAuthHandler_Platform* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineServicesAuthHandler_Platform*>(UOnlineServicesAuthHandler_Platform::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.OthersAttemptingWidget
// (None)

class UClass* UOthersAttemptingWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OthersAttemptingWidget");

	return Clss;
}


// OthersAttemptingWidget IslandsofInsight.Default__OthersAttemptingWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UOthersAttemptingWidget* UOthersAttemptingWidget::GetDefaultObj()
{
	static class UOthersAttemptingWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UOthersAttemptingWidget*>(UOthersAttemptingWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ParameterizedUrl
// (None)

class UClass* UParameterizedUrl::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParameterizedUrl");

	return Clss;
}


// ParameterizedUrl IslandsofInsight.Default__ParameterizedUrl
// (Public, ClassDefaultObject, ArchetypeObject)

class UParameterizedUrl* UParameterizedUrl::GetDefaultObj()
{
	static class UParameterizedUrl* Default = nullptr;

	if (!Default)
		Default = static_cast<UParameterizedUrl*>(UParameterizedUrl::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ParameterizedUrl.ToString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UParameterizedUrl::ToString()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParameterizedUrl", "ToString");

	Params::UParameterizedUrl_ToString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ParameterizedUrl.SetFixedParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ParamName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ParamValue                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParameterizedUrl::SetFixedParameter(const class FString& ParamName, const class FString& ParamValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParameterizedUrl", "SetFixedParameter");

	Params::UParameterizedUrl_SetFixedParameter_Params Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ParameterizedUrl.SetDynamicParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ParamName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDynamicUrlParameterValueParamFunc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParameterizedUrl::SetDynamicParameter(const class FString& ParamName, enum class EDynamicUrlParameterValue ParamFunc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParameterizedUrl", "SetDynamicParameter");

	Params::UParameterizedUrl_SetDynamicParameter_Params Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamFunc = ParamFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ParameterizedUrl.RemoveParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ParamName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParameterizedUrl::RemoveParameter(const class FString& ParamName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParameterizedUrl", "RemoveParameter");

	Params::UParameterizedUrl_RemoveParameter_Params Parms{};

	Parms.ParamName = ParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ParameterizedUrl.ComputeDynamicUrlParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDynamicUrlParameterValueParamType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UParameterizedUrl::ComputeDynamicUrlParameter(enum class EDynamicUrlParameterValue ParamType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParameterizedUrl", "ComputeDynamicUrlParameter");

	Params::UParameterizedUrl_ComputeDynamicUrlParameter_Params Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.Pareidolon
// (Actor)

class UClass* APareidolon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Pareidolon");

	return Clss;
}


// Pareidolon IslandsofInsight.Default__Pareidolon
// (Public, ClassDefaultObject, ArchetypeObject)

class APareidolon* APareidolon::GetDefaultObj()
{
	static class APareidolon* Default = nullptr;

	if (!Default)
		Default = static_cast<APareidolon*>(APareidolon::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PartyChatMessageWidget
// (None)

class UClass* UPartyChatMessageWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyChatMessageWidget");

	return Clss;
}


// PartyChatMessageWidget IslandsofInsight.Default__PartyChatMessageWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartyChatMessageWidget* UPartyChatMessageWidget::GetDefaultObj()
{
	static class UPartyChatMessageWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartyChatMessageWidget*>(UPartyChatMessageWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PartyChatMessageWidget.SetupMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Message                                                          (Parm, NativeAccessSpecifierPublic)

void UPartyChatMessageWidget::SetupMessage(const class FString& UserName, class FText Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyChatMessageWidget", "SetupMessage");

	Params::UPartyChatMessageWidget_SetupMessage_Params Parms{};

	Parms.UserName = UserName;
	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PartyChatNotificationWidget
// (None)

class UClass* UPartyChatNotificationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyChatNotificationWidget");

	return Clss;
}


// PartyChatNotificationWidget IslandsofInsight.Default__PartyChatNotificationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartyChatNotificationWidget* UPartyChatNotificationWidget::GetDefaultObj()
{
	static class UPartyChatNotificationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartyChatNotificationWidget*>(UPartyChatNotificationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PartyChatWidget
// (None)

class UClass* UPartyChatWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyChatWidget");

	return Clss;
}


// PartyChatWidget IslandsofInsight.Default__PartyChatWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartyChatWidget* UPartyChatWidget::GetDefaultObj()
{
	static class UPartyChatWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartyChatWidget*>(UPartyChatWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PartyChatWidget.CloseWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPartyChatWidget::CloseWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyChatWidget", "CloseWidget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartyChatWidget.AddMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      UserName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Message                                                          (Parm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartyChatWidget::AddMessage(const class FString& UserName, class FText Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyChatWidget", "AddMessage");

	Params::UPartyChatWidget_AddMessage_Params Parms{};

	Parms.UserName = UserName;
	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PartyDisplayWidget
// (None)

class UClass* UPartyDisplayWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyDisplayWidget");

	return Clss;
}


// PartyDisplayWidget IslandsofInsight.Default__PartyDisplayWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartyDisplayWidget* UPartyDisplayWidget::GetDefaultObj()
{
	static class UPartyDisplayWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartyDisplayWidget*>(UPartyDisplayWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PartyDisplayWidget.BP_GetHelpState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PuzzleName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartyDisplayWidget::BP_GetHelpState(bool Val, const class FString& Name, const class FString& PuzzleName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyDisplayWidget", "BP_GetHelpState");

	Params::UPartyDisplayWidget_BP_GetHelpState_Params Parms{};

	Parms.Val = Val;
	Parms.Name = Name;
	Parms.PuzzleName = PuzzleName;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PartyInvitePromptWidget
// (None)

class UClass* UPartyInvitePromptWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyInvitePromptWidget");

	return Clss;
}


// PartyInvitePromptWidget IslandsofInsight.Default__PartyInvitePromptWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartyInvitePromptWidget* UPartyInvitePromptWidget::GetDefaultObj()
{
	static class UPartyInvitePromptWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartyInvitePromptWidget*>(UPartyInvitePromptWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PartyInvitePromptWidget.ReplyToPartyInvite
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               Response                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartyInvitePromptWidget::ReplyToPartyInvite(bool Response)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyInvitePromptWidget", "ReplyToPartyInvite");

	Params::UPartyInvitePromptWidget_ReplyToPartyInvite_Params Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartyInvitePromptWidget.BP_HandleNonInviterMember
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASophiaPlayerState*          PlayerState                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartyInvitePromptWidget::BP_HandleNonInviterMember(class ASophiaPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartyInvitePromptWidget", "BP_HandleNonInviterMember");

	Params::UPartyInvitePromptWidget_BP_HandleNonInviterMember_Params Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PartyRosary
// (Actor)

class UClass* APartyRosary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartyRosary");

	return Clss;
}


// PartyRosary IslandsofInsight.Default__PartyRosary
// (Public, ClassDefaultObject, ArchetypeObject)

class APartyRosary* APartyRosary::GetDefaultObj()
{
	static class APartyRosary* Default = nullptr;

	if (!Default)
		Default = static_cast<APartyRosary*>(APartyRosary::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PartySystemComponent
// (None)

class UClass* UPartySystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PartySystemComponent");

	return Clss;
}


// PartySystemComponent IslandsofInsight.Default__PartySystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPartySystemComponent* UPartySystemComponent::GetDefaultObj()
{
	static class UPartySystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPartySystemComponent*>(UPartySystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PartySystemComponent.ServerExclusive_SendGridInvite
// (Final, Native, Public, Const)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::ServerExclusive_SendGridInvite(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "ServerExclusive_SendGridInvite");

	Params::UPartySystemComponent_ServerExclusive_SendGridInvite_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.ServerExclusive_AddToParty
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::ServerExclusive_AddToParty(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "ServerExclusive_AddToParty");

	Params::UPartySystemComponent_ServerExclusive_AddToParty_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_UpdateKrakenPartyMembers
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<class FString>              InPartyMembers                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_UpdateKrakenPartyMembers(TArray<class FString>& InPartyMembers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_UpdateKrakenPartyMembers");

	Params::UPartySystemComponent_Server_UpdateKrakenPartyMembers_Params Parms{};

	Parms.InPartyMembers = InPartyMembers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_TestSolveTogether
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASophiaRune*                 InviteRune                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class ECellColor>      InputCopy                                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_TestSolveTogether(class ASophiaRune* InviteRune, TArray<enum class ECellColor>& InputCopy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_TestSolveTogether");

	Params::UPartySystemComponent_Server_TestSolveTogether_Params Parms{};

	Parms.InviteRune = InviteRune;
	Parms.InputCopy = InputCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_StartSolveTogether
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASophiaRune*                 InviteRune                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class ECellColor>      InputCopy                                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_StartSolveTogether(class ASophiaRune* InviteRune, TArray<enum class ECellColor>& InputCopy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_StartSolveTogether");

	Params::UPartySystemComponent_Server_StartSolveTogether_Params Parms{};

	Parms.InviteRune = InviteRune;
	Parms.InputCopy = InputCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_setPuzzle
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APuzzleBase*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_setPuzzle(class APuzzleBase* Puzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_setPuzzle");

	Params::UPartySystemComponent_Server_setPuzzle_Params Parms{};

	Parms.Puzzle = Puzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_SendChatMessage
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Text                                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_SendChatMessage(class ASophiaPlayerState* P, class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_SendChatMessage");

	Params::UPartySystemComponent_Server_SendChatMessage_Params Parms{};

	Parms.P = P;
	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_ResetPartyInfo
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:

void UPartySystemComponent::Server_ResetPartyInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_ResetPartyInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_RequestOwnerSolveTogether
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASophiaPlayerState*          OtherPlayer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_RequestOwnerSolveTogether(class ASophiaPlayerState* OtherPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_RequestOwnerSolveTogether");

	Params::UPartySystemComponent_Server_RequestOwnerSolveTogether_Params Parms{};

	Parms.OtherPlayer = OtherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_ReplyToPartyInvite
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// bool                               JoinParty                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_ReplyToPartyInvite(bool JoinParty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_ReplyToPartyInvite");

	Params::UPartySystemComponent_Server_ReplyToPartyInvite_Params Parms{};

	Parms.JoinParty = JoinParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_ReplyToGridInvite
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// bool                               JoinParty                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_ReplyToGridInvite(bool JoinParty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_ReplyToGridInvite");

	Params::UPartySystemComponent_Server_ReplyToGridInvite_Params Parms{};

	Parms.JoinParty = JoinParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_RemoveFromParty
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_RemoveFromParty(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_RemoveFromParty");

	Params::UPartySystemComponent_Server_RemoveFromParty_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_RejectSolveTogetherOnCompletePuzzle
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void UPartySystemComponent::Server_RejectSolveTogetherOnCompletePuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_RejectSolveTogetherOnCompletePuzzle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_RejectPartyInvite
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:

void UPartySystemComponent::Server_RejectPartyInvite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_RejectPartyInvite");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_InitializeKrakenParty
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      PartyId                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LeaderID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              AutoJoinKey                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_InitializeKrakenParty(const class FString& PartyId, const class FString& LeaderID, int32 AutoJoinKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_InitializeKrakenParty");

	Params::UPartySystemComponent_Server_InitializeKrakenParty_Params Parms{};

	Parms.PartyId = PartyId;
	Parms.LeaderID = LeaderID;
	Parms.AutoJoinKey = AutoJoinKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_GiveLeadershipTo
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_GiveLeadershipTo(class ASophiaPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_GiveLeadershipTo");

	Params::UPartySystemComponent_Server_GiveLeadershipTo_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Server_AddToKrakenParty
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FKrakenPartyDetails         PartyDetails                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void UPartySystemComponent::Server_AddToKrakenParty(const struct FKrakenPartyDetails& PartyDetails)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Server_AddToKrakenParty");

	Params::UPartySystemComponent_Server_AddToKrakenParty_Params Parms{};

	Parms.PartyDetails = PartyDetails;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.PlayerIsInMyParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::PlayerIsInMyParty(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "PlayerIsInMyParty");

	Params::UPartySystemComponent_PlayerIsInMyParty_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.OnRep_KrakenParty
// (Final, Native, Private)
// Parameters:

void UPartySystemComponent::OnRep_KrakenParty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "OnRep_KrakenParty");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.NetMultiCast_SendChatMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASophiaPlayerState*          Sender                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Text                                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartySystemComponent::NetMultiCast_SendChatMessage(class ASophiaPlayerState* Sender, class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "NetMultiCast_SendChatMessage");

	Params::UPartySystemComponent_NetMultiCast_SendChatMessage_Params Parms{};

	Parms.Sender = Sender;
	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.IsPartyLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::IsPartyLeader(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "IsPartyLeader");

	Params::UPartySystemComponent_IsPartyLeader_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.IsPartyFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::IsPartyFull()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "IsPartyFull");

	Params::UPartySystemComponent_IsPartyFull_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.IsLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::IsLeader()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "IsLeader");

	Params::UPartySystemComponent_IsLeader_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.IsHelper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::IsHelper()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "IsHelper");

	Params::UPartySystemComponent_IsHelper_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.IsHelpee
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::IsHelpee()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "IsHelpee");

	Params::UPartySystemComponent_IsHelpee_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.InParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::InParty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "InParty");

	Params::UPartySystemComponent_InParty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.InHelperBond
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::InHelperBond()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "InHelperBond");

	Params::UPartySystemComponent_InHelperBond_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GiveLeadershipTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::GiveLeadershipTo(class ASophiaPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GiveLeadershipTo");

	Params::UPartySystemComponent_GiveLeadershipTo_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.GetPendingPartyInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPartyInvite                ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPartyInvite UPartySystemComponent::GetPendingPartyInvite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetPendingPartyInvite");

	Params::UPartySystemComponent_GetPendingPartyInvite_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetPartySize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPartySystemComponent::GetPartySize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetPartySize");

	Params::UPartySystemComponent_GetPartySize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetPartyMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ASophiaPlayerState*>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASophiaPlayerState*> UPartySystemComponent::GetPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetPartyMembers");

	Params::UPartySystemComponent_GetPartyMembers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetKrakenPartyMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UPartySystemComponent::GetKrakenPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetKrakenPartyMembers");

	Params::UPartySystemComponent_GetKrakenPartyMembers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetHelperBondPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APuzzleBase*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APuzzleBase* UPartySystemComponent::GetHelperBondPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetHelperBondPuzzle");

	Params::UPartySystemComponent_GetHelperBondPuzzle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetHelperBondParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ASophiaPlayerState*>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASophiaPlayerState*> UPartySystemComponent::GetHelperBondParty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetHelperBondParty");

	Params::UPartySystemComponent_GetHelperBondParty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetCurPuzzle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APuzzleBase*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APuzzleBase* UPartySystemComponent::GetCurPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetCurPuzzle");

	Params::UPartySystemComponent_GetCurPuzzle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetCurPartyInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPartyInvite                ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPartyInvite UPartySystemComponent::GetCurPartyInvite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetCurPartyInvite");

	Params::UPartySystemComponent_GetCurPartyInvite_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.GetCurGridInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGridInvite                 ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGridInvite UPartySystemComponent::GetCurGridInvite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "GetCurGridInvite");

	Params::UPartySystemComponent_GetCurGridInvite_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.Client_StartSolveTogether
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void UPartySystemComponent::Client_StartSolveTogether()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Client_StartSolveTogether");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Client_RemoveSelfFromKrakenParty
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                      NewLeaderId                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Client_RemoveSelfFromKrakenParty(const class FString& NewLeaderId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Client_RemoveSelfFromKrakenParty");

	Params::UPartySystemComponent_Client_RemoveSelfFromKrakenParty_Params Parms{};

	Parms.NewLeaderId = NewLeaderId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Client_RemoveRejectedPartyInvite
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class FString                      InvitedPlayerId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Client_RemoveRejectedPartyInvite(const class FString& InvitedPlayerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Client_RemoveRejectedPartyInvite");

	Params::UPartySystemComponent_Client_RemoveRejectedPartyInvite_Params Parms{};

	Parms.InvitedPlayerId = InvitedPlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Client_RejectSolveTogether
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void UPartySystemComponent::Client_RejectSolveTogether()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Client_RejectSolveTogether");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.Client_GiveLeadershipTo
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::Client_GiveLeadershipTo(class ASophiaPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "Client_GiveLeadershipTo");

	Params::UPartySystemComponent_Client_GiveLeadershipTo_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PartySystemComponent.CanRemoveFromParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::CanRemoveFromParty(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "CanRemoveFromParty");

	Params::UPartySystemComponent_CanRemoveFromParty_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.CanPromoteToPartyLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::CanPromoteToPartyLeader(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "CanPromoteToPartyLeader");

	Params::UPartySystemComponent_CanPromoteToPartyLeader_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.CanInviteToParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartySystemComponent::CanInviteToParty(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "CanInviteToParty");

	Params::UPartySystemComponent_CanInviteToParty_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PartySystemComponent.BPC_SolveTogetherReply_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Response                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaPlayerState*          OtherPlayer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySystemComponent::BPC_SolveTogetherReply_C(bool Response, class ASophiaPlayerState* OtherPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PartySystemComponent", "BPC_SolveTogetherReply_C");

	Params::UPartySystemComponent_BPC_SolveTogetherReply_C_Params Parms{};

	Parms.Response = Response;
	Parms.OtherPlayer = OtherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PassiveItemDisplay
// (None)

class UClass* UPassiveItemDisplay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PassiveItemDisplay");

	return Clss;
}


// PassiveItemDisplay IslandsofInsight.Default__PassiveItemDisplay
// (Public, ClassDefaultObject, ArchetypeObject)

class UPassiveItemDisplay* UPassiveItemDisplay::GetDefaultObj()
{
	static class UPassiveItemDisplay* Default = nullptr;

	if (!Default)
		Default = static_cast<UPassiveItemDisplay*>(UPassiveItemDisplay::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PassiveItemDisplayElement
// (None)

class UClass* UPassiveItemDisplayElement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PassiveItemDisplayElement");

	return Clss;
}


// PassiveItemDisplayElement IslandsofInsight.Default__PassiveItemDisplayElement
// (Public, ClassDefaultObject, ArchetypeObject)

class UPassiveItemDisplayElement* UPassiveItemDisplayElement::GetDefaultObj()
{
	static class UPassiveItemDisplayElement* Default = nullptr;

	if (!Default)
		Default = static_cast<UPassiveItemDisplayElement*>(UPassiveItemDisplayElement::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PathIntegration
// (Actor)

class UClass* APathIntegration::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PathIntegration");

	return Clss;
}


// PathIntegration IslandsofInsight.Default__PathIntegration
// (Public, ClassDefaultObject, ArchetypeObject)

class APathIntegration* APathIntegration::GetDefaultObj()
{
	static class APathIntegration* Default = nullptr;

	if (!Default)
		Default = static_cast<APathIntegration*>(APathIntegration::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PathIntegration.OnStartExit
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APathIntegration::OnStartExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "OnStartExit");

	Params::APathIntegration_OnStartExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PathIntegration.OnStartEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APathIntegration::OnStartEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "OnStartEnter");

	Params::APathIntegration_OnStartEnter_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PathIntegration.OnObstacleEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APathIntegration::OnObstacleEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "OnObstacleEnter");

	Params::APathIntegration_OnObstacleEnter_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PathIntegration.OnFinishEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APathIntegration::OnFinishEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "OnFinishEnter");

	Params::APathIntegration_OnFinishEnter_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PathIntegration.OnBoundExit
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APathIntegration::OnBoundExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "OnBoundExit");

	Params::APathIntegration_OnBoundExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PathIntegration.BP_UseMaterials
// (Event, Protected, BlueprintEvent)
// Parameters:

void APathIntegration::BP_UseMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "BP_UseMaterials");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PathIntegration.BP_CreateMaterials
// (Event, Protected, BlueprintEvent)
// Parameters:

void APathIntegration::BP_CreateMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PathIntegration", "BP_CreateMaterials");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.PathIntegrationWidget
// (None)

class UClass* UPathIntegrationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PathIntegrationWidget");

	return Clss;
}


// PathIntegrationWidget IslandsofInsight.Default__PathIntegrationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPathIntegrationWidget* UPathIntegrationWidget::GetDefaultObj()
{
	static class UPathIntegrationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPathIntegrationWidget*>(UPathIntegrationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PersonalTeleportEgg
// (Actor)

class UClass* APersonalTeleportEgg::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PersonalTeleportEgg");

	return Clss;
}


// PersonalTeleportEgg IslandsofInsight.Default__PersonalTeleportEgg
// (Public, ClassDefaultObject, ArchetypeObject)

class APersonalTeleportEgg* APersonalTeleportEgg::GetDefaultObj()
{
	static class APersonalTeleportEgg* Default = nullptr;

	if (!Default)
		Default = static_cast<APersonalTeleportEgg*>(APersonalTeleportEgg::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PersonalTeleportEgg.SetOwningPlayer
// (Native, Public)
// Parameters:
// class ASophiaPlayerState*          PS                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APersonalTeleportEgg::SetOwningPlayer(class ASophiaPlayerState* PS)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PersonalTeleportEgg", "SetOwningPlayer");

	Params::APersonalTeleportEgg_SetOwningPlayer_Params Parms{};

	Parms.PS = PS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PersonalTeleportEgg.BP_EggOnTickClient
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DistanceToPlayer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APersonalTeleportEgg::BP_EggOnTickClient(float DeltaTime, float DistanceToPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PersonalTeleportEgg", "BP_EggOnTickClient");

	Params::APersonalTeleportEgg_BP_EggOnTickClient_Params Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.DistanceToPlayer = DistanceToPlayer;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PingFPSWidget
// (None)

class UClass* UPingFPSWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PingFPSWidget");

	return Clss;
}


// PingFPSWidget IslandsofInsight.Default__PingFPSWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPingFPSWidget* UPingFPSWidget::GetDefaultObj()
{
	static class UPingFPSWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPingFPSWidget*>(UPingFPSWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PingFPSWidget.GetPingText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPingFPSWidget::GetPingText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PingFPSWidget", "GetPingText");

	Params::UPingFPSWidget_GetPingText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PingFPSWidget.GetFPSText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPingFPSWidget::GetFPSText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PingFPSWidget", "GetFPSText");

	Params::UPingFPSWidget_GetFPSText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PingIP
// (None)

class UClass* UPingIP::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PingIP");

	return Clss;
}


// PingIP IslandsofInsight.Default__PingIP
// (Public, ClassDefaultObject, ArchetypeObject)

class UPingIP* UPingIP::GetDefaultObj()
{
	static class UPingIP* Default = nullptr;

	if (!Default)
		Default = static_cast<UPingIP*>(UPingIP::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PingIP.SendPing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      IpAddress                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPingIP::SendPing(const class FString& IpAddress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PingIP", "SendPing");

	Params::UPingIP_SendPing_Params Parms{};

	Parms.IpAddress = IpAddress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PlatformEditorRepresentative
// (Actor)

class UClass* APlatformEditorRepresentative::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformEditorRepresentative");

	return Clss;
}


// PlatformEditorRepresentative IslandsofInsight.Default__PlatformEditorRepresentative
// (Public, ClassDefaultObject, ArchetypeObject)

class APlatformEditorRepresentative* APlatformEditorRepresentative::GetDefaultObj()
{
	static class APlatformEditorRepresentative* Default = nullptr;

	if (!Default)
		Default = static_cast<APlatformEditorRepresentative*>(APlatformEditorRepresentative::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PlatformMovement
// (None)

class UClass* UPlatformMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformMovement");

	return Clss;
}


// PlatformMovement IslandsofInsight.Default__PlatformMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlatformMovement* UPlatformMovement::GetDefaultObj()
{
	static class UPlatformMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlatformMovement*>(UPlatformMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PlayerCurrencyWidget
// (None)

class UClass* UPlayerCurrencyWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerCurrencyWidget");

	return Clss;
}


// PlayerCurrencyWidget IslandsofInsight.Default__PlayerCurrencyWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerCurrencyWidget* UPlayerCurrencyWidget::GetDefaultObj()
{
	static class UPlayerCurrencyWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerCurrencyWidget*>(UPlayerCurrencyWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerCurrencyWidget.ResetCurrencyTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPlayerCurrencyWidget::ResetCurrencyTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCurrencyWidget", "ResetCurrencyTime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PlayerLocationMarkerInfoWidget
// (None)

class UClass* UPlayerLocationMarkerInfoWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerLocationMarkerInfoWidget");

	return Clss;
}


// PlayerLocationMarkerInfoWidget IslandsofInsight.Default__PlayerLocationMarkerInfoWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerLocationMarkerInfoWidget* UPlayerLocationMarkerInfoWidget::GetDefaultObj()
{
	static class UPlayerLocationMarkerInfoWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerLocationMarkerInfoWidget*>(UPlayerLocationMarkerInfoWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PlayerStatisticRankingData
// (None)

class UClass* UPlayerStatisticRankingData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerStatisticRankingData");

	return Clss;
}


// PlayerStatisticRankingData IslandsofInsight.Default__PlayerStatisticRankingData
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerStatisticRankingData* UPlayerStatisticRankingData::GetDefaultObj()
{
	static class UPlayerStatisticRankingData* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerStatisticRankingData*>(UPlayerStatisticRankingData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PlayerMastery
// (None)

class UClass* UPlayerMastery::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerMastery");

	return Clss;
}


// PlayerMastery IslandsofInsight.Default__PlayerMastery
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerMastery* UPlayerMastery::GetDefaultObj()
{
	static class UPlayerMastery* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerMastery*>(UPlayerMastery::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerMastery.RefreshLeaderboards
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPlayerMastery::RefreshLeaderboards()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "RefreshLeaderboards");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerMastery.GetValueForRank
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              RankIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetValueForRank(int32 RankIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetValueForRank");

	Params::UPlayerMastery_GetValueForRank_Params Parms{};

	Parms.RankIndex = RankIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetValue");

	Params::UPlayerMastery_GetValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankNameForRankIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Rank                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlayerMastery::GetRankNameForRankIndex(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankNameForRankIndex");

	Params::UPlayerMastery_GetRankNameForRankIndex_Params Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankIndexWithFractionForValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetRankIndexWithFractionForValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankIndexWithFractionForValue");

	Params::UPlayerMastery_GetRankIndexWithFractionForValue_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankIndexWithFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetRankIndexWithFraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankIndexWithFraction");

	Params::UPlayerMastery_GetRankIndexWithFraction_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankIndexForValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerMastery::GetRankIndexForValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankIndexForValue");

	Params::UPlayerMastery_GetRankIndexForValue_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerMastery::GetRankIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankIndex");

	Params::UPlayerMastery_GetRankIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankIconForRankIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Rank                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UPlayerMastery::GetRankIconForRankIndex(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankIconForRankIndex");

	Params::UPlayerMastery_GetRankIconForRankIndex_Params Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetRankBorderIconForRankIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Rank                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UPlayerMastery::GetRankBorderIconForRankIndex(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetRankBorderIconForRankIndex");

	Params::UPlayerMastery_GetRankBorderIconForRankIndex_Params Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetProgressToNextRankForValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetProgressToNextRankForValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetProgressToNextRankForValue");

	Params::UPlayerMastery_GetProgressToNextRankForValue_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetProgressToNextRank
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerMastery::GetProgressToNextRank()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetProgressToNextRank");

	Params::UPlayerMastery_GetProgressToNextRank_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetFormattableCurrentRankName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlayerMastery::GetFormattableCurrentRankName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetFormattableCurrentRankName");

	Params::UPlayerMastery_GetFormattableCurrentRankName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.GetCurrentRankName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlayerMastery::GetCurrentRankName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "GetCurrentRankName");

	Params::UPlayerMastery_GetCurrentRankName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerMastery.AreLeaderboardsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerMastery::AreLeaderboardsLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerMastery", "AreLeaderboardsLoaded");

	Params::UPlayerMastery_AreLeaderboardsLoaded_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PlayerMasteryLevelsSeed
// (None)

class UClass* UPlayerMasteryLevelsSeed::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerMasteryLevelsSeed");

	return Clss;
}


// PlayerMasteryLevelsSeed IslandsofInsight.Default__PlayerMasteryLevelsSeed
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerMasteryLevelsSeed* UPlayerMasteryLevelsSeed::GetDefaultObj()
{
	static class UPlayerMasteryLevelsSeed* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerMasteryLevelsSeed*>(UPlayerMasteryLevelsSeed::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PlayerSocialMenuWidget
// (None)

class UClass* UPlayerSocialMenuWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerSocialMenuWidget");

	return Clss;
}


// PlayerSocialMenuWidget IslandsofInsight.Default__PlayerSocialMenuWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerSocialMenuWidget* UPlayerSocialMenuWidget::GetDefaultObj()
{
	static class UPlayerSocialMenuWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerSocialMenuWidget*>(UPlayerSocialMenuWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerSocialMenuWidget.TrySendPingMessageToPingTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FPlayerPingMessage          PingMessage                                                      (Parm, NativeAccessSpecifierPublic)
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult UPlayerSocialMenuWidget::TrySendPingMessageToPingTarget(const struct FPlayerPingMessage& PingMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerSocialMenuWidget", "TrySendPingMessageToPingTarget");

	Params::UPlayerSocialMenuWidget_TrySendPingMessageToPingTarget_Params Parms{};

	Parms.PingMessage = PingMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerSocialMenuWidget.TryPartyInvitePingTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult UPlayerSocialMenuWidget::TryPartyInvitePingTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerSocialMenuWidget", "TryPartyInvitePingTarget");

	Params::UPlayerSocialMenuWidget_TryPartyInvitePingTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PlayerStatsBar
// (None)

class UClass* UPlayerStatsBar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerStatsBar");

	return Clss;
}


// PlayerStatsBar IslandsofInsight.Default__PlayerStatsBar
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerStatsBar* UPlayerStatsBar::GetDefaultObj()
{
	static class UPlayerStatsBar* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerStatsBar*>(UPlayerStatsBar::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerStatsBar.DisplayExperience
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              NewExp                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsBar::DisplayExperience(float NewExp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerStatsBar", "DisplayExperience");

	Params::UPlayerStatsBar_DisplayExperience_Params Parms{};

	Parms.NewExp = NewExp;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PlayerTeleportVolume
// (Actor)

class UClass* APlayerTeleportVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerTeleportVolume");

	return Clss;
}


// PlayerTeleportVolume IslandsofInsight.Default__PlayerTeleportVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerTeleportVolume* APlayerTeleportVolume::GetDefaultObj()
{
	static class APlayerTeleportVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerTeleportVolume*>(APlayerTeleportVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerTeleportVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerTeleportVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerTeleportVolume", "OnOverlapEnd");

	Params::APlayerTeleportVolume_OnOverlapEnd_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerTeleportVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                      OverlappedActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerTeleportVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerTeleportVolume", "OnOverlapBegin");

	Params::APlayerTeleportVolume_OnOverlapBegin_Params Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PlayerVoiceChatActor
// (Actor)

class UClass* APlayerVoiceChatActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerVoiceChatActor");

	return Clss;
}


// PlayerVoiceChatActor IslandsofInsight.Default__PlayerVoiceChatActor
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerVoiceChatActor* APlayerVoiceChatActor::GetDefaultObj()
{
	static class APlayerVoiceChatActor* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerVoiceChatActor*>(APlayerVoiceChatActor::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerSetMaxProximityRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              _maxProximityRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerSetMaxProximityRange(float _maxProximityRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerSetMaxProximityRange");

	Params::APlayerVoiceChatActor_ServerSetMaxProximityRange_Params Parms{};

	Parms._maxProximityRange = _maxProximityRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerSetAttenuation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               EnableAttenuation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      _pathToAttenuationAsset                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerSetAttenuation(bool EnableAttenuation, const class FString& _pathToAttenuationAsset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerSetAttenuation");

	Params::APlayerVoiceChatActor_ServerSetAttenuation_Params Parms{};

	Parms.EnableAttenuation = EnableAttenuation;
	Parms._pathToAttenuationAsset = _pathToAttenuationAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerSetAllowUseProximity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               _allowUseRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerSetAllowUseProximity(bool _allowUseRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerSetAllowUseProximity");

	Params::APlayerVoiceChatActor_ServerSetAllowUseProximity_Params Parms{};

	Parms._allowUseRange = _allowUseRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerSetAllowUseGlobal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               _allowUseGlobal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerSetAllowUseGlobal(bool _allowUseGlobal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerSetAllowUseGlobal");

	Params::APlayerVoiceChatActor_ServerSetAllowUseGlobal_Params Parms{};

	Parms._allowUseGlobal = _allowUseGlobal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerRemoveChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ChannelToRemove                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerRemoveChannel(int32 ChannelToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerRemoveChannel");

	Params::APlayerVoiceChatActor_ServerRemoveChannel_Params Parms{};

	Parms.ChannelToRemove = ChannelToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.ServerAddChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ChannelToAdd                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::ServerAddChannel(int32 ChannelToAdd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "ServerAddChannel");

	Params::APlayerVoiceChatActor_ServerAddChannel_Params Parms{};

	Parms.ChannelToAdd = ChannelToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RPCServerUpdatePosAudioComp
// (Net, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                     WorldPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::RPCServerUpdatePosAudioComp(const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RPCServerUpdatePosAudioComp");

	Params::APlayerVoiceChatActor_RPCServerUpdatePosAudioComp_Params Parms{};

	Parms.WorldPos = WorldPos;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RPCClientSetMicrophoneVolume
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::RPCClientSetMicrophoneVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RPCClientSetMicrophoneVolume");

	Params::APlayerVoiceChatActor_RPCClientSetMicrophoneVolume_Params Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RPCClientAskRemoveChannel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              ChannelToRemove                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::RPCClientAskRemoveChannel(int32 ChannelToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RPCClientAskRemoveChannel");

	Params::APlayerVoiceChatActor_RPCClientAskRemoveChannel_Params Parms{};

	Parms.ChannelToRemove = ChannelToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RPCClientAskAddChannel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              ChannelToAdd                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::RPCClientAskAddChannel(int32 ChannelToAdd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RPCClientAskAddChannel");

	Params::APlayerVoiceChatActor_RPCClientAskAddChannel_Params Parms{};

	Parms.ChannelToAdd = ChannelToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RepNotifyVoiceVolume
// (Final, Native, Public)
// Parameters:

void APlayerVoiceChatActor::RepNotifyVoiceVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RepNotifyVoiceVolume");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RepNotifyMicComp
// (Final, Native, Public)
// Parameters:

void APlayerVoiceChatActor::RepNotifyMicComp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RepNotifyMicComp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.RepNotifyAttenuationAsset
// (Final, Native, Public)
// Parameters:

void APlayerVoiceChatActor::RepNotifyAttenuationAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "RepNotifyAttenuationAsset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.muteAudio
// (Final, Native, Public)
// Parameters:
// bool                               IsMute                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::MuteAudio(bool IsMute)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "muteAudio");

	Params::APlayerVoiceChatActor_MuteAudio_Params Parms{};

	Parms.IsMute = IsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerVoiceChatActor.DelegateEndPlayOwner
// (Final, Native, Public)
// Parameters:
// class AActor*                      Act                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEndPlayReason          EndPlayReason                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerVoiceChatActor::DelegateEndPlayOwner(class AActor* Act, enum class EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerVoiceChatActor", "DelegateEndPlayOwner");

	Params::APlayerVoiceChatActor_DelegateEndPlayOwner_Params Parms{};

	Parms.Act = Act;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.UniversalVoiceChat
// (None)

class UClass* UUniversalVoiceChat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UniversalVoiceChat");

	return Clss;
}


// UniversalVoiceChat IslandsofInsight.Default__UniversalVoiceChat
// (Public, ClassDefaultObject, ArchetypeObject)

class UUniversalVoiceChat* UUniversalVoiceChat::GetDefaultObj()
{
	static class UUniversalVoiceChat* Default = nullptr;

	if (!Default)
		Default = static_cast<UUniversalVoiceChat*>(UUniversalVoiceChat::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatWasInitAudioVoiceChatQuality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatWasInitAudioVoiceChatQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatWasInitAudioVoiceChatQuality");

	Params::UUniversalVoiceChat_VoiceChatWasInitAudioVoiceChatQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatStopSpeak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatStopSpeak()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatStopSpeak");

	Params::UUniversalVoiceChat_VoiceChatStopSpeak_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatStartSpeak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               _shouldHearMyOwnVoice                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsGlobal                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              RadioChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UseProximity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxProximityRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatStartSpeak(bool _shouldHearMyOwnVoice, bool IsGlobal, int32 RadioChannel, bool UseProximity, float MaxProximityRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatStartSpeak");

	Params::UUniversalVoiceChat_VoiceChatStartSpeak_Params Parms{};

	Parms._shouldHearMyOwnVoice = _shouldHearMyOwnVoice;
	Parms.IsGlobal = IsGlobal;
	Parms.RadioChannel = RadioChannel;
	Parms.UseProximity = UseProximity;
	Parms.MaxProximityRange = MaxProximityRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatSetMicrophoneVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatSetMicrophoneVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatSetMicrophoneVolume");

	Params::UUniversalVoiceChat_VoiceChatSetMicrophoneVolume_Params Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatRemoveChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              ChannelToRemove                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatRemoveChannel(int32 ChannelToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatRemoveChannel");

	Params::UUniversalVoiceChat_VoiceChatRemoveChannel_Params Parms{};

	Parms.ChannelToRemove = ChannelToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatLocalMuteSomeone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                PlayerToMute                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShouldMute                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniversalVoiceChat::VoiceChatLocalMuteSomeone(class UObject* WorldContextObject, class APlayerState* PlayerToMute, bool ShouldMute)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatLocalMuteSomeone");

	Params::UUniversalVoiceChat_VoiceChatLocalMuteSomeone_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerToMute = PlayerToMute;
	Parms.ShouldMute = ShouldMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatLocalIsMutedSomeone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                PlayerToCheckMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatLocalIsMutedSomeone(class UObject* WorldContextObject, class APlayerState* PlayerToCheckMute)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatLocalIsMutedSomeone");

	Params::UUniversalVoiceChat_VoiceChatLocalIsMutedSomeone_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerToCheckMute = PlayerToCheckMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatInitAudioVoiceChatQuality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              _sampleRate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              _numChannels                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatInitAudioVoiceChatQuality(int32 _sampleRate, int32 _numChannels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatInitAudioVoiceChatQuality");

	Params::UUniversalVoiceChat_VoiceChatInitAudioVoiceChatQuality_Params Parms{};

	Parms._sampleRate = _sampleRate;
	Parms._numChannels = _numChannels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatHasMicrophonePermission
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatHasMicrophonePermission()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatHasMicrophonePermission");

	Params::UUniversalVoiceChat_VoiceChatHasMicrophonePermission_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatGetMyLocalPlayerVoiceChat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerVoiceChatActor*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerVoiceChatActor* UUniversalVoiceChat::VoiceChatGetMyLocalPlayerVoiceChat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatGetMyLocalPlayerVoiceChat");

	Params::UUniversalVoiceChat_VoiceChatGetMyLocalPlayerVoiceChat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatCheckRegisteredToChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              ChannelToCheck                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatCheckRegisteredToChannel(int32 ChannelToCheck)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatCheckRegisteredToChannel");

	Params::UUniversalVoiceChat_VoiceChatCheckRegisteredToChannel_Params Parms{};

	Parms.ChannelToCheck = ChannelToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatAskMicrophonePermission
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UUniversalVoiceChat::VoiceChatAskMicrophonePermission()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatAskMicrophonePermission");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.UniversalVoiceChat.VoiceChatAddChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              ChannelToAdd                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUniversalVoiceChat::VoiceChatAddChannel(int32 ChannelToAdd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UniversalVoiceChat", "VoiceChatAddChannel");

	Params::UUniversalVoiceChat_VoiceChatAddChannel_Params Parms{};

	Parms.ChannelToAdd = ChannelToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PlayerWidget
// (None)

class UClass* UPlayerWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerWidget");

	return Clss;
}


// PlayerWidget IslandsofInsight.Default__PlayerWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayerWidget* UPlayerWidget::GetDefaultObj()
{
	static class UPlayerWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerWidget*>(UPlayerWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PlayerWidget.TryGetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaPlayerState*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASophiaPlayerState* UPlayerWidget::TryGetPlayerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerWidget", "TryGetPlayerState");

	Params::UPlayerWidget_TryGetPlayerState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerWidget.SetupLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPlayerWidget::SetupLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerWidget", "SetupLocalPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PlayerWidget.IsInPartyWithLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerWidget::IsInPartyWithLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerWidget", "IsInPartyWithLocalPlayer");

	Params::UPlayerWidget_IsInPartyWithLocalPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerWidget.IsBlockedByLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerWidget::IsBlockedByLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerWidget", "IsBlockedByLocalPlayer");

	Params::UPlayerWidget_IsBlockedByLocalPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PlayerWidget.BP_Setup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               TryToShowButtons                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowStatus                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerWidget::BP_Setup(const class FString& KrakenId, const class FString& KrakenName, bool TryToShowButtons, bool ShowStatus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerWidget", "BP_Setup");

	Params::UPlayerWidget_BP_Setup_Params Parms{};

	Parms.KrakenId = KrakenId;
	Parms.KrakenName = KrakenName;
	Parms.TryToShowButtons = TryToShowButtons;
	Parms.ShowStatus = ShowStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PostWorkTickInterface
// (None)

class UClass* IPostWorkTickInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PostWorkTickInterface");

	return Clss;
}


// PostWorkTickInterface IslandsofInsight.Default__PostWorkTickInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IPostWorkTickInterface* IPostWorkTickInterface::GetDefaultObj()
{
	static class IPostWorkTickInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IPostWorkTickInterface*>(IPostWorkTickInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PostWorkTickComponent
// (None)

class UClass* UPostWorkTickComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PostWorkTickComponent");

	return Clss;
}


// PostWorkTickComponent IslandsofInsight.Default__PostWorkTickComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPostWorkTickComponent* UPostWorkTickComponent::GetDefaultObj()
{
	static class UPostWorkTickComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPostWorkTickComponent*>(UPostWorkTickComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PoweredBase
// (Actor)

class UClass* APoweredBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoweredBase");

	return Clss;
}


// PoweredBase IslandsofInsight.Default__PoweredBase
// (Public, ClassDefaultObject, ArchetypeObject)

class APoweredBase* APoweredBase::GetDefaultObj()
{
	static class APoweredBase* Default = nullptr;

	if (!Default)
		Default = static_cast<APoweredBase*>(APoweredBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PoweredBase.ServerExclusive_SetPowered
// (Native, Public, HasOutParams)
// Parameters:
// class APowerLaser*                 Laser                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class ASophiaCharacter*, int32>ConnectedPlayers                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class ASophiaCharacter*            OwnerRef                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APoweredBase::ServerExclusive_SetPowered(class APowerLaser* Laser, TMap<class ASophiaCharacter*, int32>* ConnectedPlayers, class ASophiaCharacter* OwnerRef)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoweredBase", "ServerExclusive_SetPowered");

	Params::APoweredBase_ServerExclusive_SetPowered_Params Parms{};

	Parms.Laser = Laser;
	Parms.OwnerRef = OwnerRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ConnectedPlayers != nullptr)
		*ConnectedPlayers = Parms.ConnectedPlayers;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PowerCore
// (Actor)

class UClass* APowerCore::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PowerCore");

	return Clss;
}


// PowerCore IslandsofInsight.Default__PowerCore
// (Public, ClassDefaultObject, ArchetypeObject)

class APowerCore* APowerCore::GetDefaultObj()
{
	static class APowerCore* Default = nullptr;

	if (!Default)
		Default = static_cast<APowerCore*>(APowerCore::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PowerLaser
// (Actor)

class UClass* APowerLaser::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PowerLaser");

	return Clss;
}


// PowerLaser IslandsofInsight.Default__PowerLaser
// (Public, ClassDefaultObject, ArchetypeObject)

class APowerLaser* APowerLaser::GetDefaultObj()
{
	static class APowerLaser* Default = nullptr;

	if (!Default)
		Default = static_cast<APowerLaser*>(APowerLaser::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PowerLaser.BPI_OnStatusChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class EPoleStatus             NewStatus                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APowerLaser::BPI_OnStatusChanged(enum class EPoleStatus NewStatus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerLaser", "BPI_OnStatusChanged");

	Params::APowerLaser_BPI_OnStatusChanged_Params Parms{};

	Parms.NewStatus = NewStatus;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PowerPole
// (Actor)

class UClass* APowerPole::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PowerPole");

	return Clss;
}


// PowerPole IslandsofInsight.Default__PowerPole
// (Public, ClassDefaultObject, ArchetypeObject)

class APowerPole* APowerPole::GetDefaultObj()
{
	static class APowerPole* Default = nullptr;

	if (!Default)
		Default = static_cast<APowerPole*>(APowerPole::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PowerPole.OnRep_Status
// (Final, Native, Private)
// Parameters:

void APowerPole::OnRep_Status()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "OnRep_Status");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.OnRep_named
// (Final, Native, Private)
// Parameters:

void APowerPole::OnRep_named()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "OnRep_named");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.OnRep_lasersData
// (Final, Native, Private)
// Parameters:

void APowerPole::OnRep_lasersData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "OnRep_lasersData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.OnRep_isHidden
// (Final, Native, Private)
// Parameters:

void APowerPole::OnRep_isHidden()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "OnRep_isHidden");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.Multicast_addLaser
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class AActor*                      Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UseImpactPoint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactPoint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               PrioritizeImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         TargetComponent                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APowerPole::Multicast_addLaser(class AActor* Target, bool UseImpactPoint, const struct FVector& ImpactPoint, bool PrioritizeImpactPoint, class UPrimitiveComponent* TargetComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "Multicast_addLaser");

	Params::APowerPole_Multicast_addLaser_Params Parms{};

	Parms.Target = Target;
	Parms.UseImpactPoint = UseImpactPoint;
	Parms.ImpactPoint = ImpactPoint;
	Parms.PrioritizeImpactPoint = PrioritizeImpactPoint;
	Parms.TargetComponent = TargetComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.FinalTick
// (Final, Native, Private)
// Parameters:

void APowerPole::FinalTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "FinalTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PowerPole.BP_SetFloorLocation
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APowerPole::BP_SetFloorLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "BP_SetFloorLocation");

	Params::APowerPole_BP_SetFloorLocation_Params Parms{};

	Parms.NewLocation = NewLocation;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.PowerPole.BP_PlantPole
// (Event, Protected, BlueprintEvent)
// Parameters:

void APowerPole::BP_PlantPole()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "BP_PlantPole");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PowerPole.BP_ColorValid
// (Event, Protected, BlueprintEvent)
// Parameters:

void APowerPole::BP_ColorValid()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "BP_ColorValid");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PowerPole.BP_ColorInvalid
// (Event, Protected, BlueprintEvent)
// Parameters:

void APowerPole::BP_ColorInvalid()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerPole", "BP_ColorInvalid");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.PowerRing
// (Actor)

class UClass* APowerRing::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PowerRing");

	return Clss;
}


// PowerRing IslandsofInsight.Default__PowerRing
// (Public, ClassDefaultObject, ArchetypeObject)

class APowerRing* APowerRing::GetDefaultObj()
{
	static class APowerRing* Default = nullptr;

	if (!Default)
		Default = static_cast<APowerRing*>(APowerRing::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PowerRing.UpdateColor
// (Event, Public, BlueprintEvent)
// Parameters:

void APowerRing::UpdateColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerRing", "UpdateColor");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PowerRing.BP_OnZeroPotentialLaserOverlap
// (Event, Public, BlueprintEvent)
// Parameters:

void APowerRing::BP_OnZeroPotentialLaserOverlap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerRing", "BP_OnZeroPotentialLaserOverlap");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.PowerRing.BP_OnPotentialLaserOverlap
// (Event, Public, BlueprintEvent)
// Parameters:

void APowerRing::BP_OnPotentialLaserOverlap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PowerRing", "BP_OnPotentialLaserOverlap");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.ProjectionCone
// (Actor)

class UClass* AProjectionCone::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ProjectionCone");

	return Clss;
}


// ProjectionCone IslandsofInsight.Default__ProjectionCone
// (Public, ClassDefaultObject, ArchetypeObject)

class AProjectionCone* AProjectionCone::GetDefaultObj()
{
	static class AProjectionCone* Default = nullptr;

	if (!Default)
		Default = static_cast<AProjectionCone*>(AProjectionCone::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ProjectionCone.recolor
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// float                              T                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Solvable                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectionCone::Recolor(float T, float Solvable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectionCone", "recolor");

	Params::AProjectionCone_Recolor_Params Parms{};

	Parms.T = T;
	Parms.Solvable = Solvable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.ProjectionCone.OnClickFire
// (Native, Public, HasOutParams)
// Parameters:
// struct FClickEventContext          Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectionCone::OnClickFire(struct FClickEventContext& Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectionCone", "OnClickFire");

	Params::AProjectionCone_OnClickFire_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PuzzleBoundsComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UPuzzleBoundsComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleBoundsComponent");

	return Clss;
}


// PuzzleBoundsComponent IslandsofInsight.Default__PuzzleBoundsComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleBoundsComponent* UPuzzleBoundsComponent::GetDefaultObj()
{
	static class UPuzzleBoundsComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleBoundsComponent*>(UPuzzleBoundsComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleCamera
// (Actor)

class UClass* APuzzleCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleCamera");

	return Clss;
}


// PuzzleCamera IslandsofInsight.Default__PuzzleCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleCamera* APuzzleCamera::GetDefaultObj()
{
	static class APuzzleCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleCamera*>(APuzzleCamera::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleCamera.OnExitRegion
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleCamera::OnExitRegion(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleCamera", "OnExitRegion");

	Params::APuzzleCamera_OnExitRegion_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleCamera.OnEnterRegion
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APuzzleCamera::OnEnterRegion(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleCamera", "OnEnterRegion");

	Params::APuzzleCamera_OnEnterRegion_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PuzzleCellButton_DEPRECATED
// (Actor)

class UClass* APuzzleCellButton_DEPRECATED::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleCellButton_DEPRECATED");

	return Clss;
}


// PuzzleCellButton_DEPRECATED IslandsofInsight.Default__PuzzleCellButton_DEPRECATED
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleCellButton_DEPRECATED* APuzzleCellButton_DEPRECATED::GetDefaultObj()
{
	static class APuzzleCellButton_DEPRECATED* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleCellButton_DEPRECATED*>(APuzzleCellButton_DEPRECATED::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleCellButton_DEPRECATED.BPI_CellColorChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class ECellColor              CurCellColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECellColor              NewCellColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleCellButton_DEPRECATED::BPI_CellColorChanged(enum class ECellColor CurCellColor, enum class ECellColor NewCellColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleCellButton_DEPRECATED", "BPI_CellColorChanged");

	Params::APuzzleCellButton_DEPRECATED_BPI_CellColorChanged_Params Parms{};

	Parms.CurCellColor = CurCellColor;
	Parms.NewCellColor = NewCellColor;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.PuzzleClassesInfo
// (None)

class UClass* UPuzzleClassesInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleClassesInfo");

	return Clss;
}


// PuzzleClassesInfo IslandsofInsight.Default__PuzzleClassesInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleClassesInfo* UPuzzleClassesInfo::GetDefaultObj()
{
	static class UPuzzleClassesInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleClassesInfo*>(UPuzzleClassesInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleClasses
// (None)

class UClass* UPuzzleClasses::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleClasses");

	return Clss;
}


// PuzzleClasses IslandsofInsight.Default__PuzzleClasses
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleClasses* UPuzzleClasses::GetDefaultObj()
{
	static class UPuzzleClasses* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleClasses*>(UPuzzleClasses::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SlabPuzzleContainer
// (None)

class UClass* USlabPuzzleContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SlabPuzzleContainer");

	return Clss;
}


// SlabPuzzleContainer IslandsofInsight.Default__SlabPuzzleContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class USlabPuzzleContainer* USlabPuzzleContainer::GetDefaultObj()
{
	static class USlabPuzzleContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<USlabPuzzleContainer*>(USlabPuzzleContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleData
// (None)

class UClass* UPuzzleData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleData");

	return Clss;
}


// PuzzleData IslandsofInsight.Default__PuzzleData
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleData* UPuzzleData::GetDefaultObj()
{
	static class UPuzzleData* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleData*>(UPuzzleData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.WorldPuzzleData
// (None)

class UClass* UWorldPuzzleData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WorldPuzzleData");

	return Clss;
}


// WorldPuzzleData IslandsofInsight.Default__WorldPuzzleData
// (Public, ClassDefaultObject, ArchetypeObject)

class UWorldPuzzleData* UWorldPuzzleData::GetDefaultObj()
{
	static class UWorldPuzzleData* Default = nullptr;

	if (!Default)
		Default = static_cast<UWorldPuzzleData*>(UWorldPuzzleData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ContainedPuzzleData
// (None)

class UClass* UContainedPuzzleData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ContainedPuzzleData");

	return Clss;
}


// ContainedPuzzleData IslandsofInsight.Default__ContainedPuzzleData
// (Public, ClassDefaultObject, ArchetypeObject)

class UContainedPuzzleData* UContainedPuzzleData::GetDefaultObj()
{
	static class UContainedPuzzleData* Default = nullptr;

	if (!Default)
		Default = static_cast<UContainedPuzzleData*>(UContainedPuzzleData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleDatabase
// (None)

class UClass* UPuzzleDatabase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleDatabase");

	return Clss;
}


// PuzzleDatabase IslandsofInsight.Default__PuzzleDatabase
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleDatabase* UPuzzleDatabase::GetDefaultObj()
{
	static class UPuzzleDatabase* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleDatabase*>(UPuzzleDatabase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleDatabase.GetZoneNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<enum class EMainMapZoneName>OutNames                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UPuzzleDatabase::GetZoneNames(TArray<enum class EMainMapZoneName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetZoneNames");

	Params::UPuzzleDatabase_GetZoneNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);

}


// Function IslandsofInsight.PuzzleDatabase.GetZoneCompletion
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PuzzleType                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutSolved                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutTotal                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Percent                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PercentStr                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPuzzleDatabase::GetZoneCompletion(class ASophiaCharacter* Player, enum class EMainMapZoneName& ZoneName, const class FString& PuzzleType, int32* OutSolved, int32* OutTotal, int32* Percent, class FString* PercentStr)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetZoneCompletion");

	Params::UPuzzleDatabase_GetZoneCompletion_Params Parms{};

	Parms.Player = Player;
	Parms.ZoneName = ZoneName;
	Parms.PuzzleType = PuzzleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSolved != nullptr)
		*OutSolved = Parms.OutSolved;

	if (OutTotal != nullptr)
		*OutTotal = Parms.OutTotal;

	if (Percent != nullptr)
		*Percent = Parms.Percent;

	if (PercentStr != nullptr)
		*PercentStr = std::move(Parms.PercentStr);

}


// Function IslandsofInsight.PuzzleDatabase.GetSecondsUntilPuzzleTypeBatchSpawnInZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      KrakenPuzzleType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UPuzzleDatabase::GetSecondsUntilPuzzleTypeBatchSpawnInZone(const class FString& KrakenPuzzleType, enum class EMainMapZoneName ZoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetSecondsUntilPuzzleTypeBatchSpawnInZone");

	Params::UPuzzleDatabase_GetSecondsUntilPuzzleTypeBatchSpawnInZone_Params Parms{};

	Parms.KrakenPuzzleType = KrakenPuzzleType;
	Parms.ZoneName = ZoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetPuzzleTypesInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              OutNames                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bNoAlwaysSpawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPuzzleDatabase::GetPuzzleTypesInZone(enum class EMainMapZoneName& ZoneName, TArray<class FString>* OutNames, bool bNoAlwaysSpawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetPuzzleTypesInZone");

	Params::UPuzzleDatabase_GetPuzzleTypesInZone_Params Parms{};

	Parms.ZoneName = ZoneName;
	Parms.bNoAlwaysSpawn = bNoAlwaysSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);

}


// Function IslandsofInsight.PuzzleDatabase.GetAllSolvedPuzzleDataOfCategoryInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllSolvedPuzzleDataOfCategoryInZone(class ASophiaCharacter* Player, enum class EPuzzleCategory& PuzzleCategory, enum class EMainMapZoneName& ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllSolvedPuzzleDataOfCategoryInZone");

	Params::UPuzzleDatabase_GetAllSolvedPuzzleDataOfCategoryInZone_Params Parms{};

	Parms.Player = Player;
	Parms.PuzzleCategory = PuzzleCategory;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllSolvedPuzzleDataInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllSolvedPuzzleDataInZone(class ASophiaCharacter* Player, enum class EMainMapZoneName& ZoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllSolvedPuzzleDataInZone");

	Params::UPuzzleDatabase_GetAllSolvedPuzzleDataInZone_Params Parms{};

	Parms.Player = Player;
	Parms.ZoneName = ZoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllSolvedDataOfTypeInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenPuzzleType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllSolvedDataOfTypeInZone(class ASophiaCharacter* Player, const class FString& KrakenPuzzleType, enum class EMainMapZoneName& ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllSolvedDataOfTypeInZone");

	Params::UPuzzleDatabase_GetAllSolvedDataOfTypeInZone_Params Parms{};

	Parms.Player = Player;
	Parms.KrakenPuzzleType = KrakenPuzzleType;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllPuzzleDataOfTypeInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      KrakenPuzzleType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllPuzzleDataOfTypeInZone(const class FString& KrakenPuzzleType, enum class EMainMapZoneName& ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllPuzzleDataOfTypeInZone");

	Params::UPuzzleDatabase_GetAllPuzzleDataOfTypeInZone_Params Parms{};

	Parms.KrakenPuzzleType = KrakenPuzzleType;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllPuzzleDataOfCategoryInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EPuzzleCategory         PuzzleCategory                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllPuzzleDataOfCategoryInZone(enum class EPuzzleCategory& PuzzleCategory, enum class EMainMapZoneName& ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllPuzzleDataOfCategoryInZone");

	Params::UPuzzleDatabase_GetAllPuzzleDataOfCategoryInZone_Params Parms{};

	Parms.PuzzleCategory = PuzzleCategory;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllPuzzleDataInZone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllPuzzleDataInZone(enum class EMainMapZoneName& ZoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllPuzzleDataInZone");

	Params::UPuzzleDatabase_GetAllPuzzleDataInZone_Params Parms{};

	Parms.ZoneName = ZoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllActiveSolvedSandboxPuzzleDataOfTypeInZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenPuzzleType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllActiveSolvedSandboxPuzzleDataOfTypeInZone(class ASophiaCharacter* Player, const class FString& KrakenPuzzleType, enum class EMainMapZoneName ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllActiveSolvedSandboxPuzzleDataOfTypeInZone");

	Params::UPuzzleDatabase_GetAllActiveSolvedSandboxPuzzleDataOfTypeInZone_Params Parms{};

	Parms.Player = Player;
	Parms.KrakenPuzzleType = KrakenPuzzleType;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.PuzzleDatabase.GetAllActiveSandboxPuzzleDataOfTypeInZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      KrakenPuzzleType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZoneName                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSandboxProgressionRelevant                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPuzzleData*>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPuzzleData*> UPuzzleDatabase::GetAllActiveSandboxPuzzleDataOfTypeInZone(const class FString& KrakenPuzzleType, enum class EMainMapZoneName ZoneName, bool bSandboxProgressionRelevant)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleDatabase", "GetAllActiveSandboxPuzzleDataOfTypeInZone");

	Params::UPuzzleDatabase_GetAllActiveSandboxPuzzleDataOfTypeInZone_Params Parms{};

	Parms.KrakenPuzzleType = KrakenPuzzleType;
	Parms.ZoneName = ZoneName;
	Parms.bSandboxProgressionRelevant = bSandboxProgressionRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PuzzleGrid
// (None)

class UClass* UPuzzleGrid::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleGrid");

	return Clss;
}


// PuzzleGrid IslandsofInsight.Default__PuzzleGrid
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleGrid* UPuzzleGrid::GetDefaultObj()
{
	static class UPuzzleGrid* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleGrid*>(UPuzzleGrid::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleGrid.OnRep_ServerState
// (Final, Native, Private)
// Parameters:

void UPuzzleGrid::OnRep_ServerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleGrid", "OnRep_ServerState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleGrid.GetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPuzzleGrid::GetLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleGrid", "GetLevel");

	Params::UPuzzleGrid_GetLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PuzzleGridFilenameWidget
// (None)

class UClass* UPuzzleGridFilenameWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleGridFilenameWidget");

	return Clss;
}


// PuzzleGridFilenameWidget IslandsofInsight.Default__PuzzleGridFilenameWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleGridFilenameWidget* UPuzzleGridFilenameWidget::GetDefaultObj()
{
	static class UPuzzleGridFilenameWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleGridFilenameWidget*>(UPuzzleGridFilenameWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleInstructionTip_DEPRECATED
// (Actor)

class UClass* APuzzleInstructionTip_DEPRECATED::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleInstructionTip_DEPRECATED");

	return Clss;
}


// PuzzleInstructionTip_DEPRECATED IslandsofInsight.Default__PuzzleInstructionTip_DEPRECATED
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleInstructionTip_DEPRECATED* APuzzleInstructionTip_DEPRECATED::GetDefaultObj()
{
	static class APuzzleInstructionTip_DEPRECATED* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleInstructionTip_DEPRECATED*>(APuzzleInstructionTip_DEPRECATED::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleLeaderboardWidget
// (None)

class UClass* UPuzzleLeaderboardWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleLeaderboardWidget");

	return Clss;
}


// PuzzleLeaderboardWidget IslandsofInsight.Default__PuzzleLeaderboardWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleLeaderboardWidget* UPuzzleLeaderboardWidget::GetDefaultObj()
{
	static class UPuzzleLeaderboardWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleLeaderboardWidget*>(UPuzzleLeaderboardWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TargetedJumpingPad
// (Actor)

class UClass* ATargetedJumpingPad::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TargetedJumpingPad");

	return Clss;
}


// TargetedJumpingPad IslandsofInsight.Default__TargetedJumpingPad
// (Public, ClassDefaultObject, ArchetypeObject)

class ATargetedJumpingPad* ATargetedJumpingPad::GetDefaultObj()
{
	static class ATargetedJumpingPad* Default = nullptr;

	if (!Default)
		Default = static_cast<ATargetedJumpingPad*>(ATargetedJumpingPad::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TargetedJumpingPad.CalculateVelocityFromJumpPad
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               IsInverse                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bValidOnServer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ATargetedJumpingPad::CalculateVelocityFromJumpPad(bool IsInverse, bool bValidOnServer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TargetedJumpingPad", "CalculateVelocityFromJumpPad");

	Params::ATargetedJumpingPad_CalculateVelocityFromJumpPad_Params Parms{};

	Parms.IsInverse = IsInverse;
	Parms.bValidOnServer = bValidOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.PuzzleLockedJumpingPad
// (Actor)

class UClass* APuzzleLockedJumpingPad::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleLockedJumpingPad");

	return Clss;
}


// PuzzleLockedJumpingPad IslandsofInsight.Default__PuzzleLockedJumpingPad
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleLockedJumpingPad* APuzzleLockedJumpingPad::GetDefaultObj()
{
	static class APuzzleLockedJumpingPad* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleLockedJumpingPad*>(APuzzleLockedJumpingPad::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleLockedJumpingPad.OnRep_UnlockedPlayers
// (Final, Native, Protected, Const)
// Parameters:
// TArray<class ASophiaCharacter*>    Old                                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void APuzzleLockedJumpingPad::OnRep_UnlockedPlayers(const TArray<class ASophiaCharacter*>& Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleLockedJumpingPad", "OnRep_UnlockedPlayers");

	Params::APuzzleLockedJumpingPad_OnRep_UnlockedPlayers_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.PuzzleLockedJumpingPad.NM_LaunchPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ASophiaCharacter*            SophiaChar                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleLockedJumpingPad::NM_LaunchPlayer(class ASophiaCharacter* SophiaChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleLockedJumpingPad", "NM_LaunchPlayer");

	Params::APuzzleLockedJumpingPad_NM_LaunchPlayer_Params Parms{};

	Parms.SophiaChar = SophiaChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PuzzleRegistrationPlatform
// (Actor)

class UClass* APuzzleRegistrationPlatform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleRegistrationPlatform");

	return Clss;
}


// PuzzleRegistrationPlatform IslandsofInsight.Default__PuzzleRegistrationPlatform
// (Public, ClassDefaultObject, ArchetypeObject)

class APuzzleRegistrationPlatform* APuzzleRegistrationPlatform::GetDefaultObj()
{
	static class APuzzleRegistrationPlatform* Default = nullptr;

	if (!Default)
		Default = static_cast<APuzzleRegistrationPlatform*>(APuzzleRegistrationPlatform::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.PuzzleRegistrationPlatform.OnParentPuzzleWorkersUpdate
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FPuzzleCharInfo>     Solvers                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APuzzleRegistrationPlatform::OnParentPuzzleWorkersUpdate(TArray<struct FPuzzleCharInfo>& Solvers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PuzzleRegistrationPlatform", "OnParentPuzzleWorkersUpdate");

	Params::APuzzleRegistrationPlatform_OnParentPuzzleWorkersUpdate_Params Parms{};

	Parms.Solvers = Solvers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.PuzzleScreenMarkerWidget
// (None)

class UClass* UPuzzleScreenMarkerWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleScreenMarkerWidget");

	return Clss;
}


// PuzzleScreenMarkerWidget IslandsofInsight.Default__PuzzleScreenMarkerWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleScreenMarkerWidget* UPuzzleScreenMarkerWidget::GetDefaultObj()
{
	static class UPuzzleScreenMarkerWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleScreenMarkerWidget*>(UPuzzleScreenMarkerWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PuzzleSolveNotificationContainer
// (None)

class UClass* UPuzzleSolveNotificationContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PuzzleSolveNotificationContainer");

	return Clss;
}


// PuzzleSolveNotificationContainer IslandsofInsight.Default__PuzzleSolveNotificationContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UPuzzleSolveNotificationContainer* UPuzzleSolveNotificationContainer::GetDefaultObj()
{
	static class UPuzzleSolveNotificationContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UPuzzleSolveNotificationContainer*>(UPuzzleSolveNotificationContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.PyramidShadowTrigger
// (Actor)

class UClass* APyramidShadowTrigger::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PyramidShadowTrigger");

	return Clss;
}


// PyramidShadowTrigger IslandsofInsight.Default__PyramidShadowTrigger
// (Public, ClassDefaultObject, ArchetypeObject)

class APyramidShadowTrigger* APyramidShadowTrigger::GetDefaultObj()
{
	static class APyramidShadowTrigger* Default = nullptr;

	if (!Default)
		Default = static_cast<APyramidShadowTrigger*>(APyramidShadowTrigger::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QFPMistakeBox
// (None)

class UClass* UQFPMistakeBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QFPMistakeBox");

	return Clss;
}


// QFPMistakeBox IslandsofInsight.Default__QFPMistakeBox
// (Public, ClassDefaultObject, ArchetypeObject)

class UQFPMistakeBox* UQFPMistakeBox::GetDefaultObj()
{
	static class UQFPMistakeBox* Default = nullptr;

	if (!Default)
		Default = static_cast<UQFPMistakeBox*>(UQFPMistakeBox::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QFPMistakeBox.GetBoxVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UQFPMistakeBox::GetBoxVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeBox", "GetBoxVisibility");

	Params::UQFPMistakeBox_GetBoxVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QFPMistakeBox.BP_SetIconStates
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              ErrorCount                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQFPMistakeBox::BP_SetIconStates(int32 ErrorCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeBox", "BP_SetIconStates");

	Params::UQFPMistakeBox_BP_SetIconStates_Params Parms{};

	Parms.ErrorCount = ErrorCount;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.QFPMistakeBox.BP_PlayMistakeAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              ErrorCount                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQFPMistakeBox::BP_PlayMistakeAnim(int32 ErrorCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeBox", "BP_PlayMistakeAnim");

	Params::UQFPMistakeBox_BP_PlayMistakeAnim_Params Parms{};

	Parms.ErrorCount = ErrorCount;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.QFPMistakeBox.BP_Init
// (Event, Public, BlueprintEvent)
// Parameters:

void UQFPMistakeBox::BP_Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeBox", "BP_Init");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.QFPMistakeIcon
// (None)

class UClass* UQFPMistakeIcon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QFPMistakeIcon");

	return Clss;
}


// QFPMistakeIcon IslandsofInsight.Default__QFPMistakeIcon
// (Public, ClassDefaultObject, ArchetypeObject)

class UQFPMistakeIcon* UQFPMistakeIcon::GetDefaultObj()
{
	static class UQFPMistakeIcon* Default = nullptr;

	if (!Default)
		Default = static_cast<UQFPMistakeIcon*>(UQFPMistakeIcon::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QFPMistakeIcon.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Error                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQFPMistakeIcon::SetState(bool Error)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeIcon", "SetState");

	Params::UQFPMistakeIcon_SetState_Params Parms{};

	Parms.Error = Error;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QFPMistakeIcon.BP_SetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               Error                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQFPMistakeIcon::BP_SetState(bool Error)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPMistakeIcon", "BP_SetState");

	Params::UQFPMistakeIcon_BP_SetState_Params Parms{};

	Parms.Error = Error;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.QFPTierStreakDisplay
// (None)

class UClass* UQFPTierStreakDisplay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QFPTierStreakDisplay");

	return Clss;
}


// QFPTierStreakDisplay IslandsofInsight.Default__QFPTierStreakDisplay
// (Public, ClassDefaultObject, ArchetypeObject)

class UQFPTierStreakDisplay* UQFPTierStreakDisplay::GetDefaultObj()
{
	static class UQFPTierStreakDisplay* Default = nullptr;

	if (!Default)
		Default = static_cast<UQFPTierStreakDisplay*>(UQFPTierStreakDisplay::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QFPTierStreakDisplay.GetDisplayVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UQFPTierStreakDisplay::GetDisplayVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "GetDisplayVisibility");

	Params::UQFPTierStreakDisplay_GetDisplayVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QFPTierStreakDisplay.BP_UpdateTier
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQFPTierStreakDisplay::BP_UpdateTier(int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "BP_UpdateTier");

	Params::UQFPTierStreakDisplay_BP_UpdateTier_Params Parms{};

	Parms.Tier = Tier;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.QFPTierStreakDisplay.BP_UpdateStreak
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        StreakMessage                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQFPTierStreakDisplay::BP_UpdateStreak(class FText& StreakMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "BP_UpdateStreak");

	Params::UQFPTierStreakDisplay_BP_UpdateStreak_Params Parms{};

	Parms.StreakMessage = StreakMessage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.QFPTierStreakDisplay.BP_UpdateSolvedCount
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        SolvedMessage                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQFPTierStreakDisplay::BP_UpdateSolvedCount(class FText& SolvedMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "BP_UpdateSolvedCount");

	Params::UQFPTierStreakDisplay_BP_UpdateSolvedCount_Params Parms{};

	Parms.SolvedMessage = SolvedMessage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.QFPTierStreakDisplay.BP_PlayTierUpgradeAnim
// (Event, Public, BlueprintEvent)
// Parameters:

void UQFPTierStreakDisplay::BP_PlayTierUpgradeAnim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "BP_PlayTierUpgradeAnim");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.QFPTierStreakDisplay.BP_Init
// (Event, Public, BlueprintEvent)
// Parameters:

void UQFPTierStreakDisplay::BP_Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QFPTierStreakDisplay", "BP_Init");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.QFPVolume
// (Actor)

class UClass* AQFPVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QFPVolume");

	return Clss;
}


// QFPVolume IslandsofInsight.Default__QFPVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AQFPVolume* AQFPVolume::GetDefaultObj()
{
	static class AQFPVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AQFPVolume*>(AQFPVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestData
// (None)

class UClass* UQuestData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestData");

	return Clss;
}


// QuestData IslandsofInsight.Default__QuestData
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestData* UQuestData::GetDefaultObj()
{
	static class UQuestData* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestData*>(UQuestData::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestData.InitPlaceHolderQuests
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestData::InitPlaceHolderQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestData", "InitPlaceHolderQuests");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.QuestInfoContainer
// (None)

class UClass* UQuestInfoContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestInfoContainer");

	return Clss;
}


// QuestInfoContainer IslandsofInsight.Default__QuestInfoContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestInfoContainer* UQuestInfoContainer::GetDefaultObj()
{
	static class UQuestInfoContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestInfoContainer*>(UQuestInfoContainer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestInfoContainer.BPI_SlideIn
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWorldQuest*                 Quest                                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestInfoContainer::BPI_SlideIn(class UWorldQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestInfoContainer", "BPI_SlideIn");

	Params::UQuestInfoContainer_BPI_SlideIn_Params Parms{};

	Parms.Quest = Quest;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.QuestInfoLineWidget
// (None)

class UClass* UQuestInfoLineWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestInfoLineWidget");

	return Clss;
}


// QuestInfoLineWidget IslandsofInsight.Default__QuestInfoLineWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestInfoLineWidget* UQuestInfoLineWidget::GetDefaultObj()
{
	static class UQuestInfoLineWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestInfoLineWidget*>(UQuestInfoLineWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestInfoLineWidget.InitializeQuestInfoLine
// (Event, Public, BlueprintEvent)
// Parameters:

void UQuestInfoLineWidget::InitializeQuestInfoLine()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestInfoLineWidget", "InitializeQuestInfoLine");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.QuestInfoWidget
// (None)

class UClass* UQuestInfoWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestInfoWidget");

	return Clss;
}


// QuestInfoWidget IslandsofInsight.Default__QuestInfoWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestInfoWidget* UQuestInfoWidget::GetDefaultObj()
{
	static class UQuestInfoWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestInfoWidget*>(UQuestInfoWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestNotificationWidget
// (None)

class UClass* UQuestNotificationWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestNotificationWidget");

	return Clss;
}


// QuestNotificationWidget IslandsofInsight.Default__QuestNotificationWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestNotificationWidget* UQuestNotificationWidget::GetDefaultObj()
{
	static class UQuestNotificationWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestNotificationWidget*>(UQuestNotificationWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestNotificationWidget.BPC_InitNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                        Text                                                             (Parm, NativeAccessSpecifierPublic)
// enum class EQuestType              Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Orbs                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Xp                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Gold                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestNotificationWidget::BPC_InitNotification(class FText Text, enum class EQuestType Type, int32 Orbs, int32 Xp, int32 Gold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestNotificationWidget", "BPC_InitNotification");

	Params::UQuestNotificationWidget_BPC_InitNotification_Params Parms{};

	Parms.Text = Text;
	Parms.Type = Type;
	Parms.Orbs = Orbs;
	Parms.Xp = Xp;
	Parms.Gold = Gold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.QuestObjective
// (None)

class UClass* UQuestObjective::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective");

	return Clss;
}


// QuestObjective IslandsofInsight.Default__QuestObjective
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective* UQuestObjective::GetDefaultObj()
{
	static class UQuestObjective* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective*>(UQuestObjective::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestObjective.ShouldDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::ShouldDisplay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "ShouldDisplay");

	Params::UQuestObjective_ShouldDisplay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.PrereqChainIsComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::PrereqChainIsComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "PrereqChainIsComplete");

	Params::UQuestObjective_PrereqChainIsComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.PertainsToPuzzle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APuzzleBase*                 Pb                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::PertainsToPuzzle(class APuzzleBase* Pb)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "PertainsToPuzzle");

	Params::UQuestObjective_PertainsToPuzzle_Params Parms{};

	Parms.Pb = Pb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.IsOptional
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::IsOptional()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "IsOptional");

	Params::UQuestObjective_IsOptional_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.IsGiveBorbOnCompletion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::IsGiveBorbOnCompletion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "IsGiveBorbOnCompletion");

	Params::UQuestObjective_IsGiveBorbOnCompletion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.IsComplete
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestObjective::IsComplete(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "IsComplete");

	Params::UQuestObjective_IsComplete_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.GetProgressMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UQuestObjective::GetProgressMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "GetProgressMessage");

	Params::UQuestObjective_GetProgressMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestObjective.GetDisplayMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UQuestObjective::GetDisplayMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestObjective", "GetDisplayMessage");

	Params::UQuestObjective_GetDisplayMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.QuestObjective_CompleteDaily
// (None)

class UClass* UQuestObjective_CompleteDaily::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_CompleteDaily");

	return Clss;
}


// QuestObjective_CompleteDaily IslandsofInsight.Default__QuestObjective_CompleteDaily
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_CompleteDaily* UQuestObjective_CompleteDaily::GetDefaultObj()
{
	static class UQuestObjective_CompleteDaily* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_CompleteDaily*>(UQuestObjective_CompleteDaily::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_ConnectMeshes
// (None)

class UClass* UQuestObjective_ConnectMeshes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_ConnectMeshes");

	return Clss;
}


// QuestObjective_ConnectMeshes IslandsofInsight.Default__QuestObjective_ConnectMeshes
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_ConnectMeshes* UQuestObjective_ConnectMeshes::GetDefaultObj()
{
	static class UQuestObjective_ConnectMeshes* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_ConnectMeshes*>(UQuestObjective_ConnectMeshes::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_Interact
// (None)

class UClass* UQuestObjective_Interact::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_Interact");

	return Clss;
}


// QuestObjective_Interact IslandsofInsight.Default__QuestObjective_Interact
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_Interact* UQuestObjective_Interact::GetDefaultObj()
{
	static class UQuestObjective_Interact* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_Interact*>(UQuestObjective_Interact::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_Mirabilis
// (None)

class UClass* UQuestObjective_Mirabilis::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_Mirabilis");

	return Clss;
}


// QuestObjective_Mirabilis IslandsofInsight.Default__QuestObjective_Mirabilis
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_Mirabilis* UQuestObjective_Mirabilis::GetDefaultObj()
{
	static class UQuestObjective_Mirabilis* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_Mirabilis*>(UQuestObjective_Mirabilis::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_ParticularPuzzle
// (None)

class UClass* UQuestObjective_ParticularPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_ParticularPuzzle");

	return Clss;
}


// QuestObjective_ParticularPuzzle IslandsofInsight.Default__QuestObjective_ParticularPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_ParticularPuzzle* UQuestObjective_ParticularPuzzle::GetDefaultObj()
{
	static class UQuestObjective_ParticularPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_ParticularPuzzle*>(UQuestObjective_ParticularPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_ParticularPuzzleProgress
// (None)

class UClass* UQuestObjective_ParticularPuzzleProgress::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_ParticularPuzzleProgress");

	return Clss;
}


// QuestObjective_ParticularPuzzleProgress IslandsofInsight.Default__QuestObjective_ParticularPuzzleProgress
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_ParticularPuzzleProgress* UQuestObjective_ParticularPuzzleProgress::GetDefaultObj()
{
	static class UQuestObjective_ParticularPuzzleProgress* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_ParticularPuzzleProgress*>(UQuestObjective_ParticularPuzzleProgress::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_ParticularPuzzleSolveDuration
// (None)

class UClass* UQuestObjective_ParticularPuzzleSolveDuration::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_ParticularPuzzleSolveDuration");

	return Clss;
}


// QuestObjective_ParticularPuzzleSolveDuration IslandsofInsight.Default__QuestObjective_ParticularPuzzleSolveDuration
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_ParticularPuzzleSolveDuration* UQuestObjective_ParticularPuzzleSolveDuration::GetDefaultObj()
{
	static class UQuestObjective_ParticularPuzzleSolveDuration* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_ParticularPuzzleSolveDuration*>(UQuestObjective_ParticularPuzzleSolveDuration::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_PuzzlesOfType
// (None)

class UClass* UQuestObjective_PuzzlesOfType::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_PuzzlesOfType");

	return Clss;
}


// QuestObjective_PuzzlesOfType IslandsofInsight.Default__QuestObjective_PuzzlesOfType
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_PuzzlesOfType* UQuestObjective_PuzzlesOfType::GetDefaultObj()
{
	static class UQuestObjective_PuzzlesOfType* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_PuzzlesOfType*>(UQuestObjective_PuzzlesOfType::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_PuzzlesOfTypeCounting
// (None)

class UClass* UQuestObjective_PuzzlesOfTypeCounting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_PuzzlesOfTypeCounting");

	return Clss;
}


// QuestObjective_PuzzlesOfTypeCounting IslandsofInsight.Default__QuestObjective_PuzzlesOfTypeCounting
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_PuzzlesOfTypeCounting* UQuestObjective_PuzzlesOfTypeCounting::GetDefaultObj()
{
	static class UQuestObjective_PuzzlesOfTypeCounting* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_PuzzlesOfTypeCounting*>(UQuestObjective_PuzzlesOfTypeCounting::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_PuzzlesOfTypeRespawning
// (None)

class UClass* UQuestObjective_PuzzlesOfTypeRespawning::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_PuzzlesOfTypeRespawning");

	return Clss;
}


// QuestObjective_PuzzlesOfTypeRespawning IslandsofInsight.Default__QuestObjective_PuzzlesOfTypeRespawning
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_PuzzlesOfTypeRespawning* UQuestObjective_PuzzlesOfTypeRespawning::GetDefaultObj()
{
	static class UQuestObjective_PuzzlesOfTypeRespawning* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_PuzzlesOfTypeRespawning*>(UQuestObjective_PuzzlesOfTypeRespawning::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestObjective_UniqueKIDPuzzlesOfTypeCounting
// (None)

class UClass* UQuestObjective_UniqueKIDPuzzlesOfTypeCounting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestObjective_UniqueKIDPuzzlesOfTypeCounting");

	return Clss;
}


// QuestObjective_UniqueKIDPuzzlesOfTypeCounting IslandsofInsight.Default__QuestObjective_UniqueKIDPuzzlesOfTypeCounting
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestObjective_UniqueKIDPuzzlesOfTypeCounting* UQuestObjective_UniqueKIDPuzzlesOfTypeCounting::GetDefaultObj()
{
	static class UQuestObjective_UniqueKIDPuzzlesOfTypeCounting* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestObjective_UniqueKIDPuzzlesOfTypeCounting*>(UQuestObjective_UniqueKIDPuzzlesOfTypeCounting::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.QuestPickup
// (Actor)

class UClass* AQuestPickup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestPickup");

	return Clss;
}


// QuestPickup IslandsofInsight.Default__QuestPickup
// (Public, ClassDefaultObject, ArchetypeObject)

class AQuestPickup* AQuestPickup::GetDefaultObj()
{
	static class AQuestPickup* Default = nullptr;

	if (!Default)
		Default = static_cast<AQuestPickup*>(AQuestPickup::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestPickup.SelectPickup
// (Native, Protected, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestPickup::SelectPickup(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestPickup", "SelectPickup");

	Params::AQuestPickup_SelectPickup_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestPickup.OnConfirm
// (Native, Protected, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuestPickup::OnConfirm(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestPickup", "OnConfirm");

	Params::AQuestPickup_OnConfirm_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestPickup.DeselectPickup
// (Native, Protected, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestPickup::DeselectPickup(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestPickup", "DeselectPickup");

	Params::AQuestPickup_DeselectPickup_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.QuestSystemComponent
// (None)

class UClass* UQuestSystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestSystemComponent");

	return Clss;
}


// QuestSystemComponent IslandsofInsight.Default__QuestSystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestSystemComponent* UQuestSystemComponent::GetDefaultObj()
{
	static class UQuestSystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestSystemComponent*>(UQuestSystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestSystemComponent.UpdateMaxSandboxQuests
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::UpdateMaxSandboxQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "UpdateMaxSandboxQuests");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.UnwrapBorbChildren
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBlueOrbSourceData          InBorb                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FBlueOrbSourceData>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBlueOrbSourceData> UQuestSystemComponent::UnwrapBorbChildren(struct FBlueOrbSourceData& InBorb)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "UnwrapBorbChildren");

	Params::UQuestSystemComponent_UnwrapBorbChildren_Params Parms{};

	Parms.InBorb = InBorb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestSystemComponent.TogglePinQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        QuestIndex                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestSystemComponent::TogglePinQuest(class FName& QuestIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "TogglePinQuest");

	Params::UQuestSystemComponent_TogglePinQuest_Params Parms{};

	Parms.QuestIndex = QuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.SetupDailies
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::SetupDailies()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "SetupDailies");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.Server_UpdateQuestState
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                        QuestID                                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SerializedData                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKrakenAddBasicRewardsParamsRewards                                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_ProgressionQuestEventData                                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestSystemComponent::Server_UpdateQuestState(class FName& QuestID, const class FString& SerializedData, struct FKrakenAddBasicRewardsParams& Rewards, struct FBhvrAnalyticsEvent_ProgressionQuest& EventData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "Server_UpdateQuestState");

	Params::UQuestSystemComponent_Server_UpdateQuestState_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.SerializedData = SerializedData;
	Parms.Rewards = Rewards;
	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.Server_CheatQuestObjective
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void UQuestSystemComponent::Server_CheatQuestObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "Server_CheatQuestObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.Server_CheatQuest
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void UQuestSystemComponent::Server_CheatQuest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "Server_CheatQuest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.Server_AddQuest
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestSystemComponent::Server_AddQuest(class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "Server_AddQuest");

	Params::UQuestSystemComponent_Server_AddQuest_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.Server_AddBlueOrb
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FBhvrAnalyticsEvent_ProgressionQuestEventData                                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestSystemComponent::Server_AddBlueOrb(struct FBhvrAnalyticsEvent_ProgressionQuest& EventData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "Server_AddBlueOrb");

	Params::UQuestSystemComponent_Server_AddBlueOrb_Params Parms{};

	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.LoadQuestData
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::LoadQuestData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "LoadQuestData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.IsQuestValid
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        QuestID                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestSystemComponent::IsQuestValid(class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "IsQuestValid");

	Params::UQuestSystemComponent_IsQuestValid_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestSystemComponent.GetCompletedActiveQuests
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UQuestSystemComponent::GetCompletedActiveQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "GetCompletedActiveQuests");

	Params::UQuestSystemComponent_GetCompletedActiveQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestSystemComponent.GetAllBlueOrbSourcesFormatted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FBlueOrbSourceData>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBlueOrbSourceData> UQuestSystemComponent::GetAllBlueOrbSourcesFormatted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "GetAllBlueOrbSourcesFormatted");

	Params::UQuestSystemComponent_GetAllBlueOrbSourcesFormatted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestSystemComponent.GetAllBlueOrbSourceData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FBlueOrbSourceDataForBP>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBlueOrbSourceDataForBP> UQuestSystemComponent::GetAllBlueOrbSourceData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "GetAllBlueOrbSourceData");

	Params::UQuestSystemComponent_GetAllBlueOrbSourceData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.QuestSystemComponent.CheatCompleteQuestObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::CheatCompleteQuestObjective()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "CheatCompleteQuestObjective");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.CheatCompleteQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::CheatCompleteQuest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "CheatCompleteQuest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.CancelDailyQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestSystemComponent::CancelDailyQuest(class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "CancelDailyQuest");

	Params::UQuestSystemComponent_CancelDailyQuest_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.BPC_AnnounceNewQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuestSystemComponent::BPC_AnnounceNewQuest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "BPC_AnnounceNewQuest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestSystemComponent.AddQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestSystemComponent::AddQuest(class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestSystemComponent", "AddQuest");

	Params::UQuestSystemComponent_AddQuest_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.QuestVendor
// (Actor)

class UClass* AQuestVendor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestVendor");

	return Clss;
}


// QuestVendor IslandsofInsight.Default__QuestVendor
// (Public, ClassDefaultObject, ArchetypeObject)

class AQuestVendor* AQuestVendor::GetDefaultObj()
{
	static class AQuestVendor* Default = nullptr;

	if (!Default)
		Default = static_cast<AQuestVendor*>(AQuestVendor::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.QuestVendor.OpenActiveQuests
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AQuestVendor::OpenActiveQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestVendor", "OpenActiveQuests");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.QuestVendor.GetSpawnedQuests
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AQuestPickup*>        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AQuestPickup*> AQuestVendor::GetSpawnedQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuestVendor", "GetSpawnedQuests");

	Params::AQuestVendor_GetSpawnedQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.QuestVendorMessage
// (None)

class UClass* UQuestVendorMessage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuestVendorMessage");

	return Clss;
}


// QuestVendorMessage IslandsofInsight.Default__QuestVendorMessage
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuestVendorMessage* UQuestVendorMessage::GetDefaultObj()
{
	static class UQuestVendorMessage* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuestVendorMessage*>(UQuestVendorMessage::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RacingPuzzle
// (Actor)

class UClass* ARacingPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingPuzzle");

	return Clss;
}


// RacingPuzzle IslandsofInsight.Default__RacingPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingPuzzle* ARacingPuzzle::GetDefaultObj()
{
	static class ARacingPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingPuzzle*>(ARacingPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingPuzzle.OnPlayerDisconnected
// (Final, Native, Private)
// Parameters:
// class AActor*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEndPlayReason          Reason                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingPuzzle::OnPlayerDisconnected(class AActor* A, enum class EEndPlayReason Reason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzle", "OnPlayerDisconnected");

	Params::ARacingPuzzle_OnPlayerDisconnected_Params Parms{};

	Parms.A = A;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingPuzzle.BPI_NewlyCompleteMilestone
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                              Idx                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumMilestones                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocalBestSolveTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MilestoneTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingPuzzle::BPI_NewlyCompleteMilestone(int32 Idx, int32 NumMilestones, float LocalBestSolveTime, float MilestoneTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzle", "BPI_NewlyCompleteMilestone");

	Params::ARacingPuzzle_BPI_NewlyCompleteMilestone_Params Parms{};

	Parms.Idx = Idx;
	Parms.NumMilestones = NumMilestones;
	Parms.LocalBestSolveTime = LocalBestSolveTime;
	Parms.MilestoneTime = MilestoneTime;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.RacingBalls
// (Actor)

class UClass* ARacingBalls::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingBalls");

	return Clss;
}


// RacingBalls IslandsofInsight.Default__RacingBalls
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingBalls* ARacingBalls::GetDefaultObj()
{
	static class ARacingBalls* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingBalls*>(ARacingBalls::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingBalls.OnRep_unmarkedColour
// (Final, Native, Protected)
// Parameters:

void ARacingBalls::OnRep_unmarkedColour()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingBalls", "OnRep_unmarkedColour");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingBalls.OnBallOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingBalls::OnBallOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingBalls", "OnBallOverlap");

	Params::ARacingBalls_OnBallOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingBalls.BP_UpdateOnSolve
// (Event, Protected, BlueprintEvent)
// Parameters:

void ARacingBalls::BP_UpdateOnSolve()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingBalls", "BP_UpdateOnSolve");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RacingBalls.BP_OnUpdateRacingBallsVisual
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class URacingBallsMeshComponent*   Mesh                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*        InnerMesh                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NormalizedTimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                C                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERacingBallsVisualState VisualState                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CurrentlyBeingControlledByATeam                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingBalls::BP_OnUpdateRacingBallsVisual(class URacingBallsMeshComponent* Mesh, class UStaticMeshComponent* InnerMesh, int32 Index, float NormalizedTimeLeft, const struct FLinearColor& C, enum class ERacingBallsVisualState VisualState, bool CurrentlyBeingControlledByATeam)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingBalls", "BP_OnUpdateRacingBallsVisual");

	Params::ARacingBalls_BP_OnUpdateRacingBallsVisual_Params Parms{};

	Parms.Mesh = Mesh;
	Parms.InnerMesh = InnerMesh;
	Parms.Index = Index;
	Parms.NormalizedTimeLeft = NormalizedTimeLeft;
	Parms.C = C;
	Parms.VisualState = VisualState;
	Parms.CurrentlyBeingControlledByATeam = CurrentlyBeingControlledByATeam;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingBalls.BP_OnClientInitialized
// (Event, Protected, BlueprintEvent)
// Parameters:

void ARacingBalls::BP_OnClientInitialized()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingBalls", "BP_OnClientInitialized");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RacingBallsMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* URacingBallsMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingBallsMeshComponent");

	return Clss;
}


// RacingBallsMeshComponent IslandsofInsight.Default__RacingBallsMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class URacingBallsMeshComponent* URacingBallsMeshComponent::GetDefaultObj()
{
	static class URacingBallsMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<URacingBallsMeshComponent*>(URacingBallsMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RacingCheckpointsMinigame
// (Actor)

class UClass* ARacingCheckpointsMinigame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingCheckpointsMinigame");

	return Clss;
}


// RacingCheckpointsMinigame IslandsofInsight.Default__RacingCheckpointsMinigame
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingCheckpointsMinigame* ARacingCheckpointsMinigame::GetDefaultObj()
{
	static class ARacingCheckpointsMinigame* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingCheckpointsMinigame*>(ARacingCheckpointsMinigame::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnStartPlatformOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingCheckpointsMinigame::OnStartPlatformOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnStartPlatformOverlap");

	Params::ARacingCheckpointsMinigame_OnStartPlatformOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnStartPlatformExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingCheckpointsMinigame::OnStartPlatformExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnStartPlatformExit");

	Params::ARacingCheckpointsMinigame_OnStartPlatformExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnRep_SpawnedCheckpointMeshes
// (Final, Native, Private)
// Parameters:

void ARacingCheckpointsMinigame::OnRep_SpawnedCheckpointMeshes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnRep_SpawnedCheckpointMeshes");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnRep_RacingCheckpointsReached
// (Final, Native, Private)
// Parameters:

void ARacingCheckpointsMinigame::OnRep_RacingCheckpointsReached()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnRep_RacingCheckpointsReached");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnRep_InRace
// (Final, Native, Private)
// Parameters:

void ARacingCheckpointsMinigame::OnRep_InRace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnRep_InRace");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingCheckpointsMinigame.OnCheckpointMeshOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingCheckpointsMinigame::OnCheckpointMeshOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingCheckpointsMinigame", "OnCheckpointMeshOverlap");

	Params::ARacingCheckpointsMinigame_OnCheckpointMeshOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.RacingMetaPuzzle
// (Actor)

class UClass* ARacingMetaPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingMetaPuzzle");

	return Clss;
}


// RacingMetaPuzzle IslandsofInsight.Default__RacingMetaPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingMetaPuzzle* ARacingMetaPuzzle::GetDefaultObj()
{
	static class ARacingMetaPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingMetaPuzzle*>(ARacingMetaPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingMetaPuzzle.Server_Cancel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::Server_Cancel(class ASophiaPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "Server_Cancel");

	Params::ARacingMetaPuzzle_Server_Cancel_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.Overlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::Overlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "Overlap");

	Params::ARacingMetaPuzzle_Overlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.OnRep_started
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzle::OnRep_started()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "OnRep_started");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.OnRep_failed
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzle::OnRep_failed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "OnRep_failed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.OnRep_curState
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzle::OnRep_curState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "OnRep_curState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.OnRep_curRounds
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzle::OnRep_curRounds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "OnRep_curRounds");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.OnRep_CollectiblesLeft
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzle::OnRep_CollectiblesLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "OnRep_CollectiblesLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.NetMultiCast_TentativeScore
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CollectibleCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::NetMultiCast_TentativeScore(class ASophiaPlayerState* Player, int32 CollectibleCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "NetMultiCast_TentativeScore");

	Params::ARacingMetaPuzzle_NetMultiCast_TentativeScore_Params Parms{};

	Parms.Player = Player;
	Parms.CollectibleCount = CollectibleCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.NetMultiCast_NotifyMoreCones
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                              ConeCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::NetMultiCast_NotifyMoreCones(int32 ConeCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "NetMultiCast_NotifyMoreCones");

	Params::ARacingMetaPuzzle_NetMultiCast_NotifyMoreCones_Params Parms{};

	Parms.ConeCount = ConeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.NetMultiCast_NotifyDrop
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::NetMultiCast_NotifyDrop(class ASophiaPlayerState* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "NetMultiCast_NotifyDrop");

	Params::ARacingMetaPuzzle_NetMultiCast_NotifyDrop_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.NetMultiCast_FinalScore
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASophiaPlayerState*          Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Score                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowCollectionCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingMetaPuzzle::NetMultiCast_FinalScore(class ASophiaPlayerState* Player, int32 Score, bool ShowCollectionCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "NetMultiCast_FinalScore");

	Params::ARacingMetaPuzzle_NetMultiCast_FinalScore_Params Parms{};

	Parms.Player = Player;
	Parms.Score = Score;
	Parms.ShowCollectionCount = ShowCollectionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzle.BP_OnLanded
// (Event, Public, BlueprintEvent)
// Parameters:

void ARacingMetaPuzzle::BP_OnLanded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzle", "BP_OnLanded");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RacingMetaPuzzleAcceptableVolume
// (Actor)

class UClass* ARacingMetaPuzzleAcceptableVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingMetaPuzzleAcceptableVolume");

	return Clss;
}


// RacingMetaPuzzleAcceptableVolume IslandsofInsight.Default__RacingMetaPuzzleAcceptableVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingMetaPuzzleAcceptableVolume* ARacingMetaPuzzleAcceptableVolume::GetDefaultObj()
{
	static class ARacingMetaPuzzleAcceptableVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingMetaPuzzleAcceptableVolume*>(ARacingMetaPuzzleAcceptableVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RacingMetaPuzzleCollectible
// (Actor)

class UClass* ARacingMetaPuzzleCollectible::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingMetaPuzzleCollectible");

	return Clss;
}


// RacingMetaPuzzleCollectible IslandsofInsight.Default__RacingMetaPuzzleCollectible
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingMetaPuzzleCollectible* ARacingMetaPuzzleCollectible::GetDefaultObj()
{
	static class ARacingMetaPuzzleCollectible* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingMetaPuzzleCollectible*>(ARacingMetaPuzzleCollectible::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingMetaPuzzleCollectible.Overlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingMetaPuzzleCollectible::Overlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzleCollectible", "Overlap");

	Params::ARacingMetaPuzzleCollectible_Overlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzleCollectible.OnRep_isSpeed
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzleCollectible::OnRep_isSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzleCollectible", "OnRep_isSpeed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingMetaPuzzleCollectible.OnRep_collected
// (Final, Native, Protected)
// Parameters:

void ARacingMetaPuzzleCollectible::OnRep_collected()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingMetaPuzzleCollectible", "OnRep_collected");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.RacingMetaWidget
// (None)

class UClass* URacingMetaWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingMetaWidget");

	return Clss;
}


// RacingMetaWidget IslandsofInsight.Default__RacingMetaWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URacingMetaWidget* URacingMetaWidget::GetDefaultObj()
{
	static class URacingMetaWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URacingMetaWidget*>(URacingMetaWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RacingPuzzleWidget
// (None)

class UClass* URacingPuzzleWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingPuzzleWidget");

	return Clss;
}


// RacingPuzzleWidget IslandsofInsight.Default__RacingPuzzleWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URacingPuzzleWidget* URacingPuzzleWidget::GetDefaultObj()
{
	static class URacingPuzzleWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URacingPuzzleWidget*>(URacingPuzzleWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingPuzzleWidget.BP_ShowResultsPopup
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        TITLE                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_ShowResultsPopup(class FText& TITLE)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_ShowResultsPopup");

	Params::URacingPuzzleWidget_BP_ShowResultsPopup_Params Parms{};

	Parms.TITLE = TITLE;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_Show
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                  PuzzleIcon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_Show(class UTexture2D* PuzzleIcon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_Show");

	Params::URacingPuzzleWidget_BP_Show_Params Parms{};

	Parms.PuzzleIcon = PuzzleIcon;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_SetTeamColor
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FLinearColor                ControllerTeamColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                PlayerTeamColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_SetTeamColor(const struct FLinearColor& ControllerTeamColor, const struct FLinearColor& PlayerTeamColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_SetTeamColor");

	Params::URacingPuzzleWidget_BP_SetTeamColor_Params Parms{};

	Parms.ControllerTeamColor = ControllerTeamColor;
	Parms.PlayerTeamColor = PlayerTeamColor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_RemoveResultsPopup
// (Event, Protected, BlueprintEvent)
// Parameters:

void URacingPuzzleWidget::BP_RemoveResultsPopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_RemoveResultsPopup");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_Hide
// (Event, Protected, BlueprintEvent)
// Parameters:

void URacingPuzzleWidget::BP_Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_Hide");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_DisplayInstructions
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Instructions                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_DisplayInstructions(class FText& Instructions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_DisplayInstructions");

	Params::URacingPuzzleWidget_BP_DisplayInstructions_Params Parms{};

	Parms.Instructions = Instructions;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_AddScore
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Label                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Delta                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              DeltaSign                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_AddScore(class FText& Label, class FText& Value, class FText& Delta, float DeltaSign)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_AddScore");

	Params::URacingPuzzleWidget_BP_AddScore_Params Parms{};

	Parms.Label = Label;
	Parms.Value = Value;
	Parms.Delta = Delta;
	Parms.DeltaSign = DeltaSign;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingPuzzleWidget.BP_AddMilestone
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMilestoneResultData        Data                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URacingPuzzleWidget::BP_AddMilestone(struct FMilestoneResultData& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingPuzzleWidget", "BP_AddMilestone");

	Params::URacingPuzzleWidget_BP_AddMilestone_Params Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.RacingRings
// (Actor)

class UClass* ARacingRings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingRings");

	return Clss;
}


// RacingRings IslandsofInsight.Default__RacingRings
// (Public, ClassDefaultObject, ArchetypeObject)

class ARacingRings* ARacingRings::GetDefaultObj()
{
	static class ARacingRings* Default = nullptr;

	if (!Default)
		Default = static_cast<ARacingRings*>(ARacingRings::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingRings.OnStartExit
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingRings::OnStartExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "OnStartExit");

	Params::ARacingRings_OnStartExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingRings.OnStartEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingRings::OnStartEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "OnStartEnter");

	Params::ARacingRings_OnStartEnter_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingRings.OnRingOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARacingRings::OnRingOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "OnRingOverlap");

	Params::ARacingRings_OnRingOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingRings.OnPlayerDisconnected
// (Final, Native, Private)
// Parameters:
// class AActor*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEndPlayReason          Reason                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingRings::OnPlayerDisconnected(class AActor* A, enum class EEndPlayReason Reason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "OnPlayerDisconnected");

	Params::ARacingRings_OnPlayerDisconnected_Params Parms{};

	Parms.A = A;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingRings.OnInteractionStateChange
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ERingIntState           NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERingIntState           OldState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingRings::OnInteractionStateChange(enum class ERingIntState NewState, enum class ERingIntState OldState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "OnInteractionStateChange");

	Params::ARacingRings_OnInteractionStateChange_Params Parms{};

	Parms.NewState = NewState;
	Parms.OldState = OldState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRings.GetMostRecentPlayerScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARacingRings::GetMostRecentPlayerScore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "GetMostRecentPlayerScore");

	Params::ARacingRings_GetMostRecentPlayerScore_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RacingRings.ForceExit
// (Final, Native, Public)
// Parameters:

void ARacingRings::ForceExit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "ForceExit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RacingRings.BPI_OnRingAcquire
// (Event, Public, BlueprintEvent)
// Parameters:
// class URacingRingsMeshComponent*   Ring                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEndOfRace                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARacingRings::BPI_OnRingAcquire(class URacingRingsMeshComponent* Ring, bool bEndOfRace, class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "BPI_OnRingAcquire");

	Params::ARacingRings_BPI_OnRingAcquire_Params Parms{};

	Parms.Ring = Ring;
	Parms.bEndOfRace = bEndOfRace;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRings.BP_PostClientInit
// (Event, Protected, BlueprintEvent)
// Parameters:

void ARacingRings::BP_PostClientInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRings", "BP_PostClientInit");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RacingRingsMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* URacingRingsMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingRingsMeshComponent");

	return Clss;
}


// RacingRingsMeshComponent IslandsofInsight.Default__RacingRingsMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class URacingRingsMeshComponent* URacingRingsMeshComponent::GetDefaultObj()
{
	static class URacingRingsMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<URacingRingsMeshComponent*>(URacingRingsMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RacingRingsScoreWidget
// (None)

class UClass* URacingRingsScoreWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RacingRingsScoreWidget");

	return Clss;
}


// RacingRingsScoreWidget IslandsofInsight.Default__RacingRingsScoreWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URacingRingsScoreWidget* URacingRingsScoreWidget::GetDefaultObj()
{
	static class URacingRingsScoreWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URacingRingsScoreWidget*>(URacingRingsScoreWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RacingRingsScoreWidget.GetScoreText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URacingRingsScoreWidget::GetScoreText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "GetScoreText");

	Params::URacingRingsScoreWidget_GetScoreText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_ShowResultsPopup
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture2D*                  PuzzleIcon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        TITLE                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ShowPreviousScore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowRestartButton                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_ShowResultsPopup(class UTexture2D* PuzzleIcon, class FText& TITLE, bool ShowPreviousScore, bool ShowRestartButton)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_ShowResultsPopup");

	Params::URacingRingsScoreWidget_BP_ShowResultsPopup_Params Parms{};

	Parms.PuzzleIcon = PuzzleIcon;
	Parms.TITLE = TITLE;
	Parms.ShowPreviousScore = ShowPreviousScore;
	Parms.ShowRestartButton = ShowRestartButton;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_ShowProgressPanel
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                  PuzzleIcon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_ShowProgressPanel(class UTexture2D* PuzzleIcon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_ShowProgressPanel");

	Params::URacingRingsScoreWidget_BP_ShowProgressPanel_Params Parms{};

	Parms.PuzzleIcon = PuzzleIcon;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_SetMilestoneThresholds
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              Bronze                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Silver                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Gold                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_SetMilestoneThresholds(float Bronze, float Silver, float Gold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_SetMilestoneThresholds");

	Params::URacingRingsScoreWidget_BP_SetMilestoneThresholds_Params Parms{};

	Parms.Bronze = Bronze;
	Parms.Silver = Silver;
	Parms.Gold = Gold;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_SetCurrentProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              Percentage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_SetCurrentProgress(float Percentage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_SetCurrentProgress");

	Params::URacingRingsScoreWidget_BP_SetCurrentProgress_Params Parms{};

	Parms.Percentage = Percentage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_SetBestProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                              Percentage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_SetBestProgress(float Percentage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_SetBestProgress");

	Params::URacingRingsScoreWidget_BP_SetBestProgress_Params Parms{};

	Parms.Percentage = Percentage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_Hide
// (Event, Protected, BlueprintEvent)
// Parameters:

void URacingRingsScoreWidget::BP_Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_Hide");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_DisplayInstructions
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Instructions                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_DisplayInstructions(class FText& Instructions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_DisplayInstructions");

	Params::URacingRingsScoreWidget_BP_DisplayInstructions_Params Parms{};

	Parms.Instructions = Instructions;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RacingRingsScoreWidget.BP_AddScore
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Label                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URacingRingsScoreWidget::BP_AddScore(class FText& Label, class FText& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RacingRingsScoreWidget", "BP_AddScore");

	Params::URacingRingsScoreWidget_BP_AddScore_Params Parms{};

	Parms.Label = Label;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.RaymarchFractalMatch
// (Actor)

class UClass* ARaymarchFractalMatch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RaymarchFractalMatch");

	return Clss;
}


// RaymarchFractalMatch IslandsofInsight.Default__RaymarchFractalMatch
// (Public, ClassDefaultObject, ArchetypeObject)

class ARaymarchFractalMatch* ARaymarchFractalMatch::GetDefaultObj()
{
	static class ARaymarchFractalMatch* Default = nullptr;

	if (!Default)
		Default = static_cast<ARaymarchFractalMatch*>(ARaymarchFractalMatch::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RespawningPuzzlesVolume
// (Actor)

class UClass* ARespawningPuzzlesVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RespawningPuzzlesVolume");

	return Clss;
}


// RespawningPuzzlesVolume IslandsofInsight.Default__RespawningPuzzlesVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ARespawningPuzzlesVolume* ARespawningPuzzlesVolume::GetDefaultObj()
{
	static class ARespawningPuzzlesVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ARespawningPuzzlesVolume*>(ARespawningPuzzlesVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RichTextBlockInputKeyDecorator
// (None)

class UClass* URichTextBlockInputKeyDecorator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RichTextBlockInputKeyDecorator");

	return Clss;
}


// RichTextBlockInputKeyDecorator IslandsofInsight.Default__RichTextBlockInputKeyDecorator
// (Public, ClassDefaultObject, ArchetypeObject)

class URichTextBlockInputKeyDecorator* URichTextBlockInputKeyDecorator::GetDefaultObj()
{
	static class URichTextBlockInputKeyDecorator* Default = nullptr;

	if (!Default)
		Default = static_cast<URichTextBlockInputKeyDecorator*>(URichTextBlockInputKeyDecorator::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RingFind
// (Actor)

class UClass* ARingFind::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RingFind");

	return Clss;
}


// RingFind IslandsofInsight.Default__RingFind
// (Public, ClassDefaultObject, ArchetypeObject)

class ARingFind* ARingFind::GetDefaultObj()
{
	static class ARingFind* Default = nullptr;

	if (!Default)
		Default = static_cast<ARingFind*>(ARingFind::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RingFind.Solve
// (Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARingFind::Solve(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RingFind", "Solve");

	Params::ARingFind_Solve_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RingFind.SetEmissiveColour
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     Colour                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARingFind::SetEmissiveColour(const struct FVector& Colour)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RingFind", "SetEmissiveColour");

	Params::ARingFind_SetEmissiveColour_Params Parms{};

	Parms.Colour = Colour;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RingFind.InBox
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     HitLoc                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Axis                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARingFind::InBox(const struct FVector& HitLoc, const struct FVector& B1, const struct FVector& B2, int32 Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RingFind", "InBox");

	Params::ARingFind_InBox_Params Parms{};

	Parms.HitLoc = HitLoc;
	Parms.B1 = B1;
	Parms.B2 = B2;
	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RingFind.GetLineBoundsIntersectionPoint
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     B1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     L1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     L2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARingFind::GetLineBoundsIntersectionPoint(const struct FVector& B1, const struct FVector& B2, const struct FVector& L1, const struct FVector& L2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RingFind", "GetLineBoundsIntersectionPoint");

	Params::ARingFind_GetLineBoundsIntersectionPoint_Params Parms{};

	Parms.B1 = B1;
	Parms.B2 = B2;
	Parms.L1 = L1;
	Parms.L2 = L2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RingFind.GetIntersection
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                              FDst1                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FDst2                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     P1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     P2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLoc                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARingFind::GetIntersection(float FDst1, float FDst2, const struct FVector& P1, const struct FVector& P2, struct FVector* HitLoc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RingFind", "GetIntersection");

	Params::ARingFind_GetIntersection_Params Parms{};

	Parms.FDst1 = FDst1;
	Parms.FDst2 = FDst2;
	Parms.P1 = P1;
	Parms.P2 = P2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLoc != nullptr)
		*HitLoc = std::move(Parms.HitLoc);

	return Parms.ReturnValue;

}


// Class IslandsofInsight.RingFindGrouping
// (Actor)

class UClass* ARingFindGrouping::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RingFindGrouping");

	return Clss;
}


// RingFindGrouping IslandsofInsight.Default__RingFindGrouping
// (Public, ClassDefaultObject, ArchetypeObject)

class ARingFindGrouping* ARingFindGrouping::GetDefaultObj()
{
	static class ARingFindGrouping* Default = nullptr;

	if (!Default)
		Default = static_cast<ARingFindGrouping*>(ARingFindGrouping::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterBall
// (Actor)

class UClass* ARollercoasterBall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterBall");

	return Clss;
}


// RollercoasterBall IslandsofInsight.Default__RollercoasterBall
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterBall* ARollercoasterBall::GetDefaultObj()
{
	static class ARollercoasterBall* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterBall*>(ARollercoasterBall::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterButton
// (Actor)

class UClass* ARollercoasterButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterButton");

	return Clss;
}


// RollercoasterButton IslandsofInsight.Default__RollercoasterButton
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterButton* ARollercoasterButton::GetDefaultObj()
{
	static class ARollercoasterButton* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterButton*>(ARollercoasterButton::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RollercoasterButton.OnStopPress
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollercoasterButton::OnStopPress(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollercoasterButton", "OnStopPress");

	Params::ARollercoasterButton_OnStopPress_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollercoasterButton.OnStartPress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARollercoasterButton::OnStartPress(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollercoasterButton", "OnStartPress");

	Params::ARollercoasterButton_OnStartPress_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.RollercoasterManipulator
// (Actor)

class UClass* ARollercoasterManipulator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterManipulator");

	return Clss;
}


// RollercoasterManipulator IslandsofInsight.Default__RollercoasterManipulator
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterManipulator* ARollercoasterManipulator::GetDefaultObj()
{
	static class ARollercoasterManipulator* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterManipulator*>(ARollercoasterManipulator::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterGate
// (Actor)

class UClass* ARollercoasterGate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterGate");

	return Clss;
}


// RollercoasterGate IslandsofInsight.Default__RollercoasterGate
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterGate* ARollercoasterGate::GetDefaultObj()
{
	static class ARollercoasterGate* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterGate*>(ARollercoasterGate::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterGravityField
// (Actor)

class UClass* ARollercoasterGravityField::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterGravityField");

	return Clss;
}


// RollercoasterGravityField IslandsofInsight.Default__RollercoasterGravityField
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterGravityField* ARollercoasterGravityField::GetDefaultObj()
{
	static class ARollercoasterGravityField* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterGravityField*>(ARollercoasterGravityField::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterLauncher
// (Actor)

class UClass* ARollercoasterLauncher::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterLauncher");

	return Clss;
}


// RollercoasterLauncher IslandsofInsight.Default__RollercoasterLauncher
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterLauncher* ARollercoasterLauncher::GetDefaultObj()
{
	static class ARollercoasterLauncher* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterLauncher*>(ARollercoasterLauncher::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollercoasterPuzzle
// (Actor)

class UClass* ARollercoasterPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollercoasterPuzzle");

	return Clss;
}


// RollercoasterPuzzle IslandsofInsight.Default__RollercoasterPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollercoasterPuzzle* ARollercoasterPuzzle::GetDefaultObj()
{
	static class ARollercoasterPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollercoasterPuzzle*>(ARollercoasterPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RollercoasterPuzzle.OnResetButtonStopPress
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollercoasterPuzzle::OnResetButtonStopPress(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollercoasterPuzzle", "OnResetButtonStopPress");

	Params::ARollercoasterPuzzle_OnResetButtonStopPress_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollercoasterPuzzle.OnResetButtonStartPress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARollercoasterPuzzle::OnResetButtonStartPress(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollercoasterPuzzle", "OnResetButtonStartPress");

	Params::ARollercoasterPuzzle_OnResetButtonStartPress_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollercoasterPuzzle.OnFinish
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARollercoasterPuzzle::OnFinish(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollercoasterPuzzle", "OnFinish");

	Params::ARollercoasterPuzzle_OnFinish_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.RollingCube
// (Actor)

class UClass* ARollingCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollingCube");

	return Clss;
}


// RollingCube IslandsofInsight.Default__RollingCube
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollingCube* ARollingCube::GetDefaultObj()
{
	static class ARollingCube* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollingCube*>(ARollingCube::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RollingCube.SetMetaSolved
// (Final, Native, Public)
// Parameters:
// bool                               IsSolved                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollingCube::SetMetaSolved(bool IsSolved)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCube", "SetMetaSolved");

	Params::ARollingCube_SetMetaSolved_Params Parms{};

	Parms.IsSolved = IsSolved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollingCube.OnRep_GoalMesh
// (Final, Native, Private)
// Parameters:

void ARollingCube::OnRep_GoalMesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCube", "OnRep_GoalMesh");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollingCube.BP_InitCube
// (Event, Public, BlueprintEvent)
// Parameters:

void ARollingCube::BP_InitCube()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCube", "BP_InitCube");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RollingCube.BP_CubeLands
// (Event, Public, BlueprintEvent)
// Parameters:

void ARollingCube::BP_CubeLands()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCube", "BP_CubeLands");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RollingCubeGridBase
// (Actor)

class UClass* ARollingCubeGridBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollingCubeGridBase");

	return Clss;
}


// RollingCubeGridBase IslandsofInsight.Default__RollingCubeGridBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollingCubeGridBase* ARollingCubeGridBase::GetDefaultObj()
{
	static class ARollingCubeGridBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollingCubeGridBase*>(ARollingCubeGridBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RollingCubeGridBase.setCubeMaterial
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Mat                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CallInit                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollingCubeGridBase::SetCubeMaterial(class UMaterialInterface* Mat, bool CallInit, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "setCubeMaterial");

	Params::ARollingCubeGridBase_SetCubeMaterial_Params Parms{};

	Parms.Mat = Mat;
	Parms.CallInit = CallInit;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollingCubeGridBase.NetMultiCast_RollCube
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// enum class EDirections             Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CubeIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               AbleToRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaCharacter*            Sender                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Length                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollingCubeGridBase::NetMultiCast_RollCube(enum class EDirections Direction, int32 CubeIndex, bool AbleToRoll, class ASophiaCharacter* Sender, int32 X, int32 Y, int32 Length, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "NetMultiCast_RollCube");

	Params::ARollingCubeGridBase_NetMultiCast_RollCube_Params Parms{};

	Parms.Direction = Direction;
	Parms.CubeIndex = CubeIndex;
	Parms.AbleToRoll = AbleToRoll;
	Parms.Sender = Sender;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Length = Length;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollingCubeGridBase.NetMultiCast_ClaimCube
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CubeIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CLAIM                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SOLVED                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARollingCubeGridBase::NetMultiCast_ClaimCube(class ASophiaCharacter* Player, int32 CubeIndex, bool CLAIM, bool SOLVED)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "NetMultiCast_ClaimCube");

	Params::ARollingCubeGridBase_NetMultiCast_ClaimCube_Params Parms{};

	Parms.Player = Player;
	Parms.CubeIndex = CubeIndex;
	Parms.CLAIM = CLAIM;
	Parms.SOLVED = SOLVED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RollingCubeGridBase.BPI_ExitPuzzle
// (Event, Protected, BlueprintEvent)
// Parameters:

void ARollingCubeGridBase::BPI_ExitPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "BPI_ExitPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RollingCubeGridBase.BPI_EnterPuzzle
// (Event, Protected, BlueprintEvent)
// Parameters:

void ARollingCubeGridBase::BPI_EnterPuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "BPI_EnterPuzzle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RollingCubeGridBase.BP_UpdatePaintedTiles
// (Event, Public, BlueprintEvent)
// Parameters:

void ARollingCubeGridBase::BP_UpdatePaintedTiles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridBase", "BP_UpdatePaintedTiles");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RollingCubeGridMeta
// (Actor)

class UClass* ARollingCubeGridMeta::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollingCubeGridMeta");

	return Clss;
}


// RollingCubeGridMeta IslandsofInsight.Default__RollingCubeGridMeta
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollingCubeGridMeta* ARollingCubeGridMeta::GetDefaultObj()
{
	static class ARollingCubeGridMeta* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollingCubeGridMeta*>(ARollingCubeGridMeta::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RollingCubeGridMulti
// (Actor)

class UClass* ARollingCubeGridMulti::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollingCubeGridMulti");

	return Clss;
}


// RollingCubeGridMulti IslandsofInsight.Default__RollingCubeGridMulti
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollingCubeGridMulti* ARollingCubeGridMulti::GetDefaultObj()
{
	static class ARollingCubeGridMulti* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollingCubeGridMulti*>(ARollingCubeGridMulti::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RollingCubeGridMulti.GetSpec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRollingCubeMultiPuzzleSpec ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRollingCubeMultiPuzzleSpec ARollingCubeGridMulti::GetSpec()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RollingCubeGridMulti", "GetSpec");

	Params::ARollingCubeGridMulti_GetSpec_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.RollingCubeTile
// (Actor)

class UClass* ARollingCubeTile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RollingCubeTile");

	return Clss;
}


// RollingCubeTile IslandsofInsight.Default__RollingCubeTile
// (Public, ClassDefaultObject, ArchetypeObject)

class ARollingCubeTile* ARollingCubeTile::GetDefaultObj()
{
	static class ARollingCubeTile* Default = nullptr;

	if (!Default)
		Default = static_cast<ARollingCubeTile*>(ARollingCubeTile::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RosaryComboWidget
// (None)

class UClass* URosaryComboWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosaryComboWidget");

	return Clss;
}


// RosaryComboWidget IslandsofInsight.Default__RosaryComboWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URosaryComboWidget* URosaryComboWidget::GetDefaultObj()
{
	static class URosaryComboWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URosaryComboWidget*>(URosaryComboWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RosaryComboWidget.IsWidgetVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility URosaryComboWidget::IsWidgetVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosaryComboWidget", "IsWidgetVisible");

	Params::URosaryComboWidget_IsWidgetVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RosaryComboWidget.GetProgressBarPercentage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URosaryComboWidget::GetProgressBarPercentage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosaryComboWidget", "GetProgressBarPercentage");

	Params::URosaryComboWidget_GetProgressBarPercentage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RosaryComboWidget.GetBonusText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URosaryComboWidget::GetBonusText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosaryComboWidget", "GetBonusText");

	Params::URosaryComboWidget_GetBonusText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.RosaryPartyComboWidget
// (None)

class UClass* URosaryPartyComboWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosaryPartyComboWidget");

	return Clss;
}


// RosaryPartyComboWidget IslandsofInsight.Default__RosaryPartyComboWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URosaryPartyComboWidget* URosaryPartyComboWidget::GetDefaultObj()
{
	static class URosaryPartyComboWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URosaryPartyComboWidget*>(URosaryPartyComboWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RosaryPartyLeaderboardWidget
// (None)

class UClass* URosaryPartyLeaderboardWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosaryPartyLeaderboardWidget");

	return Clss;
}


// RosaryPartyLeaderboardWidget IslandsofInsight.Default__RosaryPartyLeaderboardWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URosaryPartyLeaderboardWidget* URosaryPartyLeaderboardWidget::GetDefaultObj()
{
	static class URosaryPartyLeaderboardWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URosaryPartyLeaderboardWidget*>(URosaryPartyLeaderboardWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RosarySpeedRound
// (Actor)

class UClass* ARosarySpeedRound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosarySpeedRound");

	return Clss;
}


// RosarySpeedRound IslandsofInsight.Default__RosarySpeedRound
// (Public, ClassDefaultObject, ArchetypeObject)

class ARosarySpeedRound* ARosarySpeedRound::GetDefaultObj()
{
	static class ARosarySpeedRound* Default = nullptr;

	if (!Default)
		Default = static_cast<ARosarySpeedRound*>(ARosarySpeedRound::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RosarySpeedRound.OnStartPlatformOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARosarySpeedRound::OnStartPlatformOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRound", "OnStartPlatformOverlap");

	Params::ARosarySpeedRound_OnStartPlatformOverlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RosarySpeedRound.OnStartPlatformExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARosarySpeedRound::OnStartPlatformExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRound", "OnStartPlatformExit");

	Params::ARosarySpeedRound_OnStartPlatformExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RosarySpeedRound.BP_EndRound
// (Event, Public, BlueprintEvent)
// Parameters:

void ARosarySpeedRound::BP_EndRound()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRound", "BP_EndRound");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RosarySpeedRoundWidget
// (None)

class UClass* URosarySpeedRoundWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosarySpeedRoundWidget");

	return Clss;
}


// RosarySpeedRoundWidget IslandsofInsight.Default__RosarySpeedRoundWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class URosarySpeedRoundWidget* URosarySpeedRoundWidget::GetDefaultObj()
{
	static class URosarySpeedRoundWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<URosarySpeedRoundWidget*>(URosarySpeedRoundWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_ShowResultsPopup
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        TITLE                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_ShowResultsPopup(class FText& TITLE)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_ShowResultsPopup");

	Params::URosarySpeedRoundWidget_BP_ShowResultsPopup_Params Parms{};

	Parms.TITLE = TITLE;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_Show
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                  PuzzleIcon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_Show(class UTexture2D* PuzzleIcon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_Show");

	Params::URosarySpeedRoundWidget_BP_Show_Params Parms{};

	Parms.PuzzleIcon = PuzzleIcon;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_SetTeamColor
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FLinearColor                ControllerTeamColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                PlayerTeamColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_SetTeamColor(const struct FLinearColor& ControllerTeamColor, const struct FLinearColor& PlayerTeamColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_SetTeamColor");

	Params::URosarySpeedRoundWidget_BP_SetTeamColor_Params Parms{};

	Parms.ControllerTeamColor = ControllerTeamColor;
	Parms.PlayerTeamColor = PlayerTeamColor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_RemoveResultsPopup
// (Event, Protected, BlueprintEvent)
// Parameters:

void URosarySpeedRoundWidget::BP_RemoveResultsPopup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_RemoveResultsPopup");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_Hide
// (Event, Protected, BlueprintEvent)
// Parameters:

void URosarySpeedRoundWidget::BP_Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_Hide");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_DisplayInstructions
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Instructions                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_DisplayInstructions(class FText& Instructions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_DisplayInstructions");

	Params::URosarySpeedRoundWidget_BP_DisplayInstructions_Params Parms{};

	Parms.Instructions = Instructions;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_AddScore
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        Label                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Delta                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              DeltaSign                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_AddScore(class FText& Label, class FText& Value, class FText& Delta, float DeltaSign)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_AddScore");

	Params::URosarySpeedRoundWidget_BP_AddScore_Params Parms{};

	Parms.Label = Label;
	Parms.Value = Value;
	Parms.Delta = Delta;
	Parms.DeltaSign = DeltaSign;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RosarySpeedRoundWidget.BP_AddMilestone
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMilestoneResultData        Data                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URosarySpeedRoundWidget::BP_AddMilestone(struct FMilestoneResultData& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RosarySpeedRoundWidget", "BP_AddMilestone");

	Params::URosarySpeedRoundWidget_BP_AddMilestone_Params Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.RosarySpeedrunSpawnVolume
// (Actor)

class UClass* ARosarySpeedrunSpawnVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RosarySpeedrunSpawnVolume");

	return Clss;
}


// RosarySpeedrunSpawnVolume IslandsofInsight.Default__RosarySpeedrunSpawnVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ARosarySpeedrunSpawnVolume* ARosarySpeedrunSpawnVolume::GetDefaultObj()
{
	static class ARosarySpeedrunSpawnVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ARosarySpeedrunSpawnVolume*>(ARosarySpeedrunSpawnVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.RtmConnection
// (None)

class UClass* URtmConnection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RtmConnection");

	return Clss;
}


// RtmConnection IslandsofInsight.Default__RtmConnection
// (Public, ClassDefaultObject, ArchetypeObject)

class URtmConnection* URtmConnection::GetDefaultObj()
{
	static class URtmConnection* Default = nullptr;

	if (!Default)
		Default = static_cast<URtmConnection*>(URtmConnection::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RtmConnection.HandleNewConnection
// (Final, Native, Private)
// Parameters:

void URtmConnection::HandleNewConnection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RtmConnection", "HandleNewConnection");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RtmConnection.HandleMessage
// (Final, Native, Private)
// Parameters:
// class FString                      Message                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URtmConnection::HandleMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RtmConnection", "HandleMessage");

	Params::URtmConnection_HandleMessage_Params Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RtmConnection.HandleConnectionError
// (Final, Native, Private)
// Parameters:
// class FString                      Error                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URtmConnection::HandleConnectionError(const class FString& Error)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RtmConnection", "HandleConnectionError");

	Params::URtmConnection_HandleConnectionError_Params Parms{};

	Parms.Error = Error;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RtmConnection.HandleClose
// (Final, Native, Private)
// Parameters:
// int32                              StatusCode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Reason                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWasClean                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URtmConnection::HandleClose(int32 StatusCode, const class FString& Reason, bool bWasClean)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RtmConnection", "HandleClose");

	Params::URtmConnection_HandleClose_Params Parms{};

	Parms.StatusCode = StatusCode;
	Parms.Reason = Reason;
	Parms.bWasClean = bWasClean;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.RuleBox
// (None)

class UClass* URuleBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RuleBox");

	return Clss;
}


// RuleBox IslandsofInsight.Default__RuleBox
// (Public, ClassDefaultObject, ArchetypeObject)

class URuleBox* URuleBox::GetDefaultObj()
{
	static class URuleBox* Default = nullptr;

	if (!Default)
		Default = static_cast<URuleBox*>(URuleBox::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RuleBox.BP_UpdateStatus
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               ShowBar                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuleBox::BP_UpdateStatus(bool ShowBar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RuleBox", "BP_UpdateStatus");

	Params::URuleBox_BP_UpdateStatus_Params Parms{};

	Parms.ShowBar = ShowBar;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RuleBox.BP_PlayOpeningAnims
// (Event, Protected, BlueprintEvent)
// Parameters:

void URuleBox::BP_PlayOpeningAnims()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RuleBox", "BP_PlayOpeningAnims");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RuleBoxContainer
// (None)

class UClass* URuleBoxContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RuleBoxContainer");

	return Clss;
}


// RuleBoxContainer IslandsofInsight.Default__RuleBoxContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class URuleBoxContainer* URuleBoxContainer::GetDefaultObj()
{
	static class URuleBoxContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<URuleBoxContainer*>(URuleBoxContainer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RuleBoxContainer.GetRuleContainerText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URuleBoxContainer::GetRuleContainerText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RuleBoxContainer", "GetRuleContainerText");

	Params::URuleBoxContainer_GetRuleContainerText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RuleBoxContainer.GetContainerVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility URuleBoxContainer::GetContainerVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RuleBoxContainer", "GetContainerVisibility");

	Params::URuleBoxContainer_GetContainerVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.RunePrereqWire
// (Actor)

class UClass* ARunePrereqWire::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RunePrereqWire");

	return Clss;
}


// RunePrereqWire IslandsofInsight.Default__RunePrereqWire
// (Public, ClassDefaultObject, ArchetypeObject)

class ARunePrereqWire* ARunePrereqWire::GetDefaultObj()
{
	static class ARunePrereqWire* Default = nullptr;

	if (!Default)
		Default = static_cast<ARunePrereqWire*>(ARunePrereqWire::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RunePrereqWire.BP_ActivateWire
// (Event, Public, BlueprintEvent)
// Parameters:

void ARunePrereqWire::BP_ActivateWire()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RunePrereqWire", "BP_ActivateWire");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RyoanjiObstacle
// (Actor)

class UClass* ARyoanjiObstacle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RyoanjiObstacle");

	return Clss;
}


// RyoanjiObstacle IslandsofInsight.Default__RyoanjiObstacle
// (Public, ClassDefaultObject, ArchetypeObject)

class ARyoanjiObstacle* ARyoanjiObstacle::GetDefaultObj()
{
	static class ARyoanjiObstacle* Default = nullptr;

	if (!Default)
		Default = static_cast<ARyoanjiObstacle*>(ARyoanjiObstacle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RyoanjiObstacle.BP_UpdateOnSolve
// (Event, Public, BlueprintEvent)
// Parameters:

void ARyoanjiObstacle::BP_UpdateOnSolve()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiObstacle", "BP_UpdateOnSolve");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.RyoanjiPuzzle
// (Actor)

class UClass* ARyoanjiPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RyoanjiPuzzle");

	return Clss;
}


// RyoanjiPuzzle IslandsofInsight.Default__RyoanjiPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ARyoanjiPuzzle* ARyoanjiPuzzle::GetDefaultObj()
{
	static class ARyoanjiPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ARyoanjiPuzzle*>(ARyoanjiPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.RyoanjiPuzzle.StopPlaying
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*         OverlappedComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Other                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARyoanjiPuzzle::StopPlaying(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "StopPlaying");

	Params::ARyoanjiPuzzle_StopPlaying_Params Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RyoanjiPuzzle.StartPlaying
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Other                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARyoanjiPuzzle::StartPlaying(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "StartPlaying");

	Params::ARyoanjiPuzzle_StartPlaying_Params Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.RyoanjiPuzzle.GetZOffsetAtCoordinate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARyoanjiPuzzle::GetZOffsetAtCoordinate(float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "GetZOffsetAtCoordinate");

	Params::ARyoanjiPuzzle_GetZOffsetAtCoordinate_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RyoanjiPuzzle.GetLaserAbsoluteZAtCoordinate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              X                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARyoanjiPuzzle::GetLaserAbsoluteZAtCoordinate(float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "GetLaserAbsoluteZAtCoordinate");

	Params::ARyoanjiPuzzle_GetLaserAbsoluteZAtCoordinate_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.RyoanjiPuzzle.BPI_SetObstacleState
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                              IsmIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EObstacleState          NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARyoanjiPuzzle::BPI_SetObstacleState(int32 IsmIndex, enum class EObstacleState NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "BPI_SetObstacleState");

	Params::ARyoanjiPuzzle_BPI_SetObstacleState_Params Parms{};

	Parms.IsmIndex = IsmIndex;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.RyoanjiPuzzle.BPI_SetObstacleHidden
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                              IsmIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Hidden                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARyoanjiPuzzle::BPI_SetObstacleHidden(int32 IsmIndex, bool Hidden)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RyoanjiPuzzle", "BPI_SetObstacleHidden");

	Params::ARyoanjiPuzzle_BPI_SetObstacleHidden_Params Parms{};

	Parms.IsmIndex = IsmIndex;
	Parms.Hidden = Hidden;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.SandboxGameMode
// (Actor)

class UClass* ASandboxGameMode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SandboxGameMode");

	return Clss;
}


// SandboxGameMode IslandsofInsight.Default__SandboxGameMode
// (Public, ClassDefaultObject, ArchetypeObject)

class ASandboxGameMode* ASandboxGameMode::GetDefaultObj()
{
	static class ASandboxGameMode* Default = nullptr;

	if (!Default)
		Default = static_cast<ASandboxGameMode*>(ASandboxGameMode::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SandboxGameMode.LaunchEvent
// (Final, Native, Protected)
// Parameters:

void ASandboxGameMode::LaunchEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SandboxGameMode", "LaunchEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SandboxGameState
// (Actor)

class UClass* ASandboxGameState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SandboxGameState");

	return Clss;
}


// SandboxGameState IslandsofInsight.Default__SandboxGameState
// (Public, ClassDefaultObject, ArchetypeObject)

class ASandboxGameState* ASandboxGameState::GetDefaultObj()
{
	static class ASandboxGameState* Default = nullptr;

	if (!Default)
		Default = static_cast<ASandboxGameState*>(ASandboxGameState::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SandboxGameState.ServerExclusive_UpdateEventPrompt
// (Native, Public)
// Parameters:
// int32                              State                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASandboxGameState::ServerExclusive_UpdateEventPrompt(int32 State)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SandboxGameState", "ServerExclusive_UpdateEventPrompt");

	Params::ASandboxGameState_ServerExclusive_UpdateEventPrompt_Params Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SandboxProgressionData
// (None)

class UClass* USandboxProgressionData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SandboxProgressionData");

	return Clss;
}


// SandboxProgressionData IslandsofInsight.Default__SandboxProgressionData
// (Public, ClassDefaultObject, ArchetypeObject)

class USandboxProgressionData* USandboxProgressionData::GetDefaultObj()
{
	static class USandboxProgressionData* Default = nullptr;

	if (!Default)
		Default = static_cast<USandboxProgressionData*>(USandboxProgressionData::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SandboxProgressionData.GetPuzzleCategoryData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSandboxProgressionPuzzleCategoryDataReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSandboxProgressionPuzzleCategoryData USandboxProgressionData::GetPuzzleCategoryData(enum class EMainMapZoneName ZONE, enum class EPuzzleCategory PuzzleCategory)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SandboxProgressionData", "GetPuzzleCategoryData");

	Params::USandboxProgressionData_GetPuzzleCategoryData_Params Parms{};

	Parms.ZONE = ZONE;
	Parms.PuzzleCategory = PuzzleCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SandboxProgressionNotification
// (None)

class UClass* USandboxProgressionNotification::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SandboxProgressionNotification");

	return Clss;
}


// SandboxProgressionNotification IslandsofInsight.Default__SandboxProgressionNotification
// (Public, ClassDefaultObject, ArchetypeObject)

class USandboxProgressionNotification* USandboxProgressionNotification::GetDefaultObj()
{
	static class USandboxProgressionNotification* Default = nullptr;

	if (!Default)
		Default = static_cast<USandboxProgressionNotification*>(USandboxProgressionNotification::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SandboxZone
// (SceneComponent)

class UClass* USandboxZone::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SandboxZone");

	return Clss;
}


// SandboxZone IslandsofInsight.Default__SandboxZone
// (Public, ClassDefaultObject, ArchetypeObject)

class USandboxZone* USandboxZone::GetDefaultObj()
{
	static class USandboxZone* Default = nullptr;

	if (!Default)
		Default = static_cast<USandboxZone*>(USandboxZone::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ScreenMarkerContainer
// (None)

class UClass* UScreenMarkerContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ScreenMarkerContainer");

	return Clss;
}


// ScreenMarkerContainer IslandsofInsight.Default__ScreenMarkerContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UScreenMarkerContainer* UScreenMarkerContainer::GetDefaultObj()
{
	static class UScreenMarkerContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UScreenMarkerContainer*>(UScreenMarkerContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ScreenshotTaker
// (None)

class UClass* UScreenshotTaker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ScreenshotTaker");

	return Clss;
}


// ScreenshotTaker IslandsofInsight.Default__ScreenshotTaker
// (Public, ClassDefaultObject, ArchetypeObject)

class UScreenshotTaker* UScreenshotTaker::GetDefaultObj()
{
	static class UScreenshotTaker* Default = nullptr;

	if (!Default)
		Default = static_cast<UScreenshotTaker*>(UScreenshotTaker::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ScreenshotTaker.RequestScreenshot
// (Native, Public, BlueprintCallable)
// Parameters:

void UScreenshotTaker::RequestScreenshot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScreenshotTaker", "RequestScreenshot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SecretSignifier
// (Actor)

class UClass* ASecretSignifier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SecretSignifier");

	return Clss;
}


// SecretSignifier IslandsofInsight.Default__SecretSignifier
// (Public, ClassDefaultObject, ArchetypeObject)

class ASecretSignifier* ASecretSignifier::GetDefaultObj()
{
	static class ASecretSignifier* Default = nullptr;

	if (!Default)
		Default = static_cast<ASecretSignifier*>(ASecretSignifier::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SecretSignifier.IsSecretUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASecretSignifier::IsSecretUnlocked(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "IsSecretUnlocked");

	Params::ASecretSignifier_IsSecretUnlocked_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SecretSignifier.IsClueUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASophiaCharacter*            Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASecretSignifier::IsClueUnlocked(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "IsClueUnlocked");

	Params::ASecretSignifier_IsClueUnlocked_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SecretSignifier.BP_SetSecretActivated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ASecretSignifier::BP_SetSecretActivated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "BP_SetSecretActivated");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SecretSignifier.BP_SetClueActivated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ASecretSignifier::BP_SetClueActivated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "BP_SetClueActivated");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SecretSignifier.ActivateSecret
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ASecretSignifier::ActivateSecret()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "ActivateSecret");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SecretSignifier.ActivateClue
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ASecretSignifier::ActivateClue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SecretSignifier", "ActivateClue");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.Seek5
// (Actor)

class UClass* ASeek5::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Seek5");

	return Clss;
}


// Seek5 IslandsofInsight.Default__Seek5
// (Public, ClassDefaultObject, ArchetypeObject)

class ASeek5* ASeek5::GetDefaultObj()
{
	static class ASeek5* Default = nullptr;

	if (!Default)
		Default = static_cast<ASeek5*>(ASeek5::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Seek5.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESeek5State             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESeek5State ASeek5::GetState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "GetState");

	Params::ASeek5_GetState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Seek5.GetNumberCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASeek5::GetNumberCompleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "GetNumberCompleted");

	Params::ASeek5_GetNumberCompleted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Seek5.GetHiddenObjectForUpgrade
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USeek5HiddenObject*          ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USeek5HiddenObject* ASeek5::GetHiddenObjectForUpgrade()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "GetHiddenObjectForUpgrade");

	Params::ASeek5_GetHiddenObjectForUpgrade_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Seek5.BP_ProcessStateConsequences_C
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASeek5::BP_ProcessStateConsequences_C()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "BP_ProcessStateConsequences_C");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Seek5.BP_OnHiddenObjectFoundStateChanged_C
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USeek5HiddenObject*          Object                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeek5::BP_OnHiddenObjectFoundStateChanged_C(class USeek5HiddenObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "BP_OnHiddenObjectFoundStateChanged_C");

	Params::ASeek5_BP_OnHiddenObjectFoundStateChanged_C_Params Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Seek5.BP_OnComponentHovered_C
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         Object                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Hover                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeek5::BP_OnComponentHovered_C(class UPrimitiveComponent* Object, bool Hover)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5", "BP_OnComponentHovered_C");

	Params::ASeek5_BP_OnComponentHovered_C_Params Parms{};

	Parms.Object = Object;
	Parms.Hover = Hover;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.Seek5HiddenObject
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* USeek5HiddenObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Seek5HiddenObject");

	return Clss;
}


// Seek5HiddenObject IslandsofInsight.Default__Seek5HiddenObject
// (Public, ClassDefaultObject, ArchetypeObject)

class USeek5HiddenObject* USeek5HiddenObject::GetDefaultObj()
{
	static class USeek5HiddenObject* Default = nullptr;

	if (!Default)
		Default = static_cast<USeek5HiddenObject*>(USeek5HiddenObject::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Seek5Widget
// (None)

class UClass* USeek5Widget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Seek5Widget");

	return Clss;
}


// Seek5Widget IslandsofInsight.Default__Seek5Widget
// (Public, ClassDefaultObject, ArchetypeObject)

class USeek5Widget* USeek5Widget::GetDefaultObj()
{
	static class USeek5Widget* Default = nullptr;

	if (!Default)
		Default = static_cast<USeek5Widget*>(USeek5Widget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Seek5Widget.BP_ProcessSeek5
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASeek5*                      Seek5                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeek5Widget::BP_ProcessSeek5(class ASeek5* Seek5)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5Widget", "BP_ProcessSeek5");

	Params::USeek5Widget_BP_ProcessSeek5_Params Parms{};

	Parms.Seek5 = Seek5;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.Seek5Widget.BP_CloseSeek5
// (Event, Protected, BlueprintEvent)
// Parameters:

void USeek5Widget::BP_CloseSeek5()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5Widget", "BP_CloseSeek5");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.Seek5Widget.BP_ActivateSeek5
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASeek5*                      Seek5                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeek5Widget::BP_ActivateSeek5(class ASeek5* Seek5)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Seek5Widget", "BP_ActivateSeek5");

	Params::USeek5Widget_BP_ActivateSeek5_Params Parms{};

	Parms.Seek5 = Seek5;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.SerializedPuzzle
// (None)

class UClass* USerializedPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SerializedPuzzle");

	return Clss;
}


// SerializedPuzzle IslandsofInsight.Default__SerializedPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class USerializedPuzzle* USerializedPuzzle::GetDefaultObj()
{
	static class USerializedPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<USerializedPuzzle*>(USerializedPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.AutoDeletingGenericPuzzleInfo
// (None)

class UClass* UAutoDeletingGenericPuzzleInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AutoDeletingGenericPuzzleInfo");

	return Clss;
}


// AutoDeletingGenericPuzzleInfo IslandsofInsight.Default__AutoDeletingGenericPuzzleInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class UAutoDeletingGenericPuzzleInfo* UAutoDeletingGenericPuzzleInfo::GetDefaultObj()
{
	static class UAutoDeletingGenericPuzzleInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<UAutoDeletingGenericPuzzleInfo*>(UAutoDeletingGenericPuzzleInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SerializedPuzzleSpawningComponentWithAutoDeletion
// (SceneComponent)

class UClass* USerializedPuzzleSpawningComponentWithAutoDeletion::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SerializedPuzzleSpawningComponentWithAutoDeletion");

	return Clss;
}


// SerializedPuzzleSpawningComponentWithAutoDeletion IslandsofInsight.Default__SerializedPuzzleSpawningComponentWithAutoDeletion
// (Public, ClassDefaultObject, ArchetypeObject)

class USerializedPuzzleSpawningComponentWithAutoDeletion* USerializedPuzzleSpawningComponentWithAutoDeletion::GetDefaultObj()
{
	static class USerializedPuzzleSpawningComponentWithAutoDeletion* Default = nullptr;

	if (!Default)
		Default = static_cast<USerializedPuzzleSpawningComponentWithAutoDeletion*>(USerializedPuzzleSpawningComponentWithAutoDeletion::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ServerToKrakenAuthHandler
// (None)

class UClass* UServerToKrakenAuthHandler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ServerToKrakenAuthHandler");

	return Clss;
}


// ServerToKrakenAuthHandler IslandsofInsight.Default__ServerToKrakenAuthHandler
// (Public, ClassDefaultObject, ArchetypeObject)

class UServerToKrakenAuthHandler* UServerToKrakenAuthHandler::GetDefaultObj()
{
	static class UServerToKrakenAuthHandler* Default = nullptr;

	if (!Default)
		Default = static_cast<UServerToKrakenAuthHandler*>(UServerToKrakenAuthHandler::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SettingsMenu
// (None)

class UClass* USettingsMenu::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SettingsMenu");

	return Clss;
}


// SettingsMenu IslandsofInsight.Default__SettingsMenu
// (Public, ClassDefaultObject, ArchetypeObject)

class USettingsMenu* USettingsMenu::GetDefaultObj()
{
	static class USettingsMenu* Default = nullptr;

	if (!Default)
		Default = static_cast<USettingsMenu*>(USettingsMenu::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SettingsMenu.SwapToMasteries
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               Toggled                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenu::SwapToMasteries(bool Toggled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "SwapToMasteries");

	Params::USettingsMenu_SwapToMasteries_Params Parms{};

	Parms.Toggled = Toggled;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SettingsMenu.SwapToGameMenu
// (Event, Public, BlueprintEvent)
// Parameters:

void USettingsMenu::SwapToGameMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "SwapToGameMenu");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SettingsMenu.SwapToBugReport
// (Event, Public, BlueprintEvent)
// Parameters:

void USettingsMenu::SwapToBugReport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "SwapToBugReport");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SettingsMenu.SwapToAdmin
// (Event, Public, BlueprintEvent)
// Parameters:

void USettingsMenu::SwapToAdmin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "SwapToAdmin");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SettingsMenu.Close
// (Event, Public, BlueprintEvent)
// Parameters:

void USettingsMenu::Close()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "Close");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SettingsMenu.BP_OnAdminUnlocked
// (Event, Protected, BlueprintEvent)
// Parameters:

void USettingsMenu::BP_OnAdminUnlocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "BP_OnAdminUnlocked");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SettingsMenu.BP_BugReportMenu
// (Event, Protected, BlueprintEvent)
// Parameters:

void USettingsMenu::BP_BugReportMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SettingsMenu", "BP_BugReportMenu");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SideNotificationContainer
// (None)

class UClass* USideNotificationContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SideNotificationContainer");

	return Clss;
}


// SideNotificationContainer IslandsofInsight.Default__SideNotificationContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class USideNotificationContainer* USideNotificationContainer::GetDefaultObj()
{
	static class USideNotificationContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<USideNotificationContainer*>(USideNotificationContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.Skill
// (None)

class UClass* USkill::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Skill");

	return Clss;
}


// Skill IslandsofInsight.Default__Skill
// (Public, ClassDefaultObject, ArchetypeObject)

class USkill* USkill::GetDefaultObj()
{
	static class USkill* Default = nullptr;

	if (!Default)
		Default = static_cast<USkill*>(USkill::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Skill.MeetsLevelRequirements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkill::MeetsLevelRequirements()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "MeetsLevelRequirements");

	Params::USkill_MeetsLevelRequirements_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.IsCheatToggled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkill::IsCheatToggled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "IsCheatToggled");

	Params::USkill_IsCheatToggled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetUpgradeTierInformation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FUpgradeTierInformation>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FUpgradeTierInformation> USkill::GetUpgradeTierInformation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetUpgradeTierInformation");

	Params::USkill_GetUpgradeTierInformation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetSpentPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkill::GetSpentPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetSpentPoints");

	Params::USkill_GetSpentPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetSkillIdentifierName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USkill::GetSkillIdentifierName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetSkillIdentifierName");

	Params::USkill_GetSkillIdentifierName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetSkillDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USkill::GetSkillDisplayName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetSkillDisplayName");

	Params::USkill_GetSkillDisplayName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetSkillDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USkill::GetSkillDescription()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetSkillDescription");

	Params::USkill_GetSkillDescription_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetSkillCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkill::GetSkillCost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetSkillCost");

	Params::USkill_GetSkillCost_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetRequiredLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkill::GetRequiredLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetRequiredLevel");

	Params::USkill_GetRequiredLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetMaxPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkill::GetMaxPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetMaxPoints");

	Params::USkill_GetMaxPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.GetImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateBrush                 ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush USkill::GetImage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "GetImage");

	Params::USkill_GetImage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.Skill.CanUpgrade
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkill::CanUpgrade()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Skill", "CanUpgrade");

	Params::USkill_CanUpgrade_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SkillTreeData
// (None)

class UClass* USkillTreeData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkillTreeData");

	return Clss;
}


// SkillTreeData IslandsofInsight.Default__SkillTreeData
// (Public, ClassDefaultObject, ArchetypeObject)

class USkillTreeData* USkillTreeData::GetDefaultObj()
{
	static class USkillTreeData* Default = nullptr;

	if (!Default)
		Default = static_cast<USkillTreeData*>(USkillTreeData::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SkillTreeData.SortSkills
// (Final, Native, Protected)
// Parameters:

void USkillTreeData::SortSkills()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "SortSkills");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SkillTreeData.GetVisibleSkills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class USkill*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class USkill*> USkillTreeData::GetVisibleSkills()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "GetVisibleSkills");

	Params::USkillTreeData_GetVisibleSkills_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SkillTreeData.GetTotalSpentSkillPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkillTreeData::GetTotalSpentSkillPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "GetTotalSpentSkillPoints");

	Params::USkillTreeData_GetTotalSpentSkillPoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SkillTreeData.GetSkills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class USkill*>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class USkill*> USkillTreeData::GetSkills()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "GetSkills");

	Params::USkillTreeData_GetSkills_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SkillTreeData.GetSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkill*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkill* USkillTreeData::GetSkill(const class FString& SkillName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "GetSkill");

	Params::USkillTreeData_GetSkill_Params Parms{};

	Parms.SkillName = SkillName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SkillTreeData.GetNextSkillPointGoldCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkillTreeData::GetNextSkillPointGoldCost(const class FString& SkillName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkillTreeData", "GetNextSkillPointGoldCost");

	Params::USkillTreeData_GetNextSkillPointGoldCost_Params Parms{};

	Parms.SkillName = SkillName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SlideInSideNotificationContainer
// (None)

class UClass* USlideInSideNotificationContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SlideInSideNotificationContainer");

	return Clss;
}


// SlideInSideNotificationContainer IslandsofInsight.Default__SlideInSideNotificationContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class USlideInSideNotificationContainer* USlideInSideNotificationContainer::GetDefaultObj()
{
	static class USlideInSideNotificationContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<USlideInSideNotificationContainer*>(USlideInSideNotificationContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ASlider2D
// (None)

class UClass* UASlider2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ASlider2D");

	return Clss;
}


// ASlider2D IslandsofInsight.Default__ASlider2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UASlider2D* UASlider2D::GetDefaultObj()
{
	static class UASlider2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UASlider2D*>(UASlider2D::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SocialMenuPreliminaryWidget
// (None)

class UClass* USocialMenuPreliminaryWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SocialMenuPreliminaryWidget");

	return Clss;
}


// SocialMenuPreliminaryWidget IslandsofInsight.Default__SocialMenuPreliminaryWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class USocialMenuPreliminaryWidget* USocialMenuPreliminaryWidget::GetDefaultObj()
{
	static class USocialMenuPreliminaryWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<USocialMenuPreliminaryWidget*>(USocialMenuPreliminaryWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SocialSystemComponent
// (None)

class UClass* USocialSystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SocialSystemComponent");

	return Clss;
}


// SocialSystemComponent IslandsofInsight.Default__SocialSystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USocialSystemComponent* USocialSystemComponent::GetDefaultObj()
{
	static class USocialSystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USocialSystemComponent*>(USocialSystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SocialSystemComponent.TrySendPingMessage_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerPingMessage          PingMessage                                                      (Parm, NativeAccessSpecifierPublic)
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult USocialSystemComponent::TrySendPingMessage_C(class ASophiaPlayerState* Target, const struct FPlayerPingMessage& PingMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TrySendPingMessage_C");

	Params::USocialSystemComponent_TrySendPingMessage_C_Params Parms{};

	Parms.Target = Target;
	Parms.PingMessage = PingMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TrySendPartyInviteByKrakenId_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      TargetKrakenUserId                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult USocialSystemComponent::TrySendPartyInviteByKrakenId_C(const class FString& TargetKrakenUserId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TrySendPartyInviteByKrakenId_C");

	Params::USocialSystemComponent_TrySendPartyInviteByKrakenId_C_Params Parms{};

	Parms.TargetKrakenUserId = TargetKrakenUserId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TrySendPartyInvite_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult USocialSystemComponent::TrySendPartyInvite_C(class ASophiaPlayerState* Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TrySendPartyInvite_C");

	Params::USocialSystemComponent_TrySendPartyInvite_C_Params Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TrySendGridInvite_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Invitee                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPingMessageAttemptResultReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPingMessageAttemptResult USocialSystemComponent::TrySendGridInvite_C(class ASophiaPlayerState* Invitee)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TrySendGridInvite_C");

	Params::USocialSystemComponent_TrySendGridInvite_C_Params Parms{};

	Parms.Invitee = Invitee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TrySendCreateLocationPing
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                     Loc                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ELocationPingType       PingType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             HitComponent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APuzzleBase*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALocationPing*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALocationPing* USocialSystemComponent::TrySendCreateLocationPing(const struct FVector& Loc, enum class ELocationPingType PingType, class USceneComponent* HitComponent, class APuzzleBase* Puzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TrySendCreateLocationPing");

	Params::USocialSystemComponent_TrySendCreateLocationPing_Params Parms{};

	Parms.Loc = Loc;
	Parms.PingType = PingType;
	Parms.HitComponent = HitComponent;
	Parms.Puzzle = Puzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TryRemoveLocationPing_C
// (Final, Native, Public)
// Parameters:
// class ALocationPing*               MapMarker                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialSystemComponent::TryRemoveLocationPing_C(class ALocationPing* MapMarker)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TryRemoveLocationPing_C");

	Params::USocialSystemComponent_TryRemoveLocationPing_C_Params Parms{};

	Parms.MapMarker = MapMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.TryEstablishHelperBond
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USocialSystemComponent::TryEstablishHelperBond()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "TryEstablishHelperBond");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_UpdateLocationPings
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<struct FLocationPingInfo>   UndirectedLocationPings                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_UpdateLocationPings(TArray<struct FLocationPingInfo>& UndirectedLocationPings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_UpdateLocationPings");

	Params::USocialSystemComponent_Server_UpdateLocationPings_Params Parms{};

	Parms.UndirectedLocationPings = UndirectedLocationPings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_TryEstablishHelperBond
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FLocationPingInfo           PingInfo                                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_TryEstablishHelperBond(const struct FLocationPingInfo& PingInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_TryEstablishHelperBond");

	Params::USocialSystemComponent_Server_TryEstablishHelperBond_Params Parms{};

	Parms.PingInfo = PingInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_SetBlockedPlayers
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<struct FPersistentPlayerReference>BlockedPlayersList                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_SetBlockedPlayers(TArray<struct FPersistentPlayerReference>& BlockedPlayersList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_SetBlockedPlayers");

	Params::USocialSystemComponent_Server_SetBlockedPlayers_Params Parms{};

	Parms.BlockedPlayersList = BlockedPlayersList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_SendPingMessage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaPlayerState*          InTarget                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        InText                                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_SendPingMessage(class ASophiaPlayerState* InTarget, class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_SendPingMessage");

	Params::USocialSystemComponent_Server_SendPingMessage_Params Parms{};

	Parms.InTarget = InTarget;
	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_SendGridInvite
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaPlayerState*          Invitee                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_SendGridInvite(class ASophiaPlayerState* Invitee)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_SendGridInvite");

	Params::USocialSystemComponent_Server_SendGridInvite_Params Parms{};

	Parms.Invitee = Invitee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_SendFriendRequest
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASophiaPlayerState*          Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_SendFriendRequest(class ASophiaPlayerState* Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_SendFriendRequest");

	Params::USocialSystemComponent_Server_SendFriendRequest_Params Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_RemoveFriendRequest
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void USocialSystemComponent::Server_RemoveFriendRequest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_RemoveFriendRequest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Server_BlockUnblock
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FPersistentPlayerReference  SocialPlayerRef                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLock                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::Server_BlockUnblock(const struct FPersistentPlayerReference& SocialPlayerRef, bool bLock)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Server_BlockUnblock");

	Params::USocialSystemComponent_Server_BlockUnblock_Params Parms{};

	Parms.SocialPlayerRef = SocialPlayerRef;
	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.NetMulti_UpdateLocationPings
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// TArray<struct FLocationPingInfo>   Pings                                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USocialSystemComponent::NetMulti_UpdateLocationPings(TArray<struct FLocationPingInfo>& Pings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "NetMulti_UpdateLocationPings");

	Params::USocialSystemComponent_NetMulti_UpdateLocationPings_Params Parms{};

	Parms.Pings = Pings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.IsFriendsWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialSystemComponent::IsFriendsWith(const class FString& KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "IsFriendsWith");

	Params::USocialSystemComponent_IsFriendsWith_Params Parms{};

	Parms.KrakenId = KrakenId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.HasBlockedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialSystemComponent::HasBlockedPlayer(const class FString& KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "HasBlockedPlayer");

	Params::USocialSystemComponent_HasBlockedPlayer_Params Parms{};

	Parms.KrakenId = KrakenId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.GetMaxLocationPingCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ELocationPingType       Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USocialSystemComponent::GetMaxLocationPingCount(enum class ELocationPingType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "GetMaxLocationPingCount");

	Params::USocialSystemComponent_GetMaxLocationPingCount_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.Client_TryEstablishHelperBond
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               HasHelperBond                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLocationPingInfo           PingInfo                                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USocialSystemComponent::Client_TryEstablishHelperBond(bool HasHelperBond, const struct FLocationPingInfo& PingInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Client_TryEstablishHelperBond");

	Params::USocialSystemComponent_Client_TryEstablishHelperBond_Params Parms{};

	Parms.HasHelperBond = HasHelperBond;
	Parms.PingInfo = PingInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Client_SendPingMessage
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ASophiaPlayerState*          Sender                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        InText                                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void USocialSystemComponent::Client_SendPingMessage(class ASophiaPlayerState* Sender, class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Client_SendPingMessage");

	Params::USocialSystemComponent_Client_SendPingMessage_Params Parms{};

	Parms.Sender = Sender;
	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Client_RemoveGridHelpMarker
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void USocialSystemComponent::Client_RemoveGridHelpMarker()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Client_RemoveGridHelpMarker");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.Client_OnMessageSentByPlayer
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ASophiaPlayerState*          Sender                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::Client_OnMessageSentByPlayer(class ASophiaPlayerState* Sender)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "Client_OnMessageSentByPlayer");

	Params::USocialSystemComponent_Client_OnMessageSentByPlayer_Params Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.CanSendCooldownLocationPings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialSystemComponent::CanSendCooldownLocationPings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "CanSendCooldownLocationPings");

	Params::USocialSystemComponent_CanSendCooldownLocationPings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.CanSee
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// struct FLocationPingInfo           Ping                                                             (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialSystemComponent::CanSee(struct FLocationPingInfo* Ping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "CanSee");

	Params::USocialSystemComponent_CanSee_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Ping != nullptr)
		*Ping = std::move(Parms.Ping);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SocialSystemComponent.BPC_TryRemoveFriend_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPersistentPlayerReference  Target                                                           (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::BPC_TryRemoveFriend_C(const struct FPersistentPlayerReference& Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "BPC_TryRemoveFriend_C");

	Params::USocialSystemComponent_BPC_TryRemoveFriend_C_Params Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.BPC_TryAddFriend_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::BPC_TryAddFriend_C(class ASophiaPlayerState* Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "BPC_TryAddFriend_C");

	Params::USocialSystemComponent_BPC_TryAddFriend_C_Params Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.BPC_RejectFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USocialSystemComponent::BPC_RejectFriendRequest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "BPC_RejectFriendRequest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.BPC_AcceptFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USocialSystemComponent::BPC_AcceptFriendRequest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "BPC_AcceptFriendRequest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SocialSystemComponent.BlockUnblock_C
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLock                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialSystemComponent::BlockUnblock_C(class ASophiaPlayerState* Target, bool bLock)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SocialSystemComponent", "BlockUnblock_C");

	Params::USocialSystemComponent_BlockUnblock_C_Params Parms{};

	Parms.Target = Target;
	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SocketRSThread
// (None)

class UClass* USocketRSThread::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SocketRSThread");

	return Clss;
}


// SocketRSThread IslandsofInsight.Default__SocketRSThread
// (Public, ClassDefaultObject, ArchetypeObject)

class USocketRSThread* USocketRSThread::GetDefaultObj()
{
	static class USocketRSThread* Default = nullptr;

	if (!Default)
		Default = static_cast<USocketRSThread*>(USocketRSThread::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaActorReferenceBase
// (None)

class UClass* USophiaActorReferenceBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaActorReferenceBase");

	return Clss;
}


// SophiaActorReferenceBase IslandsofInsight.Default__SophiaActorReferenceBase
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaActorReferenceBase* USophiaActorReferenceBase::GetDefaultObj()
{
	static class USophiaActorReferenceBase* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaActorReferenceBase*>(USophiaActorReferenceBase::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaPuzzleReference
// (None)

class UClass* USophiaPuzzleReference::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaPuzzleReference");

	return Clss;
}


// SophiaPuzzleReference IslandsofInsight.Default__SophiaPuzzleReference
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaPuzzleReference* USophiaPuzzleReference::GetDefaultObj()
{
	static class USophiaPuzzleReference* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaPuzzleReference*>(USophiaPuzzleReference::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaClickableReference
// (None)

class UClass* USophiaClickableReference::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaClickableReference");

	return Clss;
}


// SophiaClickableReference IslandsofInsight.Default__SophiaClickableReference
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaClickableReference* USophiaClickableReference::GetDefaultObj()
{
	static class USophiaClickableReference* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaClickableReference*>(USophiaClickableReference::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaRuneReference
// (None)

class UClass* USophiaRuneReference::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaRuneReference");

	return Clss;
}


// SophiaRuneReference IslandsofInsight.Default__SophiaRuneReference
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaRuneReference* USophiaRuneReference::GetDefaultObj()
{
	static class USophiaRuneReference* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaRuneReference*>(USophiaRuneReference::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaAnimInstance
// (None)

class UClass* USophiaAnimInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaAnimInstance");

	return Clss;
}


// SophiaAnimInstance IslandsofInsight.Default__SophiaAnimInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaAnimInstance* USophiaAnimInstance::GetDefaultObj()
{
	static class USophiaAnimInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaAnimInstance*>(USophiaAnimInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaAnimInstance.GetRelevantAnimTimeSetValue
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USophiaAnimInstance::GetRelevantAnimTimeSetValue(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaAnimInstance", "GetRelevantAnimTimeSetValue");

	Params::USophiaAnimInstance_GetRelevantAnimTimeSetValue_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SophiaBoxComponent
// (SceneComponent, PrimitiveComponent)

class UClass* USophiaBoxComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaBoxComponent");

	return Clss;
}


// SophiaBoxComponent IslandsofInsight.Default__SophiaBoxComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaBoxComponent* USophiaBoxComponent::GetDefaultObj()
{
	static class USophiaBoxComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaBoxComponent*>(USophiaBoxComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaCharacter
// (Actor, Pawn)

class UClass* ASophiaCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaCharacter");

	return Clss;
}


// SophiaCharacter IslandsofInsight.Default__SophiaCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaCharacter* ASophiaCharacter::GetDefaultObj()
{
	static class ASophiaCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaCharacter*>(ASophiaCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaCharacter.WardrobeClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::WardrobeClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "WardrobeClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.UpgradesClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::UpgradesClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "UpgradesClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ToggleMenuCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Activate                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::ToggleMenuCamera(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ToggleMenuCamera");

	Params::ASophiaCharacter_ToggleMenuCamera_Params Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ThankHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          Helper                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::ThankHelper(class ASophiaPlayerState* Helper)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ThankHelper");

	Params::ASophiaCharacter_ThankHelper_Params Parms{};

	Parms.Helper = Helper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.StartTeamVsTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::StartTeamVsTeam()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "StartTeamVsTeam");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SpawnTeleportEggOnServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void ASophiaCharacter::SpawnTeleportEggOnServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SpawnTeleportEggOnServer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SpawnBots
// (Final, Native, Public, HasOutParams)
// Parameters:
// class ANavmeshAISpawner*           MeshSpawner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASophiaCharacter::SpawnBots(class ANavmeshAISpawner* MeshSpawner, struct FHitResult& OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SpawnBots");

	Params::ASophiaCharacter_SpawnBots_Params Parms{};

	Parms.MeshSpawner = MeshSpawner;
	Parms.OutHit = OutHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ShowServerFPS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bVal                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::ShowServerFPS(bool bVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ShowServerFPS");

	Params::ASophiaCharacter_ShowServerFPS_Params Parms{};

	Parms.bVal = bVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ShowChargeJumpUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::ShowChargeJumpUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ShowChargeJumpUI");

	Params::ASophiaCharacter_ShowChargeJumpUI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.ShouldHairBeVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::ShouldHairBeVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ShouldHairBeVisible");

	Params::ASophiaCharacter_ShouldHairBeVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.SetWidgetInputMode
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class UUserWidget*                 InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetWidgetInputMode(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetWidgetInputMode");

	Params::ASophiaCharacter_SetWidgetInputMode_Params Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetTitle(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetTitle");

	Params::ASophiaCharacter_SetTitle_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetThirdPerson
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewThirdPerson                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetThirdPerson(bool NewThirdPerson)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetThirdPerson");

	Params::ASophiaCharacter_SetThirdPerson_Params Parms{};

	Parms.NewThirdPerson = NewThirdPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetSprintMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ESprintMode             NewSprintMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetSprintMode(enum class ESprintMode NewSprintMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetSprintMode");

	Params::ASophiaCharacter_SetSprintMode_Params Parms{};

	Parms.NewSprintMode = NewSprintMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetHudDisabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Disabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetHudDisabled(bool Disabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetHudDisabled");

	Params::ASophiaCharacter_SetHudDisabled_Params Parms{};

	Parms.Disabled = Disabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetGameInputMode
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:

void ASophiaCharacter::SetGameInputMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetGameInputMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetGameAndUIInputMode
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class UUserWidget*                 InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetGameAndUIInputMode(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetGameAndUIInputMode");

	Params::ASophiaCharacter_SetGameAndUIInputMode_Params Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetEmoteIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetEmoteIndex(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetEmoteIndex");

	Params::ASophiaCharacter_SetEmoteIndex_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetDefaultMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::SetDefaultMovementMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetDefaultMovementMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetCustomizationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCustomizationData          InInfo                                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bMale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSetKraken                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetCustomizationData(const struct FCustomizationData& InInfo, bool bMale, bool bSetKraken)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetCustomizationData");

	Params::ASophiaCharacter_SetCustomizationData_Params Parms{};

	Parms.InInfo = InInfo;
	Parms.bMale = bMale;
	Parms.bSetKraken = bSetKraken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetCurrentJumpCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewJumpCount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetCurrentJumpCount(int32 NewJumpCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetCurrentJumpCount");

	Params::ASophiaCharacter_SetCurrentJumpCount_Params Parms{};

	Parms.NewJumpCount = NewJumpCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetCostume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USophiaCostumeInfo*          CostumeInfo                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetCostume(class USophiaCostumeInfo* CostumeInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetCostume");

	Params::ASophiaCharacter_SetCostume_Params Parms{};

	Parms.CostumeInfo = CostumeInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetCanControlCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetCanControlCamera(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetCanControlCamera");

	Params::ASophiaCharacter_SetCanControlCamera_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.SetBlinkStartingNumJumps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewJumpCount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::SetBlinkStartingNumJumps(int32 NewJumpCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "SetBlinkStartingNumJumps");

	Params::ASophiaCharacter_SetBlinkStartingNumJumps_Params Parms{};

	Parms.NewJumpCount = NewJumpCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ServerExclusive_SendAllMessages
// (Final, Native, Public)
// Parameters:

void ASophiaCharacter::ServerExclusive_SendAllMessages()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ServerExclusive_SendAllMessages");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UseItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// enum class EItemType               Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UseItem(enum class EItemType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UseItem");

	Params::ASophiaCharacter_Server_UseItem_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UpdateLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UpdateLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UpdateLevel");

	Params::ASophiaCharacter_Server_UpdateLevel_Params Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UpdateEarnedCosmetic
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UpdateEarnedCosmetic(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UpdateEarnedCosmetic");

	Params::ASophiaCharacter_Server_UpdateEarnedCosmetic_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UnlockJumpPadByPuzzle
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APuzzleLockedJumpingPad*     JumpingPad                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UnlockJumpPadByPuzzle(class APuzzleLockedJumpingPad* JumpingPad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UnlockJumpPadByPuzzle");

	Params::ASophiaCharacter_Server_UnlockJumpPadByPuzzle_Params Parms{};

	Parms.JumpingPad = JumpingPad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UnlockJumpPad
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALockedJumpingPad*           JumpingPad                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UnlockJumpPad(class ALockedJumpingPad* JumpingPad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UnlockJumpPad");

	Params::ASophiaCharacter_Server_UnlockJumpPad_Params Parms{};

	Parms.JumpingPad = JumpingPad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_UnlockEncyclopediaEntry
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      EncyclopediaEntryID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_UnlockEncyclopediaEntry(const class FString& EncyclopediaEntryID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_UnlockEncyclopediaEntry");

	Params::ASophiaCharacter_Server_UnlockEncyclopediaEntry_Params Parms{};

	Parms.EncyclopediaEntryID = EncyclopediaEntryID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_TryUnlockGate
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ALevelRestrictionVolume*     TheGate                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_TryUnlockGate(class ALevelRestrictionVolume* TheGate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_TryUnlockGate");

	Params::ASophiaCharacter_Server_TryUnlockGate_Params Parms{};

	Parms.TheGate = TheGate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SwitchSkin
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaCharacter::Server_SwitchSkin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SwitchSkin");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_StartTeamVsTeam
// (Net, Native, Event, Public, NetServer)
// Parameters:

void ASophiaCharacter::Server_StartTeamVsTeam()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_StartTeamVsTeam");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SpawnItemJumpingPad
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void ASophiaCharacter::Server_SpawnItemJumpingPad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SpawnItemJumpingPad");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SpawnBots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ANavmeshAISpawner*           MeshSpawner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SpawnBots(class ANavmeshAISpawner* MeshSpawner, struct FHitResult& OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SpawnBots");

	Params::ASophiaCharacter_Server_SpawnBots_Params Parms{};

	Parms.MeshSpawner = MeshSpawner;
	Parms.OutHit = OutHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_ShowServerFPS
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                               bVal                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_ShowServerFPS(bool bVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_ShowServerFPS");

	Params::ASophiaCharacter_Server_ShowServerFPS_Params Parms{};

	Parms.bVal = bVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetTitle
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetTitle(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetTitle");

	Params::ASophiaCharacter_Server_SetTitle_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetServerParams
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FServerParams               NewParams                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetServerParams(const struct FServerParams& NewParams)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetServerParams");

	Params::ASophiaCharacter_Server_SetServerParams_Params Parms{};

	Parms.NewParams = NewParams;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetSeenEncyclopedia
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetSeenEncyclopedia(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetSeenEncyclopedia");

	Params::ASophiaCharacter_Server_SetSeenEncyclopedia_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetReady
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:

void ASophiaCharacter::Server_SetReady()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetReady");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetMaleCustomizationData
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FCustomizationData          InInfo                                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetMaleCustomizationData(struct FCustomizationData& InInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetMaleCustomizationData");

	Params::ASophiaCharacter_Server_SetMaleCustomizationData_Params Parms{};

	Parms.InInfo = InInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetLockingJumpPadAndTime
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AJumpingPad*                 InPad                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Ping                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetLockingJumpPadAndTime(class AJumpingPad* InPad, uint8 Ping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetLockingJumpPadAndTime");

	Params::ASophiaCharacter_Server_SetLockingJumpPadAndTime_Params Parms{};

	Parms.InPad = InPad;
	Parms.Ping = Ping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetInputVector
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                     NewInputVector                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetInputVector(struct FVector& NewInputVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetInputVector");

	Params::ASophiaCharacter_Server_SetInputVector_Params Parms{};

	Parms.NewInputVector = NewInputVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetIgnoreClientMovementErrorChecksAndCorrection
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetIgnoreClientMovementErrorChecksAndCorrection(bool Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetIgnoreClientMovementErrorChecksAndCorrection");

	Params::ASophiaCharacter_Server_SetIgnoreClientMovementErrorChecksAndCorrection_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetEmoteIndex
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetEmoteIndex(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetEmoteIndex");

	Params::ASophiaCharacter_Server_SetEmoteIndex_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetCustomizationData
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FCustomizationData          InInfo                                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetCustomizationData(struct FCustomizationData& InInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetCustomizationData");

	Params::ASophiaCharacter_Server_SetCustomizationData_Params Parms{};

	Parms.InInfo = InInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetCostume
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class USophiaCostumeInfo*          CostumeInfo                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetCostume(class USophiaCostumeInfo* CostumeInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetCostume");

	Params::ASophiaCharacter_Server_SetCostume_Params Parms{};

	Parms.CostumeInfo = CostumeInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SetCheatBlink
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                               NewCheatValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SetCheatBlink(bool NewCheatValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SetCheatBlink");

	Params::ASophiaCharacter_Server_SetCheatBlink_Params Parms{};

	Parms.NewCheatValue = NewCheatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SendHelpMessage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASophiaPlayerState*          SendTo                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                SendFrom                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SendHelpMessage(class ASophiaPlayerState* SendTo, class APlayerState* SendFrom)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SendHelpMessage");

	Params::ASophiaCharacter_Server_SendHelpMessage_Params Parms{};

	Parms.SendTo = SendTo;
	Parms.SendFrom = SendFrom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SendCombo
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APartyRosary*                Rosary                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Combo                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SendCombo(class APartyRosary* Rosary, int32 Combo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SendCombo");

	Params::ASophiaCharacter_Server_SendCombo_Params Parms{};

	Parms.Rosary = Rosary;
	Parms.Combo = Combo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SendClicked
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class AClickableBase*              P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SendClicked(class AClickableBase* P, struct FHitResult& OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SendClicked");

	Params::ASophiaCharacter_Server_SendClicked_Params Parms{};

	Parms.P = P;
	Parms.OutHit = OutHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_SendChatMessage
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Text                                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_SendChatMessage(class ASophiaPlayerState* P, class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_SendChatMessage");

	Params::ASophiaCharacter_Server_SendChatMessage_Params Parms{};

	Parms.P = P;
	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_RespawnPlayer
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaCharacter::Server_RespawnPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_RespawnPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_PlayerLevelUp
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:

void ASophiaCharacter::Server_PlayerLevelUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_PlayerLevelUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_PlayDoubleJumpMontage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaCharacter::Server_PlayDoubleJumpMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_PlayDoubleJumpMontage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_GyroPuzzle_Sync
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class AGyroPuzzle*                 P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TrueSolveTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TrueLaserLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    TrueLaserRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_GyroPuzzle_Sync(class AGyroPuzzle* P, float TrueSolveTime, const struct FVector& TrueLaserLocation, const struct FRotator& TrueLaserRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_GyroPuzzle_Sync");

	Params::ASophiaCharacter_Server_GyroPuzzle_Sync_Params Parms{};

	Parms.P = P;
	Parms.TrueSolveTime = TrueSolveTime;
	Parms.TrueLaserLocation = TrueLaserLocation;
	Parms.TrueLaserRotation = TrueLaserRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_GridPuzzle_RequestSPLock
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class ASophiaRune*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_GridPuzzle_RequestSPLock(class ASophiaRune* Puzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_GridPuzzle_RequestSPLock");

	Params::ASophiaCharacter_Server_GridPuzzle_RequestSPLock_Params Parms{};

	Parms.Puzzle = Puzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_GridPuzzle_ReleaseSPLock
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class ASophiaRune*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_GridPuzzle_ReleaseSPLock(class ASophiaRune* Puzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_GridPuzzle_ReleaseSPLock");

	Params::ASophiaCharacter_Server_GridPuzzle_ReleaseSPLock_Params Parms{};

	Parms.Puzzle = Puzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatUnlockUpgrades
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaCharacter::Server_CheatUnlockUpgrades()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatUnlockUpgrades");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatUnlockItems
// (Net, Native, Event, Protected, NetServer, BlueprintCallable, NetValidate)
// Parameters:

void ASophiaCharacter::Server_CheatUnlockItems()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatUnlockItems");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatSpawnRandomAirdrop
// (Net, Native, Event, Protected, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// int32                              Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CheatSpawnRandomAirdrop(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatSpawnRandomAirdrop");

	Params::ASophiaCharacter_Server_CheatSpawnRandomAirdrop_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatPowerPoles
// (Net, Native, Event, Protected, NetServer, BlueprintCallable, NetValidate)
// Parameters:

void ASophiaCharacter::Server_CheatPowerPoles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatPowerPoles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatForceStartMatch
// (Net, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:

void ASophiaCharacter::Server_CheatForceStartMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatForceStartMatch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatEndgame
// (Net, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:

void ASophiaCharacter::Server_CheatEndgame()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatEndgame");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatAddXP
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CheatAddXP(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatAddXP");

	Params::ASophiaCharacter_Server_CheatAddXP_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatAddMasteryXP
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CheatAddMasteryXP(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatAddMasteryXP");

	Params::ASophiaCharacter_Server_CheatAddMasteryXP_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatAddGold
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CheatAddGold(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatAddGold");

	Params::ASophiaCharacter_Server_CheatAddGold_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatAddBlueOrb
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CheatAddBlueOrb(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatAddBlueOrb");

	Params::ASophiaCharacter_Server_CheatAddBlueOrb_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CheatActivateEvent
// (Net, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:

void ASophiaCharacter::Server_CheatActivateEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CheatActivateEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_ChangeMap
// (Net, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class FString                      MapName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_ChangeMap(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_ChangeMap");

	Params::ASophiaCharacter_Server_ChangeMap_Params Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CancelRacingCheckpoints
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARacingCheckpointsMinigame*  RacingCheckpoints                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_CancelRacingCheckpoints(class ARacingCheckpointsMinigame* RacingCheckpoints)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CancelRacingCheckpoints");

	Params::ASophiaCharacter_Server_CancelRacingCheckpoints_Params Parms{};

	Parms.RacingCheckpoints = RacingCheckpoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_CancelDoubleJumpMontage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaCharacter::Server_CancelDoubleJumpMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_CancelDoubleJumpMontage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_ApplyDamageWithTimer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Timer                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_ApplyDamageWithTimer(int32 Amount, float Timer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_ApplyDamageWithTimer");

	Params::ASophiaCharacter_Server_ApplyDamageWithTimer_Params Parms{};

	Parms.Amount = Amount;
	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_ApplyDamage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_ApplyDamage(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_ApplyDamage");

	Params::ASophiaCharacter_Server_ApplyDamage_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_AdminSpawnBots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              SpawnCount                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Server_AdminSpawnBots(int32 SpawnCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_AdminSpawnBots");

	Params::ASophiaCharacter_Server_AdminSpawnBots_Params Parms{};

	Parms.SpawnCount = SpawnCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Server_AdminDespawnBots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void ASophiaCharacter::Server_AdminDespawnBots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Server_AdminDespawnBots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.RemoveFakeLoadingScreen
// (Final, Native, Public)
// Parameters:

void ASophiaCharacter::RemoveFakeLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "RemoveFakeLoadingScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ReceivedBlueOrbEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::ReceivedBlueOrbEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ReceivedBlueOrbEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.PurchaseCosmetic
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::PurchaseCosmetic(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "PurchaseCosmetic");

	Params::ASophiaCharacter_PurchaseCosmetic_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.PlayFootstepSound
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                               bIsWater                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::PlayFootstepSound(bool bIsWater)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "PlayFootstepSound");

	Params::ASophiaCharacter_PlayFootstepSound_Params Parms{};

	Parms.bIsWater = bIsWater;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.PerformRespawnTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::PerformRespawnTeleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "PerformRespawnTeleport");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OpenUpgradeMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                 ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ASophiaCharacter::OpenUpgradeMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OpenUpgradeMenu");

	Params::ASophiaCharacter_OpenUpgradeMenu_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_UnlockedCosmetics
// (Native, Protected)
// Parameters:

void ASophiaCharacter::OnRep_UnlockedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_UnlockedCosmetics");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_selectedCostume
// (Final, Native, Public)
// Parameters:
// class USophiaCostumeInfo*          Prior                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::OnRep_selectedCostume(class USophiaCostumeInfo* Prior)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_selectedCostume");

	Params::ASophiaCharacter_OnRep_selectedCostume_Params Parms{};

	Parms.Prior = Prior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_PlayerTitle
// (Native, Protected)
// Parameters:

void ASophiaCharacter::OnRep_PlayerTitle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_PlayerTitle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_MaleCustomizationData
// (Native, Protected)
// Parameters:

void ASophiaCharacter::OnRep_MaleCustomizationData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_MaleCustomizationData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_IsPlayerReady
// (Final, Native, Protected)
// Parameters:

void ASophiaCharacter::OnRep_IsPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_IsPlayerReady");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_EventPromptState
// (Final, Native, Public)
// Parameters:

void ASophiaCharacter::OnRep_EventPromptState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_EventPromptState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_CustomizationData
// (Native, Protected)
// Parameters:

void ASophiaCharacter::OnRep_CustomizationData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_CustomizationData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRep_curSkinIndex
// (Final, Native, Protected, Const)
// Parameters:

void ASophiaCharacter::OnRep_curSkinIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRep_curSkinIndex");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnRecall
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::OnRecall()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnRecall");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnPlayerCollision
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComponent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Result                                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASophiaCharacter::OnPlayerCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& HitLocation, struct FHitResult& Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnPlayerCollision");

	Params::ASophiaCharacter_OnPlayerCollision_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.HitLocation = HitLocation;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnCosmeticBoughtFailed
// (Final, Native, Public)
// Parameters:
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::OnCosmeticBoughtFailed(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnCosmeticBoughtFailed");

	Params::ASophiaCharacter_OnCosmeticBoughtFailed_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.OnCosmeticBought
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FKrakenPurchaseData         ItemId                                                           (Parm, NativeAccessSpecifierPublic)

void ASophiaCharacter::OnCosmeticBought(const struct FKrakenPurchaseData& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "OnCosmeticBought");

	Params::ASophiaCharacter_OnCosmeticBought_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.NetMultiCast_SendChatMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASophiaPlayerState*          Sender                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Text                                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::NetMultiCast_SendChatMessage(class ASophiaPlayerState* Sender, class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "NetMultiCast_SendChatMessage");

	Params::ASophiaCharacter_NetMultiCast_SendChatMessage_Params Parms{};

	Parms.Sender = Sender;
	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.NetMultiCast_PlayerLevelUp
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:

void ASophiaCharacter::NetMultiCast_PlayerLevelUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "NetMultiCast_PlayerLevelUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.MultiCast_PlayDoubleJumpMontage
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:

void ASophiaCharacter::MultiCast_PlayDoubleJumpMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "MultiCast_PlayDoubleJumpMontage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.MultiCast_CancelDoubleJumpMontage
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:

void ASophiaCharacter::MultiCast_CancelDoubleJumpMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "MultiCast_CancelDoubleJumpMontage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.MasteriesClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::MasteriesClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "MasteriesClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.MapToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::MapToggle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "MapToggle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.MapClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::MapClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "MapClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.LocalPlayerExclusive_TeleportToNearestBeacon
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::LocalPlayerExclusive_TeleportToNearestBeacon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "LocalPlayerExclusive_TeleportToNearestBeacon");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.LocalPlayerExclusive_OnLocalPLayerLevelUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::LocalPlayerExclusive_OnLocalPLayerLevelUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "LocalPlayerExclusive_OnLocalPLayerLevelUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.IsPauseMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsPauseMenuVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsPauseMenuVisible");

	Params::ASophiaCharacter_IsPauseMenuVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsMapMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsMapMenuVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsMapMenuVisible");

	Params::ASophiaCharacter_IsMapMenuVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsLoadingComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsLoadingComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsLoadingComplete");

	Params::ASophiaCharacter_IsLoadingComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsInPuzzleMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsInPuzzleMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsInPuzzleMode");

	Params::ASophiaCharacter_IsInPuzzleMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsInGridMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsInGridMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsInGridMode");

	Params::ASophiaCharacter_IsInGridMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsCreationVisible
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsCreationVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsCreationVisible");

	Params::ASophiaCharacter_IsCreationVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.IsBlueOrbVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::IsBlueOrbVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "IsBlueOrbVisible");

	Params::ASophiaCharacter_IsBlueOrbVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.HandleHelpMessage_PS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASophiaPlayerState*          PS                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::HandleHelpMessage_PS(class ASophiaPlayerState* PS)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "HandleHelpMessage_PS");

	Params::ASophiaCharacter_HandleHelpMessage_PS_Params Parms{};

	Parms.PS = PS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.HandleHelpMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APuzzleBase*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::HandleHelpMessage(class APuzzleBase* Puzzle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "HandleHelpMessage");

	Params::ASophiaCharacter_HandleHelpMessage_Params Parms{};

	Parms.Puzzle = Puzzle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.GetThirdPerson
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::GetThirdPerson()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetThirdPerson");

	Params::ASophiaCharacter_GetThirdPerson_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetStandingLockedJumpPad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALockedJumpingPad*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALockedJumpingPad* ASophiaCharacter::GetStandingLockedJumpPad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetStandingLockedJumpPad");

	Params::ASophiaCharacter_GetStandingLockedJumpPad_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASophiaCharacter::GetPlayerName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetPlayerName");

	Params::ASophiaCharacter_GetPlayerName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetMusicComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMusicComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMusicComponent* ASophiaCharacter::GetMusicComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetMusicComponent");

	Params::ASophiaCharacter_GetMusicComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetMapComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharMapComponent*           ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharMapComponent* ASophiaCharacter::GetMapComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetMapComponent");

	Params::ASophiaCharacter_GetMapComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASophiaCharacter::GetInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetInputVector");

	Params::ASophiaCharacter_GetInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetExtendedCMC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UExtendedMovementComponent*  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UExtendedMovementComponent* ASophiaCharacter::GetExtendedCMC()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetExtendedCMC");

	Params::ASophiaCharacter_GetExtendedCMC_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetEventPromptState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEventPrompt                ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FEventPrompt ASophiaCharacter::GetEventPromptState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetEventPromptState");

	Params::ASophiaCharacter_GetEventPromptState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetEmoteIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASophiaCharacter::GetEmoteIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetEmoteIndex");

	Params::ASophiaCharacter_GetEmoteIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetCheatSandboxSolves
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASophiaCharacter::GetCheatSandboxSolves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetCheatSandboxSolves");

	Params::ASophiaCharacter_GetCheatSandboxSolves_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetCheatInfiniteBlink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::GetCheatInfiniteBlink()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetCheatInfiniteBlink");

	Params::ASophiaCharacter_GetCheatInfiniteBlink_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetCapsuleBaseLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              ZOffset                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASophiaCharacter::GetCapsuleBaseLocation(float ZOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetCapsuleBaseLocation");

	Params::ASophiaCharacter_GetCapsuleBaseLocation_Params Parms{};

	Parms.ZOffset = ZOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetCameraForwardFacingVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASophiaCharacter::GetCameraForwardFacingVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetCameraForwardFacingVector");

	Params::ASophiaCharacter_GetCameraForwardFacingVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetCameraFacingDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ASophiaCharacter::GetCameraFacingDirection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetCameraFacingDirection");

	Params::ASophiaCharacter_GetCameraFacingDirection_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetBlinkStartingNumJumps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASophiaCharacter::GetBlinkStartingNumJumps()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetBlinkStartingNumJumps");

	Params::ASophiaCharacter_GetBlinkStartingNumJumps_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAbilitySystemComponent*     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* ASophiaCharacter::GetAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "GetAbilitySystemComponent");

	Params::ASophiaCharacter_GetAbilitySystemComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.ExitLoreFragmentInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::ExitLoreFragmentInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ExitLoreFragmentInput");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.EncyclopediaPuzzlesClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::EncyclopediaPuzzlesClick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "EncyclopediaPuzzlesClick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.DoesGridNeedCursor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::DoesGridNeedCursor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "DoesGridNeedCursor");

	Params::ASophiaCharacter_DoesGridNeedCursor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.ContextAwareMapToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::ContextAwareMapToggle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ContextAwareMapToggle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Client_SetControlRot
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FRotator                    ControlRot                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::Client_SetControlRot(struct FRotator& ControlRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Client_SetControlRot");

	Params::ASophiaCharacter_Client_SetControlRot_Params Parms{};

	Parms.ControlRot = ControlRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Client_SendHelpMessage
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class APlayerState*                SendFrom                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::Client_SendHelpMessage(class APlayerState* SendFrom)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Client_SendHelpMessage");

	Params::ASophiaCharacter_Client_SendHelpMessage_Params Parms{};

	Parms.SendFrom = SendFrom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Client_RemoveLoading
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void ASophiaCharacter::Client_RemoveLoading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Client_RemoveLoading");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Client_AddAllFeedMessages
// (Net, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FFeedMessage>        Msgs                                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Client_AddAllFeedMessages(TArray<struct FFeedMessage>& Msgs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Client_AddAllFeedMessages");

	Params::ASophiaCharacter_Client_AddAllFeedMessages_Params Parms{};

	Parms.Msgs = Msgs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.Client_AddAllCentralMessages
// (Net, Native, Event, Public, NetClient)
// Parameters:
// TArray<class FText>                Msgs                                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::Client_AddAllCentralMessages(TArray<class FText>& Msgs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "Client_AddAllCentralMessages");

	Params::ASophiaCharacter_Client_AddAllCentralMessages_Params Parms{};

	Parms.Msgs = Msgs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.CheckIfLanded
// (Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheckIfLanded(struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "CheckIfLanded");

	Params::ASophiaCharacter_CheckIfLanded_Params Parms{};

	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.CheatUnlockZone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheatUnlockZone(enum class EMainMapZoneName ZONE)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "CheatUnlockZone");

	Params::ASophiaCharacter_CheatUnlockZone_Params Parms{};

	Parms.ZONE = ZONE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatUnlockUpgrades
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatUnlockUpgrades()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatUnlockUpgrades");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatUnlockEncyclopedia
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatUnlockEncyclopedia()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatUnlockEncyclopedia");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatUnlockCosmetic
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatUnlockCosmetic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatUnlockCosmetic");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatSolvePuzzle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatSolvePuzzle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatSolvePuzzle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.CheatShowOrphanPuzzles
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatShowOrphanPuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "CheatShowOrphanPuzzles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatExtendTrailLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatExtendTrailLength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatExtendTrailLength");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.CheatDie
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatDie()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "CheatDie");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatAddXP
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheatAddXP(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatAddXP");

	Params::ASophiaCharacter_CheatAddXP_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.CheatAddSandboxSolves
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::CheatAddSandboxSolves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "CheatAddSandboxSolves");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatAddMasteryXP
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheatAddMasteryXP(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatAddMasteryXP");

	Params::ASophiaCharacter_CheatAddMasteryXP_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatAddGold
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheatAddGold(struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatAddGold");

	Params::ASophiaCharacter_CheatAddGold_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.cheatAddBlueOrb
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::CheatAddBlueOrb(struct FBhvrAnalyticsEvent_Base& Event, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "cheatAddBlueOrb");

	Params::ASophiaCharacter_CheatAddBlueOrb_Params Parms{};

	Parms.Event = Event;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ChargeJumpTimer
// (Final, Native, Public)
// Parameters:

void ASophiaCharacter::ChargeJumpTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ChargeJumpTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.ChangeFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              FOV                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ZoomFOV                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::ChangeFOV(float FOV, float ZoomFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "ChangeFOV");

	Params::ASophiaCharacter_ChangeFOV_Params Parms{};

	Parms.FOV = FOV;
	Parms.ZoomFOV = ZoomFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BPI_OnTeleport
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              TeleportDistance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BPI_OnTeleport(float TeleportDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPI_OnTeleport");

	Params::ASophiaCharacter_BPI_OnTeleport_Params Parms{};

	Parms.TeleportDistance = TeleportDistance;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BPI_OnSleepingPuzzleClicked
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class APuzzleBase*                 Puzzle                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ErrorMsg                                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaCharacter::BPI_OnSleepingPuzzleClicked(class APuzzleBase* Puzzle, class FText& ErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPI_OnSleepingPuzzleClicked");

	Params::ASophiaCharacter_BPI_OnSleepingPuzzleClicked_Params Parms{};

	Parms.Puzzle = Puzzle;
	Parms.ErrorMsg = ErrorMsg;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BPI_OnLevelUp
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BPI_OnLevelUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPI_OnLevelUp");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BPC_cheatAddXP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BPC_cheatAddXP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPC_cheatAddXP");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BPC_cheatAddMasteryXP
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BPC_cheatAddMasteryXP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPC_cheatAddMasteryXP");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BPC_cheatAddManyBlueOrb
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BPC_cheatAddManyBlueOrb(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPC_cheatAddManyBlueOrb");

	Params::ASophiaCharacter_BPC_cheatAddManyBlueOrb_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BPC_cheatAddGold
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BPC_cheatAddGold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPC_cheatAddGold");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BPC_cheatAddBlueOrb
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BPC_cheatAddBlueOrb()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BPC_cheatAddBlueOrb");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BP_TriggerUpgradeTutorial
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_TriggerUpgradeTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_TriggerUpgradeTutorial");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_ToggleWings
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               IsWingsActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_ToggleWings(bool IsWingsActive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_ToggleWings");

	Params::ASophiaCharacter_BP_ToggleWings_Params Parms{};

	Parms.IsWingsActive = IsWingsActive;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_TickLocal
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_TickLocal(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_TickLocal");

	Params::ASophiaCharacter_BP_TickLocal_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_SpawnMatchboxVTrail
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     BoxLoc1                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxLoc2                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlayerLoc                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    MatchboxTexture                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_SpawnMatchboxVTrail(const struct FVector& BoxLoc1, const struct FVector& BoxLoc2, const struct FVector& PlayerLoc, class UTexture* MatchboxTexture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_SpawnMatchboxVTrail");

	Params::ASophiaCharacter_BP_SpawnMatchboxVTrail_Params Parms{};

	Parms.BoxLoc1 = BoxLoc1;
	Parms.BoxLoc2 = BoxLoc2;
	Parms.PlayerLoc = PlayerLoc;
	Parms.MatchboxTexture = MatchboxTexture;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_SetPlayerVisible
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_SetPlayerVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_SetPlayerVisible");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_SetGravProjectileVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               NewVisibility                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_SetGravProjectileVisibility(bool NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_SetGravProjectileVisibility");

	Params::ASophiaCharacter_BP_SetGravProjectileVisibility_Params Parms{};

	Parms.NewVisibility = NewVisibility;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_ScrollingWhileForcedFirstPerson
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_ScrollingWhileForcedFirstPerson()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_ScrollingWhileForcedFirstPerson");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_RemoveFakeLoadingScreen
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_RemoveFakeLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_RemoveFakeLoadingScreen");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_ReceivedBlueOrb
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_ReceivedBlueOrb()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_ReceivedBlueOrb");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_PuzzleForcedFirstPerson
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_PuzzleForcedFirstPerson()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_PuzzleForcedFirstPerson");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_PostInit
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_PostInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_PostInit");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_PlayEmote
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_PlayEmote()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_PlayEmote");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OpenNewPuzzleModal
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OpenNewPuzzleModal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OpenNewPuzzleModal");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnWave
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnWave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnWave");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnVault
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnVault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnVault");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnUnlockedCosmetics
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnUnlockedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnUnlockedCosmetics");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnRecall
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnRecall()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnRecall");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnMoreThanNecessaryPuzzlesInObjectiveSolvedForTheFirstTime
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnMoreThanNecessaryPuzzlesInObjectiveSolvedForTheFirstTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnMoreThanNecessaryPuzzlesInObjectiveSolvedForTheFirstTime");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnMaleCustomizationDataUpdated
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnMaleCustomizationDataUpdated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnMaleCustomizationDataUpdated");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnLaunch
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnLaunch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnLaunch");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnCustomizationDataUpdated
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnCustomizationDataUpdated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnCustomizationDataUpdated");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnCosmeticBoughtFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_OnCosmeticBoughtFailed(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnCosmeticBoughtFailed");

	Params::ASophiaCharacter_BP_OnCosmeticBoughtFailed_Params Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnCosmeticBought
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                      ItemId                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_OnCosmeticBought(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnCosmeticBought");

	Params::ASophiaCharacter_BP_OnCosmeticBought_Params Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnClickedViewFinder
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnClickedViewFinder()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnClickedViewFinder");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnClickedRosary
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnClickedRosary()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnClickedRosary");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnClickedProjectionCone
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnClickedProjectionCone()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnClickedProjectionCone");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnClickedMatchBox
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnClickedMatchBox()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnClickedMatchBox");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnClickedGyroRing
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnClickedGyroRing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnClickedGyroRing");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_OnCancelMatchBox
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_OnCancelMatchBox()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_OnCancelMatchBox");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_NewGravProjectile
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGravityBallProjectile*      Projectile                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_NewGravProjectile(class AGravityBallProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_NewGravProjectile");

	Params::ASophiaCharacter_BP_NewGravProjectile_Params Parms{};

	Parms.Projectile = Projectile;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_LoreItemInput
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_LoreItemInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_LoreItemInput");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_LoreItemExit
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_LoreItemExit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_LoreItemExit");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_IsWaterActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::BP_IsWaterActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_IsWaterActor");

	Params::ASophiaCharacter_BP_IsWaterActor_Params Parms{};

	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.BP_IsThirdPersonView
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               ThirdPersonViewIsActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_IsThirdPersonView(bool ThirdPersonViewIsActive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_IsThirdPersonView");

	Params::ASophiaCharacter_BP_IsThirdPersonView_Params Parms{};

	Parms.ThirdPersonViewIsActive = ThirdPersonViewIsActive;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_HasPole
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               HasPole                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_HasPole(bool HasPole)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_HasPole");

	Params::ASophiaCharacter_BP_HasPole_Params Parms{};

	Parms.HasPole = HasPole;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_GrantWings
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BP_GrantWings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_GrantWings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BP_GrantEtherealHair
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::BP_GrantEtherealHair()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_GrantEtherealHair");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.BP_GetFirstLocalPlayerHUD
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaHUD*                  HUD                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::BP_GetFirstLocalPlayerHUD(class UObject* WorldContextObject, class ASophiaHUD** HUD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_GetFirstLocalPlayerHUD");

	Params::ASophiaCharacter_BP_GetFirstLocalPlayerHUD_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HUD != nullptr)
		*HUD = Parms.HUD;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.BP_GetDefaultCustomization
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCustomizationData          Data                                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCustomizationData          MaleData                                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_GetDefaultCustomization(struct FCustomizationData* Data, struct FCustomizationData* MaleData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_GetDefaultCustomization");

	Params::ASophiaCharacter_BP_GetDefaultCustomization_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (MaleData != nullptr)
		*MaleData = std::move(Parms.MaleData);

}


// Function IslandsofInsight.SophiaCharacter.BP_ClickedLoreFragment
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEncyclopediaEntry*          Lore                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_ClickedLoreFragment(class UEncyclopediaEntry* Lore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_ClickedLoreFragment");

	Params::ASophiaCharacter_BP_ClickedLoreFragment_Params Parms{};

	Parms.Lore = Lore;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.BP_BlueOrbInput
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASophiaCharacter::BP_BlueOrbInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_BlueOrbInput");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaCharacter.BP_AssignDummyGravProjectileTo
// (Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*             ObjRef                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::BP_AssignDummyGravProjectileTo(class USceneComponent* ObjRef)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "BP_AssignDummyGravProjectileTo");

	Params::ASophiaCharacter_BP_AssignDummyGravProjectileTo_Params Parms{};

	Parms.ObjRef = ObjRef;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaCharacter.AreOtherInputWidgetsVisible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                 InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaCharacter::AreOtherInputWidgetsVisible(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "AreOtherInputWidgetsVisible");

	Params::ASophiaCharacter_AreOtherInputWidgetsVisible_Params Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaCharacter.AdminSpawnBots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              SpawnCount                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::AdminSpawnBots(int32 SpawnCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "AdminSpawnBots");

	Params::ASophiaCharacter_AdminSpawnBots_Params Parms{};

	Parms.SpawnCount = SpawnCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.AdminDespawnBots
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ASophiaCharacter::AdminDespawnBots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "AdminDespawnBots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaCharacter.AddMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                        MessageText                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bPreventSpam                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaCharacter::AddMessage(class FText& MessageText, bool bPreventSpam)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaCharacter", "AddMessage");

	Params::ASophiaCharacter_AddMessage_Params Parms{};

	Parms.MessageText = MessageText;
	Parms.bPreventSpam = bPreventSpam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaController
// (Actor, PlayerController)

class UClass* ASophiaController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaController");

	return Clss;
}


// SophiaController IslandsofInsight.Default__SophiaController
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaController* ASophiaController::GetDefaultObj()
{
	static class ASophiaController* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaController*>(ASophiaController::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaController.VisualizePuzzleBounds
// (Final, Exec, Native, Protected, Const)
// Parameters:
// bool                               Visualize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::VisualizePuzzleBounds(bool Visualize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "VisualizePuzzleBounds");

	Params::ASophiaController_VisualizePuzzleBounds_Params Parms{};

	Parms.Visualize = Visualize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.ServerFPS
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::ServerFPS(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "ServerFPS");

	Params::ASophiaController_ServerFPS_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.ServerExclusive_SavePlayerLoc
// (Final, Native, Public)
// Parameters:

void ASophiaController::ServerExclusive_SavePlayerLoc()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "ServerExclusive_SavePlayerLoc");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.ServerConsole
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                      CommandLine                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::ServerConsole(const class FString& CommandLine)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "ServerConsole");

	Params::ASophiaController_ServerConsole_Params Parms{};

	Parms.CommandLine = CommandLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_SetKrakenId
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      KrakenToken                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoLogin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Server_SetKrakenId(const class FString& KrakenToken, bool bAutoLogin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_SetKrakenId");

	Params::ASophiaController_Server_SetKrakenId_Params Parms{};

	Parms.KrakenToken = KrakenToken;
	Parms.bAutoLogin = bAutoLogin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_SendCreatedPuzzleNames
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<class FString>              ClientCreatedPuzzles                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              ClientDestroyedPuzzles                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaController::Server_SendCreatedPuzzleNames(TArray<class FString>& ClientCreatedPuzzles, TArray<class FString>& ClientDestroyedPuzzles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_SendCreatedPuzzleNames");

	Params::ASophiaController_Server_SendCreatedPuzzleNames_Params Parms{};

	Parms.ClientCreatedPuzzles = ClientCreatedPuzzles;
	Parms.ClientDestroyedPuzzles = ClientDestroyedPuzzles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_SendAnalyticsInfo
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FGSAnalyticsData            Data                                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaController::Server_SendAnalyticsInfo(struct FGSAnalyticsData& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_SendAnalyticsInfo");

	Params::ASophiaController_Server_SendAnalyticsInfo_Params Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_RefreshBasicPlayerData
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void ASophiaController::Server_RefreshBasicPlayerData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_RefreshBasicPlayerData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_PrintRuneTypePerZone
// (Net, NetReliable, Native, Event, Protected, NetServer, Const)
// Parameters:

void ASophiaController::Server_PrintRuneTypePerZone()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_PrintRuneTypePerZone");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_DebugQuests
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                              Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Server_DebugQuests(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_DebugQuests");

	Params::ASophiaController_Server_DebugQuests_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_DebugPlayerProgression
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaController::Server_DebugPlayerProgression()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_DebugPlayerProgression");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_CallConsoleCmdOnServer
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class FString                      CommandLine                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Server_CallConsoleCmdOnServer(const class FString& CommandLine)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_CallConsoleCmdOnServer");

	Params::ASophiaController_Server_CallConsoleCmdOnServer_Params Parms{};

	Parms.CommandLine = CommandLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Server_AddSandboxSpawnTimer
// (Net, NetReliable, Native, Event, Protected, NetServer, Const)
// Parameters:
// enum class EMainMapZoneName        ZoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PuzzleType                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Server_AddSandboxSpawnTimer(enum class EMainMapZoneName ZoneName, const class FString& PuzzleType, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Server_AddSandboxSpawnTimer");

	Params::ASophiaController_Server_AddSandboxSpawnTimer_Params Parms{};

	Parms.ZoneName = ZoneName;
	Parms.PuzzleType = PuzzleType;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.SDebugQuests
// (Final, Exec, Native, Protected)
// Parameters:
// int32                              Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::SDebugQuests(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "SDebugQuests");

	Params::ASophiaController_SDebugQuests_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.SDebugPlayerProgression
// (Final, Exec, Native, Protected)
// Parameters:

void ASophiaController::SDebugPlayerProgression()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "SDebugPlayerProgression");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.SDebugCheckRefs
// (Final, Exec, Native, Protected, Const)
// Parameters:

void ASophiaController::SDebugCheckRefs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "SDebugCheckRefs");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.SCheatQuestObj
// (Final, Exec, Native, Protected)
// Parameters:

void ASophiaController::SCheatQuestObj()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "SCheatQuestObj");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.RosaryPercent
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Percent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::RosaryPercent(int32 Percent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "RosaryPercent");

	Params::ASophiaController_RosaryPercent_Params Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.PrintSandboxZonePuzzles
// (Final, Exec, Native, Protected, Const)
// Parameters:

void ASophiaController::PrintSandboxZonePuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "PrintSandboxZonePuzzles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.PrintRuneTypePerZone
// (Final, Exec, Native, Protected, Const)
// Parameters:

void ASophiaController::PrintRuneTypePerZone()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "PrintRuneTypePerZone");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.PrintPuzzleDatabaseInfo
// (Final, Exec, Native, Protected, Const)
// Parameters:

void ASophiaController::PrintPuzzleDatabaseInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "PrintPuzzleDatabaseInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.OnBeforePuzzleRemoved
// (Final, Native, Protected)
// Parameters:
// class APuzzleBase*                 Pb                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::OnBeforePuzzleRemoved(class APuzzleBase* Pb)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "OnBeforePuzzleRemoved");

	Params::ASophiaController_OnBeforePuzzleRemoved_Params Parms{};

	Parms.Pb = Pb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.MouseInGameWindow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaController::MouseInGameWindow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "MouseInGameWindow");

	Params::ASophiaController_MouseInGameWindow_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaController.KickLocalClient
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// bool                               bIsConquest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::KickLocalClient(bool bIsConquest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "KickLocalClient");

	Params::ASophiaController_KickLocalClient_Params Parms{};

	Parms.bIsConquest = bIsConquest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.IsWalkable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                  HitResult                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaController::IsWalkable(struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "IsWalkable");

	Params::ASophiaController_IsWalkable_Params Parms{};

	Parms.HitResult = HitResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaController.GetKrakenNickname
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASophiaController::GetKrakenNickname()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "GetKrakenNickname");

	Params::ASophiaController_GetKrakenNickname_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaController.Client_SendKrakenAuthInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void ASophiaController::Client_SendKrakenAuthInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Client_SendKrakenAuthInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Client_SendAnalyticsInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                      EventType                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Client_SendAnalyticsInfo(const class FString& EventType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Client_SendAnalyticsInfo");

	Params::ASophiaController_Client_SendAnalyticsInfo_Params Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Client_PrintMessage
// (Net, NetReliable, Native, Event, Protected, NetClient, Const)
// Parameters:
// class FString                      Msg                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::Client_PrintMessage(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Client_PrintMessage");

	Params::ASophiaController_Client_PrintMessage_Params Parms{};

	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.Client_DebugPlayerProgression
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                              Xp                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Gold                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Orbs                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                      MasteryValues                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaController::Client_DebugPlayerProgression(int32 Xp, int32 Gold, int32 Orbs, TArray<float>& MasteryValues)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "Client_DebugPlayerProgression");

	Params::ASophiaController_Client_DebugPlayerProgression_Params Parms{};

	Parms.Xp = Xp;
	Parms.Gold = Gold;
	Parms.Orbs = Orbs;
	Parms.MasteryValues = MasteryValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.ChangeShowPuzzlesCheatType
// (Final, Exec, Native, Protected, Const)
// Parameters:
// class FString                      PuzzleType                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::ChangeShowPuzzlesCheatType(const class FString& PuzzleType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "ChangeShowPuzzlesCheatType");

	Params::ASophiaController_ChangeShowPuzzlesCheatType_Params Parms{};

	Parms.PuzzleType = PuzzleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.ChangeShowPuzzlesCheatSolved
// (Final, Exec, Native, Protected, Const)
// Parameters:
// bool                               bSolved                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::ChangeShowPuzzlesCheatSolved(bool bSolved)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "ChangeShowPuzzlesCheatSolved");

	Params::ASophiaController_ChangeShowPuzzlesCheatSolved_Params Parms{};

	Parms.bSolved = bSolved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.BPC_SendAnalyticsEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      EventType                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::BPC_SendAnalyticsEvent(const class FString& EventType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BPC_SendAnalyticsEvent");

	Params::ASophiaController_BPC_SendAnalyticsEvent_Params Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaController.BPC_GetKrakenID
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASophiaController::BPC_GetKrakenID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BPC_GetKrakenID");

	Params::ASophiaController_BPC_GetKrakenID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaController.BP_ServerFPS
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::BP_ServerFPS(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BP_ServerFPS");

	Params::ASophiaController_BP_ServerFPS_Params Parms{};

	Parms.Index = Index;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaController.BP_RemovePartyInvite
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaController::BP_RemovePartyInvite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BP_RemovePartyInvite");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaController.BP_OnPartyInvite
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPartyInvite                Invite                                                           (Parm, NativeAccessSpecifierPublic)

void ASophiaController::BP_OnPartyInvite(const struct FPartyInvite& Invite)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BP_OnPartyInvite");

	Params::ASophiaController_BP_OnPartyInvite_Params Parms{};

	Parms.Invite = Invite;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaController.BP_KickClient
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bIsConquest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::BP_KickClient(bool bIsConquest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "BP_KickClient");

	Params::ASophiaController_BP_KickClient_Params Parms{};

	Parms.bIsConquest = bIsConquest;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaController.AddSandboxSpawnTimer
// (Final, Exec, Native, Protected, Const)
// Parameters:
// enum class EMainMapZoneName        ZoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PuzzleType                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaController::AddSandboxSpawnTimer(enum class EMainMapZoneName ZoneName, const class FString& PuzzleType, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaController", "AddSandboxSpawnTimer");

	Params::ASophiaController_AddSandboxSpawnTimer_Params Parms{};

	Parms.ZoneName = ZoneName;
	Parms.PuzzleType = PuzzleType;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaEditorFunctionalityInterface
// (None)

class UClass* ISophiaEditorFunctionalityInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaEditorFunctionalityInterface");

	return Clss;
}


// SophiaEditorFunctionalityInterface IslandsofInsight.Default__SophiaEditorFunctionalityInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ISophiaEditorFunctionalityInterface* ISophiaEditorFunctionalityInterface::GetDefaultObj()
{
	static class ISophiaEditorFunctionalityInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ISophiaEditorFunctionalityInterface*>(ISophiaEditorFunctionalityInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaEditorHelpers
// (None)

class UClass* USophiaEditorHelpers::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaEditorHelpers");

	return Clss;
}


// SophiaEditorHelpers IslandsofInsight.Default__SophiaEditorHelpers
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaEditorHelpers* USophiaEditorHelpers::GetDefaultObj()
{
	static class USophiaEditorHelpers* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaEditorHelpers*>(USophiaEditorHelpers::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaEmote
// (None)

class UClass* USophiaEmote::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaEmote");

	return Clss;
}


// SophiaEmote IslandsofInsight.Default__SophiaEmote
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaEmote* USophiaEmote::GetDefaultObj()
{
	static class USophiaEmote* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaEmote*>(USophiaEmote::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.EmoteData
// (None)

class UClass* UEmoteData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EmoteData");

	return Clss;
}


// EmoteData IslandsofInsight.Default__EmoteData
// (Public, ClassDefaultObject, ArchetypeObject)

class UEmoteData* UEmoteData::GetDefaultObj()
{
	static class UEmoteData* Default = nullptr;

	if (!Default)
		Default = static_cast<UEmoteData*>(UEmoteData::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaEngineSubsystem
// (None)

class UClass* USophiaEngineSubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaEngineSubsystem");

	return Clss;
}


// SophiaEngineSubsystem IslandsofInsight.Default__SophiaEngineSubsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaEngineSubsystem* USophiaEngineSubsystem::GetDefaultObj()
{
	static class USophiaEngineSubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaEngineSubsystem*>(USophiaEngineSubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaGameInstance
// (None)

class UClass* USophiaGameInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaGameInstance");

	return Clss;
}


// SophiaGameInstance IslandsofInsight.Default__SophiaGameInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaGameInstance* USophiaGameInstance::GetDefaultObj()
{
	static class USophiaGameInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaGameInstance*>(USophiaGameInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaGameInstance.UnlockEarnedCosmetic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::UnlockEarnedCosmetic(const class FString& KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "UnlockEarnedCosmetic");

	Params::USophiaGameInstance_UnlockEarnedCosmetic_Params Parms{};

	Parms.KrakenId = KrakenId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetValuesForEndgameScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::SetValuesForEndgameScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetValuesForEndgameScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetMouseYSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InVal                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetMouseYSensitivity(float InVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetMouseYSensitivity");

	Params::USophiaGameInstance_SetMouseYSensitivity_Params Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetMouseXSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InVal                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetMouseXSensitivity(float InVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetMouseXSensitivity");

	Params::USophiaGameInstance_SetMouseXSensitivity_Params Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetGameStartType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EGameStartType          InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetGameStartType(enum class EGameStartType InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetGameStartType");

	Params::USophiaGameInstance_SetGameStartType_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetFoliageClusterCullingDistancesFast
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                              Size1                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Dist1                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Size2                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Dist2                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Size3                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Dist3                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetFoliageClusterCullingDistancesFast(int32 Size1, int32 Dist1, int32 Size2, int32 Dist2, int32 Size3, int32 Dist3)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetFoliageClusterCullingDistancesFast");

	Params::USophiaGameInstance_SetFoliageClusterCullingDistancesFast_Params Parms{};

	Parms.Size1 = Size1;
	Parms.Dist1 = Dist1;
	Parms.Size2 = Size2;
	Parms.Dist2 = Dist2;
	Parms.Size3 = Size3;
	Parms.Dist3 = Dist3;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetControllerYSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InVal                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetControllerYSensitivity(float InVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetControllerYSensitivity");

	Params::USophiaGameInstance_SetControllerYSensitivity_Params Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetControllerXSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InVal                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetControllerXSensitivity(float InVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetControllerXSensitivity");

	Params::USophiaGameInstance_SetControllerXSensitivity_Params Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetConquestValuesOnMatchEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               GameOverOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetConquestValuesOnMatchEnd(bool GameOverOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetConquestValuesOnMatchEnd");

	Params::USophiaGameInstance_SetConquestValuesOnMatchEnd_Params Parms{};

	Parms.GameOverOverride = GameOverOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetConquestMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetConquestMode(int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetConquestMode");

	Params::USophiaGameInstance_SetConquestMode_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetBusVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetBusVolume(int32 Volume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetBusVolume");

	Params::USophiaGameInstance_SetBusVolume_Params Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.SetArrayBusVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFMODBus*>            InArray                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USophiaGameInstance::SetArrayBusVolume(int32 Volume, const TArray<class UFMODBus*>& InArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "SetArrayBusVolume");

	Params::USophiaGameInstance_SetArrayBusVolume_Params Parms{};

	Parms.Volume = Volume;
	Parms.InArray = InArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.RestartServer
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void USophiaGameInstance::RestartServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "RestartServer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.ReportPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ReportedPlayerId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Reasons                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Details                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::ReportPlayer(const class FString& ReportedPlayerId, const class FString& Reasons, const class FString& Details)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "ReportPlayer");

	Params::USophiaGameInstance_ReportPlayer_Params Parms{};

	Parms.ReportedPlayerId = ReportedPlayerId;
	Parms.Reasons = Reasons;
	Parms.Details = Details;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.PrintStringInTestBuild
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::PrintStringInTestBuild(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "PrintStringInTestBuild");

	Params::USophiaGameInstance_PrintStringInTestBuild_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.PlayLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bPlayUntilStopped                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PlayTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::PlayLoadingScreen(bool bPlayUntilStopped, float PlayTime, class FName PackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "PlayLoadingScreen");

	Params::USophiaGameInstance_PlayLoadingScreen_Params Parms{};

	Parms.bPlayUntilStopped = bPlayUntilStopped;
	Parms.PlayTime = PlayTime;
	Parms.PackageName = PackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.OnPingSuccess
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPingIP*                     PingIP                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Region                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Ping                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::OnPingSuccess(class UPingIP* PingIP, const class FString& Region, int32 Ping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "OnPingSuccess");

	Params::USophiaGameInstance_OnPingSuccess_Params Parms{};

	Parms.PingIP = PingIP;
	Parms.Region = Region;
	Parms.Ping = Ping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.OnPingFailed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPingIP*                     PingIP                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Region                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::OnPingFailed(class UPingIP* PingIP, const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "OnPingFailed");

	Params::USophiaGameInstance_OnPingFailed_Params Parms{};

	Parms.PingIP = PingIP;
	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.OnMapLoaded
// (Native, Public)
// Parameters:
// class UWorld*                      InLoadedWorld                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::OnMapLoaded(class UWorld* InLoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "OnMapLoaded");

	Params::USophiaGameInstance_OnMapLoaded_Params Parms{};

	Parms.InLoadedWorld = InLoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.LoadGeneralKrakenData
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::LoadGeneralKrakenData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "LoadGeneralKrakenData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.LeaveQueueForGameSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::LeaveQueueForGameSession()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "LeaveQueueForGameSession");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.KrakenHeartbeatFailed
// (Final, Native, Public)
// Parameters:
// struct FOnlineServiceError         Error                                                            (Parm, NativeAccessSpecifierPublic)

void USophiaGameInstance::KrakenHeartbeatFailed(const struct FOnlineServiceError& Error)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "KrakenHeartbeatFailed");

	Params::USophiaGameInstance_KrakenHeartbeatFailed_Params Parms{};

	Parms.Error = Error;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.IsTestOrShippingBuild
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameInstance::IsTestOrShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "IsTestOrShippingBuild");

	Params::USophiaGameInstance_IsTestOrShippingBuild_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.IsStringLesserThen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameInstance::IsStringLesserThen(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "IsStringLesserThen");

	Params::USophiaGameInstance_IsStringLesserThen_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.IsFTUE
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameInstance::IsFTUE()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "IsFTUE");

	Params::USophiaGameInstance_IsFTUE_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.InvalidateActorCaches
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::InvalidateActorCaches()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "InvalidateActorCaches");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.InitQueueForGameSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::InitQueueForGameSession()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "InitQueueForGameSession");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.InitLoadingScreens
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::InitLoadingScreens()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "InitLoadingScreens");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.InitHardwareBenchmark
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              CPUValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GPUValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              WorkScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CPUMultiplier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GPUMultiplier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::InitHardwareBenchmark(float* CPUValue, float* GPUValue, int32 WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "InitHardwareBenchmark");

	Params::USophiaGameInstance_InitHardwareBenchmark_Params Parms{};

	Parms.WorkScale = WorkScale;
	Parms.CPUMultiplier = CPUMultiplier;
	Parms.GPUMultiplier = GPUMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CPUValue != nullptr)
		*CPUValue = Parms.CPUValue;

	if (GPUValue != nullptr)
		*GPUValue = Parms.GPUValue;

}


// Function IslandsofInsight.SophiaGameInstance.InitCustomizationMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::InitCustomizationMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "InitCustomizationMap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.GetNetworkURL
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameInstance::GetNetworkURL(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "GetNetworkURL");

	Params::USophiaGameInstance_GetNetworkURL_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.GetKrakenNickname
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlayerProgressionData      Data                                                             (Parm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameInstance::GetKrakenNickname(const struct FPlayerProgressionData& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "GetKrakenNickname");

	Params::USophiaGameInstance_GetKrakenNickname_Params Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.GetKrakenID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlayerProgressionData      Data                                                             (Parm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameInstance::GetKrakenID(const struct FPlayerProgressionData& Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "GetKrakenID");

	Params::USophiaGameInstance_GetKrakenID_Params Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.GetGameViewportSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USophiaGameInstance::GetGameViewportSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "GetGameViewportSize");

	Params::USophiaGameInstance_GetGameViewportSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.GetGameResolution
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USophiaGameInstance::GetGameResolution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "GetGameResolution");

	Params::USophiaGameInstance_GetGameResolution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.ForceStopLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USophiaGameInstance::ForceStopLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "ForceStopLoadingScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.FetchKrakenHeartbeat
// (Final, Native, Public)
// Parameters:

void USophiaGameInstance::FetchKrakenHeartbeat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "FetchKrakenHeartbeat");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.CreateSurveyPrompt
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FText                        PromptText                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UParameterizedUrl*           URL                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::CreateSurveyPrompt(class FText& PromptText, class UParameterizedUrl* URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "CreateSurveyPrompt");

	Params::USophiaGameInstance_CreateSurveyPrompt_Params Parms{};

	Parms.PromptText = PromptText;
	Parms.URL = URL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.ChangeMap
// (Final, Native, Public)
// Parameters:
// class FName                        MapName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::ChangeMap(class FName MapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "ChangeMap");

	Params::USophiaGameInstance_ChangeMap_Params Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_TutorialWidget
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class UUserWidget>     WidgetClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_TutorialWidget(TSubclassOf<class UUserWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_TutorialWidget");

	Params::USophiaGameInstance_BPI_TutorialWidget_Params Parms{};

	Parms.WidgetClass = WidgetClass;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_TryJoinServerFromSaveData
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BPI_TryJoinServerFromSaveData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_TryJoinServerFromSaveData");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_TryJoinServerFromMenu
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FBlueprintSessionResult     RSession                                                         (Parm, NativeAccessSpecifierPublic)
// class UMainMenu*                   Menu                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_TryJoinServerFromMenu(const struct FBlueprintSessionResult& RSession, class UMainMenu* Menu)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_TryJoinServerFromMenu");

	Params::USophiaGameInstance_BPI_TryJoinServerFromMenu_Params Parms{};

	Parms.RSession = RSession;
	Parms.Menu = Menu;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_StoreGameInstanceValuesAndSwapServer
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      ServerName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              GainedXP                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPartyJoin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_StoreGameInstanceValuesAndSwapServer(const class FString& ServerName, int32 GainedXP, bool bPartyJoin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_StoreGameInstanceValuesAndSwapServer");

	Params::USophiaGameInstance_BPI_StoreGameInstanceValuesAndSwapServer_Params Parms{};

	Parms.ServerName = ServerName;
	Parms.GainedXP = GainedXP;
	Parms.bPartyJoin = bPartyJoin;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_ShortenMapName
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameInstance::BPI_ShortenMapName(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_ShortenMapName");

	Params::USophiaGameInstance_BPI_ShortenMapName_Params Parms{};

	Parms.String = String;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_SaveCharacterData
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               Sex                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SkinIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*               Skin                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_SaveCharacterData(bool Sex, int32 SkinIndex, class USkeletalMesh* Skin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_SaveCharacterData");

	Params::USophiaGameInstance_BPI_SaveCharacterData_Params Parms{};

	Parms.Sex = Sex;
	Parms.SkinIndex = SkinIndex;
	Parms.Skin = Skin;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_RefreshServer
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      ServerName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPartyJoin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_RefreshServer(const class FString& ServerName, bool bPartyJoin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_RefreshServer");

	Params::USophiaGameInstance_BPI_RefreshServer_Params Parms{};

	Parms.ServerName = ServerName;
	Parms.bPartyJoin = bPartyJoin;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_OnServerInviteSent
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BPI_OnServerInviteSent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_OnServerInviteSent");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_OnInvitedToJoinServer
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      ID                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_OnInvitedToJoinServer(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_OnInvitedToJoinServer");

	Params::USophiaGameInstance_BPI_OnInvitedToJoinServer_Params Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_LoadCharacterData
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               Sex                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SkinIndex                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*               Skin                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_LoadCharacterData(bool* Sex, int32* SkinIndex, class USkeletalMesh** Skin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_LoadCharacterData");

	Params::USophiaGameInstance_BPI_LoadCharacterData_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	if (Sex != nullptr)
		*Sex = Parms.Sex;

	if (SkinIndex != nullptr)
		*SkinIndex = Parms.SkinIndex;

	if (Skin != nullptr)
		*Skin = Parms.Skin;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_JoinSession
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FBlueprintSessionResult     RSession                                                         (Parm, NativeAccessSpecifierPublic)
// class UMainMenu*                   InMenu                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPartyJoin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      MapName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_JoinSession(const struct FBlueprintSessionResult& RSession, class UMainMenu* InMenu, bool bPartyJoin, const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_JoinSession");

	Params::USophiaGameInstance_BPI_JoinSession_Params Parms{};

	Parms.RSession = RSession;
	Parms.InMenu = InMenu;
	Parms.bPartyJoin = bPartyJoin;
	Parms.MapName = MapName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_IsFTUE
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameInstance::BPI_IsFTUE()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_IsFTUE");

	Params::USophiaGameInstance_BPI_IsFTUE_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_GetCustomizationAsset
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterCustomizationDataAsset*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCustomizationDataAsset* USophiaGameInstance::BPI_GetCustomizationAsset(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_GetCustomizationAsset");

	Params::USophiaGameInstance_BPI_GetCustomizationAsset_Params Parms{};

	Parms.Index = Index;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_GetCurrentHorizontalFOVs
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              FOV                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ZoomFOV                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_GetCurrentHorizontalFOVs(float* FOV, float* ZoomFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_GetCurrentHorizontalFOVs");

	Params::USophiaGameInstance_BPI_GetCurrentHorizontalFOVs_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	if (FOV != nullptr)
		*FOV = Parms.FOV;

	if (ZoomFOV != nullptr)
		*ZoomFOV = Parms.ZoomFOV;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_FindGameLiftServer
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BPI_FindGameLiftServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_FindGameLiftServer");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_DestroySession
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UWorld>       Level                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BPI_DestroySession(TSoftObjectPtr<class UWorld>& Level)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_DestroySession");

	Params::USophiaGameInstance_BPI_DestroySession_Params Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BPI_CreateServerExtraSettings
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                      ServerName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ServerMapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSessionPropertyKeyPair>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSessionPropertyKeyPair> USophiaGameInstance::BPI_CreateServerExtraSettings(const class FString& ServerName, const class FString& ServerMapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_CreateServerExtraSettings");

	Params::USophiaGameInstance_BPI_CreateServerExtraSettings_Params Parms{};

	Parms.ServerName = ServerName;
	Parms.ServerMapName = ServerMapName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_ConvertMapNames
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameInstance::BPI_ConvertMapNames(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_ConvertMapNames");

	Params::USophiaGameInstance_BPI_ConvertMapNames_Params Parms{};

	Parms.String = String;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BPI_AutoDetectQualitySettings
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BPI_AutoDetectQualitySettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPI_AutoDetectQualitySettings");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BPC_GetPatchNotesByLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FString, class FString> ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> USophiaGameInstance::BPC_GetPatchNotesByLanguage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BPC_GetPatchNotesByLanguage");

	Params::USophiaGameInstance_BPC_GetPatchNotesByLanguage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameInstance.BP_PreMapLoad
// (Event, Public, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BP_PreMapLoad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_PreMapLoad");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BP_PostMapLoad
// (Event, Public, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BP_PostMapLoad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_PostMapLoad");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BP_PlayFakeLoadingScreen
// (Event, Public, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BP_PlayFakeLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_PlayFakeLoadingScreen");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BP_OnKrakenLoginFailed
// (Event, Public, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BP_OnKrakenLoginFailed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_OnKrakenLoginFailed");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BP_GetSteamAvatar
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                      SteamID                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BP_GetSteamAvatar(const class FString& SteamID, const class FString& KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_GetSteamAvatar");

	Params::USophiaGameInstance_BP_GetSteamAvatar_Params Parms{};

	Parms.SteamID = SteamID;
	Parms.KrakenId = KrakenId;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaGameInstance.BP_DoVideoSettingsCorrection
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void USophiaGameInstance::BP_DoVideoSettingsCorrection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BP_DoVideoSettingsCorrection");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.SophiaGameInstance.BenchmarkAndReturnSuggestedSettings
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// float                              CPUScore                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GPUScore                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ResolutionScale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ViewDistance                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              GeometryDetail                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PostProcessing                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Shadows                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Textures                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Effects                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Foliage                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Shaders                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SSGI                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              VolumetricFog                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BenchmarkAndReturnSuggestedSettings(float* CPUScore, float* GPUScore, int32* ResolutionScale, int32* ViewDistance, int32* GeometryDetail, int32* PostProcessing, int32* Shadows, int32* Textures, int32* Effects, int32* Foliage, int32* Shaders, int32* SSGI, int32* VolumetricFog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BenchmarkAndReturnSuggestedSettings");

	Params::USophiaGameInstance_BenchmarkAndReturnSuggestedSettings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CPUScore != nullptr)
		*CPUScore = Parms.CPUScore;

	if (GPUScore != nullptr)
		*GPUScore = Parms.GPUScore;

	if (ResolutionScale != nullptr)
		*ResolutionScale = Parms.ResolutionScale;

	if (ViewDistance != nullptr)
		*ViewDistance = Parms.ViewDistance;

	if (GeometryDetail != nullptr)
		*GeometryDetail = Parms.GeometryDetail;

	if (PostProcessing != nullptr)
		*PostProcessing = Parms.PostProcessing;

	if (Shadows != nullptr)
		*Shadows = Parms.Shadows;

	if (Textures != nullptr)
		*Textures = Parms.Textures;

	if (Effects != nullptr)
		*Effects = Parms.Effects;

	if (Foliage != nullptr)
		*Foliage = Parms.Foliage;

	if (Shaders != nullptr)
		*Shaders = Parms.Shaders;

	if (SSGI != nullptr)
		*SSGI = Parms.SSGI;

	if (VolumetricFog != nullptr)
		*VolumetricFog = Parms.VolumetricFog;

}


// Function IslandsofInsight.SophiaGameInstance.BeginLoadingScreen
// (Native, Public)
// Parameters:
// class FString                      MapName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaGameInstance::BeginLoadingScreen(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameInstance", "BeginLoadingScreen");

	Params::USophiaGameInstance_BeginLoadingScreen_Params Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaGameplayStatics
// (None)

class UClass* USophiaGameplayStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaGameplayStatics");

	return Clss;
}


// SophiaGameplayStatics IslandsofInsight.Default__SophiaGameplayStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaGameplayStatics* USophiaGameplayStatics::GetDefaultObj()
{
	static class USophiaGameplayStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaGameplayStatics*>(USophiaGameplayStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaGameplayStatics.RandomNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USophiaGameplayStatics::RandomNormal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "RandomNormal");

	Params::USophiaGameplayStatics_RandomNormal_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.PuzzleCategoryToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USophiaGameplayStatics::PuzzleCategoryToText(class UObject* WorldContextObject, enum class EPuzzleCategory Category)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "PuzzleCategoryToText");

	Params::USophiaGameplayStatics_PuzzleCategoryToText_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.PuzzleCategoryToImage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USophiaGameplayStatics::PuzzleCategoryToImage(class UObject* WorldContextObject, enum class EPuzzleCategory Category)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "PuzzleCategoryToImage");

	Params::USophiaGameplayStatics_PuzzleCategoryToImage_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.PuzzleCategoryToBackgroundImage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USophiaGameplayStatics::PuzzleCategoryToBackgroundImage(class UObject* WorldContextObject, enum class EPuzzleCategory Category)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "PuzzleCategoryToBackgroundImage");

	Params::USophiaGameplayStatics_PuzzleCategoryToBackgroundImage_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.LocalPlayerIsInDevMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameplayStatics::LocalPlayerIsInDevMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "LocalPlayerIsInDevMode");

	Params::USophiaGameplayStatics_LocalPlayerIsInDevMode_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetZoneData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UZoneData*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UZoneData* USophiaGameplayStatics::GetZoneData(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetZoneData");

	Params::USophiaGameplayStatics_GetZoneData_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetTimeSyncedWithMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bIsForUIMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                      ReferenceWorld                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReferenceActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USophiaGameplayStatics::GetTimeSyncedWithMaterials(bool bIsForUIMaterial, class UWorld* ReferenceWorld, class AActor* ReferenceActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetTimeSyncedWithMaterials");

	Params::USophiaGameplayStatics_GetTimeSyncedWithMaterials_Params Parms{};

	Parms.bIsForUIMaterial = bIsForUIMaterial;
	Parms.ReferenceWorld = ReferenceWorld;
	Parms.ReferenceActor = ReferenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetSandboxProgressionDataOriginalInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USandboxProgressionData*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USandboxProgressionData* USophiaGameplayStatics::GetSandboxProgressionDataOriginalInfo(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetSandboxProgressionDataOriginalInfo");

	Params::USophiaGameplayStatics_GetSandboxProgressionDataOriginalInfo_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPuzzleDefaultTypeInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenIdentifier                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPuzzleTypeData             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPuzzleTypeData USophiaGameplayStatics::GetPuzzleDefaultTypeInfo(class UObject* WorldContextObject, const class FString& KrakenIdentifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPuzzleDefaultTypeInfo");

	Params::USophiaGameplayStatics_GetPuzzleDefaultTypeInfo_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KrakenIdentifier = KrakenIdentifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPuzzleDatabase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPuzzleDatabase*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPuzzleDatabase* USophiaGameplayStatics::GetPuzzleDatabase(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPuzzleDatabase");

	Params::USophiaGameplayStatics_GetPuzzleDatabase_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPuzzleData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              KrakenId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPuzzleData*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPuzzleData* USophiaGameplayStatics::GetPuzzleData(class UObject* WorldContextObject, int32 KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPuzzleData");

	Params::USophiaGameplayStatics_GetPuzzleData_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KrakenId = KrakenId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPlayerSkillLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SkillName                                                        (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USophiaGameplayStatics::GetPlayerSkillLevel(class ASophiaCharacter* Player, const class FString& SkillName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPlayerSkillLevel");

	Params::USophiaGameplayStatics_GetPlayerSkillLevel_Params Parms{};

	Parms.Player = Player;
	Parms.SkillName = SkillName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPlayerSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                      World                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkill*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkill* USophiaGameplayStatics::GetPlayerSkill(class UWorld* World, const class FString& SkillName, class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPlayerSkill");

	Params::USophiaGameplayStatics_GetPlayerSkill_Params Parms{};

	Parms.World = World;
	Parms.SkillName = SkillName;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetPlayerCurrentZone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EMainMapZoneName USophiaGameplayStatics::GetPlayerCurrentZone(class ASophiaCharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetPlayerCurrentZone");

	Params::USophiaGameplayStatics_GetPlayerCurrentZone_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetDifferenceBetweenJsons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      JsonString1                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      JsonString2                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaGameplayStatics::GetDifferenceBetweenJsons(const class FString& JsonString1, const class FString& JsonString2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetDifferenceBetweenJsons");

	Params::USophiaGameplayStatics_GetDifferenceBetweenJsons_Params Parms{};

	Parms.JsonString1 = JsonString1;
	Parms.JsonString2 = JsonString2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetAllDisplayTypeCategoriesForPuzzleTypes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              KrakenTypeIDs                                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<enum class EPuzzleCategory> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<enum class EPuzzleCategory> USophiaGameplayStatics::GetAllDisplayTypeCategoriesForPuzzleTypes(class UObject* WorldContextObject, const TArray<class FString>& KrakenTypeIDs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetAllDisplayTypeCategoriesForPuzzleTypes");

	Params::USophiaGameplayStatics_GetAllDisplayTypeCategoriesForPuzzleTypes_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KrakenTypeIDs = KrakenTypeIDs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.GetActiveRewardLevelForPuzzleCategory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASophiaCharacter*            Player                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSandboxProgressionRewardDataOutRewardData                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                              OutSolvedPuzzleCount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutTargetPuzzleCount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameplayStatics::GetActiveRewardLevelForPuzzleCategory(class ASophiaCharacter* Player, enum class EPuzzleCategory PuzzleCategory, enum class EMainMapZoneName ZONE, struct FSandboxProgressionRewardData* OutRewardData, int32* OutSolvedPuzzleCount, int32* OutTargetPuzzleCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "GetActiveRewardLevelForPuzzleCategory");

	Params::USophiaGameplayStatics_GetActiveRewardLevelForPuzzleCategory_Params Parms{};

	Parms.Player = Player;
	Parms.PuzzleCategory = PuzzleCategory;
	Parms.ZONE = ZONE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRewardData != nullptr)
		*OutRewardData = std::move(Parms.OutRewardData);

	if (OutSolvedPuzzleCount != nullptr)
		*OutSolvedPuzzleCount = Parms.OutSolvedPuzzleCount;

	if (OutTargetPuzzleCount != nullptr)
		*OutTargetPuzzleCount = Parms.OutTargetPuzzleCount;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.FileSaveString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Filename                                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameplayStatics::FileSaveString(const class FString& Filename, const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "FileSaveString");

	Params::USophiaGameplayStatics_FileSaveString_Params Parms{};

	Parms.Filename = Filename;
	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaGameplayStatics.FileLoadString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Filename                                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaGameplayStatics::FileLoadString(const class FString& Filename, class FString* Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaGameplayStatics", "FileLoadString");

	Params::USophiaGameplayStatics_FileLoadString_Params Parms{};

	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SophiaGameViewportClient
// (None)

class UClass* USophiaGameViewportClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaGameViewportClient");

	return Clss;
}


// SophiaGameViewportClient IslandsofInsight.Default__SophiaGameViewportClient
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaGameViewportClient* USophiaGameViewportClient::GetDefaultObj()
{
	static class USophiaGameViewportClient* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaGameViewportClient*>(USophiaGameViewportClient::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaHUD
// (Actor)

class UClass* ASophiaHUD::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaHUD");

	return Clss;
}


// SophiaHUD IslandsofInsight.Default__SophiaHUD
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaHUD* ASophiaHUD::GetDefaultObj()
{
	static class ASophiaHUD* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaHUD*>(ASophiaHUD::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaHUD.SetCursorMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                              Option                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaHUD::SetCursorMode(uint8 Option)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaHUD", "SetCursorMode");

	Params::ASophiaHUD_SetCursorMode_Params Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaHUD.GetCurrentCursorMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECursorMode             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECursorMode ASophiaHUD::GetCurrentCursorMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaHUD", "GetCurrentCursorMode");

	Params::ASophiaHUD_GetCurrentCursorMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaHUD.BPI_StopCutscene
// (Event, Public, BlueprintEvent)
// Parameters:

void ASophiaHUD::BPI_StopCutscene()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaHUD", "BPI_StopCutscene");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SophiaInputComponent
// (None)

class UClass* USophiaInputComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaInputComponent");

	return Clss;
}


// SophiaInputComponent IslandsofInsight.Default__SophiaInputComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaInputComponent* USophiaInputComponent::GetDefaultObj()
{
	static class USophiaInputComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaInputComponent*>(USophiaInputComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaInputComponent.DoActionIfBound
// (Final, Native, Private)
// Parameters:
// FDelegateProperty_                 Action                                                           (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void USophiaInputComponent::DoActionIfBound(FDelegateProperty_ Action)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaInputComponent", "DoActionIfBound");

	Params::USophiaInputComponent_DoActionIfBound_Params Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaInputComponent.DisableInput
// (Final, Native, Public)
// Parameters:

void USophiaInputComponent::DisableInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaInputComponent", "DisableInput");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaInputComponent.BP_BindAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ActionName                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EInputEvent             KeyEvent                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FDelegateProperty_                 Action                                                           (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void USophiaInputComponent::BP_BindAction(class FName ActionName, enum class EInputEvent KeyEvent, FDelegateProperty_ Action)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaInputComponent", "BP_BindAction");

	Params::USophiaInputComponent_BP_BindAction_Params Parms{};

	Parms.ActionName = ActionName;
	Parms.KeyEvent = KeyEvent;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaLevelLibrary
// (None)

class UClass* USophiaLevelLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaLevelLibrary");

	return Clss;
}


// SophiaLevelLibrary IslandsofInsight.Default__SophiaLevelLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaLevelLibrary* USophiaLevelLibrary::GetDefaultObj()
{
	static class USophiaLevelLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaLevelLibrary*>(USophiaLevelLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaLevelLibrary.PopulateGemsForOpenEditorWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void USophiaLevelLibrary::PopulateGemsForOpenEditorWorld()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaLevelLibrary", "PopulateGemsForOpenEditorWorld");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaLevelScriptActor
// (Actor)

class UClass* ASophiaLevelScriptActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaLevelScriptActor");

	return Clss;
}


// SophiaLevelScriptActor IslandsofInsight.Default__SophiaLevelScriptActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaLevelScriptActor* ASophiaLevelScriptActor::GetDefaultObj()
{
	static class ASophiaLevelScriptActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaLevelScriptActor*>(ASophiaLevelScriptActor::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaOnlineBeaconHostObject
// (Actor)

class UClass* ASophiaOnlineBeaconHostObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaOnlineBeaconHostObject");

	return Clss;
}


// SophiaOnlineBeaconHostObject IslandsofInsight.Default__SophiaOnlineBeaconHostObject
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaOnlineBeaconHostObject* ASophiaOnlineBeaconHostObject::GetDefaultObj()
{
	static class ASophiaOnlineBeaconHostObject* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaOnlineBeaconHostObject*>(ASophiaOnlineBeaconHostObject::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaPartyBeaconClient
// (Actor)

class UClass* ASophiaPartyBeaconClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaPartyBeaconClient");

	return Clss;
}


// SophiaPartyBeaconClient IslandsofInsight.Default__SophiaPartyBeaconClient
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaPartyBeaconClient* ASophiaPartyBeaconClient::GetDefaultObj()
{
	static class ASophiaPartyBeaconClient* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaPartyBeaconClient*>(ASophiaPartyBeaconClient::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaPartyBeaconClient.ConnectToSever
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Address                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaPartyBeaconClient::ConnectToSever(const class FString& Address)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPartyBeaconClient", "ConnectToSever");

	Params::ASophiaPartyBeaconClient_ConnectToSever_Params Parms{};

	Parms.Address = Address;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SophiaPlayerState
// (Actor)

class UClass* ASophiaPlayerState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaPlayerState");

	return Clss;
}


// SophiaPlayerState IslandsofInsight.Default__SophiaPlayerState
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaPlayerState* ASophiaPlayerState::GetDefaultObj()
{
	static class ASophiaPlayerState* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaPlayerState*>(ASophiaPlayerState::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaPlayerState.SetTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                              InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::SetTeam(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "SetTeam");

	Params::ASophiaPlayerState_SetTeam_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.SetDevMode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               DevMode                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaPlayerState::SetDevMode(bool DevMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "SetDevMode");

	Params::ASophiaPlayerState_SetDevMode_Params Parms{};

	Parms.DevMode = DevMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.Server_UpgradeSkill
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldCheckValid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_UpgradeSkill(const class FString& SkillName, bool bShouldCheckValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_UpgradeSkill");

	Params::ASophiaPlayerState_Server_UpgradeSkill_Params Parms{};

	Parms.SkillName = SkillName;
	Parms.bShouldCheckValid = bShouldCheckValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_UnlockMasteryRewards
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      KrakenAchievementId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_UnlockMasteryRewards(const class FString& KrakenAchievementId, struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_UnlockMasteryRewards");

	Params::ASophiaPlayerState_Server_UnlockMasteryRewards_Params Parms{};

	Parms.KrakenAchievementId = KrakenAchievementId;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_SetTeam
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint8                              InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_SetTeam(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_SetTeam");

	Params::ASophiaPlayerState_Server_SetTeam_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_SetNamePrefix
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      NewPrefix                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Rank                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_SetNamePrefix(const class FString& NewPrefix, int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_SetNamePrefix");

	Params::ASophiaPlayerState_Server_SetNamePrefix_Params Parms{};

	Parms.NewPrefix = NewPrefix;
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_SetIsReadyToStartMatch
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                               ShouldStartMatch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_SetIsReadyToStartMatch(bool ShouldStartMatch)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_SetIsReadyToStartMatch");

	Params::ASophiaPlayerState_Server_SetIsReadyToStartMatch_Params Parms{};

	Parms.ShouldStartMatch = ShouldStartMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_SetDevMode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                               DevMode                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_SetDevMode(bool DevMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_SetDevMode");

	Params::ASophiaPlayerState_Server_SetDevMode_Params Parms{};

	Parms.DevMode = DevMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_SendBondThanks
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASophiaPlayerState*          Helper                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_SendBondThanks(class ASophiaPlayerState* Helper)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_SendBondThanks");

	Params::ASophiaPlayerState_Server_SendBondThanks_Params Parms{};

	Parms.Helper = Helper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_ConfirmStartReceivingPuzzleData
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:

void ASophiaPlayerState::Server_ConfirmStartReceivingPuzzleData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_ConfirmStartReceivingPuzzleData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_ClaimSandboxRewards
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// enum class EMainMapZoneName        ZONE                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPuzzleCategory         PuzzleCategory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_ClaimSandboxRewards(enum class EMainMapZoneName ZONE, enum class EPuzzleCategory PuzzleCategory, struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_ClaimSandboxRewards");

	Params::ASophiaPlayerState_Server_ClaimSandboxRewards_Params Parms{};

	Parms.ZONE = ZONE;
	Parms.PuzzleCategory = PuzzleCategory;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_ClaimGlobalMasteryReward
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                              RewardLevel                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBhvrAnalyticsEvent_Base    Event                                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_ClaimGlobalMasteryReward(int32 RewardLevel, struct FBhvrAnalyticsEvent_Base& Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_ClaimGlobalMasteryReward");

	Params::ASophiaPlayerState_Server_ClaimGlobalMasteryReward_Params Parms{};

	Parms.RewardLevel = RewardLevel;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_CheatSetCheatValueOnSkill
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_CheatSetCheatValueOnSkill(const class FString& SkillName, int32 Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_CheatSetCheatValueOnSkill");

	Params::ASophiaPlayerState_Server_CheatSetCheatValueOnSkill_Params Parms{};

	Parms.SkillName = SkillName;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_CheatSetCheatEnabledOnSkill
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                      SkillName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Server_CheatSetCheatEnabledOnSkill(const class FString& SkillName, bool Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_CheatSetCheatEnabledOnSkill");

	Params::ASophiaPlayerState_Server_CheatSetCheatEnabledOnSkill_Params Parms{};

	Parms.SkillName = SkillName;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Server_AcceptSpawnSerializedPuzzles
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:

void ASophiaPlayerState::Server_AcceptSpawnSerializedPuzzles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Server_AcceptSpawnSerializedPuzzles");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.OnRep_PlayerPower
// (Final, Native, Private, Const)
// Parameters:
// int32                              Old                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::OnRep_PlayerPower(int32 Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "OnRep_PlayerPower");

	Params::ASophiaPlayerState_OnRep_PlayerPower_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ASophiaPlayerState::GetTeam()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "GetTeam");

	Params::ASophiaPlayerState_GetTeam_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.GetReadyToStartMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASophiaPlayerState::GetReadyToStartMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "GetReadyToStartMatch");

	Params::ASophiaPlayerState_GetReadyToStartMatch_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.GetPlayerWisdom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASophiaPlayerState::GetPlayerWisdom()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "GetPlayerWisdom");

	Params::ASophiaPlayerState_GetPlayerWisdom_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.GetNicknameID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASophiaPlayerState::GetNicknameID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "GetNicknameID");

	Params::ASophiaPlayerState_GetNicknameID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.GetKrakenID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASophiaPlayerState::GetKrakenID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "GetKrakenID");

	Params::ASophiaPlayerState_GetKrakenID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaPlayerState.EquipMastery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlayerMastery*              Mastery                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::EquipMastery(class UPlayerMastery* Mastery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "EquipMastery");

	Params::ASophiaPlayerState_EquipMastery_Params Parms{};

	Parms.Mastery = Mastery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_SpawnSerializedPuzzles
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// TArray<class FString>              SerializedDatas                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>              NameOverrides                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_SpawnSerializedPuzzles(TArray<class FString>& SerializedDatas, TArray<class FString>& NameOverrides)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_SpawnSerializedPuzzles");

	Params::ASophiaPlayerState_Client_SpawnSerializedPuzzles_Params Parms{};

	Parms.SerializedDatas = SerializedDatas;
	Parms.NameOverrides = NameOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_ReceiveSpawnedWorldPuzzleInfos
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class USandboxZone*                ZONE                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSpawnedWorldPuzzleInfo>SpawnedPuzzlesInfo                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Version                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TotalNum                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_ReceiveSpawnedWorldPuzzleInfos(class USandboxZone* ZONE, TArray<struct FSpawnedWorldPuzzleInfo>& SpawnedPuzzlesInfo, int32 Version, int32 TotalNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_ReceiveSpawnedWorldPuzzleInfos");

	Params::ASophiaPlayerState_Client_ReceiveSpawnedWorldPuzzleInfos_Params Parms{};

	Parms.ZONE = ZONE;
	Parms.SpawnedPuzzlesInfo = SpawnedPuzzlesInfo;
	Parms.Version = Version;
	Parms.TotalNum = TotalNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_ReceiveSpawnedContainersInfos
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class USandboxZone*                ZONE                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FContainerAndContainedPuzzleInfo>SpawnedPuzzlesInfo                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Version                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TotalNum                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_ReceiveSpawnedContainersInfos(class USandboxZone* ZONE, TArray<struct FContainerAndContainedPuzzleInfo>& SpawnedPuzzlesInfo, int32 Version, int32 TotalNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_ReceiveSpawnedContainersInfos");

	Params::ASophiaPlayerState_Client_ReceiveSpawnedContainersInfos_Params Parms{};

	Parms.ZONE = ZONE;
	Parms.SpawnedPuzzlesInfo = SpawnedPuzzlesInfo;
	Parms.Version = Version;
	Parms.TotalNum = TotalNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_ReceivedBondThanks
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ASophiaPlayerState*          Helpee                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_ReceivedBondThanks(class ASophiaPlayerState* Helpee)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_ReceivedBondThanks");

	Params::ASophiaPlayerState_Client_ReceivedBondThanks_Params Parms{};

	Parms.Helpee = Helpee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_completePuzzle
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class APuzzleBase*                 Completed                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RandomValue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_completePuzzle(class APuzzleBase* Completed, float RandomValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_completePuzzle");

	Params::ASophiaPlayerState_Client_completePuzzle_Params Parms{};

	Parms.Completed = Completed;
	Parms.RandomValue = RandomValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.Client_AddPlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APlayerState*                PS                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::Client_AddPlayer(class APlayerState* PS)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "Client_AddPlayer");

	Params::ASophiaPlayerState_Client_AddPlayer_Params Parms{};

	Parms.PS = PS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaPlayerState.BPI_AskSolveTogether
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASophiaPlayerState*          OtherPlayer                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::BPI_AskSolveTogether(class ASophiaPlayerState* OtherPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "BPI_AskSolveTogether");

	Params::ASophiaPlayerState_BPI_AskSolveTogether_Params Parms{};

	Parms.OtherPlayer = OtherPlayer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function IslandsofInsight.SophiaPlayerState.BP_AskTravelWithParty
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                      IP                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASophiaPlayerState::BP_AskTravelWithParty(const class FString& IP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaPlayerState", "BP_AskTravelWithParty");

	Params::ASophiaPlayerState_BP_AskTravelWithParty_Params Parms{};

	Parms.IP = IP;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.SophiaPostProcessVolume
// (Actor)

class UClass* ASophiaPostProcessVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaPostProcessVolume");

	return Clss;
}


// SophiaPostProcessVolume IslandsofInsight.Default__SophiaPostProcessVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaPostProcessVolume* ASophiaPostProcessVolume::GetDefaultObj()
{
	static class ASophiaPostProcessVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaPostProcessVolume*>(ASophiaPostProcessVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog
// (None)

class UClass* UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog");

	return Clss;
}


// ReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog IslandsofInsight.Default__ReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog
// (Public, ClassDefaultObject, ArchetypeObject)

class UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog* UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog::GetDefaultObj()
{
	static class UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog* Default = nullptr;

	if (!Default)
		Default = static_cast<UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog*>(UReplicationGraphNode_AlwaysRelevant_ForConnection_WithLog::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaReplicationGraph
// (None)

class UClass* USophiaReplicationGraph::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaReplicationGraph");

	return Clss;
}


// SophiaReplicationGraph IslandsofInsight.Default__SophiaReplicationGraph
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaReplicationGraph* USophiaReplicationGraph::GetDefaultObj()
{
	static class USophiaReplicationGraph* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaReplicationGraph*>(USophiaReplicationGraph::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaScrollBox
// (None)

class UClass* USophiaScrollBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaScrollBox");

	return Clss;
}


// SophiaScrollBox IslandsofInsight.Default__SophiaScrollBox
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaScrollBox* USophiaScrollBox::GetDefaultObj()
{
	static class USophiaScrollBox* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaScrollBox*>(USophiaScrollBox::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaScrollBox.IsScrollBarCollapsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaScrollBox::IsScrollBarCollapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaScrollBox", "IsScrollBarCollapsed");

	Params::USophiaScrollBox_IsScrollBarCollapsed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SophiaSerializableObjectInterface
// (None)

class UClass* ISophiaSerializableObjectInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaSerializableObjectInterface");

	return Clss;
}


// SophiaSerializableObjectInterface IslandsofInsight.Default__SophiaSerializableObjectInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ISophiaSerializableObjectInterface* ISophiaSerializableObjectInterface::GetDefaultObj()
{
	static class ISophiaSerializableObjectInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ISophiaSerializableObjectInterface*>(ISophiaSerializableObjectInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaSpringArmComponent
// (SceneComponent)

class UClass* USophiaSpringArmComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaSpringArmComponent");

	return Clss;
}


// SophiaSpringArmComponent IslandsofInsight.Default__SophiaSpringArmComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaSpringArmComponent* USophiaSpringArmComponent::GetDefaultObj()
{
	static class USophiaSpringArmComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaSpringArmComponent*>(USophiaSpringArmComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaStaticMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* USophiaStaticMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaStaticMeshComponent");

	return Clss;
}


// SophiaStaticMeshComponent IslandsofInsight.Default__SophiaStaticMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaStaticMeshComponent* USophiaStaticMeshComponent::GetDefaultObj()
{
	static class USophiaStaticMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaStaticMeshComponent*>(USophiaStaticMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaUtilityStatics
// (None)

class UClass* USophiaUtilityStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaUtilityStatics");

	return Clss;
}


// SophiaUtilityStatics IslandsofInsight.Default__SophiaUtilityStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaUtilityStatics* USophiaUtilityStatics::GetDefaultObj()
{
	static class USophiaUtilityStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaUtilityStatics*>(USophiaUtilityStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaUtilityStatics.ToUnixTimestamp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   DateTime                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USophiaUtilityStatics::ToUnixTimestamp(struct FDateTime& DateTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUtilityStatics", "ToUnixTimestamp");

	Params::USophiaUtilityStatics_ToUnixTimestamp_Params Parms{};

	Parms.DateTime = DateTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUtilityStatics.GetCurrentUnixTimestamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USophiaUtilityStatics::GetCurrentUnixTimestamp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUtilityStatics", "GetCurrentUnixTimestamp");

	Params::USophiaUtilityStatics_GetCurrentUnixTimestamp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.SophiaUXStatics
// (None)

class UClass* USophiaUXStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaUXStatics");

	return Clss;
}


// SophiaUXStatics IslandsofInsight.Default__SophiaUXStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaUXStatics* USophiaUXStatics::GetDefaultObj()
{
	static class USophiaUXStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaUXStatics*>(USophiaUXStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SophiaUXStatics.SetSlotIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelSlot*                  Slot                                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              DesiredIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               MoveOtherUp                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPanelSlot*                  ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelSlot* USophiaUXStatics::SetSlotIndex(class UPanelSlot* Slot, int32 DesiredIndex, bool MoveOtherUp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "SetSlotIndex");

	Params::USophiaUXStatics_SetSlotIndex_Params Parms{};

	Parms.Slot = Slot;
	Parms.DesiredIndex = DesiredIndex;
	Parms.MoveOtherUp = MoveOtherUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.RenameTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     Outer                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      NewName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaUXStatics::RenameTexture(class UTexture2D* Texture, class UObject* Outer, const class FString& NewName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "RenameTexture");

	Params::USophiaUXStatics_RenameTexture_Params Parms{};

	Parms.Texture = Texture;
	Parms.Outer = Outer;
	Parms.NewName = NewName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaUXStatics.PasteFromClipboard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaUXStatics::PasteFromClipboard()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "PasteFromClipboard");

	Params::USophiaUXStatics_PasteFromClipboard_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetRegularHUDTextColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USophiaUXStatics::GetRegularHUDTextColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetRegularHUDTextColor");

	Params::USophiaUXStatics_GetRegularHUDTextColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetRedTeamColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USophiaUXStatics::GetRedTeamColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetRedTeamColor");

	Params::USophiaUXStatics_GetRedTeamColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetLocalizationCultureTextFromText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                        Lang                                                             (Parm, NativeAccessSpecifierPublic)
// enum class ELocalizationCulture    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ELocalizationCulture USophiaUXStatics::GetLocalizationCultureTextFromText(class FText Lang)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetLocalizationCultureTextFromText");

	Params::USophiaUXStatics_GetLocalizationCultureTextFromText_Params Parms{};

	Parms.Lang = Lang;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetLocalizationCultureText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class ELocalizationCulture    C                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USophiaUXStatics::GetLocalizationCultureText(enum class ELocalizationCulture C)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetLocalizationCultureText");

	Params::USophiaUXStatics_GetLocalizationCultureText_Params Parms{};

	Parms.C = C;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetLanguageISO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class ELocalizationCulture    C                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USophiaUXStatics::GetLanguageISO(enum class ELocalizationCulture C)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetLanguageISO");

	Params::USophiaUXStatics_GetLanguageISO_Params Parms{};

	Parms.C = C;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetCurrentLocalizationCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class ELocalizationCulture    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ELocalizationCulture USophiaUXStatics::GetCurrentLocalizationCulture()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetCurrentLocalizationCulture");

	Params::USophiaUXStatics_GetCurrentLocalizationCulture_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetBlueTeamColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USophiaUXStatics::GetBlueTeamColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetBlueTeamColor");

	Params::USophiaUXStatics_GetBlueTeamColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetBindingDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                 Widget                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Binding                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShortDisplayName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               EnsureIfNoBinding                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USophiaUXStatics::GetBindingDisplayName(class UUserWidget* Widget, class FName Binding, bool ShortDisplayName, bool EnsureIfNoBinding)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetBindingDisplayName");

	Params::USophiaUXStatics_GetBindingDisplayName_Params Parms{};

	Parms.Widget = Widget;
	Parms.Binding = Binding;
	Parms.ShortDisplayName = ShortDisplayName;
	Parms.EnsureIfNoBinding = EnsureIfNoBinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetAnyCustomizationSingleByID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      KrakenId                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationSingle        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationSingle USophiaUXStatics::GetAnyCustomizationSingleByID(class UObject* WorldContextObject, const class FString& KrakenId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetAnyCustomizationSingleByID");

	Params::USophiaUXStatics_GetAnyCustomizationSingleByID_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KrakenId = KrakenId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.GetAllNonBaseWidgetChildWidgetsRecursive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWidget*                     Widget                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>             Widgets                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UUserWidget>>ExcludedClasses                                                  (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void USophiaUXStatics::GetAllNonBaseWidgetChildWidgetsRecursive(class UWidget* Widget, TArray<class UWidget*>* Widgets, const TArray<TSubclassOf<class UUserWidget>>& ExcludedClasses)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetAllNonBaseWidgetChildWidgetsRecursive");

	Params::USophiaUXStatics_GetAllNonBaseWidgetChildWidgetsRecursive_Params Parms{};

	Parms.Widget = Widget;
	Parms.ExcludedClasses = ExcludedClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Widgets != nullptr)
		*Widgets = std::move(Parms.Widgets);

}


// Function IslandsofInsight.SophiaUXStatics.GetAllChildWidgetsRecursive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWidget*                     Widget                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>             Widgets                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UUserWidget>>ExcludedClasses                                                  (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void USophiaUXStatics::GetAllChildWidgetsRecursive(class UWidget* Widget, TArray<class UWidget*>* Widgets, const TArray<TSubclassOf<class UUserWidget>>& ExcludedClasses)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "GetAllChildWidgetsRecursive");

	Params::USophiaUXStatics_GetAllChildWidgetsRecursive_Params Parms{};

	Parms.Widget = Widget;
	Parms.ExcludedClasses = ExcludedClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Widgets != nullptr)
		*Widgets = std::move(Parms.Widgets);

}


// Function IslandsofInsight.SophiaUXStatics.CopyToClipboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ToBeCopied                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaUXStatics::CopyToClipboard(const class FString& ToBeCopied)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "CopyToClipboard");

	Params::USophiaUXStatics_CopyToClipboard_Params Parms{};

	Parms.ToBeCopied = ToBeCopied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaUXStatics.ChangeLocalizationCultureWithISO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ISO                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateKrakenSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaUXStatics::ChangeLocalizationCultureWithISO(const class FString& ISO, class UObject* ContextObject, bool bUpdateKrakenSetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "ChangeLocalizationCultureWithISO");

	Params::USophiaUXStatics_ChangeLocalizationCultureWithISO_Params Parms{};

	Parms.ISO = ISO;
	Parms.ContextObject = ContextObject;
	Parms.bUpdateKrakenSetting = bUpdateKrakenSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.ChangeLocalizationCultureText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                        C                                                                (Parm, NativeAccessSpecifierPublic)
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateKrakenSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaUXStatics::ChangeLocalizationCultureText(class FText C, class UObject* ContextObject, bool bUpdateKrakenSetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "ChangeLocalizationCultureText");

	Params::USophiaUXStatics_ChangeLocalizationCultureText_Params Parms{};

	Parms.C = C;
	Parms.ContextObject = ContextObject;
	Parms.bUpdateKrakenSetting = bUpdateKrakenSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.ChangeLocalizationCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class ELocalizationCulture    C                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateKrakenSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USophiaUXStatics::ChangeLocalizationCulture(enum class ELocalizationCulture C, class UObject* ContextObject, bool bUpdateKrakenSetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "ChangeLocalizationCulture");

	Params::USophiaUXStatics_ChangeLocalizationCulture_Params Parms{};

	Parms.C = C;
	Parms.ContextObject = ContextObject;
	Parms.bUpdateKrakenSetting = bUpdateKrakenSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.SophiaUXStatics.ChangeLocaleToSteam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaUXStatics::ChangeLocaleToSteam(class UObject* ContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "ChangeLocaleToSteam");

	Params::USophiaUXStatics_ChangeLocaleToSteam_Params Parms{};

	Parms.ContextObject = ContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaUXStatics.AddLocalPlayerMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Message                                                          (Parm, NativeAccessSpecifierPublic)

void USophiaUXStatics::AddLocalPlayerMessage(class UObject* WorldContextObject, class FText Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "AddLocalPlayerMessage");

	Params::USophiaUXStatics_AddLocalPlayerMessage_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SophiaUXStatics.AddFocusWidgetToQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBaseWidget*                 BaseWidget                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPanelWidget*                Parent                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USophiaUXStatics::AddFocusWidgetToQueue(class UBaseWidget* BaseWidget, class UPanelWidget* Parent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SophiaUXStatics", "AddFocusWidgetToQueue");

	Params::USophiaUXStatics_AddFocusWidgetToQueue_Params Parms{};

	Parms.BaseWidget = BaseWidget;
	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SophiaVisuals
// (None)

class UClass* USophiaVisuals::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaVisuals");

	return Clss;
}


// SophiaVisuals IslandsofInsight.Default__SophiaVisuals
// (Public, ClassDefaultObject, ArchetypeObject)

class USophiaVisuals* USophiaVisuals::GetDefaultObj()
{
	static class USophiaVisuals* Default = nullptr;

	if (!Default)
		Default = static_cast<USophiaVisuals*>(USophiaVisuals::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SophiaWorldSettings
// (Actor)

class UClass* ASophiaWorldSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SophiaWorldSettings");

	return Clss;
}


// SophiaWorldSettings IslandsofInsight.Default__SophiaWorldSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class ASophiaWorldSettings* ASophiaWorldSettings::GetDefaultObj()
{
	static class ASophiaWorldSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<ASophiaWorldSettings*>(ASophiaWorldSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SpawnedPuzzleContainer
// (None)

class UClass* USpawnedPuzzleContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpawnedPuzzleContainer");

	return Clss;
}


// SpawnedPuzzleContainer IslandsofInsight.Default__SpawnedPuzzleContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class USpawnedPuzzleContainer* USpawnedPuzzleContainer::GetDefaultObj()
{
	static class USpawnedPuzzleContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<USpawnedPuzzleContainer*>(USpawnedPuzzleContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SpawnOverrideVolume
// (Actor)

class UClass* ASpawnOverrideVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpawnOverrideVolume");

	return Clss;
}


// SpawnOverrideVolume IslandsofInsight.Default__SpawnOverrideVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpawnOverrideVolume* ASpawnOverrideVolume::GetDefaultObj()
{
	static class ASpawnOverrideVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpawnOverrideVolume*>(ASpawnOverrideVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SpeedrunRosary
// (Actor)

class UClass* ASpeedrunRosary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpeedrunRosary");

	return Clss;
}


// SpeedrunRosary IslandsofInsight.Default__SpeedrunRosary
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpeedrunRosary* ASpeedrunRosary::GetDefaultObj()
{
	static class ASpeedrunRosary* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpeedrunRosary*>(ASpeedrunRosary::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.SpiritGem
// (Actor)

class UClass* ASpiritGem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpiritGem");

	return Clss;
}


// SpiritGem IslandsofInsight.Default__SpiritGem
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpiritGem* ASpiritGem::GetDefaultObj()
{
	static class ASpiritGem* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpiritGem*>(ASpiritGem::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SpiritGem.Overlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpiritGem::Overlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpiritGem", "Overlap");

	Params::ASpiritGem_Overlap_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SpiritGem.OnRep_ShownPlayer
// (Final, Native, Protected)
// Parameters:

void ASpiritGem::OnRep_ShownPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpiritGem", "OnRep_ShownPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SpiritGem.BP_OnCollected
// (Event, Protected, BlueprintEvent)
// Parameters:

void ASpiritGem::BP_OnCollected()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpiritGem", "BP_OnCollected");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SpotTheDifference
// (Actor)

class UClass* ASpotTheDifference::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpotTheDifference");

	return Clss;
}


// SpotTheDifference IslandsofInsight.Default__SpotTheDifference
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpotTheDifference* ASpotTheDifference::GetDefaultObj()
{
	static class ASpotTheDifference* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpotTheDifference*>(ASpotTheDifference::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SpotTheDifference.OnRep_TotalDifferences
// (Final, Native, Private)
// Parameters:

void ASpotTheDifference::OnRep_TotalDifferences()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotTheDifference", "OnRep_TotalDifferences");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.SpotTheDifference.OnRep_AllItems
// (Final, Native, Private)
// Parameters:

void ASpotTheDifference::OnRep_AllItems()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotTheDifference", "OnRep_AllItems");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.SpotTheDifferenceItem
// (Actor)

class UClass* ASpotTheDifferenceItem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpotTheDifferenceItem");

	return Clss;
}


// SpotTheDifferenceItem IslandsofInsight.Default__SpotTheDifferenceItem
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpotTheDifferenceItem* ASpotTheDifferenceItem::GetDefaultObj()
{
	static class ASpotTheDifferenceItem* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpotTheDifferenceItem*>(ASpotTheDifferenceItem::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.StandardGridUI
// (None)

class UClass* UStandardGridUI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StandardGridUI");

	return Clss;
}


// StandardGridUI IslandsofInsight.Default__StandardGridUI
// (Public, ClassDefaultObject, ArchetypeObject)

class UStandardGridUI* UStandardGridUI::GetDefaultObj()
{
	static class UStandardGridUI* Default = nullptr;

	if (!Default)
		Default = static_cast<UStandardGridUI*>(UStandardGridUI::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.StandardGridUI.UndoReleased
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::UndoReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "UndoReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.UndoPressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::UndoPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "UndoPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.TryAgain
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::TryAgain()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "TryAgain");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.Restart
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::Restart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "Restart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.Next
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::Next()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "Next");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.IsRestartTryAgain
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStandardGridUI::IsRestartTryAgain()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "IsRestartTryAgain");

	Params::UStandardGridUI_IsRestartTryAgain_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GridButtonOnClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStandardGridUI::GridButtonOnClick(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GridButtonOnClick");

	Params::UStandardGridUI_GridButtonOnClick_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.StandardGridUI.GetUpgradeTextVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UStandardGridUI::GetUpgradeTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetUpgradeTextVisibility");

	Params::UStandardGridUI_GetUpgradeTextVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GetUpgradeTextMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UStandardGridUI::GetUpgradeTextMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetUpgradeTextMessage");

	Params::UStandardGridUI_GetUpgradeTextMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GetUndoButtonVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UStandardGridUI::GetUndoButtonVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetUndoButtonVisibility");

	Params::UStandardGridUI_GetUndoButtonVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GetRestartButtonVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UStandardGridUI::GetRestartButtonVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetRestartButtonVisibility");

	Params::UStandardGridUI_GetRestartButtonVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GetContinueButtonVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UStandardGridUI::GetContinueButtonVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetContinueButtonVisibility");

	Params::UStandardGridUI_GetContinueButtonVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.GetContinueButtonMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UStandardGridUI::GetContinueButtonMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "GetContinueButtonMessage");

	Params::UStandardGridUI_GetContinueButtonMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.StandardGridUI.Exit
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStandardGridUI::Exit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StandardGridUI", "Exit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.StarsEffect
// (None)

class UClass* UStarsEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StarsEffect");

	return Clss;
}


// StarsEffect IslandsofInsight.Default__StarsEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UStarsEffect* UStarsEffect::GetDefaultObj()
{
	static class UStarsEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UStarsEffect*>(UStarsEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.StartingIsland
// (Actor)

class UClass* AStartingIsland::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StartingIsland");

	return Clss;
}


// StartingIsland IslandsofInsight.Default__StartingIsland
// (Public, ClassDefaultObject, ArchetypeObject)

class AStartingIsland* AStartingIsland::GetDefaultObj()
{
	static class AStartingIsland* Default = nullptr;

	if (!Default)
		Default = static_cast<AStartingIsland*>(AStartingIsland::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.StyledButton
// (None)

class UClass* UStyledButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StyledButton");

	return Clss;
}


// StyledButton IslandsofInsight.Default__StyledButton
// (Public, ClassDefaultObject, ArchetypeObject)

class UStyledButton* UStyledButton::GetDefaultObj()
{
	static class UStyledButton* Default = nullptr;

	if (!Default)
		Default = static_cast<UStyledButton*>(UStyledButton::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.StyledButton.OnBindingCalled
// (Event, Public, BlueprintEvent)
// Parameters:

void UStyledButton::OnBindingCalled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StyledButton", "OnBindingCalled");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.SurveyPromptBase
// (None)

class UClass* USurveyPromptBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SurveyPromptBase");

	return Clss;
}


// SurveyPromptBase IslandsofInsight.Default__SurveyPromptBase
// (Public, ClassDefaultObject, ArchetypeObject)

class USurveyPromptBase* USurveyPromptBase::GetDefaultObj()
{
	static class USurveyPromptBase* Default = nullptr;

	if (!Default)
		Default = static_cast<USurveyPromptBase*>(USurveyPromptBase::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.SurveyPromptBase.DisplayPrompt
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        PromptText                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UParameterizedUrl*           URL                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurveyPromptBase::DisplayPrompt(class FText& PromptText, class UParameterizedUrl* URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SurveyPromptBase", "DisplayPrompt");

	Params::USurveyPromptBase_DisplayPrompt_Params Parms{};

	Parms.PromptText = PromptText;
	Parms.URL = URL;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.TargetedLocationCapsule
// (SceneComponent, PrimitiveComponent)

class UClass* UTargetedLocationCapsule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TargetedLocationCapsule");

	return Clss;
}


// TargetedLocationCapsule IslandsofInsight.Default__TargetedLocationCapsule
// (Public, ClassDefaultObject, ArchetypeObject)

class UTargetedLocationCapsule* UTargetedLocationCapsule::GetDefaultObj()
{
	static class UTargetedLocationCapsule* Default = nullptr;

	if (!Default)
		Default = static_cast<UTargetedLocationCapsule*>(UTargetedLocationCapsule::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TattooBodyDataAsset
// (None)

class UClass* UTattooBodyDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TattooBodyDataAsset");

	return Clss;
}


// TattooBodyDataAsset IslandsofInsight.Default__TattooBodyDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UTattooBodyDataAsset* UTattooBodyDataAsset::GetDefaultObj()
{
	static class UTattooBodyDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UTattooBodyDataAsset*>(UTattooBodyDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TattooFaceDataAsset
// (None)

class UClass* UTattooFaceDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TattooFaceDataAsset");

	return Clss;
}


// TattooFaceDataAsset IslandsofInsight.Default__TattooFaceDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UTattooFaceDataAsset* UTattooFaceDataAsset::GetDefaultObj()
{
	static class UTattooFaceDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UTattooFaceDataAsset*>(UTattooFaceDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TCPClient
// (Actor)

class UClass* ATCPClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TCPClient");

	return Clss;
}


// TCPClient IslandsofInsight.Default__TCPClient
// (Public, ClassDefaultObject, ArchetypeObject)

class ATCPClient* ATCPClient::GetDefaultObj()
{
	static class ATCPClient* Default = nullptr;

	if (!Default)
		Default = static_cast<ATCPClient*>(ATCPClient::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TCPClient.SendToServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                      Message                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ATCPClient::SendToServer(const TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPClient", "SendToServer");

	Params::ATCPClient_SendToServer_Params Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPClient.OnServerDisconnect
// (Final, Native, Protected)
// Parameters:
// class USocketRSThread*             PThread                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATCPClient::OnServerDisconnect(class USocketRSThread* PThread)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPClient", "OnServerDisconnect");

	Params::ATCPClient_OnServerDisconnect_Params Parms{};

	Parms.PThread = PThread;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPClient.DisconnectFromServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ATCPClient::DisconnectFromServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPClient", "DisconnectFromServer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPClient.CreateClientAndConnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ServerIP                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Port                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReceiveSize                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SendSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATCPClient::CreateClientAndConnect(const class FString& ServerIP, int32 Port, int32 ReceiveSize, int32 SendSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPClient", "CreateClientAndConnect");

	Params::ATCPClient_CreateClientAndConnect_Params Parms{};

	Parms.ServerIP = ServerIP;
	Parms.Port = Port;
	Parms.ReceiveSize = ReceiveSize;
	Parms.SendSize = SendSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPClient.ConnectServer
// (Final, Native, Public)
// Parameters:
// class FString                      ServerIP                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Port                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATCPClient::ConnectServer(const class FString& ServerIP, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPClient", "ConnectServer");

	Params::ATCPClient_ConnectServer_Params Parms{};

	Parms.ServerIP = ServerIP;
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.TCPServer
// (Actor)

class UClass* ATCPServer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TCPServer");

	return Clss;
}


// TCPServer IslandsofInsight.Default__TCPServer
// (Public, ClassDefaultObject, ArchetypeObject)

class ATCPServer* ATCPServer::GetDefaultObj()
{
	static class ATCPServer* Default = nullptr;

	if (!Default)
		Default = static_cast<ATCPServer*>(ATCPServer::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TCPServer.SendToClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                      Message                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ATCPServer::SendToClient(const TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPServer", "SendToClient");

	Params::ATCPServer_SendToClient_Params Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPServer.OnClientDisconnect
// (Final, Native, Public)
// Parameters:
// class USocketRSThread*             PThread                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATCPServer::OnClientDisconnect(class USocketRSThread* PThread)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPServer", "OnClientDisconnect");

	Params::ATCPServer_OnClientDisconnect_Params Parms{};

	Parms.PThread = PThread;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPServer.CreateServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ServerIP                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ServerPort                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReceiveBufferSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SendBufferSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATCPServer::CreateServer(const class FString& ServerIP, int32 ServerPort, int32 ReceiveBufferSize, int32 SendBufferSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPServer", "CreateServer");

	Params::ATCPServer_CreateServer_Params Parms{};

	Parms.ServerIP = ServerIP;
	Parms.ServerPort = ServerPort;
	Parms.ReceiveBufferSize = ReceiveBufferSize;
	Parms.SendBufferSize = SendBufferSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TCPServer.CloseServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ATCPServer::CloseServer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TCPServer", "CloseServer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.Telescope
// (Actor)

class UClass* ATelescope::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Telescope");

	return Clss;
}


// Telescope IslandsofInsight.Default__Telescope
// (Public, ClassDefaultObject, ArchetypeObject)

class ATelescope* ATelescope::GetDefaultObj()
{
	static class ATelescope* Default = nullptr;

	if (!Default)
		Default = static_cast<ATelescope*>(ATelescope::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.Telescope.OnClickFire
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FClickEventContext          Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATelescope::OnClickFire(struct FClickEventContext& Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Telescope", "OnClickFire");

	Params::ATelescope_OnClickFire_Params Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.TemporaryLocationPing
// (Actor)

class UClass* ATemporaryLocationPing::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TemporaryLocationPing");

	return Clss;
}


// TemporaryLocationPing IslandsofInsight.Default__TemporaryLocationPing
// (Public, ClassDefaultObject, ArchetypeObject)

class ATemporaryLocationPing* ATemporaryLocationPing::GetDefaultObj()
{
	static class ATemporaryLocationPing* Default = nullptr;

	if (!Default)
		Default = static_cast<ATemporaryLocationPing*>(ATemporaryLocationPing::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TextRenderClue
// (None)

class UClass* UTextRenderClue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextRenderClue");

	return Clss;
}


// TextRenderClue IslandsofInsight.Default__TextRenderClue
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextRenderClue* UTextRenderClue::GetDefaultObj()
{
	static class UTextRenderClue* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextRenderClue*>(UTextRenderClue::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TooltipWidget
// (None)

class UClass* UTooltipWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TooltipWidget");

	return Clss;
}


// TooltipWidget IslandsofInsight.Default__TooltipWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UTooltipWidget* UTooltipWidget::GetDefaultObj()
{
	static class UTooltipWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UTooltipWidget*>(UTooltipWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TooltipWidget.ParentIsAboveScreenMiddle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTooltipWidget::ParentIsAboveScreenMiddle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TooltipWidget", "ParentIsAboveScreenMiddle");

	Params::UTooltipWidget_ParentIsAboveScreenMiddle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.TotemIcon
// (None)

class UClass* UTotemIcon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TotemIcon");

	return Clss;
}


// TotemIcon IslandsofInsight.Default__TotemIcon
// (Public, ClassDefaultObject, ArchetypeObject)

class UTotemIcon* UTotemIcon::GetDefaultObj()
{
	static class UTotemIcon* Default = nullptr;

	if (!Default)
		Default = static_cast<UTotemIcon*>(UTotemIcon::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TotemIcon.PlaySolveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UTotemIcon::PlaySolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemIcon", "PlaySolveAnimation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TotemIcon.OnIconClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UTotemIcon::OnIconClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemIcon", "OnIconClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TotemIcon.BP_PlaySolveAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:

void UTotemIcon::BP_PlaySolveAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemIcon", "BP_PlaySolveAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.TotemIcon.BP_InitVisuals
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                               Unlocked                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Selected                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SOLVED                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTotemIcon::BP_InitVisuals(bool Unlocked, bool Selected, bool SOLVED)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemIcon", "BP_InitVisuals");

	Params::UTotemIcon_BP_InitVisuals_Params Parms{};

	Parms.Unlocked = Unlocked;
	Parms.Selected = Selected;
	Parms.SOLVED = SOLVED;

	UObject::ProcessEvent(Func, &Parms);

}


// Class IslandsofInsight.TotemNavigator
// (None)

class UClass* UTotemNavigator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TotemNavigator");

	return Clss;
}


// TotemNavigator IslandsofInsight.Default__TotemNavigator
// (Public, ClassDefaultObject, ArchetypeObject)

class UTotemNavigator* UTotemNavigator::GetDefaultObj()
{
	static class UTotemNavigator* Default = nullptr;

	if (!Default)
		Default = static_cast<UTotemNavigator*>(UTotemNavigator::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TotemNavigator.OnUpArrowClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UTotemNavigator::OnUpArrowClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "OnUpArrowClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TotemNavigator.OnDownArrowClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UTotemNavigator::OnDownArrowClicked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "OnDownArrowClicked");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TotemNavigator.IsUpArrowInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTotemNavigator::IsUpArrowInteractable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "IsUpArrowInteractable");

	Params::UTotemNavigator_IsUpArrowInteractable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TotemNavigator.IsDownArrowInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTotemNavigator::IsDownArrowInteractable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "IsDownArrowInteractable");

	Params::UTotemNavigator_IsDownArrowInteractable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TotemNavigator.GetNavigatorVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UTotemNavigator::GetNavigatorVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "GetNavigatorVisibility");

	Params::UTotemNavigator_GetNavigatorVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TotemNavigator.BPI_Resize
// (Event, Public, BlueprintEvent)
// Parameters:

void UTotemNavigator::BPI_Resize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemNavigator", "BPI_Resize");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.TotemRune
// (Actor)

class UClass* ATotemRune::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TotemRune");

	return Clss;
}


// TotemRune IslandsofInsight.Default__TotemRune
// (Public, ClassDefaultObject, ArchetypeObject)

class ATotemRune* ATotemRune::GetDefaultObj()
{
	static class ATotemRune* Default = nullptr;

	if (!Default)
		Default = static_cast<ATotemRune*>(ATotemRune::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TotemRune.GetTotemPuzzleCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATotemRune::GetTotemPuzzleCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemRune", "GetTotemPuzzleCount");

	Params::ATotemRune_GetTotemPuzzleCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TotemRune.GetTotemIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATotemRune::GetTotemIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TotemRune", "GetTotemIndex");

	Params::ATotemRune_GetTotemIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.TowerPlatformTrigger
// (Actor)

class UClass* ATowerPlatformTrigger::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TowerPlatformTrigger");

	return Clss;
}


// TowerPlatformTrigger IslandsofInsight.Default__TowerPlatformTrigger
// (Public, ClassDefaultObject, ArchetypeObject)

class ATowerPlatformTrigger* ATowerPlatformTrigger::GetDefaultObj()
{
	static class ATowerPlatformTrigger* Default = nullptr;

	if (!Default)
		Default = static_cast<ATowerPlatformTrigger*>(ATowerPlatformTrigger::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TowerPlatformTrigger.OnRep_commandsCurrentlyActivated
// (Final, Native, Protected)
// Parameters:
// bool                               Old                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATowerPlatformTrigger::OnRep_commandsCurrentlyActivated(bool Old)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPlatformTrigger", "OnRep_commandsCurrentlyActivated");

	Params::ATowerPlatformTrigger_OnRep_commandsCurrentlyActivated_Params Parms{};

	Parms.Old = Old;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.TowerClickTriggerPlatform
// (Actor)

class UClass* ATowerClickTriggerPlatform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TowerClickTriggerPlatform");

	return Clss;
}


// TowerClickTriggerPlatform IslandsofInsight.Default__TowerClickTriggerPlatform
// (Public, ClassDefaultObject, ArchetypeObject)

class ATowerClickTriggerPlatform* ATowerClickTriggerPlatform::GetDefaultObj()
{
	static class ATowerClickTriggerPlatform* Default = nullptr;

	if (!Default)
		Default = static_cast<ATowerClickTriggerPlatform*>(ATowerClickTriggerPlatform::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.TowerPlatform
// (Actor)

class UClass* ATowerPlatform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TowerPlatform");

	return Clss;
}


// TowerPlatform IslandsofInsight.Default__TowerPlatform
// (Public, ClassDefaultObject, ArchetypeObject)

class ATowerPlatform* ATowerPlatform::GetDefaultObj()
{
	static class ATowerPlatform* Default = nullptr;

	if (!Default)
		Default = static_cast<ATowerPlatform*>(ATowerPlatform::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TowerPlatform.OnRep_startingLoc
// (Final, Native, Protected)
// Parameters:

void ATowerPlatform::OnRep_startingLoc()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPlatform", "OnRep_startingLoc");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TowerPlatform.OnRep_curCommandToServerProgress
// (Final, Native, Protected)
// Parameters:

void ATowerPlatform::OnRep_curCommandToServerProgress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPlatform", "OnRep_curCommandToServerProgress");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.TowerPuzzle
// (Actor)

class UClass* ATowerPuzzle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TowerPuzzle");

	return Clss;
}


// TowerPuzzle IslandsofInsight.Default__TowerPuzzle
// (Public, ClassDefaultObject, ArchetypeObject)

class ATowerPuzzle* ATowerPuzzle::GetDefaultObj()
{
	static class ATowerPuzzle* Default = nullptr;

	if (!Default)
		Default = static_cast<ATowerPuzzle*>(ATowerPuzzle::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TowerPuzzle.OnSolverExit
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATowerPuzzle::OnSolverExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPuzzle", "OnSolverExit");

	Params::ATowerPuzzle_OnSolverExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TowerPuzzle.OnSolverCollide
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATowerPuzzle::OnSolverCollide(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPuzzle", "OnSolverCollide");

	Params::ATowerPuzzle_OnSolverCollide_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TowerPuzzle.OnChallengerExit
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATowerPuzzle::OnChallengerExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPuzzle", "OnChallengerExit");

	Params::ATowerPuzzle_OnChallengerExit_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TowerPuzzle.OnChallengerCollide
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATowerPuzzle::OnChallengerCollide(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerPuzzle", "OnChallengerCollide");

	Params::ATowerPuzzle_OnChallengerCollide_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.TowerStandTriggerPlatform
// (Actor)

class UClass* ATowerStandTriggerPlatform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TowerStandTriggerPlatform");

	return Clss;
}


// TowerStandTriggerPlatform IslandsofInsight.Default__TowerStandTriggerPlatform
// (Public, ClassDefaultObject, ArchetypeObject)

class ATowerStandTriggerPlatform* ATowerStandTriggerPlatform::GetDefaultObj()
{
	static class ATowerStandTriggerPlatform* Default = nullptr;

	if (!Default)
		Default = static_cast<ATowerStandTriggerPlatform*>(ATowerStandTriggerPlatform::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TowerStandTriggerPlatform.OnStandOverlapEnd
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATowerStandTriggerPlatform::OnStandOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerStandTriggerPlatform", "OnStandOverlapEnd");

	Params::ATowerStandTriggerPlatform_OnStandOverlapEnd_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TowerStandTriggerPlatform.OnStandOverlapBegin
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATowerStandTriggerPlatform::OnStandOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TowerStandTriggerPlatform", "OnStandOverlapBegin");

	Params::ATowerStandTriggerPlatform_OnStandOverlapBegin_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.TutorialBox
// (None)

class UClass* UTutorialBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TutorialBox");

	return Clss;
}


// TutorialBox IslandsofInsight.Default__TutorialBox
// (Public, ClassDefaultObject, ArchetypeObject)

class UTutorialBox* UTutorialBox::GetDefaultObj()
{
	static class UTutorialBox* Default = nullptr;

	if (!Default)
		Default = static_cast<UTutorialBox*>(UTutorialBox::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TutorialBox.GetBoxVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UTutorialBox::GetBoxVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialBox", "GetBoxVisibility");

	Params::UTutorialBox_GetBoxVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TutorialBox.GetBoxMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTutorialBox::GetBoxMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialBox", "GetBoxMessage");

	Params::UTutorialBox_GetBoxMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TutorialBox.BP_UpdateTutorialMessage
// (Event, Public, BlueprintEvent)
// Parameters:

void UTutorialBox::BP_UpdateTutorialMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialBox", "BP_UpdateTutorialMessage");



	UObject::ProcessEvent(Func, nullptr);

}


// Function IslandsofInsight.TutorialBox.BP_PlayAppearAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void UTutorialBox::BP_PlayAppearAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialBox", "BP_PlayAppearAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.TutorialTextTools
// (None)

class UClass* UTutorialTextTools::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TutorialTextTools");

	return Clss;
}


// TutorialTextTools IslandsofInsight.Default__TutorialTextTools
// (Public, ClassDefaultObject, ArchetypeObject)

class UTutorialTextTools* UTutorialTextTools::GetDefaultObj()
{
	static class UTutorialTextTools* Default = nullptr;

	if (!Default)
		Default = static_cast<UTutorialTextTools*>(UTutorialTextTools::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TutorialTextTools.MarkAllLevelsNotUpdated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UTutorialTextTools::MarkAllLevelsNotUpdated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialTextTools", "MarkAllLevelsNotUpdated");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.TutorialTextTools.ChangePuzzleTutorialMessageToFText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialTextTools::ChangePuzzleTutorialMessageToFText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialTextTools", "ChangePuzzleTutorialMessageToFText");

	Params::UTutorialTextTools_ChangePuzzleTutorialMessageToFText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TutorialTextTools.ChangeAllPuzzleTutorialMessageToFText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UTutorialTextTools::ChangeAllPuzzleTutorialMessageToFText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialTextTools", "ChangeAllPuzzleTutorialMessageToFText");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.TutorialWidget
// (None)

class UClass* UTutorialWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TutorialWidget");

	return Clss;
}


// TutorialWidget IslandsofInsight.Default__TutorialWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UTutorialWidget* UTutorialWidget::GetDefaultObj()
{
	static class UTutorialWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UTutorialWidget*>(UTutorialWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TutorialWidget.BP_RemoveWidget
// (Event, Public, BlueprintEvent)
// Parameters:

void UTutorialWidget::BP_RemoveWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialWidget", "BP_RemoveWidget");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.TwoSidedPuzzleMaker
// (None)

class UClass* UTwoSidedPuzzleMaker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TwoSidedPuzzleMaker");

	return Clss;
}


// TwoSidedPuzzleMaker IslandsofInsight.Default__TwoSidedPuzzleMaker
// (Public, ClassDefaultObject, ArchetypeObject)

class UTwoSidedPuzzleMaker* UTwoSidedPuzzleMaker::GetDefaultObj()
{
	static class UTwoSidedPuzzleMaker* Default = nullptr;

	if (!Default)
		Default = static_cast<UTwoSidedPuzzleMaker*>(UTwoSidedPuzzleMaker::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TwoSidedPuzzleMaker.WriteTwoSidedPuzzleToFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      InFilename1                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InFilename2                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutFilename                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddQuestionMarks                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTwoSidedPuzzleMaker::WriteTwoSidedPuzzleToFile(const class FString& InFilename1, const class FString& InFilename2, const class FString& OutFilename, bool bAddQuestionMarks)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwoSidedPuzzleMaker", "WriteTwoSidedPuzzleToFile");

	Params::UTwoSidedPuzzleMaker_WriteTwoSidedPuzzleToFile_Params Parms{};

	Parms.InFilename1 = InFilename1;
	Parms.InFilename2 = InFilename2;
	Parms.OutFilename = OutFilename;
	Parms.bAddQuestionMarks = bAddQuestionMarks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.TwoStateGenericGridButton
// (None)

class UClass* UTwoStateGenericGridButton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TwoStateGenericGridButton");

	return Clss;
}


// TwoStateGenericGridButton IslandsofInsight.Default__TwoStateGenericGridButton
// (Public, ClassDefaultObject, ArchetypeObject)

class UTwoStateGenericGridButton* UTwoStateGenericGridButton::GetDefaultObj()
{
	static class UTwoStateGenericGridButton* Default = nullptr;

	if (!Default)
		Default = static_cast<UTwoStateGenericGridButton*>(UTwoStateGenericGridButton::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.TwoStateGenericGridButton.IsInBaseState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EGenericGridButtonType  Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwoStateGenericGridButton::IsInBaseState(enum class EGenericGridButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwoStateGenericGridButton", "IsInBaseState");

	Params::UTwoStateGenericGridButton_IsInBaseState_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.TwoStateGenericGridButton.BP_UpdateVisualState
// (Event, Public, BlueprintEvent)
// Parameters:

void UTwoStateGenericGridButton::BP_UpdateVisualState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwoStateGenericGridButton", "BP_UpdateVisualState");



	UObject::ProcessEvent(Func, nullptr);

}


// Class IslandsofInsight.UGISPlayers
// (None)

class UClass* UUGISPlayers::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UGISPlayers");

	return Clss;
}


// UGISPlayers IslandsofInsight.Default__UGISPlayers
// (Public, ClassDefaultObject, ArchetypeObject)

class UUGISPlayers* UUGISPlayers::GetDefaultObj()
{
	static class UUGISPlayers* Default = nullptr;

	if (!Default)
		Default = static_cast<UUGISPlayers*>(UUGISPlayers::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.VerticalBox_Sophia
// (None)

class UClass* UVerticalBox_Sophia::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VerticalBox_Sophia");

	return Clss;
}


// VerticalBox_Sophia IslandsofInsight.Default__VerticalBox_Sophia
// (Public, ClassDefaultObject, ArchetypeObject)

class UVerticalBox_Sophia* UVerticalBox_Sophia::GetDefaultObj()
{
	static class UVerticalBox_Sophia* Default = nullptr;

	if (!Default)
		Default = static_cast<UVerticalBox_Sophia*>(UVerticalBox_Sophia::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ViewfinderCamera
// (Actor)

class UClass* AViewfinderCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ViewfinderCamera");

	return Clss;
}


// ViewfinderCamera IslandsofInsight.Default__ViewfinderCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class AViewfinderCamera* AViewfinderCamera::GetDefaultObj()
{
	static class AViewfinderCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<AViewfinderCamera*>(AViewfinderCamera::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ViewfinderImage
// (Actor)

class UClass* AViewfinderImage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ViewfinderImage");

	return Clss;
}


// ViewfinderImage IslandsofInsight.Default__ViewfinderImage
// (Public, ClassDefaultObject, ArchetypeObject)

class AViewfinderImage* AViewfinderImage::GetDefaultObj()
{
	static class AViewfinderImage* Default = nullptr;

	if (!Default)
		Default = static_cast<AViewfinderImage*>(AViewfinderImage::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ViewfinderUIPanel
// (Actor)

class UClass* AViewfinderUIPanel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ViewfinderUIPanel");

	return Clss;
}


// ViewfinderUIPanel IslandsofInsight.Default__ViewfinderUIPanel
// (Public, ClassDefaultObject, ArchetypeObject)

class AViewfinderUIPanel* AViewfinderUIPanel::GetDefaultObj()
{
	static class AViewfinderUIPanel* Default = nullptr;

	if (!Default)
		Default = static_cast<AViewfinderUIPanel*>(AViewfinderUIPanel::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ViewfinderUIWidget
// (None)

class UClass* UViewfinderUIWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ViewfinderUIWidget");

	return Clss;
}


// ViewfinderUIWidget IslandsofInsight.Default__ViewfinderUIWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UViewfinderUIWidget* UViewfinderUIWidget::GetDefaultObj()
{
	static class UViewfinderUIWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UViewfinderUIWidget*>(UViewfinderUIWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ViewfinderUIWidget.GetBonusRewardsTextVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ESlateVisibility        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateVisibility UViewfinderUIWidget::GetBonusRewardsTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ViewfinderUIWidget", "GetBonusRewardsTextVisibility");

	Params::UViewfinderUIWidget_GetBonusRewardsTextVisibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ViewfinderUIWidget.GetBonusRewardsMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UViewfinderUIWidget::GetBonusRewardsMessage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ViewfinderUIWidget", "GetBonusRewardsMessage");

	Params::UViewfinderUIWidget_GetBonusRewardsMessage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.WorldQuest
// (None)

class UClass* UWorldQuest::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WorldQuest");

	return Clss;
}


// WorldQuest IslandsofInsight.Default__WorldQuest
// (Public, ClassDefaultObject, ArchetypeObject)

class UWorldQuest* UWorldQuest::GetDefaultObj()
{
	static class UWorldQuest* Default = nullptr;

	if (!Default)
		Default = static_cast<UWorldQuest*>(UWorldQuest::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.WorldQuest.SetDailySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDailyQuestSlot         Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldQuest::SetDailySlot(enum class EDailyQuestSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "SetDailySlot");

	Params::UWorldQuest_SetDailySlot_Params Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function IslandsofInsight.WorldQuest.IsHiddenFromUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldQuest::IsHiddenFromUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "IsHiddenFromUI");

	Params::UWorldQuest_IsHiddenFromUI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.IsFirstTimeDailyCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldQuest::IsFirstTimeDailyCompleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "IsFirstTimeDailyCompleted");

	Params::UWorldQuest_IsFirstTimeDailyCompleted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.IsFeatured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldQuest::IsFeatured()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "IsFeatured");

	Params::UWorldQuest_IsFeatured_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldQuest::IsEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "IsEnabled");

	Params::UWorldQuest_IsEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.IsDailyComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldQuest::IsDailyComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "IsDailyComplete");

	Params::UWorldQuest_IsDailyComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetUnlockCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWorldQuest::GetUnlockCost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetUnlockCost");

	Params::UWorldQuest_GetUnlockCost_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetQuestType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWorldQuestType         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWorldQuestType UWorldQuest::GetQuestType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetQuestType");

	Params::UWorldQuest_GetQuestType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetPrereqQuests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSet<class FName>                  ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class FName> UWorldQuest::GetPrereqQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetPrereqQuests");

	Params::UWorldQuest_GetPrereqQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetMinLevelToUnlock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWorldQuest::GetMinLevelToUnlock()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetMinLevelToUnlock");

	Params::UWorldQuest_GetMinLevelToUnlock_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetDailySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDailyQuestSlot         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDailyQuestSlot UWorldQuest::GetDailySlot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetDailySlot");

	Params::UWorldQuest_GetDailySlot_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetDailyPool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDailyQuestPoolType     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDailyQuestPoolType UWorldQuest::GetDailyPool()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetDailyPool");

	Params::UWorldQuest_GetDailyPool_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.GetCreationTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UWorldQuest::GetCreationTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "GetCreationTime");

	Params::UWorldQuest_GetCreationTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.WorldQuest.CompleteDaily
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:

void UWorldQuest::CompleteDaily()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldQuest", "CompleteDaily");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class IslandsofInsight.YajilinNumber
// (None)

class UClass* UYajilinNumber::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("YajilinNumber");

	return Clss;
}


// YajilinNumber IslandsofInsight.Default__YajilinNumber
// (Public, ClassDefaultObject, ArchetypeObject)

class UYajilinNumber* UYajilinNumber::GetDefaultObj()
{
	static class UYajilinNumber* Default = nullptr;

	if (!Default)
		Default = static_cast<UYajilinNumber*>(UYajilinNumber::StaticClass()->DefaultObject);

	return Default;
}


// Class IslandsofInsight.ZoneDataEntry
// (None)

class UClass* UZoneDataEntry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ZoneDataEntry");

	return Clss;
}


// ZoneDataEntry IslandsofInsight.Default__ZoneDataEntry
// (Public, ClassDefaultObject, ArchetypeObject)

class UZoneDataEntry* UZoneDataEntry::GetDefaultObj()
{
	static class UZoneDataEntry* Default = nullptr;

	if (!Default)
		Default = static_cast<UZoneDataEntry*>(UZoneDataEntry::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ZoneDataEntry.GetNumberedZoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UZoneDataEntry::GetNumberedZoneName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ZoneDataEntry", "GetNumberedZoneName");

	Params::UZoneDataEntry_GetNumberedZoneName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class IslandsofInsight.ZoneData
// (None)

class UClass* UZoneData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ZoneData");

	return Clss;
}


// ZoneData IslandsofInsight.Default__ZoneData
// (Public, ClassDefaultObject, ArchetypeObject)

class UZoneData* UZoneData::GetDefaultObj()
{
	static class UZoneData* Default = nullptr;

	if (!Default)
		Default = static_cast<UZoneData*>(UZoneData::StaticClass()->DefaultObject);

	return Default;
}


// Function IslandsofInsight.ZoneData.ZoneIndex_to_Zone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ZoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UZoneDataEntry*              ReturnValue                                                      (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UZoneDataEntry* UZoneData::ZoneIndex_to_Zone(int32 ZoneIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ZoneData", "ZoneIndex_to_Zone");

	Params::UZoneData_ZoneIndex_to_Zone_Params Parms{};

	Parms.ZoneIndex = ZoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function IslandsofInsight.ZoneData.ZoneEnum_to_Zone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EMainMapZoneName        ZoneEnum                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UZoneDataEntry*              ReturnValue                                                      (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UZoneDataEntry* UZoneData::ZoneEnum_to_Zone(enum class EMainMapZoneName ZoneEnum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ZoneData", "ZoneEnum_to_Zone");

	Params::UZoneData_ZoneEnum_to_Zone_Params Parms{};

	Parms.ZoneEnum = ZoneEnum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}

}


