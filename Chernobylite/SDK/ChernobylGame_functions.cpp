#pragma once

// Dumped with Dumper-7!


#include "../SDK.hpp"

namespace SDK
{
//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------


// Class ChernobylGame.ActorHighlightImage
// (Actor)

class UClass* AActorHighlightImage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ActorHighlightImage");

	return Clss;
}


// ActorHighlightImage ChernobylGame.Default__ActorHighlightImage
// (Public, ClassDefaultObject, ArchetypeObject)

class AActorHighlightImage* AActorHighlightImage::GetDefaultObj()
{
	static class AActorHighlightImage* Default = nullptr;

	if (!Default)
		Default = static_cast<AActorHighlightImage*>(AActorHighlightImage::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.BaseBuff
// (None)

class UClass* UBaseBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BaseBuff");

	return Clss;
}


// BaseBuff ChernobylGame.Default__BaseBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UBaseBuff* UBaseBuff::GetDefaultObj()
{
	static class UBaseBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UBaseBuff*>(UBaseBuff::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BaseBuff.IsHidden
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseBuff::IsHidden()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuff", "IsHidden");

	Params::UBaseBuff_IsHidden_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuff.GetReadableName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UBaseBuff::GetReadableName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuff", "GetReadableName");

	Params::UBaseBuff_GetReadableName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.AICalmReactionBuff
// (None)

class UClass* UAICalmReactionBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AICalmReactionBuff");

	return Clss;
}


// AICalmReactionBuff ChernobylGame.Default__AICalmReactionBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UAICalmReactionBuff* UAICalmReactionBuff::GetDefaultObj()
{
	static class UAICalmReactionBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UAICalmReactionBuff*>(UAICalmReactionBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AIMeleeDelay
// (None)

class UClass* UAIMeleeDelay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AIMeleeDelay");

	return Clss;
}


// AIMeleeDelay ChernobylGame.Default__AIMeleeDelay
// (Public, ClassDefaultObject, ArchetypeObject)

class UAIMeleeDelay* UAIMeleeDelay::GetDefaultObj()
{
	static class UAIMeleeDelay* Default = nullptr;

	if (!Default)
		Default = static_cast<UAIMeleeDelay*>(UAIMeleeDelay::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AIMeleeStunBuff
// (None)

class UClass* UAIMeleeStunBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AIMeleeStunBuff");

	return Clss;
}


// AIMeleeStunBuff ChernobylGame.Default__AIMeleeStunBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UAIMeleeStunBuff* UAIMeleeStunBuff::GetDefaultObj()
{
	static class UAIMeleeStunBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UAIMeleeStunBuff*>(UAIMeleeStunBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AKSaveTestActor
// (Actor)

class UClass* AAKSaveTestActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AKSaveTestActor");

	return Clss;
}


// AKSaveTestActor ChernobylGame.Default__AKSaveTestActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AAKSaveTestActor* AAKSaveTestActor::GetDefaultObj()
{
	static class AAKSaveTestActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AAKSaveTestActor*>(AAKSaveTestActor::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AnimSystemQueue
// (None)

class UClass* UAnimSystemQueue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimSystemQueue");

	return Clss;
}


// AnimSystemQueue ChernobylGame.Default__AnimSystemQueue
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimSystemQueue* UAnimSystemQueue::GetDefaultObj()
{
	static class UAnimSystemQueue* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimSystemQueue*>(UAnimSystemQueue::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AntiBuildSystemVolume
// (Actor)

class UClass* AAntiBuildSystemVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AntiBuildSystemVolume");

	return Clss;
}


// AntiBuildSystemVolume ChernobylGame.Default__AntiBuildSystemVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AAntiBuildSystemVolume* AAntiBuildSystemVolume::GetDefaultObj()
{
	static class AAntiBuildSystemVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AAntiBuildSystemVolume*>(AAntiBuildSystemVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.AreaSlotVolume
// (Actor)

class UClass* AAreaSlotVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AreaSlotVolume");

	return Clss;
}


// AreaSlotVolume ChernobylGame.Default__AreaSlotVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AAreaSlotVolume* AAreaSlotVolume::GetDefaultObj()
{
	static class AAreaSlotVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AAreaSlotVolume*>(AAreaSlotVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.AreaSlotVolume.OnOverlapStart
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAreaSlotVolume::OnOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AreaSlotVolume", "OnOverlapStart");

	Params::AAreaSlotVolume_OnOverlapStart_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.ArmorComponent
// (None)

class UClass* UArmorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ArmorComponent");

	return Clss;
}


// ArmorComponent ChernobylGame.Default__ArmorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UArmorComponent* UArmorComponent::GetDefaultObj()
{
	static class UArmorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UArmorComponent*>(UArmorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ArmorComponent.TakeDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Points                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     InDamageClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::TakeDamage(float Points, TSubclassOf<class UDamageType> InDamageClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "TakeDamage");

	Params::UArmorComponent_TakeDamage_Params Parms{};

	Parms.Points = Points;
	Parms.InDamageClass = InDamageClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.ReplenishArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Points                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::ReplenishArmor(float Points)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "ReplenishArmor");

	Params::UArmorComponent_ReplenishArmor_Params Parms{};

	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.OnPawnCombatLeft
// (Final, Native, Protected)
// Parameters:

void UArmorComponent::OnPawnCombatLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "OnPawnCombatLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ArmorComponent.OnPawnCombatEntered
// (Final, Native, Protected)
// Parameters:

void UArmorComponent::OnPawnCombatEntered()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "OnPawnCombatEntered");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ArmorComponent.OnMaximimHPModified
// (Final, Native, Protected)
// Parameters:

void UArmorComponent::OnMaximimHPModified()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "OnMaximimHPModified");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ArmorComponent.K2_GetArmorInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArmorInfo                  ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FArmorInfo UArmorComponent::K2_GetArmorInfo(class FName Name, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "K2_GetArmorInfo");

	Params::UArmorComponent_K2_GetArmorInfo_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.IsArmorEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArmorComponent::IsArmorEquipped()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "IsArmorEquipped");

	Params::UArmorComponent_IsArmorEquipped_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetMaxArmorValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::GetMaxArmorValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetMaxArmorValue");

	Params::UArmorComponent_GetMaxArmorValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetInsertInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FArmorInsertInfo            ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FArmorInsertInfo UArmorComponent::GetInsertInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetInsertInfo");

	Params::UArmorComponent_GetInsertInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetEquippedArmorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UArmorComponent::GetEquippedArmorName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetEquippedArmorName");

	Params::UArmorComponent_GetEquippedArmorName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetEquippedArmorInfoName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UArmorComponent::GetEquippedArmorInfoName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetEquippedArmorInfoName");

	Params::UArmorComponent_GetEquippedArmorInfoName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetEquippedArmorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FArmorInfo                  ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

struct FArmorInfo UArmorComponent::GetEquippedArmorInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetEquippedArmorInfo");

	Params::UArmorComponent_GetEquippedArmorInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetCurrentArmorValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::GetCurrentArmorValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetCurrentArmorValue");

	Params::UArmorComponent_GetCurrentArmorValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.GetArmorStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EArmorStatType          StatType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArmorComponent::GetArmorStat(enum class EArmorStatType StatType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "GetArmorStat");

	Params::UArmorComponent_GetArmorStat_Params Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.EquipDifferentArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ArmorInfoName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::EquipDifferentArmor(class FName ArmorInfoName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "EquipDifferentArmor");

	Params::UArmorComponent_EquipDifferentArmor_Params Parms{};

	Parms.ArmorInfoName = ArmorInfoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.CanProtectFromDamageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UDamageType>     InDamageClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArmorComponent::CanProtectFromDamageType(TSubclassOf<class UDamageType> InDamageClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "CanProtectFromDamageType");

	Params::UArmorComponent_CanProtectFromDamageType_Params Parms{};

	Parms.InDamageClass = InDamageClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ArmorComponent.ArmorStatToAlertModifier
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InArmorStat                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArmorComponent::ArmorStatToAlertModifier(int32 InArmorStat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArmorComponent", "ArmorStatToAlertModifier");

	Params::UArmorComponent_ArmorStatToAlertModifier_Params Parms{};

	Parms.InArmorStat = InArmorStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.AudioObjectShooter
// (Actor)

class UClass* AAudioObjectShooter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AudioObjectShooter");

	return Clss;
}


// AudioObjectShooter ChernobylGame.Default__AudioObjectShooter
// (Public, ClassDefaultObject, ArchetypeObject)

class AAudioObjectShooter* AAudioObjectShooter::GetDefaultObj()
{
	static class AAudioObjectShooter* Default = nullptr;

	if (!Default)
		Default = static_cast<AAudioObjectShooter*>(AAudioObjectShooter::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.Backend
// (Actor)

class UClass* ABackend::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Backend");

	return Clss;
}


// Backend ChernobylGame.Default__Backend
// (Public, ClassDefaultObject, ArchetypeObject)

class ABackend* ABackend::GetDefaultObj()
{
	static class ABackend* Default = nullptr;

	if (!Default)
		Default = static_cast<ABackend*>(ABackend::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.Backend.Update2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FEventResult>        Results                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ABackend::Update2(TArray<struct FEventResult>& Results)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "Update2");

	Params::ABackend_Update2_Params Parms{};

	Parms.Results = Results;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Backend.Update
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FEventResult>        Results                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ABackend::Update(TArray<struct FEventResult>& Results)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "Update");

	Params::ABackend_Update_Params Parms{};

	Parms.Results = Results;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Backend.UnsetCompanionFromCurrentActiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::UnsetCompanionFromCurrentActiveEvent(class FName Companion)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "UnsetCompanionFromCurrentActiveEvent");

	Params::ABackend_UnsetCompanionFromCurrentActiveEvent_Params Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.SetCompanionForActiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::SetCompanionForActiveEvent(class FName Event, class FName Companion)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "SetCompanionForActiveEvent");

	Params::ABackend_SetCompanionForActiveEvent_Params Parms{};

	Parms.Event = Event;
	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.RemoveFromPotential
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABackend::RemoveFromPotential(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "RemoveFromPotential");

	Params::ABackend_RemoveFromPotential_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Backend.PutToPotential
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABackend::PutToPotential(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "PutToPotential");

	Params::ABackend_PutToPotential_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Backend.IsMapEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::IsMapEnabled(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "IsMapEnabled");

	Params::ABackend_IsMapEnabled_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.IsMainQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::IsMainQuest(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "IsMainQuest");

	Params::ABackend_IsMainQuest_Params Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ABackend::Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "Init");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Backend.GetPossibleMissions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               FromMap                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ABackend::GetPossibleMissions(enum class EEventMap FromMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetPossibleMissions");

	Params::ABackend_GetPossibleMissions_Params Parms{};

	Parms.FromMap = FromMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetPossibleCompanions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ABackend::GetPossibleCompanions(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetPossibleCompanions");

	Params::ABackend_GetPossibleCompanions_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetOuterEventStructure
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOuterEvent                 ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOuterEvent ABackend::GetOuterEventStructure(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetOuterEventStructure");

	Params::ABackend_GetOuterEventStructure_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetEventCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABackend::GetEventCount(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetEventCount");

	Params::ABackend_GetEventCount_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetCurrentDay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABackend::GetCurrentDay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetCurrentDay");

	Params::ABackend_GetCurrentDay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetCompanion4Mission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ABackend::GetCompanion4Mission(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetCompanion4Mission");

	Params::ABackend_GetCompanion4Mission_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetChance4Mission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABackend::GetChance4Mission(class FName Event, class FName Companion)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetChance4Mission");

	Params::ABackend_GetChance4Mission_Params Parms{};

	Parms.Event = Event;
	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.GetActiveEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FInnerEvent>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInnerEvent> ABackend::GetActiveEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "GetActiveEvents");

	Params::ABackend_GetActiveEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.ForceDeactiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::ForceDeactiveEvent(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "ForceDeactiveEvent");

	Params::ABackend_ForceDeactiveEvent_Params Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.ForceActiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::ForceActiveEvent(class FName EventID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "ForceActiveEvent");

	Params::ABackend_ForceActiveEvent_Params Parms{};

	Parms.EventID = EventID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.EnableMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::EnableMap(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "EnableMap");

	Params::ABackend_EnableMap_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Backend.AdditionalDays
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Days                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABackend::AdditionalDays(class FName EventID, int32 Days)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Backend", "AdditionalDays");

	Params::ABackend_AdditionalDays_Params Parms{};

	Parms.EventID = EventID;
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.BaseBuildSystemEntity
// (Actor)

class UClass* ABaseBuildSystemEntity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BaseBuildSystemEntity");

	return Clss;
}


// BaseBuildSystemEntity ChernobylGame.Default__BaseBuildSystemEntity
// (Public, ClassDefaultObject, ArchetypeObject)

class ABaseBuildSystemEntity* ABaseBuildSystemEntity::GetDefaultObj()
{
	static class ABaseBuildSystemEntity* Default = nullptr;

	if (!Default)
		Default = static_cast<ABaseBuildSystemEntity*>(ABaseBuildSystemEntity::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BaseBuildSystemEntity.SpawnPickableScrappedResource
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                        ResourceName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::SpawnPickableScrappedResource(class FName ResourceName, float Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "SpawnPickableScrappedResource");

	Params::ABaseBuildSystemEntity_SpawnPickableScrappedResource_Params Parms{};

	Parms.ResourceName = ResourceName;
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.BaseBuildSystemEntity.Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ABaseBuildSystemEntity::Show()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Show");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.SetToBeUsedByCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGNPC*                      CompanionRef                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::SetToBeUsedByCompanion(class ACGNPC* CompanionRef)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "SetToBeUsedByCompanion");

	Params::ABaseBuildSystemEntity_SetToBeUsedByCompanion_Params Parms{};

	Parms.CompanionRef = CompanionRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.SetStorID
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                              NewID                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewCols                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::SetStorID(int32 NewID, int32 NewCols)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "SetStorID");

	Params::ABaseBuildSystemEntity_SetStorID_Params Parms{};

	Parms.NewID = NewID;
	Parms.NewCols = NewCols;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.SetBuildID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ID                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::SetBuildID(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "SetBuildID");

	Params::ABaseBuildSystemEntity_SetBuildID_Params Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.RestoreCompanionToOriginalSpot
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ABaseBuildSystemEntity::RestoreCompanionToOriginalSpot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "RestoreCompanionToOriginalSpot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.Replace
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ABaseBuildSystemEntity::Replace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Replace");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.Placed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ABaseBuildSystemEntity::Placed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Placed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.OnGlobalSkinChangedCPP
// (Final, Native, Public)
// Parameters:
// enum class EGlobalSkinType         SkinType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewSkinName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::OnGlobalSkinChangedCPP(enum class EGlobalSkinType SkinType, class FName NewSkinName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "OnGlobalSkinChangedCPP");

	Params::ABaseBuildSystemEntity_OnGlobalSkinChangedCPP_Params Parms{};

	Parms.SkinType = SkinType;
	Parms.NewSkinName = NewSkinName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.OnGlobalSkinChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EGlobalSkinType         SkinType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewSkinName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::OnGlobalSkinChanged(enum class EGlobalSkinType SkinType, class FName NewSkinName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "OnGlobalSkinChanged");

	Params::ABaseBuildSystemEntity_OnGlobalSkinChanged_Params Parms{};

	Parms.SkinType = SkinType;
	Parms.NewSkinName = NewSkinName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.BaseBuildSystemEntity.MultiSweapForCollision
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     LocationOffset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseBuildSystemEntity::MultiSweapForCollision(const struct FVector& LocationOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "MultiSweapForCollision");

	Params::ABaseBuildSystemEntity_MultiSweapForCollision_Params Parms{};

	Parms.LocationOffset = LocationOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuildSystemEntity.Lifted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ABaseBuildSystemEntity::Lifted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Lifted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.IsCurrentlyUsedByCompanion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseBuildSystemEntity::IsCurrentlyUsedByCompanion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "IsCurrentlyUsedByCompanion");

	Params::ABaseBuildSystemEntity_IsCurrentlyUsedByCompanion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuildSystemEntity.Hide
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ABaseBuildSystemEntity::Hide()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Hide");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.GetStorageID
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                              ID                                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Cols                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::GetStorageID(int32* ID, int32* Cols)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "GetStorageID");

	Params::ABaseBuildSystemEntity_GetStorageID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ID != nullptr)
		*ID = Parms.ID;

	if (Cols != nullptr)
		*Cols = Parms.Cols;

}


// Function ChernobylGame.BaseBuildSystemEntity.GetRangeDecalInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EBuildSystemDecalType   DecalType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBuildSystemRangeDecalInfo  ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBuildSystemRangeDecalInfo ABaseBuildSystemEntity::GetRangeDecalInfo(enum class EBuildSystemDecalType DecalType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "GetRangeDecalInfo");

	Params::ABaseBuildSystemEntity_GetRangeDecalInfo_Params Parms{};

	Parms.DecalType = DecalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuildSystemEntity.GetBuildID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ABaseBuildSystemEntity::GetBuildID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "GetBuildID");

	Params::ABaseBuildSystemEntity_GetBuildID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuildSystemEntity.GetAdditionalComponentsToHighlight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UPrimitiveComponent*> ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> ABaseBuildSystemEntity::GetAdditionalComponentsToHighlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "GetAdditionalComponentsToHighlight");

	Params::ABaseBuildSystemEntity_GetAdditionalComponentsToHighlight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BaseBuildSystemEntity.EnableOutline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Enable                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBuildSystemEntity::EnableOutline(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "EnableOutline");

	Params::ABaseBuildSystemEntity_EnableOutline_Params Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BaseBuildSystemEntity.Deleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ABaseBuildSystemEntity::Deleted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BaseBuildSystemEntity", "Deleted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.BillboardedTextRender
// (SceneComponent, PrimitiveComponent)

class UClass* UBillboardedTextRender::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BillboardedTextRender");

	return Clss;
}


// BillboardedTextRender ChernobylGame.Default__BillboardedTextRender
// (Public, ClassDefaultObject, ArchetypeObject)

class UBillboardedTextRender* UBillboardedTextRender::GetDefaultObj()
{
	static class UBillboardedTextRender* Default = nullptr;

	if (!Default)
		Default = static_cast<UBillboardedTextRender*>(UBillboardedTextRender::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.BuffManager
// (None)

class UClass* UBuffManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuffManager");

	return Clss;
}


// BuffManager ChernobylGame.Default__BuffManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UBuffManager* UBuffManager::GetDefaultObj()
{
	static class UBuffManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UBuffManager*>(UBuffManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuffManager.RemoveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseBuff>       Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuffManager::RemoveBuff(TSubclassOf<class UBaseBuff> Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuffManager", "RemoveBuff");

	Params::UBuffManager_RemoveBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuffManager.HaveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseBuff>       Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuffManager::HaveBuff(TSubclassOf<class UBaseBuff> Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuffManager", "HaveBuff");

	Params::UBuffManager_HaveBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuffManager.AddBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseBuff>       Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuffManager::AddBuff(TSubclassOf<class UBaseBuff> Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuffManager", "AddBuff");

	Params::UBuffManager_AddBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.BufforedQuickTimeEventNode
// (None)

class UClass* UBufforedQuickTimeEventNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BufforedQuickTimeEventNode");

	return Clss;
}


// BufforedQuickTimeEventNode ChernobylGame.Default__BufforedQuickTimeEventNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UBufforedQuickTimeEventNode* UBufforedQuickTimeEventNode::GetDefaultObj()
{
	static class UBufforedQuickTimeEventNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UBufforedQuickTimeEventNode*>(UBufforedQuickTimeEventNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BufforedQuickTimeEventNode.StickRotationVertical
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBufforedQuickTimeEventNode::StickRotationVertical(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "StickRotationVertical");

	Params::UBufforedQuickTimeEventNode_StickRotationVertical_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.StickRotationHorizontal
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBufforedQuickTimeEventNode::StickRotationHorizontal(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "StickRotationHorizontal");

	Params::UBufforedQuickTimeEventNode_StickRotationHorizontal_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.PlayBufforedQuickTimeEvent
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuickTimeEventData         QuickTimeEvent                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinInputForBufferOpening                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BufferEmptyingSpeed                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxBufferSize                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBufforedQuickTimeEventNode* ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBufforedQuickTimeEventNode* UBufforedQuickTimeEventNode::PlayBufforedQuickTimeEvent(class UObject* WorldContextObject, struct FQuickTimeEventData& QuickTimeEvent, class APlayerController* PlayerController, float MinInputForBufferOpening, float BufferEmptyingSpeed, float MaxBufferSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "PlayBufforedQuickTimeEvent");

	Params::UBufforedQuickTimeEventNode_PlayBufforedQuickTimeEvent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.QuickTimeEvent = QuickTimeEvent;
	Parms.PlayerController = PlayerController;
	Parms.MinInputForBufferOpening = MinInputForBufferOpening;
	Parms.BufferEmptyingSpeed = BufferEmptyingSpeed;
	Parms.MaxBufferSize = MaxBufferSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.HoldButtonStop
// (Final, Native, Private)
// Parameters:

void UBufforedQuickTimeEventNode::HoldButtonStop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "HoldButtonStop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.HoldButtonStart
// (Final, Native, Private)
// Parameters:

void UBufforedQuickTimeEventNode::HoldButtonStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "HoldButtonStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.CancelQuickTimeEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:

void UBufforedQuickTimeEventNode::CancelQuickTimeEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "CancelQuickTimeEvent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.ButtonPressed
// (Final, Native, Private)
// Parameters:

void UBufforedQuickTimeEventNode::ButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "ButtonPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.AxisPressed
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBufforedQuickTimeEventNode::AxisPressed(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "AxisPressed");

	Params::UBufforedQuickTimeEventNode_AxisPressed_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BufforedQuickTimeEventNode.AxisHeld
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBufforedQuickTimeEventNode::AxisHeld(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BufforedQuickTimeEventNode", "AxisHeld");

	Params::UBufforedQuickTimeEventNode_AxisHeld_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.BuildEntityCompanionSpotComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UBuildEntityCompanionSpotComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildEntityCompanionSpotComponent");

	return Clss;
}


// BuildEntityCompanionSpotComponent ChernobylGame.Default__BuildEntityCompanionSpotComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UBuildEntityCompanionSpotComponent* UBuildEntityCompanionSpotComponent::GetDefaultObj()
{
	static class UBuildEntityCompanionSpotComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UBuildEntityCompanionSpotComponent*>(UBuildEntityCompanionSpotComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuildEntityCompanionSpotComponent.GetCompanionSpawnLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBuildEntityCompanionSpotComponent::GetCompanionSpawnLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildEntityCompanionSpotComponent", "GetCompanionSpawnLocation");

	Params::UBuildEntityCompanionSpotComponent_GetCompanionSpawnLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildEntityCompanionSpotComponent.CanPlaceCompanion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildEntityCompanionSpotComponent::CanPlaceCompanion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildEntityCompanionSpotComponent", "CanPlaceCompanion");

	Params::UBuildEntityCompanionSpotComponent_CanPlaceCompanion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.BuildingBuiltVolume
// (Actor)

class UClass* ABuildingBuiltVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildingBuiltVolume");

	return Clss;
}


// BuildingBuiltVolume ChernobylGame.Default__BuildingBuiltVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ABuildingBuiltVolume* ABuildingBuiltVolume::GetDefaultObj()
{
	static class ABuildingBuiltVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ABuildingBuiltVolume*>(ABuildingBuiltVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.BuildMarker
// (SceneComponent)

class UClass* UBuildMarker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildMarker");

	return Clss;
}


// BuildMarker ChernobylGame.Default__BuildMarker
// (Public, ClassDefaultObject, ArchetypeObject)

class UBuildMarker* UBuildMarker::GetDefaultObj()
{
	static class UBuildMarker* Default = nullptr;

	if (!Default)
		Default = static_cast<UBuildMarker*>(UBuildMarker::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuildMarker.Turn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    Dir                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBuildMarker::Turn(const struct FRotator& Dir)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "Turn");

	Params::UBuildMarker_Turn_Params Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.SpawnEntity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::SpawnEntity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "SpawnEntity");

	Params::UBuildMarker_SpawnEntity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.SetMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                 NewMesh                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuildMarker::SetMesh(class UStaticMesh* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "SetMesh");

	Params::UBuildMarker_SetMesh_Params Parms{};

	Parms.NewMesh = NewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.SetIsOnLevelMode
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                               NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  Transform                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBuildMarker::SetIsOnLevelMode(bool NewValue, struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "SetIsOnLevelMode");

	Params::UBuildMarker_SetIsOnLevelMode_Params Parms{};

	Parms.NewValue = NewValue;
	Parms.Transform = Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.SetBuildID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ID                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseBuildSystemEntity*      StartingRotationActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuildMarker::SetBuildID(class FName ID, class ABaseBuildSystemEntity* StartingRotationActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "SetBuildID");

	Params::UBuildMarker_SetBuildID_Params Parms{};

	Parms.ID = ID;
	Parms.StartingRotationActor = StartingRotationActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.IsInEditMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::IsInEditMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "IsInEditMode");

	Params::UBuildMarker_IsInEditMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.IsEmpty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::IsEmpty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "IsEmpty");

	Params::UBuildMarker_IsEmpty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.IsBuildEntityInControlledArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::IsBuildEntityInControlledArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "IsBuildEntityInControlledArea");

	Params::UBuildMarker_IsBuildEntityInControlledArea_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UBuildMarker::GetTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetTransform");

	Params::UBuildMarker_GetTransform_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetLastBuildSystemVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABuildSystemVolume*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABuildSystemVolume* UBuildMarker::GetLastBuildSystemVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetLastBuildSystemVolume");

	Params::UBuildMarker_GetLastBuildSystemVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetIsBuildableAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::GetIsBuildableAvailable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetIsBuildableAvailable");

	Params::UBuildMarker_GetIsBuildableAvailable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetHasEnoughResourcesCached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::GetHasEnoughResourcesCached()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetHasEnoughResourcesCached");

	Params::UBuildMarker_GetHasEnoughResourcesCached_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetCurrentBuildID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBuildMarker::GetCurrentBuildID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetCurrentBuildID");

	Params::UBuildMarker_GetCurrentBuildID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetCanPlaceQuantityCheckCached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::GetCanPlaceQuantityCheckCached()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetCanPlaceQuantityCheckCached");

	Params::UBuildMarker_GetCanPlaceQuantityCheckCached_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.GetBuildEntityInFront
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABaseBuildSystemEntity*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseBuildSystemEntity* UBuildMarker::GetBuildEntityInFront()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "GetBuildEntityInFront");

	Params::UBuildMarker_GetBuildEntityInFront_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.ClearInternals
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UBuildMarker::ClearInternals()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "ClearInternals");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.CanBePlaced
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildMarker::CanBePlaced()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "CanBePlaced");

	Params::UBuildMarker_CanBePlaced_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.BuildMarker.ActivateEditMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UBuildMarker::ActivateEditMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "ActivateEditMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildMarker.ActivateBuildMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UBuildMarker::ActivateBuildMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildMarker", "ActivateBuildMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.BuildSystemCleanerVolume
// (Actor)

class UClass* ABuildSystemCleanerVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildSystemCleanerVolume");

	return Clss;
}


// BuildSystemCleanerVolume ChernobylGame.Default__BuildSystemCleanerVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ABuildSystemCleanerVolume* ABuildSystemCleanerVolume::GetDefaultObj()
{
	static class ABuildSystemCleanerVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ABuildSystemCleanerVolume*>(ABuildSystemCleanerVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuildSystemCleanerVolume.Activate
// (Final, Native, Private, BlueprintCallable)
// Parameters:

void ABuildSystemCleanerVolume::Activate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemCleanerVolume", "Activate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.BuildSystemInterface
// (None)

class UClass* IBuildSystemInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildSystemInterface");

	return Clss;
}


// BuildSystemInterface ChernobylGame.Default__BuildSystemInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IBuildSystemInterface* IBuildSystemInterface::GetDefaultObj()
{
	static class IBuildSystemInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IBuildSystemInterface*>(IBuildSystemInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuildSystemInterface.InputUpPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputUpPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputUpPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputRotationMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              InAxis                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBuildSystemInterface::InputRotationMode(float InAxis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputRotationMode");

	Params::IBuildSystemInterface_InputRotationMode_Params Parms{};

	Parms.InAxis = InAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputRightPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputRightPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputRightPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputR2Released
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputR2Released()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputR2Released");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputR2Pressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputR2Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputR2Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputR1Pressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputR1Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputR1Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputLeftPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputLeftPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputLeftPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputL2Released
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputL2Released()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputL2Released");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputL2Pressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputL2Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputL2Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputL1Pressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputL1Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputL1Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputFaceUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputFaceUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputFaceUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputFaceRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputFaceRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputFaceRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputFaceLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputFaceLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputFaceLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputFaceDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputFaceDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputFaceDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputDPadUpPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputDPadUpPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputDPadUpPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputDPadRightPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputDPadRightPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputDPadRightPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputDPadLeftPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputDPadLeftPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputDPadLeftPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputDPadDownPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputDPadDownPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputDPadDownPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.BuildSystemInterface.InputDownPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IBuildSystemInterface::InputDownPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemInterface", "InputDownPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.BuildSystemVolume
// (Actor)

class UClass* ABuildSystemVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BuildSystemVolume");

	return Clss;
}


// BuildSystemVolume ChernobylGame.Default__BuildSystemVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ABuildSystemVolume* ABuildSystemVolume::GetDefaultObj()
{
	static class ABuildSystemVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ABuildSystemVolume*>(ABuildSystemVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.BuildSystemVolume.ChangeWorkplaceQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuildSystemVolume::ChangeWorkplaceQuality(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BuildSystemVolume", "ChangeWorkplaceQuality");

	Params::ABuildSystemVolume_ChangeWorkplaceQuality_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGMovementState
// (Actor)

class UClass* ACGMovementState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMovementState");

	return Clss;
}


// CGMovementState ChernobylGame.Default__CGMovementState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGMovementState* ACGMovementState::GetDefaultObj()
{
	static class ACGMovementState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGMovementState*>(ACGMovementState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGMovementState.Utility_AnyKeyboardKey_Pressed
// (Native, Public)
// Parameters:

void ACGMovementState::Utility_AnyKeyboardKey_Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Utility_AnyKeyboardKey_Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Utility_AnyGamepadKey_Pressed
// (Native, Public)
// Parameters:

void ACGMovementState::Utility_AnyGamepadKey_Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Utility_AnyGamepadKey_Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.StateTick
// (Native, Public)
// Parameters:
// float                              InDeltaTime                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::StateTick(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "StateTick");

	Params::ACGMovementState_StateTick_Params Parms{};

	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.SetRightLeftOnceLast
// (Final, Native, Public)
// Parameters:
// float                              InVal                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::SetRightLeftOnceLast(float InVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "SetRightLeftOnceLast");

	Params::ACGMovementState_SetRightLeftOnceLast_Params Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.RecoverKeyCombination
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<class FString>              InCombination                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACGMovementState::RecoverKeyCombination(TArray<class FString>& InCombination)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "RecoverKeyCombination");

	Params::ACGMovementState_RecoverKeyCombination_Params Parms{};

	Parms.InCombination = InCombination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_ZoomUp
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_ZoomUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_ZoomUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_ZoomDown
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_ZoomDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_ZoomDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUseScroll
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUseScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUseScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse8
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse8()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse8");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse7
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse7()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse7");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse6
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse6()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse6");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse5
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse5()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse5");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse4
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse3
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse2
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse1
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_QuickUse
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_QuickUse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_QuickUse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_Pause
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_MoveUp
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_MoveUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_MoveUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_MoveRight
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_MoveRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_MoveRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_MoveLeft
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_MoveLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_MoveLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_MoveDown
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_MoveDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_MoveDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_Map
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_Map");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_Inventory
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_Inventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_Inventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_Grab_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_Grab_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_Grab_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Shortcuts_Grab
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Shortcuts_Grab()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Shortcuts_Grab");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Up
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Sprint_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Sprint_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Sprint_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Sprint
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Sprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Sprint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Right
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Left
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Jump_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Jump_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Jump_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Jump
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Jump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Jump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Down
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Crouch_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Crouch_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Crouch_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Movement_Crouch
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Movement_Crouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Movement_Crouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Use_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Use_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Use_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Use
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Use()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Use");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_UI_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_UI_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_UI_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_UI
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_UI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_UI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Tabs_Right
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Tabs_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Tabs_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Tabs_Left
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Tabs_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Tabs_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Scrap
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Scrap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Scrap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Reload_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Reload_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Reload_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Reload
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Reload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Reload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_HideWeapon
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_HideWeapon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_HideWeapon");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Flashlight
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Flashlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Flashlight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_BuildSystem
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_BuildSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_BuildSystem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Attack_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Attack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Attack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Attack
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_AlternativeAttack_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_AlternativeAttack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_AlternativeAttack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_AlternativeAttack
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_AlternativeAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_AlternativeAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Accept_Release
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Accept_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Accept_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.PC_Interaction_Accept
// (Native, Public)
// Parameters:

void ACGMovementState::PC_Interaction_Accept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "PC_Interaction_Accept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnSwitchStart
// (Native, Public)
// Parameters:

void ACGMovementState::OnSwitchStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnSwitchStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnSwitchEnd
// (Native, Public)
// Parameters:

void ACGMovementState::OnSwitchEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnSwitchEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnReloadStart
// (Native, Public)
// Parameters:

void ACGMovementState::OnReloadStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnReloadStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnReloadEnd
// (Native, Public)
// Parameters:

void ACGMovementState::OnReloadEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnReloadEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnKeyCombination
// (Native, Public, HasOutParams)
// Parameters:
// TArray<class FString>              InCombination                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACGMovementState::OnKeyCombination(TArray<class FString>& InCombination)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnKeyCombination");

	Params::ACGMovementState_OnKeyCombination_Params Parms{};

	Parms.InCombination = InCombination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnExit
// (Native, Public)
// Parameters:

void ACGMovementState::OnExit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnExit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnEnter
// (Native, Public)
// Parameters:

void ACGMovementState::OnEnter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnEnter");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.OnClimbRequest
// (Native, Public, HasOutParams)
// Parameters:
// struct FCGClimbQuery               InClimbQuery                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGMovementState::OnClimbRequest(struct FCGClimbQuery& InClimbQuery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "OnClimbRequest");

	Params::ACGMovementState_OnClimbRequest_Params Parms{};

	Parms.InClimbQuery = InClimbQuery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.InitPawn
// (Final, Native, Protected)
// Parameters:

void ACGMovementState::InitPawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "InitPawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Global_Movement_UpDown
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Global_Movement_UpDown(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Global_Movement_UpDown");

	Params::ACGMovementState_Global_Movement_UpDown_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Global_Movement_RightLeft
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Global_Movement_RightLeft(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Global_Movement_RightLeft");

	Params::ACGMovementState_Global_Movement_RightLeft_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Global_Movement_Look_UpDown
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Global_Movement_Look_UpDown(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Global_Movement_Look_UpDown");

	Params::ACGMovementState_Global_Movement_Look_UpDown_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Global_Movement_Look_RightLeft
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Global_Movement_Look_RightLeft(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Global_Movement_Look_RightLeft");

	Params::ACGMovementState_Global_Movement_Look_RightLeft_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Global_Movement_Lean
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Global_Movement_Lean(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Global_Movement_Lean");

	Params::ACGMovementState_Global_Movement_Lean_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.GetRightLeftOnceLast
// (Final, Native, Public)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGMovementState::GetRightLeftOnceLast()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "GetRightLeftOnceLast");

	Params::ACGMovementState_GetRightLeftOnceLast_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.GetLeanAxis
// (Final, Native, Public)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGMovementState::GetLeanAxis()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "GetLeanAxis");

	Params::ACGMovementState_GetLeanAxis_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.GetEnemyChatterEnabled
// (Native, Public, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGMovementState::GetEnemyChatterEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "GetEnemyChatterEnabled");

	Params::ACGMovementState_GetEnemyChatterEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.GetClimbEnabled
// (Native, Public)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGMovementState::GetClimbEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "GetClimbEnabled");

	Params::ACGMovementState_GetClimbEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.GetAdditionalInfo
// (Final, Native, Public)
// Parameters:
// struct FCGMovementStateAdditionalInfoReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGMovementStateAdditionalInfo ACGMovementState::GetAdditionalInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "GetAdditionalInfo");

	Params::ACGMovementState_GetAdditionalInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMovementState.delegate_OnDialogueStarted
// (Native, Public)
// Parameters:

void ACGMovementState::Delegate_OnDialogueStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "delegate_OnDialogueStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.delegate_OnDialogueEnded
// (Native, Public)
// Parameters:

void ACGMovementState::Delegate_OnDialogueEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "delegate_OnDialogueEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Shortcuts_QuickUse4
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Shortcuts_QuickUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Shortcuts_QuickUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Shortcuts_QuickUse3
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Shortcuts_QuickUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Shortcuts_QuickUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Shortcuts_QuickUse2
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Shortcuts_QuickUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Shortcuts_QuickUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Shortcuts_QuickUse1
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Shortcuts_QuickUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Shortcuts_QuickUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Shortcuts_Pause
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Shortcuts_Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Shortcuts_Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Up
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Sprint_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Sprint_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Sprint_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Sprint
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Sprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Sprint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Rotate_Right
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Console_Movement_Rotate_Right(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Rotate_Right");

	Params::ACGMovementState_Console_Movement_Rotate_Right_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Rotate_Left
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::Console_Movement_Rotate_Left(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Rotate_Left");

	Params::ACGMovementState_Console_Movement_Rotate_Left_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Right
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Reloading_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Reloading_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Reloading_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Reloading
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Reloading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Reloading");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Left
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Jump_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Jump_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Jump_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Jump
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Jump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Jump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Down
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Crouch_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Crouch_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Crouch_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Movement_Crouch
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Movement_Crouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Movement_Crouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_UI_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_UI_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_UI_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_UI
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_UI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_UI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_Tabs_Right
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_Tabs_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_Tabs_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_Tabs_Left
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_Tabs_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_Tabs_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_Scrap
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_Scrap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_Scrap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_FlashLight
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_FlashLight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_FlashLight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_Attack_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_Attack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_Attack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_Attack
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_AlternativeAttack_Release
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_AlternativeAttack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_AlternativeAttack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.Console_Interaction_AlternativeAttack
// (Native, Public)
// Parameters:

void ACGMovementState::Console_Interaction_AlternativeAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "Console_Interaction_AlternativeAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.ClearKeyCombination
// (Final, Native, Public)
// Parameters:

void ACGMovementState::ClearKeyCombination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "ClearKeyCombination");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMovementState.AddKeyCombination
// (Final, Native, Public)
// Parameters:
// class FString                      InKeyString                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMovementState::AddKeyCombination(const class FString& InKeyString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMovementState", "AddKeyCombination");

	Params::ACGMovementState_AddKeyCombination_Params Parms{};

	Parms.InKeyString = InKeyString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGActionClimbState
// (Actor)

class UClass* ACGActionClimbState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGActionClimbState");

	return Clss;
}


// CGActionClimbState ChernobylGame.Default__CGActionClimbState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGActionClimbState* ACGActionClimbState::GetDefaultObj()
{
	static class ACGActionClimbState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGActionClimbState*>(ACGActionClimbState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGActiveItem
// (Actor)

class UClass* ACGActiveItem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGActiveItem");

	return Clss;
}


// CGActiveItem ChernobylGame.Default__CGActiveItem
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGActiveItem* ACGActiveItem::GetDefaultObj()
{
	static class ACGActiveItem* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGActiveItem*>(ACGActiveItem::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGActiveItem.UpdateUpgradeDisplay
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCanBeCrafted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::UpdateUpgradeDisplay(enum class EUpgradeType Type, class FName UpgradeID, bool bCanBeCrafted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "UpdateUpgradeDisplay");

	Params::ACGActiveItem_UpdateUpgradeDisplay_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;
	Parms.bCanBeCrafted = bCanBeCrafted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.UpdateUpgrade
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::UpdateUpgrade(enum class EUpgradeType Type, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "UpdateUpgrade");

	Params::ACGActiveItem_UpdateUpgrade_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.SetItemDisabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGActiveItem::SetItemDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "SetItemDisabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.SetAlternativeActivationBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InNewBlocked                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::SetAlternativeActivationBlocked(bool InNewBlocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "SetAlternativeActivationBlocked");

	Params::ACGActiveItem_SetAlternativeActivationBlocked_Params Parms{};

	Parms.InNewBlocked = InNewBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.SetActivationBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InNewBlocked                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::SetActivationBlocked(bool InNewBlocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "SetActivationBlocked");

	Params::ACGActiveItem_SetActivationBlocked_Params Parms{};

	Parms.InNewBlocked = InNewBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.SafelySetIdleState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGActiveItem::SafelySetIdleState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "SafelySetIdleState");

	Params::ACGActiveItem_SafelySetIdleState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.ResetUpgrades
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::ResetUpgrades(enum class EUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "ResetUpgrades");

	Params::ACGActiveItem_ResetUpgrades_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.RefreshUpgrades
// (Native, Public, BlueprintCallable)
// Parameters:

void ACGActiveItem::RefreshUpgrades()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "RefreshUpgrades");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.OnPlayerInitialized
// (Native, Event, Protected, BlueprintEvent)
// Parameters:

void ACGActiveItem::OnPlayerInitialized()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "OnPlayerInitialized");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.OnMovementStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class ACGMovementState>InNewMovementState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::OnMovementStateChanged(TSubclassOf<class ACGMovementState> InNewMovementState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "OnMovementStateChanged");

	Params::ACGActiveItem_OnMovementStateChanged_Params Parms{};

	Parms.InNewMovementState = InNewMovementState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.OnInventoryInitialized
// (Native, Event, Protected, BlueprintEvent)
// Parameters:

void ACGActiveItem::OnInventoryInitialized()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "OnInventoryInitialized");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.OnHideShowAdditional
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// enum class EState                  OutTargetState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::OnHideShowAdditional(enum class EState OutTargetState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "OnHideShowAdditional");

	Params::ACGActiveItem_OnHideShowAdditional_Params Parms{};

	Parms.OutTargetState = OutTargetState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.OnCancelRequest
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::OnCancelRequest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "OnCancelRequest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.LoadPaniniMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InMasterLerp                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::LoadPaniniMaterials(bool InMasterLerp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "LoadPaniniMaterials");

	Params::ACGActiveItem_LoadPaniniMaterials_Params Parms{};

	Parms.InMasterLerp = InMasterLerp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.GetUpgradeLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGActiveItem::GetUpgradeLocation(enum class EUpgradeType Type, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetUpgradeLocation");

	Params::ACGActiveItem_GetUpgradeLocation_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.GetOtherHandIKTarget
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ACGActiveItem::GetOtherHandIKTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetOtherHandIKTarget");

	Params::ACGActiveItem_GetOtherHandIKTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.GetItemDisabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGActiveItem::GetItemDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetItemDisabled");

	Params::ACGActiveItem_GetItemDisabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.GetInterpretedItemState
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EState                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EState ACGActiveItem::GetInterpretedItemState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetInterpretedItemState");

	Params::ACGActiveItem_GetInterpretedItemState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.GetHands
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACGActiveItem::GetHands()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetHands");

	Params::ACGActiveItem_GetHands_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.GetCanBeQueried
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGActiveItem::GetCanBeQueried()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "GetCanBeQueried");

	Params::ACGActiveItem_GetCanBeQueried_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGActiveItem.ForceItemState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InContext                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EState                  InNewState                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::ForceItemState(class AActor* InContext, enum class EState InNewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "ForceItemState");

	Params::ACGActiveItem_ForceItemState_Params Parms{};

	Parms.InContext = InContext;
	Parms.InNewState = InNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.FailedAlternativeActivateItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::FailedAlternativeActivateItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "FailedAlternativeActivateItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.FailedActivateItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::FailedActivateItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "FailedActivateItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.AlternativeActivationButtonReleased
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::AlternativeActivationButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "AlternativeActivationButtonReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.AlternativeActivateItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::AlternativeActivateItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "AlternativeActivateItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.AdditionalUsabilityDos
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGActiveItem::AdditionalUsabilityDos()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "AdditionalUsabilityDos");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.AdditionalUsability
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGActiveItem::AdditionalUsability()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "AdditionalUsability");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.ActivationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInGracefully                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInNoSwap                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGActiveItem::ActivationFinished(bool bInGracefully, bool bInNoSwap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "ActivationFinished");

	Params::ACGActiveItem_ActivationFinished_Params Parms{};

	Parms.bInGracefully = bInGracefully;
	Parms.bInNoSwap = bInNoSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.ActivationButtonReleased
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::ActivationButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "ActivationButtonReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGActiveItem.ActivateItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGActiveItem::ActivateItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActiveItem", "ActivateItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGActorDebug
// (None)

class UClass* UCGActorDebug::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGActorDebug");

	return Clss;
}


// CGActorDebug ChernobylGame.Default__CGActorDebug
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGActorDebug* UCGActorDebug::GetDefaultObj()
{
	static class UCGActorDebug* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGActorDebug*>(UCGActorDebug::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGActorDebug.Refresh
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGActorDebug::Refresh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGActorDebug", "Refresh");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.CGAggroComponent
// (None)

class UClass* UCGAggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAggroComponent");

	return Clss;
}


// CGAggroComponent ChernobylGame.Default__CGAggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAggroComponent* UCGAggroComponent::GetDefaultObj()
{
	static class UCGAggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAggroComponent*>(UCGAggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAggroComponent.UpdateAggroStates
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGAggroComponent::UpdateAggroStates()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "UpdateAggroStates");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAggroComponent.OnSightUpdate
// (Final, Native, Private)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                 InStimulus                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAggroComponent::OnSightUpdate(class AActor* InActor, const struct FAIStimulus& InStimulus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "OnSightUpdate");

	Params::UCGAggroComponent_OnSightUpdate_Params Parms{};

	Parms.InActor = InActor;
	Parms.InStimulus = InStimulus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAggroComponent.OnHearingUpdate
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AActor*                      InInstigator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNoiseLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseStrength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InTag                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMaxDistanceToActivateCombat                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAggroComponent::OnHearingUpdate(class AActor* InInstigator, float InNoiseRange, const struct FVector& InNoiseLocation, float InNoiseStrength, class FName InTag, float InMaxDistanceToActivateCombat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "OnHearingUpdate");

	Params::UCGAggroComponent_OnHearingUpdate_Params Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InNoiseRange = InNoiseRange;
	Parms.InNoiseLocation = InNoiseLocation;
	Parms.InNoiseStrength = InNoiseStrength;
	Parms.InTag = InTag;
	Parms.InMaxDistanceToActivateCombat = InMaxDistanceToActivateCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAggroComponent.OnDeath
// (Native, Protected, HasOutParams)
// Parameters:
// class AActor*                      InAActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCGAggroComponent::OnDeath(class AActor* InAActor, struct FCGDamageEvent& InDamageEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "OnDeath");

	Params::UCGAggroComponent_OnDeath_Params Parms{};

	Parms.InAActor = InAActor;
	Parms.InDamageEvent = InDamageEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAggroComponent.GetPotentialTargets
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGCharacter*>        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGCharacter*> UCGAggroComponent::GetPotentialTargets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "GetPotentialTargets");

	Params::UCGAggroComponent_GetPotentialTargets_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAggroComponent.GetMemories
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCGPerceptionMemory> ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<struct FCGPerceptionMemory> UCGAggroComponent::GetMemories()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "GetMemories");

	Params::UCGAggroComponent_GetMemories_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAggroComponent.GetBestTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bInPrioritizeHero                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInCheckPath                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGCharacter*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGCharacter* UCGAggroComponent::GetBestTarget(bool bInPrioritizeHero, bool bInCheckPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "GetBestTarget");

	Params::UCGAggroComponent_GetBestTarget_Params Parms{};

	Parms.bInPrioritizeHero = bInPrioritizeHero;
	Parms.bInCheckPath = bInCheckPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAggroComponent.FlushMemory
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGAggroComponent::FlushMemory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAggroComponent", "FlushMemory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAI
// (None)

class UClass* UCGAI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAI");

	return Clss;
}


// CGAI ChernobylGame.Default__CGAI
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAI* UCGAI::GetDefaultObj()
{
	static class UCGAI* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAI*>(UCGAI::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAI.SetNewMoveToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*               InAIController                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InNewMoveToActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAI::SetNewMoveToActor(class AAIController* InAIController, class AActor* InNewMoveToActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAI", "SetNewMoveToActor");

	Params::UCGAI_SetNewMoveToActor_Params Parms{};

	Parms.InAIController = InAIController;
	Parms.InNewMoveToActor = InNewMoveToActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAI.GetMoveToTaskLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*               InAIController                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCGAI::GetMoveToTaskLocation(class AAIController* InAIController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAI", "GetMoveToTaskLocation");

	Params::UCGAI_GetMoveToTaskLocation_Params Parms{};

	Parms.InAIController = InAIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAI.GetCurrentlyActiveTask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*               InAIController                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBTTaskNode*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBTTaskNode* UCGAI::GetCurrentlyActiveTask(class AAIController* InAIController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAI", "GetCurrentlyActiveTask");

	Params::UCGAI_GetCurrentlyActiveTask_Params Parms{};

	Parms.InAIController = InAIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGCharacter
// (Actor, Pawn)

class UClass* ACGCharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCharacter");

	return Clss;
}


// CGCharacter ChernobylGame.Default__CGCharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCharacter* ACGCharacter::GetDefaultObj()
{
	static class ACGCharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCharacter*>(ACGCharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCharacter.OverrideDamageClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCGDamageType>   InDamageClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGCharacter::OverrideDamageClass(TSubclassOf<class UCGDamageType> InDamageClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "OverrideDamageClass");

	Params::ACGCharacter_OverrideDamageClass_Params Parms{};

	Parms.InDamageClass = InDamageClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacter.GetVisibilityModifier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGCharacter::GetVisibilityModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetVisibilityModifier");

	Params::ACGCharacter_GetVisibilityModifier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.GetMemoryOfMeOwners
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGAICharacter*>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGAICharacter*> ACGCharacter::GetMemoryOfMeOwners()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetMemoryOfMeOwners");

	Params::ACGCharacter_GetMemoryOfMeOwners_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.GetMappedDamageCollider
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDamageCollider         InDamageCollider                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ACGCharacter::GetMappedDamageCollider(enum class EDamageCollider InDamageCollider)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetMappedDamageCollider");

	Params::ACGCharacter_GetMappedDamageCollider_Params Parms{};

	Parms.InDamageCollider = InDamageCollider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.GetDamageClassOverrideEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGCharacter::GetDamageClassOverrideEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetDamageClassOverrideEnabled");

	Params::ACGCharacter_GetDamageClassOverrideEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.GetDamageClassOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UCGDamageType>   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UCGDamageType> ACGCharacter::GetDamageClassOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetDamageClassOverride");

	Params::ACGCharacter_GetDamageClassOverride_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.GetCGCharacterMovementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCGCharacterMovementComponent*ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCGCharacterMovementComponent* ACGCharacter::GetCGCharacterMovementComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "GetCGCharacterMovementComponent");

	Params::ACGCharacter_GetCGCharacterMovementComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacter.DisableDamageClassOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGCharacter::DisableDamageClassOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacter", "DisableDamageClassOverride");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAICharacter
// (Actor, Pawn)

class UClass* ACGAICharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAICharacter");

	return Clss;
}


// CGAICharacter ChernobylGame.Default__CGAICharacter
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGAICharacter* ACGAICharacter::GetDefaultObj()
{
	static class ACGAICharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGAICharacter*>(ACGAICharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAICharacter.UpdatePointOfInterest
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InNewPointOfInterest                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::UpdatePointOfInterest(const struct FVector& InNewPointOfInterest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "UpdatePointOfInterest");

	Params::ACGAICharacter_UpdatePointOfInterest_Params Parms{};

	Parms.InNewPointOfInterest = InNewPointOfInterest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.UpdateLocomotionProperties
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGAILocomotionProperties   InLocomotionProperties                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGAICharacter::UpdateLocomotionProperties(struct FCGAILocomotionProperties& InLocomotionProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "UpdateLocomotionProperties");

	Params::ACGAICharacter_UpdateLocomotionProperties_Params Parms{};

	Parms.InLocomotionProperties = InLocomotionProperties;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.UpdateApproachIdleAnims
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGApproachIdleSettings     InNewApproachIdle                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::UpdateApproachIdleAnims(struct FCGApproachIdleSettings& InNewApproachIdle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "UpdateApproachIdleAnims");

	Params::ACGAICharacter_UpdateApproachIdleAnims_Params Parms{};

	Parms.InNewApproachIdle = InNewApproachIdle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.TargetPerceptionUpdated
// (Final, Native, Public)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                 InStimulus                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::TargetPerceptionUpdated(class AActor* InActor, const struct FAIStimulus& InStimulus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "TargetPerceptionUpdated");

	Params::ACGAICharacter_TargetPerceptionUpdated_Params Parms{};

	Parms.InActor = InActor;
	Parms.InStimulus = InStimulus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SpawnPickable
// (Final, Native, Public)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SpawnPickable(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SpawnPickable");

	Params::ACGAICharacter_SpawnPickable_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetUIDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewVisibility                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetUIDebug(bool bInNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetUIDebug");

	Params::ACGAICharacter_SetUIDebug_Params Parms{};

	Parms.bInNewVisibility = bInNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetStrafing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InStrafingTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInIsStrafing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetStrafing(class AActor* InStrafingTarget, bool bInIsStrafing)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetStrafing");

	Params::ACGAICharacter_SetStrafing_Params Parms{};

	Parms.InStrafingTarget = InStrafingTarget;
	Parms.bInIsStrafing = bInIsStrafing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetRotateInPlace
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                               bInNewRotate                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    InTargetRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::SetRotateInPlace(bool bInNewRotate, const struct FRotator& InTargetRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetRotateInPlace");

	Params::ACGAICharacter_SetRotateInPlace_Params Parms{};

	Parms.bInNewRotate = bInNewRotate;
	Parms.InTargetRotation = InTargetRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetReactionToHeroDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EReactionToVisibleHero  InNewReaction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EReactionToVisibleHero  InReactionAfterDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDelayLength                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetReactionToHeroDelayed(enum class EReactionToVisibleHero InNewReaction, enum class EReactionToVisibleHero InReactionAfterDelay, float InDelayLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetReactionToHeroDelayed");

	Params::ACGAICharacter_SetReactionToHeroDelayed_Params Parms{};

	Parms.InNewReaction = InNewReaction;
	Parms.InReactionAfterDelay = InReactionAfterDelay;
	Parms.InDelayLength = InDelayLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetReactionToHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EReactionToVisibleHero  InNewReaction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetReactionToHero(enum class EReactionToVisibleHero InNewReaction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetReactionToHero");

	Params::ACGAICharacter_SetReactionToHero_Params Parms{};

	Parms.InNewReaction = InNewReaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNextPatrolActorWithNavNoRestart
// (Native, Public, BlueprintCallable)
// Parameters:
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNextPatrolActorWithNavNoRestart(class APatrolActor* InNextPatrolActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNextPatrolActorWithNavNoRestart");

	Params::ACGAICharacter_SetNextPatrolActorWithNavNoRestart_Params Parms{};

	Parms.InNextPatrolActor = InNextPatrolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNextPatrolActorWithNav
// (Native, Public, BlueprintCallable)
// Parameters:
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNextPatrolActorWithNav(class APatrolActor* InNextPatrolActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNextPatrolActorWithNav");

	Params::ACGAICharacter_SetNextPatrolActorWithNav_Params Parms{};

	Parms.InNextPatrolActor = InNextPatrolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNextPatrolActorNoRestart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNextPatrolActorNoRestart(class APatrolActor* InNextPatrolActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNextPatrolActorNoRestart");

	Params::ACGAICharacter_SetNextPatrolActorNoRestart_Params Parms{};

	Parms.InNextPatrolActor = InNextPatrolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNextPatrolActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNextPatrolActor(class APatrolActor* InNextPatrolActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNextPatrolActor");

	Params::ACGAICharacter_SetNextPatrolActor_Params Parms{};

	Parms.InNextPatrolActor = InNextPatrolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNewAIState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCGAIState>      InNewAIState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGAIStateAdditionalInfo    InAdditionalInfo                                                 (Parm, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNewAIState(TSubclassOf<class UCGAIState> InNewAIState, const struct FCGAIStateAdditionalInfo& InAdditionalInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNewAIState");

	Params::ACGAICharacter_SetNewAIState_Params Parms{};

	Parms.InNewAIState = InNewAIState;
	Parms.InAdditionalInfo = InAdditionalInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNavTargetNewLocationResetNextPatrol
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InNewLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNavTargetNewLocationResetNextPatrol(const struct FVector& InNewLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNavTargetNewLocationResetNextPatrol");

	Params::ACGAICharacter_SetNavTargetNewLocationResetNextPatrol_Params Parms{};

	Parms.InNewLocation = InNewLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetNavTargetNewLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InNewLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetNavTargetNewLocation(const struct FVector& InNewLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetNavTargetNewLocation");

	Params::ACGAICharacter_SetNavTargetNewLocation_Params Parms{};

	Parms.InNewLocation = InNewLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetMotionfixTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  InTargetTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::SetMotionfixTargetTransform(const struct FTransform& InTargetTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetMotionfixTargetTransform");

	Params::ACGAICharacter_SetMotionfixTargetTransform_Params Parms{};

	Parms.InTargetTransform = InTargetTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetLandMovementMode
// (Native, Protected)
// Parameters:
// enum class ELandMovementMode       InMovementMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetLandMovementMode(enum class ELandMovementMode InMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetLandMovementMode");

	Params::ACGAICharacter_SetLandMovementMode_Params Parms{};

	Parms.InMovementMode = InMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetHeadTracingProperties
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// enum class EHeadTracingMode        InNewTracingMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNewTracedStationaryPoint                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InNewTracedActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*      InNewTracedSkeletalMesh                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InNewTracedSocketName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetHeadTracingProperties(enum class EHeadTracingMode InNewTracingMode, const struct FVector& InNewTracedStationaryPoint, class AActor* InNewTracedActor, class USkeletalMeshComponent* InNewTracedSkeletalMesh, class FName InNewTracedSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetHeadTracingProperties");

	Params::ACGAICharacter_SetHeadTracingProperties_Params Parms{};

	Parms.InNewTracingMode = InNewTracingMode;
	Parms.InNewTracedStationaryPoint = InNewTracedStationaryPoint;
	Parms.InNewTracedActor = InNewTracedActor;
	Parms.InNewTracedSkeletalMesh = InNewTracedSkeletalMesh;
	Parms.InNewTracedSocketName = InNewTracedSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetDeathFunctionOverrideEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetDeathFunctionOverrideEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetDeathFunctionOverrideEnabled");

	Params::ACGAICharacter_SetDeathFunctionOverrideEnabled_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetCurrentLandMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELandMovementMode       InNewLandMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetCurrentLandMovementMode(enum class ELandMovementMode InNewLandMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetCurrentLandMovementMode");

	Params::ACGAICharacter_SetCurrentLandMovementMode_Params Parms{};

	Parms.InNewLandMovementMode = InNewLandMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGCover*                    InNewCover                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetCover(class ACGCover* InNewCover)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetCover");

	Params::ACGAICharacter_SetCover_Params Parms{};

	Parms.InNewCover = InNewCover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetCollisionModeForInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EInterpolationCollisionReactionInNewReaction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetCollisionModeForInterpolation(enum class EInterpolationCollisionReaction InNewReaction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetCollisionModeForInterpolation");

	Params::ACGAICharacter_SetCollisionModeForInterpolation_Params Parms{};

	Parms.InNewReaction = InNewReaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.SetApproachIdleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewEnabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::SetApproachIdleEnabled(bool bInNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "SetApproachIdleEnabled");

	Params::ACGAICharacter_SetApproachIdleEnabled_Params Parms{};

	Parms.bInNewEnabled = bInNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.ScheduleAIAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGAIScheduledAction        InScheduledAction                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::ScheduleAIAction(struct FCGAIScheduledAction& InScheduledAction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "ScheduleAIAction");

	Params::ACGAICharacter_ScheduleAIAction_Params Parms{};

	Parms.InScheduledAction = InScheduledAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.ResetAlertTimes
// (Native, Public, BlueprintCallable)
// Parameters:

void ACGAICharacter::ResetAlertTimes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "ResetAlertTimes");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.ResetAggro
// (Native, Public, BlueprintCallable)
// Parameters:

void ACGAICharacter::ResetAggro()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "ResetAggro");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.RemoveThermalVision
// (Final, Native, Private)
// Parameters:

void ACGAICharacter::RemoveThermalVision()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "RemoveThermalVision");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.RefreshDynamicMaterialsOnAccessoriesDueToSkinChange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<class UMaterialInstanceDynamic*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> ACGAICharacter::RefreshDynamicMaterialsOnAccessoriesDueToSkinChange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "RefreshDynamicMaterialsOnAccessoriesDueToSkinChange");

	Params::ACGAICharacter_RefreshDynamicMaterialsOnAccessoriesDueToSkinChange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.RefreshDynamicMaterialsDueToSkinChange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<class UMaterialInstanceDynamic*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> ACGAICharacter::RefreshDynamicMaterialsDueToSkinChange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "RefreshDynamicMaterialsDueToSkinChange");

	Params::ACGAICharacter_RefreshDynamicMaterialsDueToSkinChange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.ReactionDelayFinished
// (Final, Native, Private)
// Parameters:
// enum class EReactionToVisibleHero  InReactionAfterDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::ReactionDelayFinished(enum class EReactionToVisibleHero InReactionAfterDelay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "ReactionDelayFinished");

	Params::ACGAICharacter_ReactionDelayFinished_Params Parms{};

	Parms.InReactionAfterDelay = InReactionAfterDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.PutRigidBodiesToSleep
// (Final, Native, Public)
// Parameters:

void ACGAICharacter::PutRigidBodiesToSleep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PutRigidBodiesToSleep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.PopScheduledAIAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCGAIScheduledAction        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCGAIScheduledAction ACGAICharacter::PopScheduledAIAction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PopScheduledAIAction");

	Params::ACGAICharacter_PopScheduledAIAction_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.PlayCustomSequence
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*               InCustomSequence                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InTargetTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InBlendInTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendOutTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InShouldInterpolate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InShouldChangeState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::PlayCustomSequence(class UAnimSequence* InCustomSequence, const struct FTransform& InTargetTransform, float InBlendInTime, float InBlendOutTime, bool InShouldInterpolate, bool InShouldChangeState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PlayCustomSequence");

	Params::ACGAICharacter_PlayCustomSequence_Params Parms{};

	Parms.InCustomSequence = InCustomSequence;
	Parms.InTargetTransform = InTargetTransform;
	Parms.InBlendInTime = InBlendInTime;
	Parms.InBlendOutTime = InBlendOutTime;
	Parms.InShouldInterpolate = InShouldInterpolate;
	Parms.InShouldChangeState = InShouldChangeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.PlayCustomAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequence*               CustomAnim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::PlayCustomAnimation(class UAnimSequence* CustomAnim, float InStartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PlayCustomAnimation");

	Params::ACGAICharacter_PlayCustomAnimation_Params Parms{};

	Parms.CustomAnim = CustomAnim;
	Parms.InStartTime = InStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.PlayCoordinatedCustomAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*               InCustomAnim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::PlayCoordinatedCustomAnimation(class UAnimSequence* InCustomAnim, float InStartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PlayCoordinatedCustomAnimation");

	Params::ACGAICharacter_PlayCoordinatedCustomAnimation_Params Parms{};

	Parms.InCustomAnim = InCustomAnim;
	Parms.InStartTime = InStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.PlayAdditiveDialogueGesture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*               InDialogueGesture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*      InMeshComponent                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::PlayAdditiveDialogueGesture(class UAnimSequence* InDialogueGesture, class USkeletalMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "PlayAdditiveDialogueGesture");

	Params::ACGAICharacter_PlayAdditiveDialogueGesture_Params Parms{};

	Parms.InDialogueGesture = InDialogueGesture;
	Parms.InMeshComponent = InMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnPatrolNodeReachedFromBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APatrolActor*                InPatrolActorReached                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::OnPatrolNodeReachedFromBP(class APatrolActor* InPatrolActorReached)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnPatrolNodeReachedFromBP");

	Params::ACGAICharacter_OnPatrolNodeReachedFromBP_Params Parms{};

	Parms.InPatrolActorReached = InPatrolActorReached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnMeshHitEvent
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*         HitComponent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComponent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACGAICharacter::OnMeshHitEvent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnMeshHitEvent");

	Params::ACGAICharacter_OnMeshHitEvent_Params Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnMaterialSkinChanged
// (Event, Protected, BlueprintEvent)
// Parameters:

void ACGAICharacter::OnMaterialSkinChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnMaterialSkinChanged");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGAICharacter.OnHpLostInternal
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                      InComponentOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      InDamageDealer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::OnHpLostInternal(class AActor* InComponentOwner, float InRemainingHpPoints, float InRemainingHpPercent, struct FCGDamageEvent& InDamageEvent, class AActor* InDamageDealer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnHpLostInternal");

	Params::ACGAICharacter_OnHpLostInternal_Params Parms{};

	Parms.InComponentOwner = InComponentOwner;
	Parms.InRemainingHpPoints = InRemainingHpPoints;
	Parms.InRemainingHpPercent = InRemainingHpPercent;
	Parms.InDamageEvent = InDamageEvent;
	Parms.InDamageDealer = InDamageDealer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnHpLostAbsoluteInternal
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                      InComponentOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      InDamageDealer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDamage                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInKillingDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::OnHpLostAbsoluteInternal(class AActor* InComponentOwner, float InRemainingHpPoints, float InRemainingHpPercent, struct FCGDamageEvent& InDamageEvent, class AActor* InDamageDealer, float InDamage, bool bInKillingDamage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnHpLostAbsoluteInternal");

	Params::ACGAICharacter_OnHpLostAbsoluteInternal_Params Parms{};

	Parms.InComponentOwner = InComponentOwner;
	Parms.InRemainingHpPoints = InRemainingHpPoints;
	Parms.InRemainingHpPercent = InRemainingHpPercent;
	Parms.InDamageEvent = InDamageEvent;
	Parms.InDamageDealer = InDamageDealer;
	Parms.InDamage = InDamage;
	Parms.bInKillingDamage = bInKillingDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnHitUpdateHitmask
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               IsCustomCall                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::OnHitUpdateHitmask(struct FCGDamageEvent& InDamageEvent, bool IsCustomCall)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnHitUpdateHitmask");

	Params::ACGAICharacter_OnHitUpdateHitmask_Params Parms{};

	Parms.InDamageEvent = InDamageEvent;
	Parms.IsCustomCall = IsCustomCall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnGlobalSkinChanged
// (Final, Native, Protected)
// Parameters:
// enum class EGlobalSkinType         SkinType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewSkinName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::OnGlobalSkinChanged(enum class EGlobalSkinType SkinType, class FName NewSkinName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnGlobalSkinChanged");

	Params::ACGAICharacter_OnGlobalSkinChanged_Params Parms{};

	Parms.SkinType = SkinType;
	Parms.NewSkinName = NewSkinName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnDeathInternal
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                      InOwner                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACGAICharacter::OnDeathInternal(class AActor* InOwner, struct FCGDamageEvent& InDamageEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnDeathInternal");

	Params::ACGAICharacter_OnDeathInternal_Params Parms{};

	Parms.InOwner = InOwner;
	Parms.InDamageEvent = InDamageEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.OnBehaviorTreeStarted
// (Final, Native, Public)
// Parameters:

void ACGAICharacter::OnBehaviorTreeStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "OnBehaviorTreeStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.LODTimerTick
// (Native, Public)
// Parameters:

void ACGAICharacter::LODTimerTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "LODTimerTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.K2_LODTimerTick
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGAICharacter::K2_LODTimerTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "K2_LODTimerTick");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGAICharacter.InitialSkinUpdate
// (Final, Native, Protected)
// Parameters:

void ACGAICharacter::InitialSkinUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "InitialSkinUpdate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.GiveOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrderQuery                 InOrder                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::GiveOrder(struct FOrderQuery& InOrder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GiveOrder");

	Params::ACGAICharacter_GiveOrder_Params Parms{};

	Parms.InOrder = InOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.GetWalkType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EAIWalkType             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIWalkType ACGAICharacter::GetWalkType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetWalkType");

	Params::ACGAICharacter_GetWalkType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetTotalDebugInformation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACGAICharacter::GetTotalDebugInformation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetTotalDebugInformation");

	Params::ACGAICharacter_GetTotalDebugInformation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetTargetSightLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGAICharacter::GetTargetSightLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetTargetSightLocation");

	Params::ACGAICharacter_GetTargetSightLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetStrafingDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGAICharacter::GetStrafingDirection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetStrafingDirection");

	Params::ACGAICharacter_GetStrafingDirection_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetShouldReactToCustomAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetShouldReactToCustomAnim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetShouldReactToCustomAnim");

	Params::ACGAICharacter_GetShouldReactToCustomAnim_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetRotationInPlaceDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGAICharacter::GetRotationInPlaceDelta()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetRotationInPlaceDelta");

	Params::ACGAICharacter_GetRotationInPlaceDelta_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetReactionToHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EReactionToVisibleHero  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EReactionToVisibleHero ACGAICharacter::GetReactionToHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetReactionToHero");

	Params::ACGAICharacter_GetReactionToHero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetRadarAfterImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARadarAfterImage*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARadarAfterImage* ACGAICharacter::GetRadarAfterImage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetRadarAfterImage");

	Params::ACGAICharacter_GetRadarAfterImage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetPointOfInterest
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGAICharacter::GetPointOfInterest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetPointOfInterest");

	Params::ACGAICharacter_GetPointOfInterest_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetNextPatrolActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APatrolActor*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APatrolActor* ACGAICharacter::GetNextPatrolActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetNextPatrolActor");

	Params::ACGAICharacter_GetNextPatrolActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetNavTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACGAICharacter::GetNavTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetNavTarget");

	Params::ACGAICharacter_GetNavTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetMotionfixTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ACGAICharacter::GetMotionfixTargetTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetMotionfixTargetTransform");

	Params::ACGAICharacter_GetMotionfixTargetTransform_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetLootRowBasedOnMap
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        DefaultLoot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, class FName>     CustomLootPerMap                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ACGAICharacter::GetLootRowBasedOnMap(class FName DefaultLoot, TMap<class FName, class FName>& CustomLootPerMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetLootRowBasedOnMap");

	Params::ACGAICharacter_GetLootRowBasedOnMap_Params Parms{};

	Parms.DefaultLoot = DefaultLoot;
	Parms.CustomLootPerMap = CustomLootPerMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetIsStrafing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetIsStrafing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetIsStrafing");

	Params::ACGAICharacter_GetIsStrafing_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetIsRotatingInPlace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetIsRotatingInPlace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetIsRotatingInPlace");

	Params::ACGAICharacter_GetIsRotatingInPlace_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetIsPawnVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGCharacter*                InCharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetIsPawnVisible(class ACGCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetIsPawnVisible");

	Params::ACGAICharacter_GetIsPawnVisible_Params Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetIsHeroVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetIsHeroVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetIsHeroVisible");

	Params::ACGAICharacter_GetIsHeroVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetHeroCleanAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bInDebug                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetHeroCleanAim(bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetHeroCleanAim");

	Params::ACGAICharacter_GetHeroCleanAim_Params Parms{};

	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetHeroAimAngleAtBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGAICharacter::GetHeroAimAngleAtBone(class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetHeroAimAngleAtBone");

	Params::ACGAICharacter_GetHeroAimAngleAtBone_Params Parms{};

	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetHeadTracingProperties
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHeadTracingProperties      ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHeadTracingProperties ACGAICharacter::GetHeadTracingProperties()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetHeadTracingProperties");

	Params::ACGAICharacter_GetHeadTracingProperties_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetHasSightMemory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      InMemoryActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetHasSightMemory(class AActor* InMemoryActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetHasSightMemory");

	Params::ACGAICharacter_GetHasSightMemory_Params Parms{};

	Parms.InMemoryActor = InMemoryActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetDeathFunctionOverrideEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetDeathFunctionOverrideEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetDeathFunctionOverrideEnabled");

	Params::ACGAICharacter_GetDeathFunctionOverrideEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentlySeeingDeadBody
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGAICharacter*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGAICharacter* ACGAICharacter::GetCurrentlySeeingDeadBody()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentlySeeingDeadBody");

	Params::ACGAICharacter_GetCurrentlySeeingDeadBody_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentLandMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ELandMovementMode       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ELandMovementMode ACGAICharacter::GetCurrentLandMovementMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentLandMovementMode");

	Params::ACGAICharacter_GetCurrentLandMovementMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentAIStateType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIStateType            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIStateType ACGAICharacter::GetCurrentAIStateType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentAIStateType");

	Params::ACGAICharacter_GetCurrentAIStateType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentAIStateClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UCGAIState>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UCGAIState> ACGAICharacter::GetCurrentAIStateClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentAIStateClass");

	Params::ACGAICharacter_GetCurrentAIStateClass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentAIState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIState                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIState ACGAICharacter::GetCurrentAIState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentAIState");

	Params::ACGAICharacter_GetCurrentAIState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCurrentAIInnerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIInnerState           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIInnerState ACGAICharacter::GetCurrentAIInnerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCurrentAIInnerState");

	Params::ACGAICharacter_GetCurrentAIInnerState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGCover*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGCover* ACGAICharacter::GetCover()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCover");

	Params::ACGAICharacter_GetCover_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCloseContacted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGAICharacter::GetCloseContacted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCloseContacted");

	Params::ACGAICharacter_GetCloseContacted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCGBlackboardComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlackboardComponent*        ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlackboardComponent* ACGAICharacter::GetCGBlackboardComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCGBlackboardComponent");

	Params::ACGAICharacter_GetCGBlackboardComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetCGAIController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGAIController*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGAIController* ACGAICharacter::GetCGAIController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetCGAIController");

	Params::ACGAICharacter_GetCGAIController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetAIWorldType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAIWorldType            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIWorldType ACGAICharacter::GetAIWorldType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetAIWorldType");

	Params::ACGAICharacter_GetAIWorldType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetAIType
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EAIType                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIType ACGAICharacter::GetAIType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetAIType");

	Params::ACGAICharacter_GetAIType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.GetAIProperties
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCGAIProperties             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGAIProperties ACGAICharacter::GetAIProperties()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "GetAIProperties");

	Params::ACGAICharacter_GetAIProperties_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.FixTransformForAnimation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  InTargetTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InInterpTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGAICharacter::FixTransformForAnimation(const struct FTransform& InTargetTransform, float InInterpTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "FixTransformForAnimation");

	Params::ACGAICharacter_FixTransformForAnimation_Params Parms{};

	Parms.InTargetTransform = InTargetTransform;
	Parms.InInterpTime = InInterpTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.FixTransform_Update
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FTransform                  InUpdatedTransform                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACGAICharacter::FixTransform_Update(const struct FTransform& InUpdatedTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "FixTransform_Update");

	Params::ACGAICharacter_FixTransform_Update_Params Parms{};

	Parms.InUpdatedTransform = InUpdatedTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.FixTransform_Finish
// (Final, Native, Protected)
// Parameters:

void ACGAICharacter::FixTransform_Finish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "FixTransform_Finish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.FindShadowMaxDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGAICharacter::FindShadowMaxDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "FindShadowMaxDistance");

	Params::ACGAICharacter_FindShadowMaxDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.FindDeathAnim
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAnimSequence*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* ACGAICharacter::FindDeathAnim(struct FCGDamageEvent& InDamageEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "FindDeathAnim");

	Params::ACGAICharacter_FindDeathAnim_Params Parms{};

	Parms.InDamageEvent = InDamageEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAICharacter.EnableDialogueHighlight
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGAICharacter::EnableDialogueHighlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "EnableDialogueHighlight");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGAICharacter.DisableHitGenerationIfMeshIsAsleep
// (Final, Native, Private)
// Parameters:

void ACGAICharacter::DisableHitGenerationIfMeshIsAsleep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "DisableHitGenerationIfMeshIsAsleep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAICharacter.DisableDialogueHighgliht
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGAICharacter::DisableDialogueHighgliht()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "DisableDialogueHighgliht");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGAICharacter.AddAlertValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InAlertValueToAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGAlertReason              InReason                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGAICharacter::AddAlertValue(float InAlertValueToAdd, const struct FCGAlertReason& InReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAICharacter", "AddAlertValue");

	Params::ACGAICharacter_AddAlertValue_Params Parms{};

	Parms.InAlertValueToAdd = InAlertValueToAdd;
	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAIController
// (Actor)

class UClass* ACGAIController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIController");

	return Clss;
}


// CGAIController ChernobylGame.Default__CGAIController
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGAIController* ACGAIController::GetDefaultObj()
{
	static class ACGAIController* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGAIController*>(ACGAIController::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGBaseCharacterMovement
// (Actor)

class UClass* ACGBaseCharacterMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGBaseCharacterMovement");

	return Clss;
}


// CGBaseCharacterMovement ChernobylGame.Default__CGBaseCharacterMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGBaseCharacterMovement* ACGBaseCharacterMovement::GetDefaultObj()
{
	static class ACGBaseCharacterMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGBaseCharacterMovement*>(ACGBaseCharacterMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAimCrouchedState
// (Actor)

class UClass* ACGAimCrouchedState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAimCrouchedState");

	return Clss;
}


// CGAimCrouchedState ChernobylGame.Default__CGAimCrouchedState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGAimCrouchedState* ACGAimCrouchedState::GetDefaultObj()
{
	static class ACGAimCrouchedState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGAimCrouchedState*>(ACGAimCrouchedState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAimState
// (Actor)

class UClass* ACGAimState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAimState");

	return Clss;
}


// CGAimState ChernobylGame.Default__CGAimState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGAimState* ACGAimState::GetDefaultObj()
{
	static class ACGAimState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGAimState*>(ACGAimState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAINoticeWidget
// (None)

class UClass* UCGAINoticeWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAINoticeWidget");

	return Clss;
}


// CGAINoticeWidget ChernobylGame.Default__CGAINoticeWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAINoticeWidget* UCGAINoticeWidget::GetDefaultObj()
{
	static class UCGAINoticeWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAINoticeWidget*>(UCGAINoticeWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAINoticeWidget.ProcessAICPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGAINoticeWidget::ProcessAICPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "ProcessAICPP");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAINoticeWidget.CreateSpottedEntryCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsFight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAINoticeWidget::CreateSpottedEntryCPP(class ACGAICharacter* AICharacter, bool bIsFight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CreateSpottedEntryCPP");

	Params::UCGAINoticeWidget_CreateSpottedEntryCPP_Params Parms{};

	Parms.AICharacter = AICharacter;
	Parms.bIsFight = bIsFight;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGAINoticeWidget.CreateSightEntryCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlert                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAINoticeWidget::CreateSightEntryCPP(class ACGAICharacter* AICharacter, bool bAlert)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CreateSightEntryCPP");

	Params::UCGAINoticeWidget_CreateSightEntryCPP_Params Parms{};

	Parms.AICharacter = AICharacter;
	Parms.bAlert = bAlert;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGAINoticeWidget.CheckIfAISpottedCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAINoticeWidget::CheckIfAISpottedCPP(class ACGAICharacter* AICharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CheckIfAISpottedCPP");

	Params::UCGAINoticeWidget_CheckIfAISpottedCPP_Params Parms{};

	Parms.AICharacter = AICharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAINoticeWidget.CheckIfAIPatrolCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAINoticeWidget::CheckIfAIPatrolCPP(class ACGAICharacter* AICharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CheckIfAIPatrolCPP");

	Params::UCGAINoticeWidget_CheckIfAIPatrolCPP_Params Parms{};

	Parms.AICharacter = AICharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAINoticeWidget.CheckIfAICombatCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAINoticeWidget::CheckIfAICombatCPP(class ACGAICharacter* AICharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CheckIfAICombatCPP");

	Params::UCGAINoticeWidget_CheckIfAICombatCPP_Params Parms{};

	Parms.AICharacter = AICharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAINoticeWidget.CheckIfAIAlertCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              AICharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAINoticeWidget::CheckIfAIAlertCPP(class ACGAICharacter* AICharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAINoticeWidget", "CheckIfAIAlertCPP");

	Params::UCGAINoticeWidget_CheckIfAIAlertCPP_Params Parms{};

	Parms.AICharacter = AICharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAIPerception
// (None)

class UClass* UCGAIPerception::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIPerception");

	return Clss;
}


// CGAIPerception ChernobylGame.Default__CGAIPerception
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIPerception* UCGAIPerception::GetDefaultObj()
{
	static class UCGAIPerception* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIPerception*>(UCGAIPerception::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIPerception.UnBlockPerception
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerceptionBlock            InPerceptionBlock                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCGAIPerception::UnBlockPerception(struct FPerceptionBlock& InPerceptionBlock)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "UnBlockPerception");

	Params::UCGAIPerception_UnBlockPerception_Params Parms{};

	Parms.InPerceptionBlock = InPerceptionBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.SetSightStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InIsActive                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIPerception::SetSightStatus(bool InIsActive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "SetSightStatus");

	Params::UCGAIPerception_SetSightStatus_Params Parms{};

	Parms.InIsActive = InIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.SetSightRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewRadius                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIPerception::SetSightRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "SetSightRadius");

	Params::UCGAIPerception_SetSightRadius_Params Parms{};

	Parms.NewRadius = NewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.SetSenseEnabledDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAISense>        InSenseToDeactivate                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDelayTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInPostDelayEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInEnable                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIPerception::SetSenseEnabledDelayed(TSubclassOf<class UAISense> InSenseToDeactivate, float InDelayTime, bool bInPostDelayEnabled, bool bInEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "SetSenseEnabledDelayed");

	Params::UCGAIPerception_SetSenseEnabledDelayed_Params Parms{};

	Parms.InSenseToDeactivate = InSenseToDeactivate;
	Parms.InDelayTime = InDelayTime;
	Parms.bInPostDelayEnabled = bInPostDelayEnabled;
	Parms.bInEnable = bInEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.SetHearingRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InHearingRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIPerception::SetHearingRange(float InHearingRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "SetHearingRange");

	Params::UCGAIPerception_SetHearingRange_Params Parms{};

	Parms.InHearingRange = InHearingRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.ResetAlertValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGAIPerception::ResetAlertValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "ResetAlertValue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.ResetAlertDelay
// (Final, Native, Private)
// Parameters:

void UCGAIPerception::ResetAlertDelay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "ResetAlertDelay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.OnPercUpdatedInternal
// (Final, Native, Private)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                 InStimulus                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIPerception::OnPercUpdatedInternal(class AActor* InActor, const struct FAIStimulus& InStimulus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "OnPercUpdatedInternal");

	Params::UCGAIPerception_OnPercUpdatedInternal_Params Parms{};

	Parms.InActor = InActor;
	Parms.InStimulus = InStimulus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.GetVisionAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetVisionAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetVisionAngle");

	Params::UCGAIPerception_GetVisionAngle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetUniquePerceptionBlockIndexes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UCGAIPerception::GetUniquePerceptionBlockIndexes(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetUniquePerceptionBlockIndexes");

	Params::UCGAIPerception_GetUniquePerceptionBlockIndexes_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetSightStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::GetSightStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetSightStatus");

	Params::UCGAIPerception_GetSightStatus_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetSightRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetSightRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetSightRadius");

	Params::UCGAIPerception_GetSightRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetSightMemory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCGSightMemory>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCGSightMemory> UCGAIPerception::GetSightMemory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetSightMemory");

	Params::UCGAIPerception_GetSightMemory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetSightBlockStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::GetSightBlockStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetSightBlockStatus");

	Params::UCGAIPerception_GetSightBlockStatus_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetPerceptionBlocks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FPerceptionBlock>    ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<struct FPerceptionBlock> UCGAIPerception::GetPerceptionBlocks()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetPerceptionBlocks");

	Params::UCGAIPerception_GetPerceptionBlocks_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetLoseSightRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetLoseSightRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetLoseSightRadius");

	Params::UCGAIPerception_GetLoseSightRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetIsPawnVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGCharacter*                InTargetCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::GetIsPawnVisible(class ACGCharacter* InTargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetIsPawnVisible");

	Params::UCGAIPerception_GetIsPawnVisible_Params Parms{};

	Parms.InTargetCharacter = InTargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetIsHeroVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::GetIsHeroVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetIsHeroVisible");

	Params::UCGAIPerception_GetIsHeroVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetHearingRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetHearingRange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetHearingRange");

	Params::UCGAIPerception_GetHearingRange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetHearingBlockStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::GetHearingBlockStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetHearingBlockStatus");

	Params::UCGAIPerception_GetHearingBlockStatus_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetFullFocusHalfAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetFullFocusHalfAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetFullFocusHalfAngle");

	Params::UCGAIPerception_GetFullFocusHalfAngle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetCurrentlyVisibleActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCGAIPerception::GetCurrentlyVisibleActors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetCurrentlyVisibleActors");

	Params::UCGAIPerception_GetCurrentlyVisibleActors_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetCurrentAlertValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UCGAIPerception::GetCurrentAlertValues()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetCurrentAlertValues");

	Params::UCGAIPerception_GetCurrentAlertValues_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.GetCurrentAlertValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::GetCurrentAlertValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "GetCurrentAlertValue");

	Params::UCGAIPerception_GetCurrentAlertValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.EnabledDelayFinished
// (Final, Native, Private)
// Parameters:
// bool                               bInPostDelayEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>        InSenseToDeactivate                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIPerception::EnabledDelayFinished(bool bInPostDelayEnabled, TSubclassOf<class UAISense> InSenseToDeactivate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "EnabledDelayFinished");

	Params::UCGAIPerception_EnabledDelayFinished_Params Parms{};

	Parms.bInPostDelayEnabled = bInPostDelayEnabled;
	Parms.InSenseToDeactivate = InSenseToDeactivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.ComparePerceptionBlockIndexes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIPerception::ComparePerceptionBlockIndexes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "ComparePerceptionBlockIndexes");

	Params::UCGAIPerception_ComparePerceptionBlockIndexes_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIPerception.BlockPerception
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerceptionBlock            InPerceptionBlock                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCGAIPerception::BlockPerception(struct FPerceptionBlock& InPerceptionBlock)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "BlockPerception");

	Params::UCGAIPerception_BlockPerception_Params Parms{};

	Parms.InPerceptionBlock = InPerceptionBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.AddSightMemory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCGSightMemory              InSightMemory                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIPerception::AddSightMemory(const struct FCGSightMemory& InSightMemory)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "AddSightMemory");

	Params::UCGAIPerception_AddSightMemory_Params Parms{};

	Parms.InSightMemory = InSightMemory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIPerception.AddAlertValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InValueToAdd                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGAlertReason              InAlertReason                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAIPerception::AddAlertValue(float InValueToAdd, const struct FCGAlertReason& InAlertReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIPerception", "AddAlertValue");

	Params::UCGAIPerception_AddAlertValue_Params Parms{};

	Parms.InValueToAdd = InValueToAdd;
	Parms.InAlertReason = InAlertReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAIState
// (None)

class UClass* UCGAIState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState");

	return Clss;
}


// CGAIState ChernobylGame.Default__CGAIState
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState* UCGAIState::GetDefaultObj()
{
	static class UCGAIState* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState*>(UCGAIState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState.ZeroAlert
// (Native, Public)
// Parameters:
// struct FCGAlertReason              InReason                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIState::ZeroAlert(const struct FCGAlertReason& InReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "ZeroAlert");

	Params::UCGAIState_ZeroAlert_Params Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.PerceptionUpdate
// (Native, Public)
// Parameters:
// class AActor*                      InAActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                 InStimulus                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIState::PerceptionUpdate(class AActor* InAActor, const struct FAIStimulus& InStimulus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "PerceptionUpdate");

	Params::UCGAIState_PerceptionUpdate_Params Parms{};

	Parms.InAActor = InAActor;
	Parms.InStimulus = InStimulus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnTeleporterCastStart
// (Native, Public)
// Parameters:

void UCGAIState::OnTeleporterCastStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnTeleporterCastStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnTeleporterCastEnd
// (Native, Public)
// Parameters:

void UCGAIState::OnTeleporterCastEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnTeleporterCastEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnShotFired
// (Native, Public)
// Parameters:

void UCGAIState::OnShotFired()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnShotFired");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnNPCHeadTracingHeroUpdate
// (Native, Public)
// Parameters:
// bool                               bUpdate                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnNPCHeadTracingHeroUpdate(bool bUpdate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnNPCHeadTracingHeroUpdate");

	Params::UCGAIState_OnNPCHeadTracingHeroUpdate_Params Parms{};

	Parms.bUpdate = bUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnNoiseHeard
// (Native, Public, HasDefaults)
// Parameters:
// class AActor*                      InInstigator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNoiseLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseStrength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InTag                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMaxDistanceToActivateCombat                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnNoiseHeard(class AActor* InInstigator, float InNoiseRange, const struct FVector& InNoiseLocation, float InNoiseStrength, class FName InTag, float InMaxDistanceToActivateCombat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnNoiseHeard");

	Params::UCGAIState_OnNoiseHeard_Params Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InNoiseRange = InNoiseRange;
	Parms.InNoiseLocation = InNoiseLocation;
	Parms.InNoiseStrength = InNoiseStrength;
	Parms.InTag = InTag;
	Parms.InMaxDistanceToActivateCombat = InMaxDistanceToActivateCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnMoveToTaskFinished
// (Native, Public)
// Parameters:
// enum class EBTNodeResult           InTaskResult                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InActorReached                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnMoveToTaskFinished(enum class EBTNodeResult InTaskResult, class AActor* InActorReached)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnMoveToTaskFinished");

	Params::UCGAIState_OnMoveToTaskFinished_Params Parms{};

	Parms.InTaskResult = InTaskResult;
	Parms.InActorReached = InActorReached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHPLost
// (Native, Public, HasOutParams)
// Parameters:
// class AActor*                      ComponentOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RemainingHpPoints                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RemainingHpPercent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              DamageEvent                                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      DamageDealer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnHPLost(class AActor* ComponentOwner, float RemainingHpPoints, float RemainingHpPercent, struct FCGDamageEvent& DamageEvent, class AActor* DamageDealer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHPLost");

	Params::UCGAIState_OnHPLost_Params Parms{};

	Parms.ComponentOwner = ComponentOwner;
	Parms.RemainingHpPoints = RemainingHpPoints;
	Parms.RemainingHpPercent = RemainingHpPercent;
	Parms.DamageEvent = DamageEvent;
	Parms.DamageDealer = DamageDealer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHideShowFinished
// (Native, Public)
// Parameters:
// bool                               bInShown                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnHideShowFinished(bool bInShown)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHideShowFinished");

	Params::UCGAIState_OnHideShowFinished_Params Parms{};

	Parms.bInShown = bInShown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroTakeDamage
// (Native, Public, HasOutParams)
// Parameters:
// float                              InDamage                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                 InEventInstigator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InDamageCauser                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState::OnHeroTakeDamage(float InDamage, struct FCGDamageEvent& InDamageEvent, class AController* InEventInstigator, class AActor* InDamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroTakeDamage");

	Params::UCGAIState_OnHeroTakeDamage_Params Parms{};

	Parms.InDamage = InDamage;
	Parms.InDamageEvent = InDamageEvent;
	Parms.InEventInstigator = InEventInstigator;
	Parms.InDamageCauser = InDamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroLeavingMeleeRange
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroLeavingMeleeRange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroLeavingMeleeRange");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroLeavingClose
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroLeavingClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroLeavingClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroGettingMeleeRange
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroGettingMeleeRange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroGettingMeleeRange");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroGettingClose
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroGettingClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroGettingClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroCustomAnim_Started
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroCustomAnim_Started()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroCustomAnim_Started");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.OnHeroCustomAnim_Finished
// (Native, Public)
// Parameters:

void UCGAIState::OnHeroCustomAnim_Finished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "OnHeroCustomAnim_Finished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.MaxAlert
// (Native, Public)
// Parameters:
// struct FCGAlertReason              InReason                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIState::MaxAlert(const struct FCGAlertReason& InReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "MaxAlert");

	Params::UCGAIState_MaxAlert_Params Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.InterrogationDialogueBranch_Kill
// (Native, Public)
// Parameters:

void UCGAIState::InterrogationDialogueBranch_Kill()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "InterrogationDialogueBranch_Kill");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.InterrogationDialogueBranch_Ignore
// (Native, Public)
// Parameters:

void UCGAIState::InterrogationDialogueBranch_Ignore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "InterrogationDialogueBranch_Ignore");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.InterrogationDialogueBranch_Attack
// (Native, Public)
// Parameters:

void UCGAIState::InterrogationDialogueBranch_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "InterrogationDialogueBranch_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.HalfAlert
// (Native, Public)
// Parameters:
// struct FCGAlertReason              InReason                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIState::HalfAlert(const struct FCGAlertReason& InReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "HalfAlert");

	Params::UCGAIState_HalfAlert_Params Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState.GetHeroCleanAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bInDebug                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIState::GetHeroCleanAim(bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState", "GetHeroCleanAim");

	Params::UCGAIState_GetHeroCleanAim_Params Parms{};

	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAIState_Chernohost
// (None)

class UClass* UCGAIState_Chernohost::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost");

	return Clss;
}


// CGAIState_Chernohost ChernobylGame.Default__CGAIState_Chernohost
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost* UCGAIState_Chernohost::GetDefaultObj()
{
	static class UCGAIState_Chernohost* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost*>(UCGAIState_Chernohost::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_Hunt
// (None)

class UClass* UCGAIState_Chernohost_Hunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_Hunt");

	return Clss;
}


// CGAIState_Chernohost_Hunt ChernobylGame.Default__CGAIState_Chernohost_Hunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_Hunt* UCGAIState_Chernohost_Hunt::GetDefaultObj()
{
	static class UCGAIState_Chernohost_Hunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_Hunt*>(UCGAIState_Chernohost_Hunt::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_HApproach
// (None)

class UClass* UCGAIState_Chernohost_HApproach::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_HApproach");

	return Clss;
}


// CGAIState_Chernohost_HApproach ChernobylGame.Default__CGAIState_Chernohost_HApproach
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_HApproach* UCGAIState_Chernohost_HApproach::GetDefaultObj()
{
	static class UCGAIState_Chernohost_HApproach* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_HApproach*>(UCGAIState_Chernohost_HApproach::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_HAttack
// (None)

class UClass* UCGAIState_Chernohost_HAttack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_HAttack");

	return Clss;
}


// CGAIState_Chernohost_HAttack ChernobylGame.Default__CGAIState_Chernohost_HAttack
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_HAttack* UCGAIState_Chernohost_HAttack::GetDefaultObj()
{
	static class UCGAIState_Chernohost_HAttack* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_HAttack*>(UCGAIState_Chernohost_HAttack::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_HeroLost
// (None)

class UClass* UCGAIState_Chernohost_HeroLost::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_HeroLost");

	return Clss;
}


// CGAIState_Chernohost_HeroLost ChernobylGame.Default__CGAIState_Chernohost_HeroLost
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_HeroLost* UCGAIState_Chernohost_HeroLost::GetDefaultObj()
{
	static class UCGAIState_Chernohost_HeroLost* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_HeroLost*>(UCGAIState_Chernohost_HeroLost::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_HNotice
// (None)

class UClass* UCGAIState_Chernohost_HNotice::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_HNotice");

	return Clss;
}


// CGAIState_Chernohost_HNotice ChernobylGame.Default__CGAIState_Chernohost_HNotice
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_HNotice* UCGAIState_Chernohost_HNotice::GetDefaultObj()
{
	static class UCGAIState_Chernohost_HNotice* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_HNotice*>(UCGAIState_Chernohost_HNotice::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_InWall
// (None)

class UClass* UCGAIState_Chernohost_InWall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_InWall");

	return Clss;
}


// CGAIState_Chernohost_InWall ChernobylGame.Default__CGAIState_Chernohost_InWall
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_InWall* UCGAIState_Chernohost_InWall::GetDefaultObj()
{
	static class UCGAIState_Chernohost_InWall* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_InWall*>(UCGAIState_Chernohost_InWall::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_Patrol
// (None)

class UClass* UCGAIState_Chernohost_Patrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_Patrol");

	return Clss;
}


// CGAIState_Chernohost_Patrol ChernobylGame.Default__CGAIState_Chernohost_Patrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_Patrol* UCGAIState_Chernohost_Patrol::GetDefaultObj()
{
	static class UCGAIState_Chernohost_Patrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_Patrol*>(UCGAIState_Chernohost_Patrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_PFromPortal
// (None)

class UClass* UCGAIState_Chernohost_PFromPortal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_PFromPortal");

	return Clss;
}


// CGAIState_Chernohost_PFromPortal ChernobylGame.Default__CGAIState_Chernohost_PFromPortal
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_PFromPortal* UCGAIState_Chernohost_PFromPortal::GetDefaultObj()
{
	static class UCGAIState_Chernohost_PFromPortal* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_PFromPortal*>(UCGAIState_Chernohost_PFromPortal::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_PInPortal
// (None)

class UClass* UCGAIState_Chernohost_PInPortal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_PInPortal");

	return Clss;
}


// CGAIState_Chernohost_PInPortal ChernobylGame.Default__CGAIState_Chernohost_PInPortal
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_PInPortal* UCGAIState_Chernohost_PInPortal::GetDefaultObj()
{
	static class UCGAIState_Chernohost_PInPortal* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_PInPortal*>(UCGAIState_Chernohost_PInPortal::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_PIntoPortal
// (None)

class UClass* UCGAIState_Chernohost_PIntoPortal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_PIntoPortal");

	return Clss;
}


// CGAIState_Chernohost_PIntoPortal ChernobylGame.Default__CGAIState_Chernohost_PIntoPortal
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_PIntoPortal* UCGAIState_Chernohost_PIntoPortal::GetDefaultObj()
{
	static class UCGAIState_Chernohost_PIntoPortal* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_PIntoPortal*>(UCGAIState_Chernohost_PIntoPortal::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_PWalk
// (None)

class UClass* UCGAIState_Chernohost_PWalk::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_PWalk");

	return Clss;
}


// CGAIState_Chernohost_PWalk ChernobylGame.Default__CGAIState_Chernohost_PWalk
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_PWalk* UCGAIState_Chernohost_PWalk::GetDefaultObj()
{
	static class UCGAIState_Chernohost_PWalk* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_PWalk*>(UCGAIState_Chernohost_PWalk::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_Retreat
// (None)

class UClass* UCGAIState_Chernohost_Retreat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_Retreat");

	return Clss;
}


// CGAIState_Chernohost_Retreat ChernobylGame.Default__CGAIState_Chernohost_Retreat
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_Retreat* UCGAIState_Chernohost_Retreat::GetDefaultObj()
{
	static class UCGAIState_Chernohost_Retreat* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_Retreat*>(UCGAIState_Chernohost_Retreat::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_REnter
// (None)

class UClass* UCGAIState_Chernohost_REnter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_REnter");

	return Clss;
}


// CGAIState_Chernohost_REnter ChernobylGame.Default__CGAIState_Chernohost_REnter
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_REnter* UCGAIState_Chernohost_REnter::GetDefaultObj()
{
	static class UCGAIState_Chernohost_REnter* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_REnter*>(UCGAIState_Chernohost_REnter::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_RMove
// (None)

class UClass* UCGAIState_Chernohost_RMove::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_RMove");

	return Clss;
}


// CGAIState_Chernohost_RMove ChernobylGame.Default__CGAIState_Chernohost_RMove
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_RMove* UCGAIState_Chernohost_RMove::GetDefaultObj()
{
	static class UCGAIState_Chernohost_RMove* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_RMove*>(UCGAIState_Chernohost_RMove::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_RPortalIn
// (None)

class UClass* UCGAIState_Chernohost_RPortalIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_RPortalIn");

	return Clss;
}


// CGAIState_Chernohost_RPortalIn ChernobylGame.Default__CGAIState_Chernohost_RPortalIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_RPortalIn* UCGAIState_Chernohost_RPortalIn::GetDefaultObj()
{
	static class UCGAIState_Chernohost_RPortalIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_RPortalIn*>(UCGAIState_Chernohost_RPortalIn::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Chernohost_Teleporting
// (None)

class UClass* UCGAIState_Chernohost_Teleporting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Chernohost_Teleporting");

	return Clss;
}


// CGAIState_Chernohost_Teleporting ChernobylGame.Default__CGAIState_Chernohost_Teleporting
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Chernohost_Teleporting* UCGAIState_Chernohost_Teleporting::GetDefaultObj()
{
	static class UCGAIState_Chernohost_Teleporting* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Chernohost_Teleporting*>(UCGAIState_Chernohost_Teleporting::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker
// (None)

class UClass* UCGAIState_DStalker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker");

	return Clss;
}


// CGAIState_DStalker ChernobylGame.Default__CGAIState_DStalker
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker* UCGAIState_DStalker::GetDefaultObj()
{
	static class UCGAIState_DStalker* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker*>(UCGAIState_DStalker::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_Alert
// (None)

class UClass* UCGAIState_DStalker_Alert::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_Alert");

	return Clss;
}


// CGAIState_DStalker_Alert ChernobylGame.Default__CGAIState_DStalker_Alert
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_Alert* UCGAIState_DStalker_Alert::GetDefaultObj()
{
	static class UCGAIState_DStalker_Alert* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_Alert*>(UCGAIState_DStalker_Alert::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_AlertStand
// (None)

class UClass* UCGAIState_DStalker_AlertStand::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_AlertStand");

	return Clss;
}


// CGAIState_DStalker_AlertStand ChernobylGame.Default__CGAIState_DStalker_AlertStand
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_AlertStand* UCGAIState_DStalker_AlertStand::GetDefaultObj()
{
	static class UCGAIState_DStalker_AlertStand* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_AlertStand*>(UCGAIState_DStalker_AlertStand::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_TP
// (None)

class UClass* UCGAIState_DStalker_TP::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_TP");

	return Clss;
}


// CGAIState_DStalker_TP ChernobylGame.Default__CGAIState_DStalker_TP
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_TP* UCGAIState_DStalker_TP::GetDefaultObj()
{
	static class UCGAIState_DStalker_TP* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_TP*>(UCGAIState_DStalker_TP::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_AlertTP
// (None)

class UClass* UCGAIState_DStalker_AlertTP::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_AlertTP");

	return Clss;
}


// CGAIState_DStalker_AlertTP ChernobylGame.Default__CGAIState_DStalker_AlertTP
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_AlertTP* UCGAIState_DStalker_AlertTP::GetDefaultObj()
{
	static class UCGAIState_DStalker_AlertTP* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_AlertTP*>(UCGAIState_DStalker_AlertTP::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_AlertTPIn
// (None)

class UClass* UCGAIState_DStalker_AlertTPIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_AlertTPIn");

	return Clss;
}


// CGAIState_DStalker_AlertTPIn ChernobylGame.Default__CGAIState_DStalker_AlertTPIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_AlertTPIn* UCGAIState_DStalker_AlertTPIn::GetDefaultObj()
{
	static class UCGAIState_DStalker_AlertTPIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_AlertTPIn*>(UCGAIState_DStalker_AlertTPIn::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_AlertTPLoop
// (None)

class UClass* UCGAIState_DStalker_AlertTPLoop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_AlertTPLoop");

	return Clss;
}


// CGAIState_DStalker_AlertTPLoop ChernobylGame.Default__CGAIState_DStalker_AlertTPLoop
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_AlertTPLoop* UCGAIState_DStalker_AlertTPLoop::GetDefaultObj()
{
	static class UCGAIState_DStalker_AlertTPLoop* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_AlertTPLoop*>(UCGAIState_DStalker_AlertTPLoop::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_AlertTPOut
// (None)

class UClass* UCGAIState_DStalker_AlertTPOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_AlertTPOut");

	return Clss;
}


// CGAIState_DStalker_AlertTPOut ChernobylGame.Default__CGAIState_DStalker_AlertTPOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_AlertTPOut* UCGAIState_DStalker_AlertTPOut::GetDefaultObj()
{
	static class UCGAIState_DStalker_AlertTPOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_AlertTPOut*>(UCGAIState_DStalker_AlertTPOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_FakeHunt
// (None)

class UClass* UCGAIState_DStalker_FakeHunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_FakeHunt");

	return Clss;
}


// CGAIState_DStalker_FakeHunt ChernobylGame.Default__CGAIState_DStalker_FakeHunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_FakeHunt* UCGAIState_DStalker_FakeHunt::GetDefaultObj()
{
	static class UCGAIState_DStalker_FakeHunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_FakeHunt*>(UCGAIState_DStalker_FakeHunt::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_Hunt
// (None)

class UClass* UCGAIState_DStalker_Hunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_Hunt");

	return Clss;
}


// CGAIState_DStalker_Hunt ChernobylGame.Default__CGAIState_DStalker_Hunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_Hunt* UCGAIState_DStalker_Hunt::GetDefaultObj()
{
	static class UCGAIState_DStalker_Hunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_Hunt*>(UCGAIState_DStalker_Hunt::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_HRecovery
// (None)

class UClass* UCGAIState_DStalker_HRecovery::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_HRecovery");

	return Clss;
}


// CGAIState_DStalker_HRecovery ChernobylGame.Default__CGAIState_DStalker_HRecovery
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_HRecovery* UCGAIState_DStalker_HRecovery::GetDefaultObj()
{
	static class UCGAIState_DStalker_HRecovery* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_HRecovery*>(UCGAIState_DStalker_HRecovery::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_HuntTP
// (None)

class UClass* UCGAIState_DStalker_HuntTP::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_HuntTP");

	return Clss;
}


// CGAIState_DStalker_HuntTP ChernobylGame.Default__CGAIState_DStalker_HuntTP
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_HuntTP* UCGAIState_DStalker_HuntTP::GetDefaultObj()
{
	static class UCGAIState_DStalker_HuntTP* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_HuntTP*>(UCGAIState_DStalker_HuntTP::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_HuntTPIn
// (None)

class UClass* UCGAIState_DStalker_HuntTPIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_HuntTPIn");

	return Clss;
}


// CGAIState_DStalker_HuntTPIn ChernobylGame.Default__CGAIState_DStalker_HuntTPIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_HuntTPIn* UCGAIState_DStalker_HuntTPIn::GetDefaultObj()
{
	static class UCGAIState_DStalker_HuntTPIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_HuntTPIn*>(UCGAIState_DStalker_HuntTPIn::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_HuntTPLoop
// (None)

class UClass* UCGAIState_DStalker_HuntTPLoop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_HuntTPLoop");

	return Clss;
}


// CGAIState_DStalker_HuntTPLoop ChernobylGame.Default__CGAIState_DStalker_HuntTPLoop
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_HuntTPLoop* UCGAIState_DStalker_HuntTPLoop::GetDefaultObj()
{
	static class UCGAIState_DStalker_HuntTPLoop* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_HuntTPLoop*>(UCGAIState_DStalker_HuntTPLoop::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_HuntTPOut
// (None)

class UClass* UCGAIState_DStalker_HuntTPOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_HuntTPOut");

	return Clss;
}


// CGAIState_DStalker_HuntTPOut ChernobylGame.Default__CGAIState_DStalker_HuntTPOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_HuntTPOut* UCGAIState_DStalker_HuntTPOut::GetDefaultObj()
{
	static class UCGAIState_DStalker_HuntTPOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_HuntTPOut*>(UCGAIState_DStalker_HuntTPOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_Idle
// (None)

class UClass* UCGAIState_DStalker_Idle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_Idle");

	return Clss;
}


// CGAIState_DStalker_Idle ChernobylGame.Default__CGAIState_DStalker_Idle
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_Idle* UCGAIState_DStalker_Idle::GetDefaultObj()
{
	static class UCGAIState_DStalker_Idle* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_Idle*>(UCGAIState_DStalker_Idle::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_Initial
// (None)

class UClass* UCGAIState_DStalker_Initial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_Initial");

	return Clss;
}


// CGAIState_DStalker_Initial ChernobylGame.Default__CGAIState_DStalker_Initial
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_Initial* UCGAIState_DStalker_Initial::GetDefaultObj()
{
	static class UCGAIState_DStalker_Initial* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_Initial*>(UCGAIState_DStalker_Initial::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_InPatrol
// (None)

class UClass* UCGAIState_DStalker_InPatrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_InPatrol");

	return Clss;
}


// CGAIState_DStalker_InPatrol ChernobylGame.Default__CGAIState_DStalker_InPatrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_InPatrol* UCGAIState_DStalker_InPatrol::GetDefaultObj()
{
	static class UCGAIState_DStalker_InPatrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_InPatrol*>(UCGAIState_DStalker_InPatrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_NeutralTP
// (None)

class UClass* UCGAIState_DStalker_NeutralTP::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_NeutralTP");

	return Clss;
}


// CGAIState_DStalker_NeutralTP ChernobylGame.Default__CGAIState_DStalker_NeutralTP
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_NeutralTP* UCGAIState_DStalker_NeutralTP::GetDefaultObj()
{
	static class UCGAIState_DStalker_NeutralTP* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_NeutralTP*>(UCGAIState_DStalker_NeutralTP::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_NeutralTPIn
// (None)

class UClass* UCGAIState_DStalker_NeutralTPIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_NeutralTPIn");

	return Clss;
}


// CGAIState_DStalker_NeutralTPIn ChernobylGame.Default__CGAIState_DStalker_NeutralTPIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_NeutralTPIn* UCGAIState_DStalker_NeutralTPIn::GetDefaultObj()
{
	static class UCGAIState_DStalker_NeutralTPIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_NeutralTPIn*>(UCGAIState_DStalker_NeutralTPIn::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_NeutralTPLoop
// (None)

class UClass* UCGAIState_DStalker_NeutralTPLoop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_NeutralTPLoop");

	return Clss;
}


// CGAIState_DStalker_NeutralTPLoop ChernobylGame.Default__CGAIState_DStalker_NeutralTPLoop
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_NeutralTPLoop* UCGAIState_DStalker_NeutralTPLoop::GetDefaultObj()
{
	static class UCGAIState_DStalker_NeutralTPLoop* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_NeutralTPLoop*>(UCGAIState_DStalker_NeutralTPLoop::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_NeutralTPOut
// (None)

class UClass* UCGAIState_DStalker_NeutralTPOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_NeutralTPOut");

	return Clss;
}


// CGAIState_DStalker_NeutralTPOut ChernobylGame.Default__CGAIState_DStalker_NeutralTPOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_NeutralTPOut* UCGAIState_DStalker_NeutralTPOut::GetDefaultObj()
{
	static class UCGAIState_DStalker_NeutralTPOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_NeutralTPOut*>(UCGAIState_DStalker_NeutralTPOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_OutPatrol
// (None)

class UClass* UCGAIState_DStalker_OutPatrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_OutPatrol");

	return Clss;
}


// CGAIState_DStalker_OutPatrol ChernobylGame.Default__CGAIState_DStalker_OutPatrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_OutPatrol* UCGAIState_DStalker_OutPatrol::GetDefaultObj()
{
	static class UCGAIState_DStalker_OutPatrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_OutPatrol*>(UCGAIState_DStalker_OutPatrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_DStalker_Patrol
// (None)

class UClass* UCGAIState_DStalker_Patrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_DStalker_Patrol");

	return Clss;
}


// CGAIState_DStalker_Patrol ChernobylGame.Default__CGAIState_DStalker_Patrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_DStalker_Patrol* UCGAIState_DStalker_Patrol::GetDefaultObj()
{
	static class UCGAIState_DStalker_Patrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_DStalker_Patrol*>(UCGAIState_DStalker_Patrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster
// (None)

class UClass* UCGAIState_Duster::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster");

	return Clss;
}


// CGAIState_Duster ChernobylGame.Default__CGAIState_Duster
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster* UCGAIState_Duster::GetDefaultObj()
{
	static class UCGAIState_Duster* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster*>(UCGAIState_Duster::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_Combat
// (None)

class UClass* UCGAIState_Duster_Combat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_Combat");

	return Clss;
}


// CGAIState_Duster_Combat ChernobylGame.Default__CGAIState_Duster_Combat
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_Combat* UCGAIState_Duster_Combat::GetDefaultObj()
{
	static class UCGAIState_Duster_Combat* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_Combat*>(UCGAIState_Duster_Combat::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Duster_Combat.RequestIdle
// (Final, Native, Private)
// Parameters:

void UCGAIState_Duster_Combat::RequestIdle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Duster_Combat", "RequestIdle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Duster_Attack
// (None)

class UClass* UCGAIState_Duster_Attack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_Attack");

	return Clss;
}


// CGAIState_Duster_Attack ChernobylGame.Default__CGAIState_Duster_Attack
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_Attack* UCGAIState_Duster_Attack::GetDefaultObj()
{
	static class UCGAIState_Duster_Attack* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_Attack*>(UCGAIState_Duster_Attack::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_Idle
// (None)

class UClass* UCGAIState_Duster_Idle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_Idle");

	return Clss;
}


// CGAIState_Duster_Idle ChernobylGame.Default__CGAIState_Duster_Idle
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_Idle* UCGAIState_Duster_Idle::GetDefaultObj()
{
	static class UCGAIState_Duster_Idle* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_Idle*>(UCGAIState_Duster_Idle::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_TransBase
// (None)

class UClass* UCGAIState_Duster_TransBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_TransBase");

	return Clss;
}


// CGAIState_Duster_TransBase ChernobylGame.Default__CGAIState_Duster_TransBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_TransBase* UCGAIState_Duster_TransBase::GetDefaultObj()
{
	static class UCGAIState_Duster_TransBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_TransBase*>(UCGAIState_Duster_TransBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_Trans
// (None)

class UClass* UCGAIState_Duster_Trans::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_Trans");

	return Clss;
}


// CGAIState_Duster_Trans ChernobylGame.Default__CGAIState_Duster_Trans
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_Trans* UCGAIState_Duster_Trans::GetDefaultObj()
{
	static class UCGAIState_Duster_Trans* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_Trans*>(UCGAIState_Duster_Trans::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_TransIn
// (None)

class UClass* UCGAIState_Duster_TransIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_TransIn");

	return Clss;
}


// CGAIState_Duster_TransIn ChernobylGame.Default__CGAIState_Duster_TransIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_TransIn* UCGAIState_Duster_TransIn::GetDefaultObj()
{
	static class UCGAIState_Duster_TransIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_TransIn*>(UCGAIState_Duster_TransIn::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Duster_TransOut
// (None)

class UClass* UCGAIState_Duster_TransOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Duster_TransOut");

	return Clss;
}


// CGAIState_Duster_TransOut ChernobylGame.Default__CGAIState_Duster_TransOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Duster_TransOut* UCGAIState_Duster_TransOut::GetDefaultObj()
{
	static class UCGAIState_Duster_TransOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Duster_TransOut*>(UCGAIState_Duster_TransOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Global_CustomSequence
// (None)

class UClass* UCGAIState_Global_CustomSequence::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Global_CustomSequence");

	return Clss;
}


// CGAIState_Global_CustomSequence ChernobylGame.Default__CGAIState_Global_CustomSequence
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Global_CustomSequence* UCGAIState_Global_CustomSequence::GetDefaultObj()
{
	static class UCGAIState_Global_CustomSequence* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Global_CustomSequence*>(UCGAIState_Global_CustomSequence::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Global_Standby
// (None)

class UClass* UCGAIState_Global_Standby::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Global_Standby");

	return Clss;
}


// CGAIState_Global_Standby ChernobylGame.Default__CGAIState_Global_Standby
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Global_Standby* UCGAIState_Global_Standby::GetDefaultObj()
{
	static class UCGAIState_Global_Standby* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Global_Standby*>(UCGAIState_Global_Standby::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Global_Standby.BackToPrevious
// (Final, Native, Private)
// Parameters:

void UCGAIState_Global_Standby::BackToPrevious()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Global_Standby", "BackToPrevious");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Hunt
// (None)

class UClass* UCGAIState_Hunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Hunt");

	return Clss;
}


// CGAIState_Hunt ChernobylGame.Default__CGAIState_Hunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Hunt* UCGAIState_Hunt::GetDefaultObj()
{
	static class UCGAIState_Hunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Hunt*>(UCGAIState_Hunt::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Idle
// (None)

class UClass* UCGAIState_Idle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Idle");

	return Clss;
}


// CGAIState_Idle ChernobylGame.Default__CGAIState_Idle
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Idle* UCGAIState_Idle::GetDefaultObj()
{
	static class UCGAIState_Idle* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Idle*>(UCGAIState_Idle::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC
// (None)

class UClass* UCGAIState_NPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC");

	return Clss;
}


// CGAIState_NPC ChernobylGame.Default__CGAIState_NPC
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC* UCGAIState_NPC::GetDefaultObj()
{
	static class UCGAIState_NPC* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC*>(UCGAIState_NPC::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_ApproachIdle
// (None)

class UClass* UCGAIState_NPC_ApproachIdle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_ApproachIdle");

	return Clss;
}


// CGAIState_NPC_ApproachIdle ChernobylGame.Default__CGAIState_NPC_ApproachIdle
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_ApproachIdle* UCGAIState_NPC_ApproachIdle::GetDefaultObj()
{
	static class UCGAIState_NPC_ApproachIdle* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_ApproachIdle*>(UCGAIState_NPC_ApproachIdle::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_Idle
// (None)

class UClass* UCGAIState_NPC_Idle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_Idle");

	return Clss;
}


// CGAIState_NPC_Idle ChernobylGame.Default__CGAIState_NPC_Idle
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_Idle* UCGAIState_NPC_Idle::GetDefaultObj()
{
	static class UCGAIState_NPC_Idle* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_Idle*>(UCGAIState_NPC_Idle::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_IdleNeutral
// (None)

class UClass* UCGAIState_NPC_IdleNeutral::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_IdleNeutral");

	return Clss;
}


// CGAIState_NPC_IdleNeutral ChernobylGame.Default__CGAIState_NPC_IdleNeutral
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_IdleNeutral* UCGAIState_NPC_IdleNeutral::GetDefaultObj()
{
	static class UCGAIState_NPC_IdleNeutral* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_IdleNeutral*>(UCGAIState_NPC_IdleNeutral::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_IdleStealth
// (None)

class UClass* UCGAIState_NPC_IdleStealth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_IdleStealth");

	return Clss;
}


// CGAIState_NPC_IdleStealth ChernobylGame.Default__CGAIState_NPC_IdleStealth
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_IdleStealth* UCGAIState_NPC_IdleStealth::GetDefaultObj()
{
	static class UCGAIState_NPC_IdleStealth* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_IdleStealth*>(UCGAIState_NPC_IdleStealth::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_MoveBase
// (None)

class UClass* UCGAIState_NPC_MoveBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_MoveBase");

	return Clss;
}


// CGAIState_NPC_MoveBase ChernobylGame.Default__CGAIState_NPC_MoveBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_MoveBase* UCGAIState_NPC_MoveBase::GetDefaultObj()
{
	static class UCGAIState_NPC_MoveBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_MoveBase*>(UCGAIState_NPC_MoveBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_RunNeutral
// (None)

class UClass* UCGAIState_NPC_RunNeutral::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_RunNeutral");

	return Clss;
}


// CGAIState_NPC_RunNeutral ChernobylGame.Default__CGAIState_NPC_RunNeutral
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_RunNeutral* UCGAIState_NPC_RunNeutral::GetDefaultObj()
{
	static class UCGAIState_NPC_RunNeutral* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_RunNeutral*>(UCGAIState_NPC_RunNeutral::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_RunStealth
// (None)

class UClass* UCGAIState_NPC_RunStealth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_RunStealth");

	return Clss;
}


// CGAIState_NPC_RunStealth ChernobylGame.Default__CGAIState_NPC_RunStealth
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_RunStealth* UCGAIState_NPC_RunStealth::GetDefaultObj()
{
	static class UCGAIState_NPC_RunStealth* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_RunStealth*>(UCGAIState_NPC_RunStealth::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_NPC_WalkStealth
// (None)

class UClass* UCGAIState_NPC_WalkStealth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_NPC_WalkStealth");

	return Clss;
}


// CGAIState_NPC_WalkStealth ChernobylGame.Default__CGAIState_NPC_WalkStealth
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_NPC_WalkStealth* UCGAIState_NPC_WalkStealth::GetDefaultObj()
{
	static class UCGAIState_NPC_WalkStealth* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_NPC_WalkStealth*>(UCGAIState_NPC_WalkStealth::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Patrol
// (None)

class UClass* UCGAIState_Patrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Patrol");

	return Clss;
}


// CGAIState_Patrol ChernobylGame.Default__CGAIState_Patrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Patrol* UCGAIState_Patrol::GetDefaultObj()
{
	static class UCGAIState_Patrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Patrol*>(UCGAIState_Patrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_ShadOut
// (None)

class UClass* UCGAIState_ShadOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut");

	return Clss;
}


// CGAIState_ShadOut ChernobylGame.Default__CGAIState_ShadOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut* UCGAIState_ShadOut::GetDefaultObj()
{
	static class UCGAIState_ShadOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut*>(UCGAIState_ShadOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_ShadOut_HuntBase
// (None)

class UClass* UCGAIState_ShadOut_HuntBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut_HuntBase");

	return Clss;
}


// CGAIState_ShadOut_HuntBase ChernobylGame.Default__CGAIState_ShadOut_HuntBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut_HuntBase* UCGAIState_ShadOut_HuntBase::GetDefaultObj()
{
	static class UCGAIState_ShadOut_HuntBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut_HuntBase*>(UCGAIState_ShadOut_HuntBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_ShadOut_PatrolBase
// (None)

class UClass* UCGAIState_ShadOut_PatrolBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut_PatrolBase");

	return Clss;
}


// CGAIState_ShadOut_PatrolBase ChernobylGame.Default__CGAIState_ShadOut_PatrolBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut_PatrolBase* UCGAIState_ShadOut_PatrolBase::GetDefaultObj()
{
	static class UCGAIState_ShadOut_PatrolBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut_PatrolBase*>(UCGAIState_ShadOut_PatrolBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_ShadOut_PatrolIn
// (None)

class UClass* UCGAIState_ShadOut_PatrolIn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut_PatrolIn");

	return Clss;
}


// CGAIState_ShadOut_PatrolIn ChernobylGame.Default__CGAIState_ShadOut_PatrolIn
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut_PatrolIn* UCGAIState_ShadOut_PatrolIn::GetDefaultObj()
{
	static class UCGAIState_ShadOut_PatrolIn* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut_PatrolIn*>(UCGAIState_ShadOut_PatrolIn::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_ShadOut_PatrolIn.TryLeavingPortal
// (Final, Native, Private)
// Parameters:

void UCGAIState_ShadOut_PatrolIn::TryLeavingPortal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_ShadOut_PatrolIn", "TryLeavingPortal");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_ShadOut_PatrolIn.OnLeavingAnimFinished
// (Final, Native, Private)
// Parameters:

void UCGAIState_ShadOut_PatrolIn::OnLeavingAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_ShadOut_PatrolIn", "OnLeavingAnimFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_ShadOut_PatrolLoop
// (None)

class UClass* UCGAIState_ShadOut_PatrolLoop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut_PatrolLoop");

	return Clss;
}


// CGAIState_ShadOut_PatrolLoop ChernobylGame.Default__CGAIState_ShadOut_PatrolLoop
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut_PatrolLoop* UCGAIState_ShadOut_PatrolLoop::GetDefaultObj()
{
	static class UCGAIState_ShadOut_PatrolLoop* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut_PatrolLoop*>(UCGAIState_ShadOut_PatrolLoop::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_ShadOut_PatrolOut
// (None)

class UClass* UCGAIState_ShadOut_PatrolOut::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_ShadOut_PatrolOut");

	return Clss;
}


// CGAIState_ShadOut_PatrolOut ChernobylGame.Default__CGAIState_ShadOut_PatrolOut
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_ShadOut_PatrolOut* UCGAIState_ShadOut_PatrolOut::GetDefaultObj()
{
	static class UCGAIState_ShadOut_PatrolOut* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_ShadOut_PatrolOut*>(UCGAIState_ShadOut_PatrolOut::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Shadow_AWallRouting
// (None)

class UClass* UCGAIState_Shadow_AWallRouting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Shadow_AWallRouting");

	return Clss;
}


// CGAIState_Shadow_AWallRouting ChernobylGame.Default__CGAIState_Shadow_AWallRouting
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Shadow_AWallRouting* UCGAIState_Shadow_AWallRouting::GetDefaultObj()
{
	static class UCGAIState_Shadow_AWallRouting* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Shadow_AWallRouting*>(UCGAIState_Shadow_AWallRouting::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Shadow_InWall
// (None)

class UClass* UCGAIState_Shadow_InWall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Shadow_InWall");

	return Clss;
}


// CGAIState_Shadow_InWall ChernobylGame.Default__CGAIState_Shadow_InWall
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Shadow_InWall* UCGAIState_Shadow_InWall::GetDefaultObj()
{
	static class UCGAIState_Shadow_InWall* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Shadow_InWall*>(UCGAIState_Shadow_InWall::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Shadow_LeftCombat
// (None)

class UClass* UCGAIState_Shadow_LeftCombat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Shadow_LeftCombat");

	return Clss;
}


// CGAIState_Shadow_LeftCombat ChernobylGame.Default__CGAIState_Shadow_LeftCombat
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Shadow_LeftCombat* UCGAIState_Shadow_LeftCombat::GetDefaultObj()
{
	static class UCGAIState_Shadow_LeftCombat* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Shadow_LeftCombat*>(UCGAIState_Shadow_LeftCombat::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Shadow_PWallRouting
// (None)

class UClass* UCGAIState_Shadow_PWallRouting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Shadow_PWallRouting");

	return Clss;
}


// CGAIState_Shadow_PWallRouting ChernobylGame.Default__CGAIState_Shadow_PWallRouting
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Shadow_PWallRouting* UCGAIState_Shadow_PWallRouting::GetDefaultObj()
{
	static class UCGAIState_Shadow_PWallRouting* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Shadow_PWallRouting*>(UCGAIState_Shadow_PWallRouting::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier
// (None)

class UClass* UCGAIState_Soldier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier");

	return Clss;
}


// CGAIState_Soldier ChernobylGame.Default__CGAIState_Soldier
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier* UCGAIState_Soldier::GetDefaultObj()
{
	static class UCGAIState_Soldier* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier*>(UCGAIState_Soldier::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier.TryFindCover
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier::TryFindCover()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier", "TryFindCover");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier.SquadBackInPlace
// (Native, Public)
// Parameters:

void UCGAIState_Soldier::SquadBackInPlace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier", "SquadBackInPlace");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier.OnShooterRemoved
// (Native, Public)
// Parameters:

void UCGAIState_Soldier::OnShooterRemoved()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier", "OnShooterRemoved");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier.CheckForStealthkillOnVisible
// (Native, Public)
// Parameters:

void UCGAIState_Soldier::CheckForStealthkillOnVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier", "CheckForStealthkillOnVisible");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_Alert
// (None)

class UClass* UCGAIState_Soldier_Alert::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_Alert");

	return Clss;
}


// CGAIState_Soldier_Alert ChernobylGame.Default__CGAIState_Soldier_Alert
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_Alert* UCGAIState_Soldier_Alert::GetDefaultObj()
{
	static class UCGAIState_Soldier_Alert* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_Alert*>(UCGAIState_Soldier_Alert::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_Alert.OnPatrolRet
// (Final, Native, Protected)
// Parameters:

void UCGAIState_Soldier_Alert::OnPatrolRet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_Alert", "OnPatrolRet");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_Alert.OnNotifyBeginReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                        InNotifyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBranchingPointNotifyPayloadInBranchingPointPayload                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCGAIState_Soldier_Alert::OnNotifyBeginReceived(class FName InNotifyName, struct FBranchingPointNotifyPayload& InBranchingPointPayload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_Alert", "OnNotifyBeginReceived");

	Params::UCGAIState_Soldier_Alert_OnNotifyBeginReceived_Params Parms{};

	Parms.InNotifyName = InNotifyName;
	Parms.InBranchingPointPayload = InBranchingPointPayload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_AApproach
// (None)

class UClass* UCGAIState_Soldier_AApproach::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_AApproach");

	return Clss;
}


// CGAIState_Soldier_AApproach ChernobylGame.Default__CGAIState_Soldier_AApproach
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_AApproach* UCGAIState_Soldier_AApproach::GetDefaultObj()
{
	static class UCGAIState_Soldier_AApproach* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_AApproach*>(UCGAIState_Soldier_AApproach::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_AlertBlank
// (None)

class UClass* UCGAIState_Soldier_AlertBlank::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_AlertBlank");

	return Clss;
}


// CGAIState_Soldier_AlertBlank ChernobylGame.Default__CGAIState_Soldier_AlertBlank
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_AlertBlank* UCGAIState_Soldier_AlertBlank::GetDefaultObj()
{
	static class UCGAIState_Soldier_AlertBlank* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_AlertBlank*>(UCGAIState_Soldier_AlertBlank::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_AReached
// (None)

class UClass* UCGAIState_Soldier_AReached::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_AReached");

	return Clss;
}


// CGAIState_Soldier_AReached ChernobylGame.Default__CGAIState_Soldier_AReached
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_AReached* UCGAIState_Soldier_AReached::GetDefaultObj()
{
	static class UCGAIState_Soldier_AReached* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_AReached*>(UCGAIState_Soldier_AReached::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_Hunt
// (None)

class UClass* UCGAIState_Soldier_Hunt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_Hunt");

	return Clss;
}


// CGAIState_Soldier_Hunt ChernobylGame.Default__CGAIState_Soldier_Hunt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_Hunt* UCGAIState_Soldier_Hunt::GetDefaultObj()
{
	static class UCGAIState_Soldier_Hunt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_Hunt*>(UCGAIState_Soldier_Hunt::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_Hunt.DodgeTick
// (Native, Public)
// Parameters:

void UCGAIState_Soldier_Hunt::DodgeTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_Hunt", "DodgeTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_ArrestBase
// (None)

class UClass* UCGAIState_Soldier_ArrestBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_ArrestBase");

	return Clss;
}


// CGAIState_Soldier_ArrestBase ChernobylGame.Default__CGAIState_Soldier_ArrestBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_ArrestBase* UCGAIState_Soldier_ArrestBase::GetDefaultObj()
{
	static class UCGAIState_Soldier_ArrestBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_ArrestBase*>(UCGAIState_Soldier_ArrestBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_ArrestAttempt
// (None)

class UClass* UCGAIState_Soldier_ArrestAttempt::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_ArrestAttempt");

	return Clss;
}


// CGAIState_Soldier_ArrestAttempt ChernobylGame.Default__CGAIState_Soldier_ArrestAttempt
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_ArrestAttempt* UCGAIState_Soldier_ArrestAttempt::GetDefaultObj()
{
	static class UCGAIState_Soldier_ArrestAttempt* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_ArrestAttempt*>(UCGAIState_Soldier_ArrestAttempt::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_ArrestAttempt.SetAttack
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_ArrestAttempt::SetAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_ArrestAttempt", "SetAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_ArrestAttempt.Repeat
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_ArrestAttempt::Repeat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_ArrestAttempt", "Repeat");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_ArrestAttempt.Arrest
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_ArrestAttempt::Arrest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_ArrestAttempt", "Arrest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_ArrestAttemptO
// (None)

class UClass* UCGAIState_Soldier_ArrestAttemptO::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_ArrestAttemptO");

	return Clss;
}


// CGAIState_Soldier_ArrestAttemptO ChernobylGame.Default__CGAIState_Soldier_ArrestAttemptO
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_ArrestAttemptO* UCGAIState_Soldier_ArrestAttemptO::GetDefaultObj()
{
	static class UCGAIState_Soldier_ArrestAttemptO* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_ArrestAttemptO*>(UCGAIState_Soldier_ArrestAttemptO::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_ASpotSK
// (None)

class UClass* UCGAIState_Soldier_ASpotSK::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_ASpotSK");

	return Clss;
}


// CGAIState_Soldier_ASpotSK ChernobylGame.Default__CGAIState_Soldier_ASpotSK
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_ASpotSK* UCGAIState_Soldier_ASpotSK::GetDefaultObj()
{
	static class UCGAIState_Soldier_ASpotSK* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_ASpotSK*>(UCGAIState_Soldier_ASpotSK::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HAttack
// (None)

class UClass* UCGAIState_Soldier_HAttack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HAttack");

	return Clss;
}


// CGAIState_Soldier_HAttack ChernobylGame.Default__CGAIState_Soldier_HAttack
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HAttack* UCGAIState_Soldier_HAttack::GetDefaultObj()
{
	static class UCGAIState_Soldier_HAttack* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HAttack*>(UCGAIState_Soldier_HAttack::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HAttackS
// (None)

class UClass* UCGAIState_Soldier_HAttackS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HAttackS");

	return Clss;
}


// CGAIState_Soldier_HAttackS ChernobylGame.Default__CGAIState_Soldier_HAttackS
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HAttackS* UCGAIState_Soldier_HAttackS::GetDefaultObj()
{
	static class UCGAIState_Soldier_HAttackS* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HAttackS*>(UCGAIState_Soldier_HAttackS::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HAttackO
// (None)

class UClass* UCGAIState_Soldier_HAttackO::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HAttackO");

	return Clss;
}


// CGAIState_Soldier_HAttackO ChernobylGame.Default__CGAIState_Soldier_HAttackO
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HAttackO* UCGAIState_Soldier_HAttackO::GetDefaultObj()
{
	static class UCGAIState_Soldier_HAttackO* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HAttackO*>(UCGAIState_Soldier_HAttackO::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HAttackO.ValidityTick
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HAttackO::ValidityTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HAttackO", "ValidityTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HAttackO.OnVCAimFinish
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HAttackO::OnVCAimFinish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HAttackO", "OnVCAimFinish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HAttackO.LazyTick
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HAttackO::LazyTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HAttackO", "LazyTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HAttackVC
// (None)

class UClass* UCGAIState_Soldier_HAttackVC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HAttackVC");

	return Clss;
}


// CGAIState_Soldier_HAttackVC ChernobylGame.Default__CGAIState_Soldier_HAttackVC
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HAttackVC* UCGAIState_Soldier_HAttackVC::GetDefaultObj()
{
	static class UCGAIState_Soldier_HAttackVC* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HAttackVC*>(UCGAIState_Soldier_HAttackVC::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HAttackVC.OnVCAimFinish
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_HAttackVC::OnVCAimFinish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HAttackVC", "OnVCAimFinish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HAttackVCCov
// (None)

class UClass* UCGAIState_Soldier_HAttackVCCov::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HAttackVCCov");

	return Clss;
}


// CGAIState_Soldier_HAttackVCCov ChernobylGame.Default__CGAIState_Soldier_HAttackVCCov
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HAttackVCCov* UCGAIState_Soldier_HAttackVCCov::GetDefaultObj()
{
	static class UCGAIState_Soldier_HAttackVCCov* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HAttackVCCov*>(UCGAIState_Soldier_HAttackVCCov::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HChase
// (None)

class UClass* UCGAIState_Soldier_HChase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HChase");

	return Clss;
}


// CGAIState_Soldier_HChase ChernobylGame.Default__CGAIState_Soldier_HChase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HChase* UCGAIState_Soldier_HChase::GetDefaultObj()
{
	static class UCGAIState_Soldier_HChase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HChase*>(UCGAIState_Soldier_HChase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HChase.OnTimeElapsedUponRecognise
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_HChase::OnTimeElapsedUponRecognise()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HChase", "OnTimeElapsedUponRecognise");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HChaseReached
// (None)

class UClass* UCGAIState_Soldier_HChaseReached::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HChaseReached");

	return Clss;
}


// CGAIState_Soldier_HChaseReached ChernobylGame.Default__CGAIState_Soldier_HChaseReached
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HChaseReached* UCGAIState_Soldier_HChaseReached::GetDefaultObj()
{
	static class UCGAIState_Soldier_HChaseReached* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HChaseReached*>(UCGAIState_Soldier_HChaseReached::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCover
// (None)

class UClass* UCGAIState_Soldier_HCover::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCover");

	return Clss;
}


// CGAIState_Soldier_HCover ChernobylGame.Default__CGAIState_Soldier_HCover
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCover* UCGAIState_Soldier_HCover::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCover* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCover*>(UCGAIState_Soldier_HCover::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HCover.CheckCoverValidityTickVirt
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HCover::CheckCoverValidityTickVirt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCover", "CheckCoverValidityTickVirt");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HCover.CheckCoverValidityTick
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HCover::CheckCoverValidityTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCover", "CheckCoverValidityTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HCover.CheckCoverValidity
// (Final, Native, Protected)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIState_Soldier_HCover::CheckCoverValidity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCover", "CheckCoverValidity");

	Params::UCGAIState_Soldier_HCover_CheckCoverValidity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAIState_Soldier_HCoverLoop
// (None)

class UClass* UCGAIState_Soldier_HCoverLoop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCoverLoop");

	return Clss;
}


// CGAIState_Soldier_HCoverLoop ChernobylGame.Default__CGAIState_Soldier_HCoverLoop
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCoverLoop* UCGAIState_Soldier_HCoverLoop::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCoverLoop* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCoverLoop*>(UCGAIState_Soldier_HCoverLoop::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HCoverLoop.TryFindingBetterCoverTick
// (Native, Protected)
// Parameters:

void UCGAIState_Soldier_HCoverLoop::TryFindingBetterCoverTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCoverLoop", "TryFindingBetterCoverTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HCoverLoop.TryAiming
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_HCoverLoop::TryAiming()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCoverLoop", "TryAiming");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HCoverLoop.LeaveCoverLoopElapsed
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_HCoverLoop::LeaveCoverLoopElapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCoverLoop", "LeaveCoverLoopElapsed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIState_Soldier_HCoverLoop.FindBetterCoverVirt
// (Native, Protected)
// Parameters:
// class ACGCover*                    InCover                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState_Soldier_HCoverLoop::FindBetterCoverVirt(class ACGCover* InCover)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCoverLoop", "FindBetterCoverVirt");

	Params::UCGAIState_Soldier_HCoverLoop_FindBetterCoverVirt_Params Parms{};

	Parms.InCover = InCover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HCoverReach
// (None)

class UClass* UCGAIState_Soldier_HCoverReach::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCoverReach");

	return Clss;
}


// CGAIState_Soldier_HCoverReach ChernobylGame.Default__CGAIState_Soldier_HCoverReach
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCoverReach* UCGAIState_Soldier_HCoverReach::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCoverReach* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCoverReach*>(UCGAIState_Soldier_HCoverReach::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCoverReachFin
// (None)

class UClass* UCGAIState_Soldier_HCoverReachFin::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCoverReachFin");

	return Clss;
}


// CGAIState_Soldier_HCoverReachFin ChernobylGame.Default__CGAIState_Soldier_HCoverReachFin
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCoverReachFin* UCGAIState_Soldier_HCoverReachFin::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCoverReachFin* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCoverReachFin*>(UCGAIState_Soldier_HCoverReachFin::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCoverReachVC
// (None)

class UClass* UCGAIState_Soldier_HCoverReachVC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCoverReachVC");

	return Clss;
}


// CGAIState_Soldier_HCoverReachVC ChernobylGame.Default__CGAIState_Soldier_HCoverReachVC
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCoverReachVC* UCGAIState_Soldier_HCoverReachVC::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCoverReachVC* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCoverReachVC*>(UCGAIState_Soldier_HCoverReachVC::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HCoverReachVC.OnVCAimFinish
// (Final, Native, Public)
// Parameters:

void UCGAIState_Soldier_HCoverReachVC::OnVCAimFinish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HCoverReachVC", "OnVCAimFinish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HCoverTrans
// (None)

class UClass* UCGAIState_Soldier_HCoverTrans::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCoverTrans");

	return Clss;
}


// CGAIState_Soldier_HCoverTrans ChernobylGame.Default__CGAIState_Soldier_HCoverTrans
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCoverTrans* UCGAIState_Soldier_HCoverTrans::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCoverTrans* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCoverTrans*>(UCGAIState_Soldier_HCoverTrans::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCovFromShoot
// (None)

class UClass* UCGAIState_Soldier_HCovFromShoot::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCovFromShoot");

	return Clss;
}


// CGAIState_Soldier_HCovFromShoot ChernobylGame.Default__CGAIState_Soldier_HCovFromShoot
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCovFromShoot* UCGAIState_Soldier_HCovFromShoot::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCovFromShoot* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCovFromShoot*>(UCGAIState_Soldier_HCovFromShoot::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCovShoot
// (None)

class UClass* UCGAIState_Soldier_HCovShoot::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCovShoot");

	return Clss;
}


// CGAIState_Soldier_HCovShoot ChernobylGame.Default__CGAIState_Soldier_HCovShoot
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCovShoot* UCGAIState_Soldier_HCovShoot::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCovShoot* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCovShoot*>(UCGAIState_Soldier_HCovShoot::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HCovToShoot
// (None)

class UClass* UCGAIState_Soldier_HCovToShoot::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HCovToShoot");

	return Clss;
}


// CGAIState_Soldier_HCovToShoot ChernobylGame.Default__CGAIState_Soldier_HCovToShoot
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HCovToShoot* UCGAIState_Soldier_HCovToShoot::GetDefaultObj()
{
	static class UCGAIState_Soldier_HCovToShoot* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HCovToShoot*>(UCGAIState_Soldier_HCovToShoot::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HDialogue
// (None)

class UClass* UCGAIState_Soldier_HDialogue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HDialogue");

	return Clss;
}


// CGAIState_Soldier_HDialogue ChernobylGame.Default__CGAIState_Soldier_HDialogue
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HDialogue* UCGAIState_Soldier_HDialogue::GetDefaultObj()
{
	static class UCGAIState_Soldier_HDialogue* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HDialogue*>(UCGAIState_Soldier_HDialogue::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HEvade
// (None)

class UClass* UCGAIState_Soldier_HEvade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HEvade");

	return Clss;
}


// CGAIState_Soldier_HEvade ChernobylGame.Default__CGAIState_Soldier_HEvade
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HEvade* UCGAIState_Soldier_HEvade::GetDefaultObj()
{
	static class UCGAIState_Soldier_HEvade* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HEvade*>(UCGAIState_Soldier_HEvade::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HEvade.AnimFinished
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                InMontage                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInInterrupted                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState_Soldier_HEvade::AnimFinished(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HEvade", "AnimFinished");

	Params::UCGAIState_Soldier_HEvade_AnimFinished_Params Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HHeroDown
// (None)

class UClass* UCGAIState_Soldier_HHeroDown::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HHeroDown");

	return Clss;
}


// CGAIState_Soldier_HHeroDown ChernobylGame.Default__CGAIState_Soldier_HHeroDown
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HHeroDown* UCGAIState_Soldier_HHeroDown::GetDefaultObj()
{
	static class UCGAIState_Soldier_HHeroDown* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HHeroDown*>(UCGAIState_Soldier_HHeroDown::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HHeroDown.BackToPrevious
// (Final, Native, Private)
// Parameters:

void UCGAIState_Soldier_HHeroDown::BackToPrevious()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HHeroDown", "BackToPrevious");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HMeleeAttack
// (None)

class UClass* UCGAIState_Soldier_HMeleeAttack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HMeleeAttack");

	return Clss;
}


// CGAIState_Soldier_HMeleeAttack ChernobylGame.Default__CGAIState_Soldier_HMeleeAttack
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HMeleeAttack* UCGAIState_Soldier_HMeleeAttack::GetDefaultObj()
{
	static class UCGAIState_Soldier_HMeleeAttack* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HMeleeAttack*>(UCGAIState_Soldier_HMeleeAttack::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_HMeleeAttack.AttackMontageEnded
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                InMontage                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInInterrupted                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState_Soldier_HMeleeAttack::AttackMontageEnded(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_HMeleeAttack", "AttackMontageEnded");

	Params::UCGAIState_Soldier_HMeleeAttack_AttackMontageEnded_Params Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_HMeleeBack
// (None)

class UClass* UCGAIState_Soldier_HMeleeBack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HMeleeBack");

	return Clss;
}


// CGAIState_Soldier_HMeleeBack ChernobylGame.Default__CGAIState_Soldier_HMeleeBack
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HMeleeBack* UCGAIState_Soldier_HMeleeBack::GetDefaultObj()
{
	static class UCGAIState_Soldier_HMeleeBack* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HMeleeBack*>(UCGAIState_Soldier_HMeleeBack::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HMeleeReach
// (None)

class UClass* UCGAIState_Soldier_HMeleeReach::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HMeleeReach");

	return Clss;
}


// CGAIState_Soldier_HMeleeReach ChernobylGame.Default__CGAIState_Soldier_HMeleeReach
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HMeleeReach* UCGAIState_Soldier_HMeleeReach::GetDefaultObj()
{
	static class UCGAIState_Soldier_HMeleeReach* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HMeleeReach*>(UCGAIState_Soldier_HMeleeReach::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_HStandby
// (None)

class UClass* UCGAIState_Soldier_HStandby::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_HStandby");

	return Clss;
}


// CGAIState_Soldier_HStandby ChernobylGame.Default__CGAIState_Soldier_HStandby
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_HStandby* UCGAIState_Soldier_HStandby::GetDefaultObj()
{
	static class UCGAIState_Soldier_HStandby* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_HStandby*>(UCGAIState_Soldier_HStandby::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_MeleeReaction
// (None)

class UClass* UCGAIState_Soldier_MeleeReaction::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_MeleeReaction");

	return Clss;
}


// CGAIState_Soldier_MeleeReaction ChernobylGame.Default__CGAIState_Soldier_MeleeReaction
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_MeleeReaction* UCGAIState_Soldier_MeleeReaction::GetDefaultObj()
{
	static class UCGAIState_Soldier_MeleeReaction* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_MeleeReaction*>(UCGAIState_Soldier_MeleeReaction::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIState_Soldier_MeleeReaction.OnReactionMontageFinished
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                InMontage                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInInterrupted                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAIState_Soldier_MeleeReaction::OnReactionMontageFinished(class UAnimMontage* InMontage, bool bInInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIState_Soldier_MeleeReaction", "OnReactionMontageFinished");

	Params::UCGAIState_Soldier_MeleeReaction_OnReactionMontageFinished_Params Parms{};

	Parms.InMontage = InMontage;
	Parms.bInInterrupted = bInInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGAIState_Soldier_MFrozen
// (None)

class UClass* UCGAIState_Soldier_MFrozen::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_MFrozen");

	return Clss;
}


// CGAIState_Soldier_MFrozen ChernobylGame.Default__CGAIState_Soldier_MFrozen
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_MFrozen* UCGAIState_Soldier_MFrozen::GetDefaultObj()
{
	static class UCGAIState_Soldier_MFrozen* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_MFrozen*>(UCGAIState_Soldier_MFrozen::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_Patrol
// (None)

class UClass* UCGAIState_Soldier_Patrol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_Patrol");

	return Clss;
}


// CGAIState_Soldier_Patrol ChernobylGame.Default__CGAIState_Soldier_Patrol
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_Patrol* UCGAIState_Soldier_Patrol::GetDefaultObj()
{
	static class UCGAIState_Soldier_Patrol* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_Patrol*>(UCGAIState_Soldier_Patrol::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_PatrolRet
// (None)

class UClass* UCGAIState_Soldier_PatrolRet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_PatrolRet");

	return Clss;
}


// CGAIState_Soldier_PatrolRet ChernobylGame.Default__CGAIState_Soldier_PatrolRet
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_PatrolRet* UCGAIState_Soldier_PatrolRet::GetDefaultObj()
{
	static class UCGAIState_Soldier_PatrolRet* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_PatrolRet*>(UCGAIState_Soldier_PatrolRet::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Soldier_WalkUp
// (None)

class UClass* UCGAIState_Soldier_WalkUp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Soldier_WalkUp");

	return Clss;
}


// CGAIState_Soldier_WalkUp ChernobylGame.Default__CGAIState_Soldier_WalkUp
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Soldier_WalkUp* UCGAIState_Soldier_WalkUp::GetDefaultObj()
{
	static class UCGAIState_Soldier_WalkUp* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Soldier_WalkUp*>(UCGAIState_Soldier_WalkUp::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIState_Stunned
// (None)

class UClass* UCGAIState_Stunned::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIState_Stunned");

	return Clss;
}


// CGAIState_Stunned ChernobylGame.Default__CGAIState_Stunned
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIState_Stunned* UCGAIState_Stunned::GetDefaultObj()
{
	static class UCGAIState_Stunned* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIState_Stunned*>(UCGAIState_Stunned::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAIStateComponent
// (None)

class UClass* UCGAIStateComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAIStateComponent");

	return Clss;
}


// CGAIStateComponent ChernobylGame.Default__CGAIStateComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAIStateComponent* UCGAIStateComponent::GetDefaultObj()
{
	static class UCGAIStateComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAIStateComponent*>(UCGAIStateComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAIStateComponent.SetStateAdditionalInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGAIStateAdditionalInfo    InInfo                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCGAIStateComponent::SetStateAdditionalInfo(struct FCGAIStateAdditionalInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "SetStateAdditionalInfo");

	Params::UCGAIStateComponent_SetStateAdditionalInfo_Params Parms{};

	Parms.InInfo = InInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGAIStateComponent.GetStealthKillPossibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAIStateComponent::GetStealthKillPossibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "GetStealthKillPossibility");

	Params::UCGAIStateComponent_GetStealthKillPossibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIStateComponent.GetStateAdditionalInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCGAIStateAdditionalInfo    ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGAIStateAdditionalInfo UCGAIStateComponent::GetStateAdditionalInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "GetStateAdditionalInfo");

	Params::UCGAIStateComponent_GetStateAdditionalInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIStateComponent.GetReasonOfLastStateEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGAIStateComponent::GetReasonOfLastStateEntry()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "GetReasonOfLastStateEntry");

	Params::UCGAIStateComponent_GetReasonOfLastStateEntry_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIStateComponent.GetAssociatedEnumStateType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EAIStateType            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAIStateType UCGAIStateComponent::GetAssociatedEnumStateType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "GetAssociatedEnumStateType");

	Params::UCGAIStateComponent_GetAssociatedEnumStateType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAIStateComponent.GetAssociatedClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UCGAIState>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UCGAIState> UCGAIStateComponent::GetAssociatedClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAIStateComponent", "GetAssociatedClass");

	Params::UCGAIStateComponent_GetAssociatedClass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAkReverbVolume
// (Actor)

class UClass* ACGAkReverbVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAkReverbVolume");

	return Clss;
}


// CGAkReverbVolume ChernobylGame.Default__CGAkReverbVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGAkReverbVolume* ACGAkReverbVolume::GetDefaultObj()
{
	static class ACGAkReverbVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGAkReverbVolume*>(ACGAkReverbVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAnim
// (None)

class UClass* UCGAnim::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAnim");

	return Clss;
}


// CGAnim ChernobylGame.Default__CGAnim
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAnim* UCGAnim::GetDefaultObj()
{
	static class UCGAnim* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAnim*>(UCGAnim::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAnim.IsRootmotionEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*               InAnimSequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGAnim::IsRootmotionEnabled(class UAnimSequence* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "IsRootmotionEnabled");

	Params::UCGAnim_IsRootmotionEnabled_Params Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAnim.GetRelevantAnimInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*               InAnimInstance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutTime                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InMachineIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InStateIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAnim::GetRelevantAnimInfo(class UAnimInstance* InAnimInstance, float* OutTime, int32 InMachineIndex, int32 InStateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "GetRelevantAnimInfo");

	Params::UCGAnim_GetRelevantAnimInfo_Params Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.InMachineIndex = InMachineIndex;
	Parms.InStateIndex = InStateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

}


// Function ChernobylGame.CGAnim.GetMorphTargetValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*               InAnimInstance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InMorphName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAnim::GetMorphTargetValue(class UAnimInstance* InAnimInstance, class FName InMorphName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "GetMorphTargetValue");

	Params::UCGAnim_GetMorphTargetValue_Params Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.InMorphName = InMorphName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAnim.GetMachineAndStateIndexes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*               InAnimInstance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InMachineName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InStateName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutMachineIndex                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutStateIndex                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGAnim::GetMachineAndStateIndexes(class UAnimInstance* InAnimInstance, class FName InMachineName, class FName InStateName, int32* OutMachineIndex, int32* OutStateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "GetMachineAndStateIndexes");

	Params::UCGAnim_GetMachineAndStateIndexes_Params Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.InMachineName = InMachineName;
	Parms.InStateName = InStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMachineIndex != nullptr)
		*OutMachineIndex = Parms.OutMachineIndex;

	if (OutStateIndex != nullptr)
		*OutStateIndex = Parms.OutStateIndex;

}


// Function ChernobylGame.CGAnim.GetAllMorphTargetNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*               InAnimInstance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCGAnim::GetAllMorphTargetNames(class UAnimInstance* InAnimInstance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "GetAllMorphTargetNames");

	Params::UCGAnim_GetAllMorphTargetNames_Params Parms{};

	Parms.InAnimInstance = InAnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAnim.BoneTransformInTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*               InAnimation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*      InSkeletalMesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCGAnim::BoneTransformInTime(class UAnimSequence* InAnimation, float InTime, class FName& InBoneName, class USkeletalMeshComponent* InSkeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnim", "BoneTransformInTime");

	Params::UCGAnim_BoneTransformInTime_Params Parms{};

	Parms.InAnimation = InAnimation;
	Parms.InTime = InTime;
	Parms.InBoneName = InBoneName;
	Parms.InSkeletalMesh = InSkeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAnimNotifyState
// (None)

class UClass* UCGAnimNotifyState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAnimNotifyState");

	return Clss;
}


// CGAnimNotifyState ChernobylGame.Default__CGAnimNotifyState
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAnimNotifyState* UCGAnimNotifyState::GetDefaultObj()
{
	static class UCGAnimNotifyState* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAnimNotifyState*>(UCGAnimNotifyState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGAnimNotifyState.GetStartTriggerTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*           InAnimSequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAnimNotifyState::GetStartTriggerTime(class UAnimSequenceBase* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnimNotifyState", "GetStartTriggerTime");

	Params::UCGAnimNotifyState_GetStartTriggerTime_Params Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGAnimNotifyState.GetEndTriggerTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*           InAnimSequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGAnimNotifyState::GetEndTriggerTime(class UAnimSequenceBase* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGAnimNotifyState", "GetEndTriggerTime");

	Params::UCGAnimNotifyState_GetEndTriggerTime_Params Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGAttemptMeleeDamage
// (None)

class UClass* UCGAttemptMeleeDamage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAttemptMeleeDamage");

	return Clss;
}


// CGAttemptMeleeDamage ChernobylGame.Default__CGAttemptMeleeDamage
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAttemptMeleeDamage* UCGAttemptMeleeDamage::GetDefaultObj()
{
	static class UCGAttemptMeleeDamage* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAttemptMeleeDamage*>(UCGAttemptMeleeDamage::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAttemptMeleeDamageHero
// (None)

class UClass* UCGAttemptMeleeDamageHero::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAttemptMeleeDamageHero");

	return Clss;
}


// CGAttemptMeleeDamageHero ChernobylGame.Default__CGAttemptMeleeDamageHero
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAttemptMeleeDamageHero* UCGAttemptMeleeDamageHero::GetDefaultObj()
{
	static class UCGAttemptMeleeDamageHero* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAttemptMeleeDamageHero*>(UCGAttemptMeleeDamageHero::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAttentionBar
// (None)

class UClass* UCGAttentionBar::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAttentionBar");

	return Clss;
}


// CGAttentionBar ChernobylGame.Default__CGAttentionBar
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAttentionBar* UCGAttentionBar::GetDefaultObj()
{
	static class UCGAttentionBar* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAttentionBar*>(UCGAttentionBar::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGAttentionWidget
// (None)

class UClass* UCGAttentionWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGAttentionWidget");

	return Clss;
}


// CGAttentionWidget ChernobylGame.Default__CGAttentionWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGAttentionWidget* UCGAttentionWidget::GetDefaultObj()
{
	static class UCGAttentionWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGAttentionWidget*>(UCGAttentionWidget::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGBaseCharacterMovementExtended
// (Actor)

class UClass* ACGBaseCharacterMovementExtended::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGBaseCharacterMovementExtended");

	return Clss;
}


// CGBaseCharacterMovementExtended ChernobylGame.Default__CGBaseCharacterMovementExtended
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGBaseCharacterMovementExtended* ACGBaseCharacterMovementExtended::GetDefaultObj()
{
	static class ACGBaseCharacterMovementExtended* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGBaseCharacterMovementExtended*>(ACGBaseCharacterMovementExtended::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGBlueprintInputState
// (Actor)

class UClass* ACGBlueprintInputState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGBlueprintInputState");

	return Clss;
}


// CGBlueprintInputState ChernobylGame.Default__CGBlueprintInputState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGBlueprintInputState* ACGBlueprintInputState::GetDefaultObj()
{
	static class ACGBlueprintInputState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGBlueprintInputState*>(ACGBlueprintInputState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGBTTask_MoveTo
// (None)

class UClass* UCGBTTask_MoveTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGBTTask_MoveTo");

	return Clss;
}


// CGBTTask_MoveTo ChernobylGame.Default__CGBTTask_MoveTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGBTTask_MoveTo* UCGBTTask_MoveTo::GetDefaultObj()
{
	static class UCGBTTask_MoveTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGBTTask_MoveTo*>(UCGBTTask_MoveTo::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGBuildSystemState
// (Actor)

class UClass* ACGBuildSystemState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGBuildSystemState");

	return Clss;
}


// CGBuildSystemState ChernobylGame.Default__CGBuildSystemState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGBuildSystemState* ACGBuildSystemState::GetDefaultObj()
{
	static class ACGBuildSystemState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGBuildSystemState*>(ACGBuildSystemState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCharacterMovementComponent
// (None)

class UClass* UCGCharacterMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCharacterMovementComponent");

	return Clss;
}


// CGCharacterMovementComponent ChernobylGame.Default__CGCharacterMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCharacterMovementComponent* UCGCharacterMovementComponent::GetDefaultObj()
{
	static class UCGCharacterMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCharacterMovementComponent*>(UCGCharacterMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCharacterMovementComponent.UpdateMaxSpeedModifierToSlowest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGCharacterMovementComponent::UpdateMaxSpeedModifierToSlowest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementComponent", "UpdateMaxSpeedModifierToSlowest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementComponent.SetUseAccelerationForPaths
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewValue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementComponent::SetUseAccelerationForPaths(bool bInNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementComponent", "SetUseAccelerationForPaths");

	Params::UCGCharacterMovementComponent_SetUseAccelerationForPaths_Params Parms{};

	Parms.bInNewValue = bInNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementComponent.RemoveMaxSpeedSlowdownModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Update                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementComponent::RemoveMaxSpeedSlowdownModifier(const class FString& Key, bool Update)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementComponent", "RemoveMaxSpeedSlowdownModifier");

	Params::UCGCharacterMovementComponent_RemoveMaxSpeedSlowdownModifier_Params Parms{};

	Parms.Key = Key;
	Parms.Update = Update;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementComponent.GetMappedCustomMovement
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECustomMovementMode     InCustomMovementMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UCGCharacterMovementComponent::GetMappedCustomMovement(enum class ECustomMovementMode InCustomMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementComponent", "GetMappedCustomMovement");

	Params::UCGCharacterMovementComponent_GetMappedCustomMovement_Params Parms{};

	Parms.InCustomMovementMode = InCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementComponent.AddOrUpdateMaxSpeedSlowdownModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Update                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementComponent::AddOrUpdateMaxSpeedSlowdownModifier(const class FString& Key, float Value, bool Update)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementComponent", "AddOrUpdateMaxSpeedSlowdownModifier");

	Params::UCGCharacterMovementComponent_AddOrUpdateMaxSpeedSlowdownModifier_Params Parms{};

	Parms.Key = Key;
	Parms.Value = Value;
	Parms.Update = Update;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGCharacterMovementStateMachine
// (None)

class UClass* UCGCharacterMovementStateMachine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCharacterMovementStateMachine");

	return Clss;
}


// CGCharacterMovementStateMachine ChernobylGame.Default__CGCharacterMovementStateMachine
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCharacterMovementStateMachine* UCGCharacterMovementStateMachine::GetDefaultObj()
{
	static class UCGCharacterMovementStateMachine* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCharacterMovementStateMachine*>(UCGCharacterMovementStateMachine::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCharacterMovementStateMachine.UpdateKeyCombination
// (Final, Native, Public)
// Parameters:
// class FString                      InKeyString                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementStateMachine::UpdateKeyCombination(const class FString& InKeyString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "UpdateKeyCombination");

	Params::UCGCharacterMovementStateMachine_UpdateKeyCombination_Params Parms{};

	Parms.InKeyString = InKeyString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.SetNewMovementState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACGMovementState>InNewMovementStateClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGMovementState*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGMovementState* UCGCharacterMovementStateMachine::SetNewMovementState(TSubclassOf<class ACGMovementState> InNewMovementStateClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "SetNewMovementState");

	Params::UCGCharacterMovementStateMachine_SetNewMovementState_Params Parms{};

	Parms.InNewMovementStateClass = InNewMovementStateClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.SetMovementStateMachineEnabled
// (Final, Native, Public)
// Parameters:
// bool                               InEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementStateMachine::SetMovementStateMachineEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "SetMovementStateMachineEnabled");

	Params::UCGCharacterMovementStateMachine_SetMovementStateMachineEnabled_Params Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.SetIsInputEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementStateMachine::SetIsInputEnabled(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "SetIsInputEnabled");

	Params::UCGCharacterMovementStateMachine_SetIsInputEnabled_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.SetDebugEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementStateMachine::SetDebugEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "SetDebugEnabled");

	Params::UCGCharacterMovementStateMachine_SetDebugEnabled_Params Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.ResetKeyCombination
// (Final, Native, Public)
// Parameters:

void UCGCharacterMovementStateMachine::ResetKeyCombination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "ResetKeyCombination");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.LockStateChanging
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewLock                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCharacterMovementStateMachine::LockStateChanging(bool bInNewLock)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "LockStateChanging");

	Params::UCGCharacterMovementStateMachine_LockStateChanging_Params Parms{};

	Parms.bInNewLock = bInNewLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetMovementRightInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGCharacterMovementStateMachine::GetMovementRightInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetMovementRightInput");

	Params::UCGCharacterMovementStateMachine_GetMovementRightInput_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetMovementForwardInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGCharacterMovementStateMachine::GetMovementForwardInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetMovementForwardInput");

	Params::UCGCharacterMovementStateMachine_GetMovementForwardInput_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetLeanAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGCharacterMovementStateMachine::GetLeanAxis()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetLeanAxis");

	Params::UCGCharacterMovementStateMachine_GetLeanAxis_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetIsMovementStateMachineEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCharacterMovementStateMachine::GetIsMovementStateMachineEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetIsMovementStateMachineEnabled");

	Params::UCGCharacterMovementStateMachine_GetIsMovementStateMachineEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetEnemyChatterEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCharacterMovementStateMachine::GetEnemyChatterEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetEnemyChatterEnabled");

	Params::UCGCharacterMovementStateMachine_GetEnemyChatterEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetCurrentMovementState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACGMovementState>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACGMovementState> UCGCharacterMovementStateMachine::GetCurrentMovementState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetCurrentMovementState");

	Params::UCGCharacterMovementStateMachine_GetCurrentMovementState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetCurrentKeyCombination
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCGCharacterMovementStateMachine::GetCurrentKeyCombination()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetCurrentKeyCombination");

	Params::UCGCharacterMovementStateMachine_GetCurrentKeyCombination_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetClimbEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCharacterMovementStateMachine::GetClimbEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetClimbEnabled");

	Params::UCGCharacterMovementStateMachine_GetClimbEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCharacterMovementStateMachine.GetAdditionalInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCGMovementStateAdditionalInfoReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGMovementStateAdditionalInfo UCGCharacterMovementStateMachine::GetAdditionalInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCharacterMovementStateMachine", "GetAdditionalInfo");

	Params::UCGCharacterMovementStateMachine_GetAdditionalInfo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGCheatManager
// (None)

class UClass* UCGCheatManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCheatManager");

	return Clss;
}


// CGCheatManager ChernobylGame.Default__CGCheatManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCheatManager* UCGCheatManager::GetDefaultObj()
{
	static class UCGCheatManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCheatManager*>(UCGCheatManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCheatManager.ModMorale
// (Final, Exec, Native, Private)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCheatManager::ModMorale(class FName CompanionName, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "ModMorale");

	Params::UCGCheatManager_ModMorale_Params Parms{};

	Parms.CompanionName = CompanionName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.ModLevelTime
// (Final, Exec, Native, Private)
// Parameters:
// int32                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCheatManager::ModLevelTime(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "ModLevelTime");

	Params::UCGCheatManager_ModLevelTime_Params Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.ModHP
// (Final, Exec, Native, Private)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCheatManager::ModHP(class FName CompanionName, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "ModHP");

	Params::UCGCheatManager_ModHP_Params Parms{};

	Parms.CompanionName = CompanionName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.ModCheck_Internal
// (Final, Native, Private)
// Parameters:

void UCGCheatManager::ModCheck_Internal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "ModCheck_Internal");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.ModCheck
// (Final, Exec, Native, Private)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCheatManager::ModCheck(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "ModCheck");

	Params::UCGCheatManager_ModCheck_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.CheatSpawnShadow
// (Final, Exec, Native, Private)
// Parameters:

void UCGCheatManager::CheatSpawnShadow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "CheatSpawnShadow");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.CheatSpawnGuard
// (Final, Exec, Native, Private)
// Parameters:

void UCGCheatManager::CheatSpawnGuard()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "CheatSpawnGuard");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.CheatGodMode
// (Final, Exec, Native, Private)
// Parameters:

void UCGCheatManager::CheatGodMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "CheatGodMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.CheatFlushInventory
// (Final, Exec, Native, Private)
// Parameters:

void UCGCheatManager::CheatFlushInventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "CheatFlushInventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCheatManager.CheatCrash
// (Final, Exec, Native, Private)
// Parameters:

void UCGCheatManager::CheatCrash()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCheatManager", "CheatCrash");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGChernohost
// (Actor, Pawn)

class UClass* ACGChernohost::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGChernohost");

	return Clss;
}


// CGChernohost ChernobylGame.Default__CGChernohost
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGChernohost* ACGChernohost::GetDefaultObj()
{
	static class ACGChernohost* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGChernohost*>(ACGChernohost::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGChernohost.SetAssociatedTeleportChain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportBase*       InNewTeleportBase                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGChernohost::SetAssociatedTeleportChain(class ACGShadowTeleportBase* InNewTeleportBase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "SetAssociatedTeleportChain");

	Params::ACGChernohost_SetAssociatedTeleportChain_Params Parms{};

	Parms.InNewTeleportBase = InNewTeleportBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGChernohost.ScheduleAggroReset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInReset                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGChernohost::ScheduleAggroReset(bool bInReset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "ScheduleAggroReset");

	Params::ACGChernohost_ScheduleAggroReset_Params Parms{};

	Parms.bInReset = bInReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGChernohost.GetClosestTeleport
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGShadowTeleportBase*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportBase* ACGChernohost::GetClosestTeleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "GetClosestTeleport");

	Params::ACGChernohost_GetClosestTeleport_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGChernohost.GetAssociatedTeleportChain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGShadowTeleportBase*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportBase* ACGChernohost::GetAssociatedTeleportChain()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "GetAssociatedTeleportChain");

	Params::ACGChernohost_GetAssociatedTeleportChain_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGChernohost.GetAggroResetScheduled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGChernohost::GetAggroResetScheduled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "GetAggroResetScheduled");

	Params::ACGChernohost_GetAggroResetScheduled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGChernohost.DisableTeleportCutting
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGChernohost::DisableTeleportCutting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGChernohost", "DisableTeleportCutting");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.CGMonsterAggroComponent
// (None)

class UClass* UCGMonsterAggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMonsterAggroComponent");

	return Clss;
}


// CGMonsterAggroComponent ChernobylGame.Default__CGMonsterAggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGMonsterAggroComponent* UCGMonsterAggroComponent::GetDefaultObj()
{
	static class UCGMonsterAggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGMonsterAggroComponent*>(UCGMonsterAggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGChernohostAggroComponent
// (None)

class UClass* UCGChernohostAggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGChernohostAggroComponent");

	return Clss;
}


// CGChernohostAggroComponent ChernobylGame.Default__CGChernohostAggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGChernohostAggroComponent* UCGChernohostAggroComponent::GetDefaultObj()
{
	static class UCGChernohostAggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGChernohostAggroComponent*>(UCGChernohostAggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCollectableNoteInputState
// (Actor)

class UClass* ACGCollectableNoteInputState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCollectableNoteInputState");

	return Clss;
}


// CGCollectableNoteInputState ChernobylGame.Default__CGCollectableNoteInputState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCollectableNoteInputState* ACGCollectableNoteInputState::GetDefaultObj()
{
	static class ACGCollectableNoteInputState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCollectableNoteInputState*>(ACGCollectableNoteInputState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCollisionCheckers
// (SceneComponent, PrimitiveComponent)

class UClass* UCGCollisionCheckers::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCollisionCheckers");

	return Clss;
}


// CGCollisionCheckers ChernobylGame.Default__CGCollisionCheckers
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCollisionCheckers* UCGCollisionCheckers::GetDefaultObj()
{
	static class UCGCollisionCheckers* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCollisionCheckers*>(UCGCollisionCheckers::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCollisionCheckers.SetDebugEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InNewDebug                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCollisionCheckers::SetDebugEnabled(bool InNewDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCollisionCheckers", "SetDebugEnabled");

	Params::UCGCollisionCheckers_SetDebugEnabled_Params Parms{};

	Parms.InNewDebug = InNewDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCollisionCheckers.QueryStealthKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FStealthKillQueryResult     ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStealthKillQueryResult UCGCollisionCheckers::QueryStealthKill()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCollisionCheckers", "QueryStealthKill");

	Params::UCGCollisionCheckers_QueryStealthKill_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGCollisionLimbComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UCGCollisionLimbComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCollisionLimbComponent");

	return Clss;
}


// CGCollisionLimbComponent ChernobylGame.Default__CGCollisionLimbComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCollisionLimbComponent* UCGCollisionLimbComponent::GetDefaultObj()
{
	static class UCGCollisionLimbComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCollisionLimbComponent*>(UCGCollisionLimbComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCompanionStatusPayloadWidget
// (None)

class UClass* UCGCompanionStatusPayloadWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCompanionStatusPayloadWidget");

	return Clss;
}


// CGCompanionStatusPayloadWidget ChernobylGame.Default__CGCompanionStatusPayloadWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCompanionStatusPayloadWidget* UCGCompanionStatusPayloadWidget::GetDefaultObj()
{
	static class UCGCompanionStatusPayloadWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCompanionStatusPayloadWidget*>(UCGCompanionStatusPayloadWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCompanionStatusPayloadWidget.Update
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGCompanionStatusPayloadWidget::Update()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompanionStatusPayloadWidget", "Update");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGCompanionStatusPayloadWidget.Show
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGCompanionStatusPayloadWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompanionStatusPayloadWidget", "Show");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGCompanionStatusPayloadWidget.RequestDestruct
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGCompanionStatusPayloadWidget::RequestDestruct()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompanionStatusPayloadWidget", "RequestDestruct");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGCompanionStatusPayloadWidget.InitPayload
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompanionStatusPayloadWidget::InitPayload(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompanionStatusPayloadWidget", "InitPayload");

	Params::UCGCompanionStatusPayloadWidget_InitPayload_Params Parms{};

	Parms.CompanionName = CompanionName;

	UObject::ProcessEvent(Func, &Parms);

}


// Class ChernobylGame.CGCompassBaseWidget
// (None)

class UClass* UCGCompassBaseWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCompassBaseWidget");

	return Clss;
}


// CGCompassBaseWidget ChernobylGame.Default__CGCompassBaseWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCompassBaseWidget* UCGCompassBaseWidget::GetDefaultObj()
{
	static class UCGCompassBaseWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCompassBaseWidget*>(UCGCompassBaseWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCompassBaseWidget.UpdateArrowsCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGCompassBaseWidget::UpdateArrowsCPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "UpdateArrowsCPP");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassBaseWidget.SetupWidgetReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCanvasPanel*                TagContainer                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassBaseWidget::SetupWidgetReferences(class UCanvasPanel* TagContainer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "SetupWidgetReferences");

	Params::UCGCompassBaseWidget_SetupWidgetReferences_Params Parms{};

	Parms.TagContainer = TagContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassBaseWidget.RemoveTagCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassBaseWidget::RemoveTagCPP(class UObject* Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "RemoveTagCPP");

	Params::UCGCompassBaseWidget_RemoveTagCPP_Params Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassBaseWidget.RemoveNullTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGCompassBaseWidget::RemoveNullTags()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "RemoveNullTags");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassBaseWidget.ProjectOnNearPlaneCPP
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsCustomMarker                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutNormalizedPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutDistanceZ                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassBaseWidget::ProjectOnNearPlaneCPP(const struct FVector& Location, bool bIsCustomMarker, float* OutNormalizedPosition, float* OutDistanceZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "ProjectOnNearPlaneCPP");

	Params::UCGCompassBaseWidget_ProjectOnNearPlaneCPP_Params Parms{};

	Parms.Location = Location;
	Parms.bIsCustomMarker = bIsCustomMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNormalizedPosition != nullptr)
		*OutNormalizedPosition = Parms.OutNormalizedPosition;

	if (OutDistanceZ != nullptr)
		*OutDistanceZ = Parms.OutDistanceZ;

}


// Function ChernobylGame.CGCompassBaseWidget.IsTagAQuest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bIsQuest                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCompassBaseWidget::IsTagAQuest(bool bIsQuest, class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "IsTagAQuest");

	Params::UCGCompassBaseWidget_IsTagAQuest_Params Parms{};

	Parms.bIsQuest = bIsQuest;
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.IsQuestWithNameActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCompassBaseWidget::IsQuestWithNameActive(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "IsQuestWithNameActive");

	Params::UCGCompassBaseWidget_IsQuestWithNameActive_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.HideShowTagCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESlateVisibility        NewVisibility                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassBaseWidget::HideShowTagCPP(class UObject* Tag, enum class ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "HideShowTagCPP");

	Params::UCGCompassBaseWidget_HideShowTagCPP_Params Parms{};

	Parms.Tag = Tag;
	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassBaseWidget.GetShowArrowCPP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bIsLeft                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DistanceZ                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCompassBaseWidget::GetShowArrowCPP(bool bIsLeft, float Position, float DistanceZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "GetShowArrowCPP");

	Params::UCGCompassBaseWidget_GetShowArrowCPP_Params Parms{};

	Parms.bIsLeft = bIsLeft;
	Parms.Position = Position;
	Parms.DistanceZ = DistanceZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.GetDiffForVisiblityCheckCPP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ZAxisCheckBelow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsCustomMarker                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCGCompassBaseWidget::GetDiffForVisiblityCheckCPP(class AActor* Tag, float ZAxisCheckBelow, bool bIsCustomMarker)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "GetDiffForVisiblityCheckCPP");

	Params::UCGCompassBaseWidget_GetDiffForVisiblityCheckCPP_Params Parms{};

	Parms.Tag = Tag;
	Parms.ZAxisCheckBelow = ZAxisCheckBelow;
	Parms.bIsCustomMarker = bIsCustomMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.FindTagWidgetCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCGCompassTagBaseWidget*     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCGCompassTagBaseWidget* UCGCompassBaseWidget::FindTagWidgetCPP(class UObject* Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "FindTagWidgetCPP");

	Params::UCGCompassBaseWidget_FindTagWidgetCPP_Params Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.CheckIfPlayerIsInRadiusCPP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TagRadius                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCompassBaseWidget::CheckIfPlayerIsInRadiusCPP(class AActor* Tag, float TagRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "CheckIfPlayerIsInRadiusCPP");

	Params::UCGCompassBaseWidget_CheckIfPlayerIsInRadiusCPP_Params Parms{};

	Parms.Tag = Tag;
	Parms.TagRadius = TagRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.CheckIfInsideViewCPP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ZAxisCheckBelow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsCustomMarker                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VisiblityAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGCompassBaseWidget::CheckIfInsideViewCPP(class AActor* Tag, float ZAxisCheckBelow, bool bIsCustomMarker, float VisiblityAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "CheckIfInsideViewCPP");

	Params::UCGCompassBaseWidget_CheckIfInsideViewCPP_Params Parms{};

	Parms.Tag = Tag;
	Parms.ZAxisCheckBelow = ZAxisCheckBelow;
	Parms.bIsCustomMarker = bIsCustomMarker;
	Parms.VisiblityAngle = VisiblityAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCompassBaseWidget.CalculateTagPositionCPP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCanvasPanelSlot*            BorderSlot                                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   TagMaxSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocalPosition                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCGCompassBaseWidget::CalculateTagPositionCPP(class UCanvasPanelSlot* BorderSlot, const struct FVector2D& TagMaxSize, float LocalPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassBaseWidget", "CalculateTagPositionCPP");

	Params::UCGCompassBaseWidget_CalculateTagPositionCPP_Params Parms{};

	Parms.BorderSlot = BorderSlot;
	Parms.TagMaxSize = TagMaxSize;
	Parms.LocalPosition = LocalPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGCompassTagBaseWidget
// (None)

class UClass* UCGCompassTagBaseWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCompassTagBaseWidget");

	return Clss;
}


// CGCompassTagBaseWidget ChernobylGame.Default__CGCompassTagBaseWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGCompassTagBaseWidget* UCGCompassTagBaseWidget::GetDefaultObj()
{
	static class UCGCompassTagBaseWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGCompassTagBaseWidget*>(UCGCompassTagBaseWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCompassTagBaseWidget.UpdateMetersTextCPP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassTagBaseWidget::UpdateMetersTextCPP(float Distance, float Radius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassTagBaseWidget", "UpdateMetersTextCPP");

	Params::UCGCompassTagBaseWidget_UpdateMetersTextCPP_Params Parms{};

	Parms.Distance = Distance;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassTagBaseWidget.SetupWidgetReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextBlock*                  MetersTextBlock                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                  QuestMetersTextBlock                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Tag                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassTagBaseWidget::SetupWidgetReferences(class UTextBlock* MetersTextBlock, class UTextBlock* QuestMetersTextBlock, class AActor* Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassTagBaseWidget", "SetupWidgetReferences");

	Params::UCGCompassTagBaseWidget_SetupWidgetReferences_Params Parms{};

	Parms.MetersTextBlock = MetersTextBlock;
	Parms.QuestMetersTextBlock = QuestMetersTextBlock;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCompassTagBaseWidget.SetupUpDownArrowReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UImage*                      UpArrow                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                      UpArrowGreen                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                      DownArrow                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                      DownArrowGreen                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGCompassTagBaseWidget::SetupUpDownArrowReferences(class UImage* UpArrow, class UImage* UpArrowGreen, class UImage* DownArrow, class UImage* DownArrowGreen)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCompassTagBaseWidget", "SetupUpDownArrowReferences");

	Params::UCGCompassTagBaseWidget_SetupUpDownArrowReferences_Params Parms{};

	Parms.UpArrow = UpArrow;
	Parms.UpArrowGreen = UpArrowGreen;
	Parms.DownArrow = DownArrow;
	Parms.DownArrowGreen = DownArrowGreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGConditionalWalk
// (Actor)

class UClass* ACGConditionalWalk::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGConditionalWalk");

	return Clss;
}


// CGConditionalWalk ChernobylGame.Default__CGConditionalWalk
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGConditionalWalk* ACGConditionalWalk::GetDefaultObj()
{
	static class ACGConditionalWalk* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGConditionalWalk*>(ACGConditionalWalk::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCorsairTriggerVolume
// (Actor)

class UClass* ACGCorsairTriggerVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCorsairTriggerVolume");

	return Clss;
}


// CGCorsairTriggerVolume ChernobylGame.Default__CGCorsairTriggerVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCorsairTriggerVolume* ACGCorsairTriggerVolume::GetDefaultObj()
{
	static class ACGCorsairTriggerVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCorsairTriggerVolume*>(ACGCorsairTriggerVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCover
// (Actor)

class UClass* ACGCover::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCover");

	return Clss;
}


// CGCover ChernobylGame.Default__CGCover
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCover* ACGCover::GetDefaultObj()
{
	static class ACGCover* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCover*>(ACGCover::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGCover.ShootTraceFromCover
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FCGMultitraceResult> OutHitResults                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                     InTraceEnd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       InTraceChannel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              InActorsToIgnore                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bInTraceComplex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBillboardComponent*         InVisibilityChecker                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDebugEnabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGCover::ShootTraceFromCover(TArray<struct FCGMultitraceResult>* OutHitResults, const struct FVector& InTraceEnd, enum class ECollisionChannel InTraceChannel, const TArray<class AActor*>& InActorsToIgnore, bool bInTraceComplex, class UBillboardComponent* InVisibilityChecker, bool bDebugEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "ShootTraceFromCover");

	Params::ACGCover_ShootTraceFromCover_Params Parms{};

	Parms.InTraceEnd = InTraceEnd;
	Parms.InTraceChannel = InTraceChannel;
	Parms.InActorsToIgnore = InActorsToIgnore;
	Parms.bInTraceComplex = bInTraceComplex;
	Parms.InVisibilityChecker = InVisibilityChecker;
	Parms.bDebugEnabled = bDebugEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);

}


// Function ChernobylGame.CGCover.SetMultiThread
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               bTickAnywhere                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGCover::SetMultiThread(bool bTickAnywhere)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "SetMultiThread");

	Params::ACGCover_SetMultiThread_Params Parms{};

	Parms.bTickAnywhere = bTickAnywhere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGCover.GetRandomPossibleCoverType
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGCharacter*                InAggroTarget                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InOptionalLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGSoldier*                  InSoldierContext                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECoverType              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECoverType ACGCover::GetRandomPossibleCoverType(class ACGCharacter* InAggroTarget, const struct FVector& InOptionalLocation, class ACGSoldier* InSoldierContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "GetRandomPossibleCoverType");

	Params::ACGCover_GetRandomPossibleCoverType_Params Parms{};

	Parms.InAggroTarget = InAggroTarget;
	Parms.InOptionalLocation = InOptionalLocation;
	Parms.InSoldierContext = InSoldierContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCover.GetOccupation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGAICharacter*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGAICharacter* ACGCover::GetOccupation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "GetOccupation");

	Params::ACGCover_GetOccupation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCover.GetCoverValidity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     InLocationToCheck                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGCover::GetCoverValidity(struct FVector& InLocationToCheck)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "GetCoverValidity");

	Params::ACGCover_GetCoverValidity_Params Parms{};

	Parms.InLocationToCheck = InLocationToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCover.GetCoverTypeValidity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECoverType              InCoverType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPotentialTargetLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGCover::GetCoverTypeValidity(enum class ECoverType InCoverType, const struct FVector& InPotentialTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "GetCoverTypeValidity");

	Params::ACGCover_GetCoverTypeValidity_Params Parms{};

	Parms.InCoverType = InCoverType;
	Parms.InPotentialTargetLocation = InPotentialTargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGCover.GetCheckerByCoverType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECoverType              InCoverType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArrowComponent* ACGCover::GetCheckerByCoverType(enum class ECoverType InCoverType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGCover", "GetCheckerByCoverType");

	Params::ACGCover_GetCheckerByCoverType_Params Parms{};

	Parms.InCoverType = InCoverType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGCraftingNewState
// (Actor)

class UClass* ACGCraftingNewState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCraftingNewState");

	return Clss;
}


// CGCraftingNewState ChernobylGame.Default__CGCraftingNewState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCraftingNewState* ACGCraftingNewState::GetDefaultObj()
{
	static class ACGCraftingNewState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCraftingNewState*>(ACGCraftingNewState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCraftingState
// (Actor)

class UClass* ACGCraftingState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCraftingState");

	return Clss;
}


// CGCraftingState ChernobylGame.Default__CGCraftingState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCraftingState* ACGCraftingState::GetDefaultObj()
{
	static class ACGCraftingState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCraftingState*>(ACGCraftingState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCrouchSlowModeState
// (Actor)

class UClass* ACGCrouchSlowModeState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCrouchSlowModeState");

	return Clss;
}


// CGCrouchSlowModeState ChernobylGame.Default__CGCrouchSlowModeState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCrouchSlowModeState* ACGCrouchSlowModeState::GetDefaultObj()
{
	static class ACGCrouchSlowModeState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCrouchSlowModeState*>(ACGCrouchSlowModeState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCrouchState
// (Actor)

class UClass* ACGCrouchState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCrouchState");

	return Clss;
}


// CGCrouchState ChernobylGame.Default__CGCrouchState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCrouchState* ACGCrouchState::GetDefaultObj()
{
	static class ACGCrouchState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCrouchState*>(ACGCrouchState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNoInputGhostState
// (Actor)

class UClass* ACGNoInputGhostState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNoInputGhostState");

	return Clss;
}


// CGNoInputGhostState ChernobylGame.Default__CGNoInputGhostState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNoInputGhostState* ACGNoInputGhostState::GetDefaultObj()
{
	static class ACGNoInputGhostState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNoInputGhostState*>(ACGNoInputGhostState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCutsceneInputState
// (Actor)

class UClass* ACGCutsceneInputState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCutsceneInputState");

	return Clss;
}


// CGCutsceneInputState ChernobylGame.Default__CGCutsceneInputState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCutsceneInputState* ACGCutsceneInputState::GetDefaultObj()
{
	static class ACGCutsceneInputState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCutsceneInputState*>(ACGCutsceneInputState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGCutsceneInputStateCam
// (Actor)

class UClass* ACGCutsceneInputStateCam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGCutsceneInputStateCam");

	return Clss;
}


// CGCutsceneInputStateCam ChernobylGame.Default__CGCutsceneInputStateCam
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGCutsceneInputStateCam* ACGCutsceneInputStateCam::GetDefaultObj()
{
	static class ACGCutsceneInputStateCam* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGCutsceneInputStateCam*>(ACGCutsceneInputStateCam::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType
// (None)

class UClass* UCGDamageType::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType");

	return Clss;
}


// CGDamageType ChernobylGame.Default__CGDamageType
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType* UCGDamageType::GetDefaultObj()
{
	static class UCGDamageType* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType*>(UCGDamageType::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_AIBullet
// (None)

class UClass* UCGDamageType_AIBullet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_AIBullet");

	return Clss;
}


// CGDamageType_AIBullet ChernobylGame.Default__CGDamageType_AIBullet
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_AIBullet* UCGDamageType_AIBullet::GetDefaultObj()
{
	static class UCGDamageType_AIBullet* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_AIBullet*>(UCGDamageType_AIBullet::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_AIBulletSuper
// (None)

class UClass* UCGDamageType_AIBulletSuper::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_AIBulletSuper");

	return Clss;
}


// CGDamageType_AIBulletSuper ChernobylGame.Default__CGDamageType_AIBulletSuper
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_AIBulletSuper* UCGDamageType_AIBulletSuper::GetDefaultObj()
{
	static class UCGDamageType_AIBulletSuper* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_AIBulletSuper*>(UCGDamageType_AIBulletSuper::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Bullet
// (None)

class UClass* UCGDamageType_Bullet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Bullet");

	return Clss;
}


// CGDamageType_Bullet ChernobylGame.Default__CGDamageType_Bullet
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Bullet* UCGDamageType_Bullet::GetDefaultObj()
{
	static class UCGDamageType_Bullet* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Bullet*>(UCGDamageType_Bullet::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Environmental
// (None)

class UClass* UCGDamageType_Environmental::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Environmental");

	return Clss;
}


// CGDamageType_Environmental ChernobylGame.Default__CGDamageType_Environmental
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Environmental* UCGDamageType_Environmental::GetDefaultObj()
{
	static class UCGDamageType_Environmental* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Environmental*>(UCGDamageType_Environmental::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Fall
// (None)

class UClass* UCGDamageType_Fall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Fall");

	return Clss;
}


// CGDamageType_Fall ChernobylGame.Default__CGDamageType_Fall
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Fall* UCGDamageType_Fall::GetDefaultObj()
{
	static class UCGDamageType_Fall* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Fall*>(UCGDamageType_Fall::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Fire
// (None)

class UClass* UCGDamageType_Fire::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Fire");

	return Clss;
}


// CGDamageType_Fire ChernobylGame.Default__CGDamageType_Fire
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Fire* UCGDamageType_Fire::GetDefaultObj()
{
	static class UCGDamageType_Fire* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Fire*>(UCGDamageType_Fire::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Gas
// (None)

class UClass* UCGDamageType_Gas::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Gas");

	return Clss;
}


// CGDamageType_Gas ChernobylGame.Default__CGDamageType_Gas
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Gas* UCGDamageType_Gas::GetDefaultObj()
{
	static class UCGDamageType_Gas* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Gas*>(UCGDamageType_Gas::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_HeroMelee
// (None)

class UClass* UCGDamageType_HeroMelee::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_HeroMelee");

	return Clss;
}


// CGDamageType_HeroMelee ChernobylGame.Default__CGDamageType_HeroMelee
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_HeroMelee* UCGDamageType_HeroMelee::GetDefaultObj()
{
	static class UCGDamageType_HeroMelee* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_HeroMelee*>(UCGDamageType_HeroMelee::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Poison
// (None)

class UClass* UCGDamageType_Poison::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Poison");

	return Clss;
}


// CGDamageType_Poison ChernobylGame.Default__CGDamageType_Poison
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Poison* UCGDamageType_Poison::GetDefaultObj()
{
	static class UCGDamageType_Poison* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Poison*>(UCGDamageType_Poison::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Radiation
// (None)

class UClass* UCGDamageType_Radiation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Radiation");

	return Clss;
}


// CGDamageType_Radiation ChernobylGame.Default__CGDamageType_Radiation
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Radiation* UCGDamageType_Radiation::GetDefaultObj()
{
	static class UCGDamageType_Radiation* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Radiation*>(UCGDamageType_Radiation::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_ShadowMelee
// (None)

class UClass* UCGDamageType_ShadowMelee::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_ShadowMelee");

	return Clss;
}


// CGDamageType_ShadowMelee ChernobylGame.Default__CGDamageType_ShadowMelee
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_ShadowMelee* UCGDamageType_ShadowMelee::GetDefaultObj()
{
	static class UCGDamageType_ShadowMelee* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_ShadowMelee*>(UCGDamageType_ShadowMelee::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_StealthKill
// (None)

class UClass* UCGDamageType_StealthKill::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_StealthKill");

	return Clss;
}


// CGDamageType_StealthKill ChernobylGame.Default__CGDamageType_StealthKill
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_StealthKill* UCGDamageType_StealthKill::GetDefaultObj()
{
	static class UCGDamageType_StealthKill* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_StealthKill*>(UCGDamageType_StealthKill::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDamageType_Trap
// (None)

class UClass* UCGDamageType_Trap::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDamageType_Trap");

	return Clss;
}


// CGDamageType_Trap ChernobylGame.Default__CGDamageType_Trap
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDamageType_Trap* UCGDamageType_Trap::GetDefaultObj()
{
	static class UCGDamageType_Trap* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDamageType_Trap*>(UCGDamageType_Trap::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGVirtuaShooter
// (Actor, Pawn)

class UClass* ACGVirtuaShooter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVirtuaShooter");

	return Clss;
}


// CGVirtuaShooter ChernobylGame.Default__CGVirtuaShooter
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGVirtuaShooter* ACGVirtuaShooter::GetDefaultObj()
{
	static class ACGVirtuaShooter* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGVirtuaShooter*>(ACGVirtuaShooter::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGVirtuaShooter.VirtuaTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InDeltaTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGVirtuaShooter::VirtuaTick(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "VirtuaTick");

	Params::ACGVirtuaShooter_VirtuaTick_Params Parms{};

	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.VirtuaStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGVirtuaShooter::VirtuaStop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "VirtuaStop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.VirtuaReset
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGVirtuaShooter::VirtuaReset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "VirtuaReset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.VirtuaBeginDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InDelay                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EVirtuaShotType         InShotType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGVirtuaShooter::VirtuaBeginDelayed(float InDelay, enum class EVirtuaShotType InShotType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "VirtuaBeginDelayed");

	Params::ACGVirtuaShooter_VirtuaBeginDelayed_Params Parms{};

	Parms.InDelay = InDelay;
	Parms.InShotType = InShotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.VirtuaBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EVirtuaShotType         InShotType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGVirtuaShooter::VirtuaBegin(enum class EVirtuaShotType InShotType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "VirtuaBegin");

	Params::ACGVirtuaShooter_VirtuaBegin_Params Parms{};

	Parms.InShotType = InShotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.PushVirtuaOffsight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bPush                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGVirtuaShooter::PushVirtuaOffsight(bool bPush)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "PushVirtuaOffsight");

	Params::ACGVirtuaShooter_PushVirtuaOffsight_Params Parms{};

	Parms.bPush = bPush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.OnSoliderAimIndicatorSettingsChanged
// (Final, Native, Protected)
// Parameters:

void ACGVirtuaShooter::OnSoliderAimIndicatorSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "OnSoliderAimIndicatorSettingsChanged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.OnCombatDifficultyChanged
// (Native, Protected)
// Parameters:

void ACGVirtuaShooter::OnCombatDifficultyChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "OnCombatDifficultyChanged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaShooter.GetVirtuaElapsedNormalised
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGVirtuaShooter::GetVirtuaElapsedNormalised()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "GetVirtuaElapsedNormalised");

	Params::ACGVirtuaShooter_GetVirtuaElapsedNormalised_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGVirtuaShooter.GetShotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EVirtuaShotType         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EVirtuaShotType ACGVirtuaShooter::GetShotType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "GetShotType");

	Params::ACGVirtuaShooter_GetShotType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGVirtuaShooter.GetLaserInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bGetLast                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGVirtuaLaserInfo          ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCGVirtuaLaserInfo ACGVirtuaShooter::GetLaserInfo(bool bGetLast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "GetLaserInfo");

	Params::ACGVirtuaShooter_GetLaserInfo_Params Parms{};

	Parms.bGetLast = bGetLast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGVirtuaShooter.GetIsVirtuaRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGVirtuaShooter::GetIsVirtuaRunning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "GetIsVirtuaRunning");

	Params::ACGVirtuaShooter_GetIsVirtuaRunning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGVirtuaShooter.AddToVirtuaElapsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InValueToAdd                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGVirtuaShooter::AddToVirtuaElapsed(float InValueToAdd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaShooter", "AddToVirtuaElapsed");

	Params::ACGVirtuaShooter_AddToVirtuaElapsed_Params Parms{};

	Parms.InValueToAdd = InValueToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGDarkStalker
// (Actor, Pawn)

class UClass* ACGDarkStalker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDarkStalker");

	return Clss;
}


// CGDarkStalker ChernobylGame.Default__CGDarkStalker
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDarkStalker* ACGDarkStalker::GetDefaultObj()
{
	static class ACGDarkStalker* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDarkStalker*>(ACGDarkStalker::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGDarkStalker.Shoot
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGDarkStalker::Shoot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDarkStalker", "Shoot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGDarkStalker.OnZeroHealth
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGDarkStalker::OnZeroHealth()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDarkStalker", "OnZeroHealth");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.CGDeadState
// (Actor)

class UClass* ACGDeadState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDeadState");

	return Clss;
}


// CGDeadState ChernobylGame.Default__CGDeadState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDeadState* ACGDeadState::GetDefaultObj()
{
	static class ACGDeadState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDeadState*>(ACGDeadState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDialogFocusActor
// (Actor)

class UClass* ACGDialogFocusActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDialogFocusActor");

	return Clss;
}


// CGDialogFocusActor ChernobylGame.Default__CGDialogFocusActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDialogFocusActor* ACGDialogFocusActor::GetDefaultObj()
{
	static class ACGDialogFocusActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDialogFocusActor*>(ACGDialogFocusActor::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDialogueActor
// (Actor)

class UClass* ACGDialogueActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDialogueActor");

	return Clss;
}


// CGDialogueActor ChernobylGame.Default__CGDialogueActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDialogueActor* ACGDialogueActor::GetDefaultObj()
{
	static class ACGDialogueActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDialogueActor*>(ACGDialogueActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGDialogueActor.StartDialogue_FireAndKill
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                        InStartingRow                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGDialogueActor::StartDialogue_FireAndKill(class FName InStartingRow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDialogueActor", "StartDialogue_FireAndKill");

	Params::ACGDialogueActor_StartDialogue_FireAndKill_Params Parms{};

	Parms.InStartingRow = InStartingRow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGDialogueActor.OnSkipDialogueLine_ButtonPressed
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              InAxisValue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGDialogueActor::OnSkipDialogueLine_ButtonPressed(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDialogueActor", "OnSkipDialogueLine_ButtonPressed");

	Params::ACGDialogueActor_OnSkipDialogueLine_ButtonPressed_Params Parms{};

	Parms.InAxisValue = InAxisValue;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGDialogueActor.OnDialogueEnded_FireAndKill
// (Final, Native, Protected)
// Parameters:

void ACGDialogueActor::OnDialogueEnded_FireAndKill()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDialogueActor", "OnDialogueEnded_FireAndKill");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGDialogueState
// (Actor)

class UClass* ACGDialogueState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDialogueState");

	return Clss;
}


// CGDialogueState ChernobylGame.Default__CGDialogueState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDialogueState* ACGDialogueState::GetDefaultObj()
{
	static class ACGDialogueState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDialogueState*>(ACGDialogueState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDLCRegistry
// (None)

class UClass* UCGDLCRegistry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDLCRegistry");

	return Clss;
}


// CGDLCRegistry ChernobylGame.Default__CGDLCRegistry
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDLCRegistry* UCGDLCRegistry::GetDefaultObj()
{
	static class UCGDLCRegistry* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDLCRegistry*>(UCGDLCRegistry::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDronePerception
// (None)

class UClass* UCGDronePerception::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDronePerception");

	return Clss;
}


// CGDronePerception ChernobylGame.Default__CGDronePerception
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDronePerception* UCGDronePerception::GetDefaultObj()
{
	static class UCGDronePerception* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDronePerception*>(UCGDronePerception::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGDronePerception.ForcePerceptionUpdate
// (Native, Public, BlueprintCallable)
// Parameters:

void UCGDronePerception::ForcePerceptionUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDronePerception", "ForcePerceptionUpdate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGDuster
// (Actor, Pawn)

class UClass* ACGDuster::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDuster");

	return Clss;
}


// CGDuster ChernobylGame.Default__CGDuster
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDuster* ACGDuster::GetDefaultObj()
{
	static class ACGDuster* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDuster*>(ACGDuster::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGDuster.SpawnDusterProjectile
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACGCharacter*                InTarget                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGDusterProjectile>InProjectileClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGDusterProjectile*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGDusterProjectile* ACGDuster::SpawnDusterProjectile(class ACGCharacter* InTarget, TSubclassOf<class ACGDusterProjectile> InProjectileClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDuster", "SpawnDusterProjectile");

	Params::ACGDuster_SpawnDusterProjectile_Params Parms{};

	Parms.InTarget = InTarget;
	Parms.InProjectileClass = InProjectileClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGDuster.SpawnDusterGhost
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACGDusterGhost*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGDusterGhost* ACGDuster::SpawnDusterGhost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDuster", "SpawnDusterGhost");

	Params::ACGDuster_SpawnDusterGhost_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGDuster.SetCurrentNode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGDusterNode*               InNewNode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGDuster::SetCurrentNode(class ACGDusterNode* InNewNode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDuster", "SetCurrentNode");

	Params::ACGDuster_SetCurrentNode_Params Parms{};

	Parms.InNewNode = InNewNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGDuster.RequestIdle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGDuster::RequestIdle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDuster", "RequestIdle");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGDuster.GetCurrentNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGDusterNode*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGDusterNode* ACGDuster::GetCurrentNode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDuster", "GetCurrentNode");

	Params::ACGDuster_GetCurrentNode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGDusterAggroComponent
// (None)

class UClass* UCGDusterAggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDusterAggroComponent");

	return Clss;
}


// CGDusterAggroComponent ChernobylGame.Default__CGDusterAggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGDusterAggroComponent* UCGDusterAggroComponent::GetDefaultObj()
{
	static class UCGDusterAggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGDusterAggroComponent*>(UCGDusterAggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDusterGhost
// (Actor)

class UClass* ACGDusterGhost::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDusterGhost");

	return Clss;
}


// CGDusterGhost ChernobylGame.Default__CGDusterGhost
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDusterGhost* ACGDusterGhost::GetDefaultObj()
{
	static class ACGDusterGhost* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDusterGhost*>(ACGDusterGhost::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGDusterNode
// (Actor)

class UClass* ACGDusterNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDusterNode");

	return Clss;
}


// CGDusterNode ChernobylGame.Default__CGDusterNode
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDusterNode* ACGDusterNode::GetDefaultObj()
{
	static class ACGDusterNode* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDusterNode*>(ACGDusterNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGDusterNode.RegenerateImpl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPaperSpriteComponent*       ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSpriteComponent* ACGDusterNode::RegenerateImpl()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDusterNode", "RegenerateImpl");

	Params::ACGDusterNode_RegenerateImpl_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGDusterNode.GetNodeOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGDuster*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGDuster* ACGDusterNode::GetNodeOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGDusterNode", "GetNodeOwner");

	Params::ACGDusterNode_GetNodeOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGDusterProjectile
// (Actor)

class UClass* ACGDusterProjectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGDusterProjectile");

	return Clss;
}


// CGDusterProjectile ChernobylGame.Default__CGDusterProjectile
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGDusterProjectile* ACGDusterProjectile::GetDefaultObj()
{
	static class ACGDusterProjectile* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGDusterProjectile*>(ACGDusterProjectile::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGEditor
// (None)

class UClass* UCGEditor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGEditor");

	return Clss;
}


// CGEditor ChernobylGame.Default__CGEditor
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGEditor* UCGEditor::GetDefaultObj()
{
	static class UCGEditor* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGEditor*>(UCGEditor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGEditor.SetIsEditorOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             InActorComponent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InIsEditorOnly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGEditor::SetIsEditorOnly(class UActorComponent* InActorComponent, bool InIsEditorOnly)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGEditor", "SetIsEditorOnly");

	Params::UCGEditor_SetIsEditorOnly_Params Parms{};

	Parms.InActorComponent = InActorComponent;
	Parms.InIsEditorOnly = InIsEditorOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGEditor.GetDifferentObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     InObject                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>             InArray                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                     OutObject                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InMaxIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGEditor::GetDifferentObject(class UObject* InObject, TArray<class UObject*>& InArray, class UObject** OutObject, int32 InMaxIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGEditor", "GetDifferentObject");

	Params::UCGEditor_GetDifferentObject_Params Parms{};

	Parms.InObject = InObject;
	Parms.InArray = InArray;
	Parms.InMaxIndex = InMaxIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutObject != nullptr)
		*OutObject = Parms.OutObject;

}


// Class ChernobylGame.CGEndGameCreditsSceneState
// (Actor)

class UClass* ACGEndGameCreditsSceneState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGEndGameCreditsSceneState");

	return Clss;
}


// CGEndGameCreditsSceneState ChernobylGame.Default__CGEndGameCreditsSceneState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGEndGameCreditsSceneState* ACGEndGameCreditsSceneState::GetDefaultObj()
{
	static class ACGEndGameCreditsSceneState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGEndGameCreditsSceneState*>(ACGEndGameCreditsSceneState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGEventSystem
// (None)

class UClass* UCGEventSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGEventSystem");

	return Clss;
}


// CGEventSystem ChernobylGame.Default__CGEventSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGEventSystem* UCGEventSystem::GetDefaultObj()
{
	static class UCGEventSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGEventSystem*>(UCGEventSystem::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGEventSystem.EventSystemSetValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ID                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGEventSystem::EventSystemSetValue(class UObject* WorldContextObject, class FName ID, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGEventSystem", "EventSystemSetValue");

	Params::UCGEventSystem_EventSystemSetValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ID = ID;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGEventSystem.EventSystemGetValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ID                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGEventSystem::EventSystemGetValue(class UObject* WorldContextObject, class FName ID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGEventSystem", "EventSystemGetValue");

	Params::UCGEventSystem_EventSystemGetValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGFadeNotifyState
// (None)

class UClass* UCGFadeNotifyState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFadeNotifyState");

	return Clss;
}


// CGFadeNotifyState ChernobylGame.Default__CGFadeNotifyState
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGFadeNotifyState* UCGFadeNotifyState::GetDefaultObj()
{
	static class UCGFadeNotifyState* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGFadeNotifyState*>(UCGFadeNotifyState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGFakeHero
// (Actor)

class UClass* ACGFakeHero::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFakeHero");

	return Clss;
}


// CGFakeHero ChernobylGame.Default__CGFakeHero
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGFakeHero* ACGFakeHero::GetDefaultObj()
{
	static class ACGFakeHero* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGFakeHero*>(ACGFakeHero::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGFakeHero.StartCustomAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPlayCustomAnimProperties   InProperties                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           InAnimSequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGFakeHero::StartCustomAnim(const struct FPlayCustomAnimProperties& InProperties, class UAnimSequenceBase* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "StartCustomAnim");

	Params::ACGFakeHero_StartCustomAnim_Params Parms{};

	Parms.InProperties = InProperties;
	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFakeHero.OnTemporaryLifetimeOver
// (Final, Native, Private)
// Parameters:

void ACGFakeHero::OnTemporaryLifetimeOver()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnTemporaryLifetimeOver");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFakeHero.OnInitialHideFinished
// (Final, Native, Private)
// Parameters:
// enum class EState                  InQueryInitialItemState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGActiveItem>   InQueryInitialItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGFakeHero::OnInitialHideFinished(enum class EState InQueryInitialItemState, TSubclassOf<class ACGActiveItem> InQueryInitialItemClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnInitialHideFinished");

	Params::ACGFakeHero_OnInitialHideFinished_Params Parms{};

	Parms.InQueryInitialItemState = InQueryInitialItemState;
	Parms.InQueryInitialItemClass = InQueryInitialItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFakeHero.OnEquip
// (Final, Native, Private)
// Parameters:

void ACGFakeHero::OnEquip()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnEquip");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFakeHero.OnCameraBlendOutStarted
// (Final, Native, Private)
// Parameters:

void ACGFakeHero::OnCameraBlendOutStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnCameraBlendOutStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFakeHero.OnCameraBlendInFinished
// (Final, Native, Private)
// Parameters:

void ACGFakeHero::OnCameraBlendInFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnCameraBlendInFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFakeHero.OnAnimStarted
// (Event, Protected, BlueprintEvent)
// Parameters:

void ACGFakeHero::OnAnimStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "OnAnimStarted");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGFakeHero.FindMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACGFakeHero::FindMesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFakeHero", "FindMesh");

	Params::ACGFakeHero_FindMesh_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGFallingCrouchedState
// (Actor)

class UClass* ACGFallingCrouchedState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFallingCrouchedState");

	return Clss;
}


// CGFallingCrouchedState ChernobylGame.Default__CGFallingCrouchedState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGFallingCrouchedState* ACGFallingCrouchedState::GetDefaultObj()
{
	static class ACGFallingCrouchedState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGFallingCrouchedState*>(ACGFallingCrouchedState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGFallingState
// (Actor)

class UClass* ACGFallingState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFallingState");

	return Clss;
}


// CGFallingState ChernobylGame.Default__CGFallingState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGFallingState* ACGFallingState::GetDefaultObj()
{
	static class ACGFallingState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGFallingState*>(ACGFallingState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGFlyingState
// (Actor)

class UClass* ACGFlyingState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFlyingState");

	return Clss;
}


// CGFlyingState ChernobylGame.Default__CGFlyingState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGFlyingState* ACGFlyingState::GetDefaultObj()
{
	static class ACGFlyingState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGFlyingState*>(ACGFlyingState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGFunctionLibrary
// (None)

class UClass* UCGFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGFunctionLibrary");

	return Clss;
}


// CGFunctionLibrary ChernobylGame.Default__CGFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGFunctionLibrary* UCGFunctionLibrary::GetDefaultObj()
{
	static class UCGFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGFunctionLibrary*>(UCGFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGFunctionLibrary.TryChance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InChance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::TryChance(float InChance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "TryChance");

	Params::UCGFunctionLibrary_TryChance_Params Parms{};

	Parms.InChance = InChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.StringArrayToNameArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              Array                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCGFunctionLibrary::StringArrayToNameArray(TArray<class FString>& Array)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "StringArrayToNameArray");

	Params::UCGFunctionLibrary_StringArrayToNameArray_Params Parms{};

	Parms.Array = Array;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.StopCurrentTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*               BehTree                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::StopCurrentTask(class UBehaviorTree* BehTree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "StopCurrentTask");

	Params::UCGFunctionLibrary_StopCurrentTask_Params Parms{};

	Parms.BehTree = BehTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnShadowEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class ACGShadow>     InShadowClass                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBehaviorTree>InBehaviorTree                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InShadowTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class ACGShadowTeleportingAreaBase*>InPossibleAreas                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APatrolActor*>        InPossiblePatrolNodes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class APatrolActor*                InNextPatrolNode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShadowProperties           InProperties                                                     (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
// class ACGShadow*                   OutSpawnedShadow                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGShadowTeleportBase*       InOptionalStartingTeleport                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnShadowEnemy(class UObject* WorldContextObject, TSoftClassPtr<class ACGShadow> InShadowClass, TSoftObjectPtr<class UBehaviorTree> InBehaviorTree, const struct FTransform& InShadowTransform, TArray<class ACGShadowTeleportingAreaBase*>& InPossibleAreas, TArray<class APatrolActor*>& InPossiblePatrolNodes, class APatrolActor* InNextPatrolNode, const struct FShadowProperties& InProperties, class ACGShadow** OutSpawnedShadow, bool* OutSpawnResult, class ACGShadowTeleportBase* InOptionalStartingTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnShadowEnemy");

	Params::UCGFunctionLibrary_SpawnShadowEnemy_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InShadowClass = InShadowClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InShadowTransform = InShadowTransform;
	Parms.InPossibleAreas = InPossibleAreas;
	Parms.InPossiblePatrolNodes = InPossiblePatrolNodes;
	Parms.InNextPatrolNode = InNextPatrolNode;
	Parms.InProperties = InProperties;
	Parms.InOptionalStartingTeleport = InOptionalStartingTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedShadow != nullptr)
		*OutSpawnedShadow = Parms.OutSpawnedShadow;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnPatrollerEnemyFromSoftClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class ACGSoldier>    InPatrollerClass                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBehaviorTree>InBehaviorTree                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InPatrollerTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UCGAIState>    InInitialState                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSquadName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGSoldier*                  OutSpawnedPatroller                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInCanArrest                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnPatrollerEnemyFromSoftClass(class UObject* WorldContextObject, TSoftClassPtr<class ACGSoldier> InPatrollerClass, TSoftObjectPtr<class UBehaviorTree> InBehaviorTree, const struct FTransform& InPatrollerTransform, class APatrolActor* InNextPatrolActor, TSoftClassPtr<class UCGAIState> InInitialState, class FName InSquadName, class ACGSoldier** OutSpawnedPatroller, bool* OutSpawnResult, bool bInCanArrest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnPatrollerEnemyFromSoftClass");

	Params::UCGFunctionLibrary_SpawnPatrollerEnemyFromSoftClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPatrollerClass = InPatrollerClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InPatrollerTransform = InPatrollerTransform;
	Parms.InNextPatrolActor = InNextPatrolActor;
	Parms.InInitialState = InInitialState;
	Parms.InSquadName = InSquadName;
	Parms.bInCanArrest = bInCanArrest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedPatroller != nullptr)
		*OutSpawnedPatroller = Parms.OutSpawnedPatroller;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnPatrollerEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGSoldier>      InPatrollerClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBehaviorTree*               InBehaviorTree                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InPatrollerTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APatrolActor*                InNextPatrolActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCGAIState>      InInitialState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSquadName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGSoldier*                  OutSpawnedPatroller                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInCanArrest                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnPatrollerEnemy(class UObject* WorldContextObject, TSubclassOf<class ACGSoldier> InPatrollerClass, class UBehaviorTree* InBehaviorTree, const struct FTransform& InPatrollerTransform, class APatrolActor* InNextPatrolActor, TSubclassOf<class UCGAIState> InInitialState, class FName InSquadName, class ACGSoldier** OutSpawnedPatroller, bool* OutSpawnResult, bool bInCanArrest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnPatrollerEnemy");

	Params::UCGFunctionLibrary_SpawnPatrollerEnemy_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPatrollerClass = InPatrollerClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InPatrollerTransform = InPatrollerTransform;
	Parms.InNextPatrolActor = InNextPatrolActor;
	Parms.InInitialState = InInitialState;
	Parms.InSquadName = InSquadName;
	Parms.bInCanArrest = bInCanArrest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedPatroller != nullptr)
		*OutSpawnedPatroller = Parms.OutSpawnedPatroller;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnOutdoorShadowEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGShadow>       InShadowClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBehaviorTree*               InBehaviorTree                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InShadowTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class ACGShadowTeleportBase*>InInitialOutdoorTeleports                                        (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FOutdoorShadowProperties    InProperties                                                     (Parm, NativeAccessSpecifierPublic)
// class ACGShadow*                   OutSpawnedShadow                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnOutdoorShadowEnemy(class UObject* WorldContextObject, TSubclassOf<class ACGShadow> InShadowClass, class UBehaviorTree* InBehaviorTree, const struct FTransform& InShadowTransform, const TArray<class ACGShadowTeleportBase*>& InInitialOutdoorTeleports, const struct FOutdoorShadowProperties& InProperties, class ACGShadow** OutSpawnedShadow, bool* OutSpawnResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnOutdoorShadowEnemy");

	Params::UCGFunctionLibrary_SpawnOutdoorShadowEnemy_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InShadowClass = InShadowClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InShadowTransform = InShadowTransform;
	Parms.InInitialOutdoorTeleports = InInitialOutdoorTeleports;
	Parms.InProperties = InProperties;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedShadow != nullptr)
		*OutSpawnedShadow = Parms.OutSpawnedShadow;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnHighlightOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               FollowTarget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnHighlightOnActor(class AActor* Actor, class UMaterialInterface* Material, bool FollowTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnHighlightOnActor");

	Params::UCGFunctionLibrary_SpawnHighlightOnActor_Params Parms{};

	Parms.Actor = Actor;
	Parms.Material = Material;
	Parms.FollowTarget = FollowTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnDarkStalkerEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class ACGDarkStalker>InDarkStalkerClass                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBehaviorTree>InBehaviorTree                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InDarkStalkerTransform                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ACGDarkStalker*              OutSpawnedDarkStalker                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnDarkStalkerEnemy(class UObject* WorldContextObject, TSoftClassPtr<class ACGDarkStalker> InDarkStalkerClass, TSoftObjectPtr<class UBehaviorTree> InBehaviorTree, const struct FTransform& InDarkStalkerTransform, class ACGDarkStalker** OutSpawnedDarkStalker, bool* OutSpawnResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnDarkStalkerEnemy");

	Params::UCGFunctionLibrary_SpawnDarkStalkerEnemy_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InDarkStalkerClass = InDarkStalkerClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InDarkStalkerTransform = InDarkStalkerTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedDarkStalker != nullptr)
		*OutSpawnedDarkStalker = Parms.OutSpawnedDarkStalker;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SpawnChernohostEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGChernohost>   InChernohostClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBehaviorTree*               InBehaviorTree                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCGAIState_Chernohost>InStartingState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InChernohostTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ACGShadowTeleportBase*       InOptionalStartingTeleport                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AShadowPatrolActor*          InOptionalStartingPatrolNode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGChernohost*               OutSpawnedchernohost                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSpawnResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SpawnChernohostEnemy(class UObject* WorldContextObject, TSubclassOf<class ACGChernohost> InChernohostClass, class UBehaviorTree* InBehaviorTree, TSubclassOf<class UCGAIState_Chernohost> InStartingState, const struct FTransform& InChernohostTransform, class ACGShadowTeleportBase* InOptionalStartingTeleport, class AShadowPatrolActor* InOptionalStartingPatrolNode, class ACGChernohost** OutSpawnedchernohost, bool* OutSpawnResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SpawnChernohostEnemy");

	Params::UCGFunctionLibrary_SpawnChernohostEnemy_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InChernohostClass = InChernohostClass;
	Parms.InBehaviorTree = InBehaviorTree;
	Parms.InStartingState = InStartingState;
	Parms.InChernohostTransform = InChernohostTransform;
	Parms.InOptionalStartingTeleport = InOptionalStartingTeleport;
	Parms.InOptionalStartingPatrolNode = InOptionalStartingPatrolNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSpawnedchernohost != nullptr)
		*OutSpawnedchernohost = Parms.OutSpawnedchernohost;

	if (OutSpawnResult != nullptr)
		*OutSpawnResult = Parms.OutSpawnResult;

}


// Function ChernobylGame.CGFunctionLibrary.SortSaves
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, struct FCustomSaveGameMetadataInfo>Saves                                                            (Parm, NativeAccessSpecifierPublic)
// TMap<class FString, struct FCustomSaveGameMetadataInfo>ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, struct FCustomSaveGameMetadataInfo> UCGFunctionLibrary::SortSaves(TMap<class FString, struct FCustomSaveGameMetadataInfo> Saves)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SortSaves");

	Params::UCGFunctionLibrary_SortSaves_Params Parms{};

	Parms.Saves = Saves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.SortActorsByDistanceToPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>              InArray                                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     InPoint                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCGFunctionLibrary::SortActorsByDistanceToPoint(TArray<class AActor*>& InArray, struct FVector& InPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SortActorsByDistanceToPoint");

	Params::UCGFunctionLibrary_SortActorsByDistanceToPoint_Params Parms{};

	Parms.InArray = InArray;
	Parms.InPoint = InPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.SetRenderCustomDepthStencilBitComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bit                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SetRenderCustomDepthStencilBitComponent(class UPrimitiveComponent* Component, int32 Bit, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SetRenderCustomDepthStencilBitComponent");

	Params::UCGFunctionLibrary_SetRenderCustomDepthStencilBitComponent_Params Parms{};

	Parms.Component = Component;
	Parms.Bit = Bit;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.SetRenderCustomDepthStencilBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bit                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SetRenderCustomDepthStencilBit(class AActor* Actor, int32 Bit, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SetRenderCustomDepthStencilBit");

	Params::UCGFunctionLibrary_SetRenderCustomDepthStencilBit_Params Parms{};

	Parms.Actor = Actor;
	Parms.Bit = Bit;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.SetCustomStencilDepthOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StencilValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::SetCustomStencilDepthOnActor(class AActor* Actor, bool IsEnabled, int32 StencilValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "SetCustomStencilDepthOnActor");

	Params::UCGFunctionLibrary_SetCustomStencilDepthOnActor_Params Parms{};

	Parms.Actor = Actor;
	Parms.IsEnabled = IsEnabled;
	Parms.StencilValue = StencilValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.ScreenshotDataToTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSaveScreenshotData         ScreenshotData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCGFunctionLibrary::ScreenshotDataToTexture(struct FSaveScreenshotData& ScreenshotData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "ScreenshotDataToTexture");

	Params::UCGFunctionLibrary_ScreenshotDataToTexture_Params Parms{};

	Parms.ScreenshotData = ScreenshotData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.RemoveRadarHighlights
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::RemoveRadarHighlights(class UObject* WorldContextObject, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "RemoveRadarHighlights");

	Params::UCGFunctionLibrary_RemoveRadarHighlights_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.RemoveNewLineFromString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::RemoveNewLineFromString(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "RemoveNewLineFromString");

	Params::UCGFunctionLibrary_RemoveNewLineFromString_Params Parms{};

	Parms.String = String;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.ReadPhysicalBodyStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::ReadPhysicalBodyStatus(class USkeletalMeshComponent* InSkeletalMesh, class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "ReadPhysicalBodyStatus");

	Params::UCGFunctionLibrary_ReadPhysicalBodyStatus_Params Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.ProjectWorldToScreenBidirectional
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldPosition                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTargetBehindCamera                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPlayerViewportRelative                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::ProjectWorldToScreenBidirectional(class APlayerController* Player, struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool* bTargetBehindCamera, bool bPlayerViewportRelative)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "ProjectWorldToScreenBidirectional");

	Params::UCGFunctionLibrary_ProjectWorldToScreenBidirectional_Params Parms{};

	Parms.Player = Player;
	Parms.WorldPosition = WorldPosition;
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ScreenPosition != nullptr)
		*ScreenPosition = std::move(Parms.ScreenPosition);

	if (bTargetBehindCamera != nullptr)
		*bTargetBehindCamera = Parms.bTargetBehindCamera;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.PlayCustomSequence
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*               InHeroCustomAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InHeroTargetTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FCustomAnimQuery>    InAnimQueries                                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              InBlendToTransformLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayCustomAnimProperties   InProperties                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bOldBehavior                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::PlayCustomSequence(class UAnimSequence* InHeroCustomAnim, const struct FTransform& InHeroTargetTransform, const TArray<struct FCustomAnimQuery>& InAnimQueries, float InBlendToTransformLength, const struct FPlayCustomAnimProperties& InProperties, bool bOldBehavior)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "PlayCustomSequence");

	Params::UCGFunctionLibrary_PlayCustomSequence_Params Parms{};

	Parms.InHeroCustomAnim = InHeroCustomAnim;
	Parms.InHeroTargetTransform = InHeroTargetTransform;
	Parms.InAnimQueries = InAnimQueries;
	Parms.InBlendToTransformLength = InBlendToTransformLength;
	Parms.InProperties = InProperties;
	Parms.bOldBehavior = bOldBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.PlayAnimationAt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*             InNewAnimToPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInLooping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::PlayAnimationAt(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimationAsset* InNewAnimToPlay, float InStartTime, bool bInLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "PlayAnimationAt");

	Params::UCGFunctionLibrary_PlayAnimationAt_Params Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;
	Parms.InNewAnimToPlay = InNewAnimToPlay;
	Parms.InStartTime = InStartTime;
	Parms.bInLooping = bInLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.MakeNoise
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      InInstigator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNoiseLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseStrength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InTag                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InFalloff                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInIgnoreSenseBlock                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMaxDistanceToActivateCombat                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::MakeNoise(class AActor* InInstigator, float InNoiseRange, const struct FVector& InNoiseLocation, float InNoiseStrength, class FName InTag, float InFalloff, bool bInIgnoreSenseBlock, float InMaxDistanceToActivateCombat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "MakeNoise");

	Params::UCGFunctionLibrary_MakeNoise_Params Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InNoiseRange = InNoiseRange;
	Parms.InNoiseLocation = InNoiseLocation;
	Parms.InNoiseStrength = InNoiseStrength;
	Parms.InTag = InTag;
	Parms.InFalloff = InFalloff;
	Parms.bInIgnoreSenseBlock = bInIgnoreSenseBlock;
	Parms.InMaxDistanceToActivateCombat = InMaxDistanceToActivateCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.K2_ExtractRootMotionFromRange
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*               InSequence                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartTrackPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InEndTrackPosition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCGFunctionLibrary::K2_ExtractRootMotionFromRange(class UAnimSequence* InSequence, float InStartTrackPosition, float InEndTrackPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "K2_ExtractRootMotionFromRange");

	Params::UCGFunctionLibrary_K2_ExtractRootMotionFromRange_Params Parms{};

	Parms.InSequence = InSequence;
	Parms.InStartTrackPosition = InStartTrackPosition;
	Parms.InEndTrackPosition = InEndTrackPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.K2_CGGetVisibleHeroLimbsFromPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPoint                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDebug                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              InActorsToIgnore                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ACGAICharacter*              InOptionalSightAI                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCGCollisionLimbComponent*>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UCGCollisionLimbComponent*> UCGFunctionLibrary::K2_CGGetVisibleHeroLimbsFromPoint(class UObject* WorldContextObject, struct FVector& InPoint, bool bDebug, TArray<class AActor*>& InActorsToIgnore, class ACGAICharacter* InOptionalSightAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "K2_CGGetVisibleHeroLimbsFromPoint");

	Params::UCGFunctionLibrary_K2_CGGetVisibleHeroLimbsFromPoint_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPoint = InPoint;
	Parms.bDebug = bDebug;
	Parms.InActorsToIgnore = InActorsToIgnore;
	Parms.InOptionalSightAI = InOptionalSightAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsThereAPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACGAICharacter*              InAI                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTargetLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsThereAPath(class ACGAICharacter* InAI, struct FVector& InTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsThereAPath");

	Params::UCGFunctionLibrary_IsThereAPath_Params Parms{};

	Parms.InAI = InAI;
	Parms.InTargetLocation = InTargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsSteamSubsystemValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsSteamSubsystemValid()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsSteamSubsystemValid");

	Params::UCGFunctionLibrary_IsSteamSubsystemValid_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsSteamDemo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsSteamDemo(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsSteamDemo");

	Params::UCGFunctionLibrary_IsSteamDemo_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsShippingBuild");

	Params::UCGFunctionLibrary_IsShippingBuild_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsPS4GamepadConnected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsPS4GamepadConnected(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsPS4GamepadConnected");

	Params::UCGFunctionLibrary_IsPS4GamepadConnected_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsPointClose
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InOrigin                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPoint                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsPointClose(struct FVector& InOrigin, struct FVector& InPoint, float InRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsPointClose");

	Params::UCGFunctionLibrary_IsPointClose_Params Parms{};

	Parms.InOrigin = InOrigin;
	Parms.InPoint = InPoint;
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsInTrigger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          InTriggerClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsInTrigger(class AActor* InActor, TSubclassOf<class AActor> InTriggerClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsInTrigger");

	Params::UCGFunctionLibrary_IsInTrigger_Params Parms{};

	Parms.InActor = InActor;
	Parms.InTriggerClass = InTriggerClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.IsDemoVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::IsDemoVersion(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "IsDemoVersion");

	Params::UCGFunctionLibrary_IsDemoVersion_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.HitPhysicalMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCGPhysicalMaterial*         InPhysicalMaterial                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  InHit                                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      InInstigator                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::HitPhysicalMaterial(class UCGPhysicalMaterial* InPhysicalMaterial, struct FHitResult& InHit, class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "HitPhysicalMaterial");

	Params::UCGFunctionLibrary_HitPhysicalMaterial_Params Parms{};

	Parms.InPhysicalMaterial = InPhysicalMaterial;
	Parms.InHit = InHit;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.GroupSpreadPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InGroupMember                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InSpreadCheckRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          InGroupClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>InGroupTypeQuery                                                 (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                      InSpreadTarget                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSpreadSuccessfull                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCGFunctionLibrary::GroupSpreadPoint(class AActor* InGroupMember, float InSpreadCheckRadius, TSubclassOf<class AActor> InGroupClass, const TArray<enum class EObjectTypeQuery>& InGroupTypeQuery, class AActor* InSpreadTarget, bool* bSpreadSuccessfull)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GroupSpreadPoint");

	Params::UCGFunctionLibrary_GroupSpreadPoint_Params Parms{};

	Parms.InGroupMember = InGroupMember;
	Parms.InSpreadCheckRadius = InSpreadCheckRadius;
	Parms.InGroupClass = InGroupClass;
	Parms.InGroupTypeQuery = InGroupTypeQuery;
	Parms.InSpreadTarget = InSpreadTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bSpreadSuccessfull != nullptr)
		*bSpreadSuccessfull = Parms.bSpreadSuccessfull;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetStringFromArrayOrEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              Array                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::GetStringFromArrayOrEmpty(TArray<class FString>& Array, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetStringFromArrayOrEmpty");

	Params::UCGFunctionLibrary_GetStringFromArrayOrEmpty_Params Parms{};

	Parms.Array = Array;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetResourceByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EResourceType           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EResourceType UCGFunctionLibrary::GetResourceByName(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetResourceByName");

	Params::UCGFunctionLibrary_GetResourceByName_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetRandomIntInRangeWithExclusion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InExclusion                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InRangeMin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InRangeMax                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGFunctionLibrary::GetRandomIntInRangeWithExclusion(int32 InExclusion, int32 InRangeMin, int32 InRangeMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetRandomIntInRangeWithExclusion");

	Params::UCGFunctionLibrary_GetRandomIntInRangeWithExclusion_Params Parms{};

	Parms.InExclusion = InExclusion;
	Parms.InRangeMin = InRangeMin;
	Parms.InRangeMax = InRangeMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetNameByResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGFunctionLibrary::GetNameByResource(enum class EResourceType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetNameByResource");

	Params::UCGFunctionLibrary_GetNameByResource_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetMyBoneNameFromHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGFunctionLibrary::GetMyBoneNameFromHit(struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetMyBoneNameFromHit");

	Params::UCGFunctionLibrary_GetMyBoneNameFromHit_Params Parms{};

	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetMusicManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InLevelActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGMusicManager*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGMusicManager* UCGFunctionLibrary::GetMusicManager(class AActor* InLevelActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetMusicManager");

	Params::UCGFunctionLibrary_GetMusicManager_Params Parms{};

	Parms.InLevelActor = InLevelActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetLastInputFromGamepadCPP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetLastInputFromGamepadCPP(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetLastInputFromGamepadCPP");

	Params::UCGFunctionLibrary_GetLastInputFromGamepadCPP_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetLandMovementNoStrafe
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ELandMovementMode       InLandMovement                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ELandMovementModeNoStrafeReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ELandMovementModeNoStrafe UCGFunctionLibrary::GetLandMovementNoStrafe(enum class ELandMovementMode InLandMovement)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetLandMovementNoStrafe");

	Params::UCGFunctionLibrary_GetLandMovementNoStrafe_Params Parms{};

	Parms.InLandMovement = InLandMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetKeyName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGFunctionLibrary::GetKeyName(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetKeyName");

	Params::UCGFunctionLibrary_GetKeyName_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetIsUserInterfaceEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EUserInterfaceType      UserInterfaceType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetIsUserInterfaceEnabled(class UObject* WorldContextObject, enum class EUserInterfaceType UserInterfaceType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetIsUserInterfaceEnabled");

	Params::UCGFunctionLibrary_GetIsUserInterfaceEnabled_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UserInterfaceType = UserInterfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetIsLevelFullyUnloaded
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LevelName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetIsLevelFullyUnloaded(class UObject* WorldContextObject, const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetIsLevelFullyUnloaded");

	Params::UCGFunctionLibrary_GetIsLevelFullyUnloaded_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetIsDX12GraphicsRHI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetIsDX12GraphicsRHI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetIsDX12GraphicsRHI");

	Params::UCGFunctionLibrary_GetIsDX12GraphicsRHI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetIsDLCLoaded
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDLCType                Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetIsDLCLoaded(class UObject* WorldContextObject, enum class EDLCType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetIsDLCLoaded");

	Params::UCGFunctionLibrary_GetIsDLCLoaded_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetIsActorInViewport
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetIsActorInViewport(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetIsActorInViewport");

	Params::UCGFunctionLibrary_GetIsActorInViewport_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetHeroCleanAim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInDebug                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::GetHeroCleanAim(class AActor* InActor, bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetHeroCleanAim");

	Params::UCGFunctionLibrary_GetHeroCleanAim_Params Parms{};

	Parms.InActor = InActor;
	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetHeroAimAngleAtBone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGFunctionLibrary::GetHeroAimAngleAtBone(class USkeletalMeshComponent* InSkeletalMesh, class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetHeroAimAngleAtBone");

	Params::UCGFunctionLibrary_GetHeroAimAngleAtBone_Params Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetGraphicsRHI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::GetGraphicsRHI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetGraphicsRHI");

	Params::UCGFunctionLibrary_GetGraphicsRHI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetGameVersionString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::GetGameVersionString()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetGameVersionString");

	Params::UCGFunctionLibrary_GetGameVersionString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetFirstKeyForAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        ActionName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                        ReturnValue                                                      (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UCGFunctionLibrary::GetFirstKeyForAction(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetFirstKeyForAction");

	Params::UCGFunctionLibrary_GetFirstKeyForAction_Params Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetEnglishKeyDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               RemoveSpaces                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::GetEnglishKeyDisplayName(class UObject* WorldContextObject, const struct FKey& Key, bool RemoveSpaces)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetEnglishKeyDisplayName");

	Params::UCGFunctionLibrary_GetEnglishKeyDisplayName_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = Key;
	Parms.RemoveSpaces = RemoveSpaces;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InHeroLocation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InHeroForwardVector                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InSourceForwardVector                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InSourceRightVector                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InSourceLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDirection              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDirection UCGFunctionLibrary::GetDirection(struct FVector& InHeroLocation, struct FVector& InHeroForwardVector, struct FVector& InSourceForwardVector, struct FVector& InSourceRightVector, struct FVector& InSourceLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetDirection");

	Params::UCGFunctionLibrary_GetDirection_Params Parms{};

	Parms.InHeroLocation = InHeroLocation;
	Parms.InHeroForwardVector = InHeroForwardVector;
	Parms.InSourceForwardVector = InSourceForwardVector;
	Parms.InSourceRightVector = InSourceRightVector;
	Parms.InSourceLocation = InSourceLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetCurrentSkeletalMeshLODIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGFunctionLibrary::GetCurrentSkeletalMeshLODIndex(class USkeletalMeshComponent* InSkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetCurrentSkeletalMeshLODIndex");

	Params::UCGFunctionLibrary_GetCurrentSkeletalMeshLODIndex_Params Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetCurrentMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InLevelActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECGMap                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECGMap UCGFunctionLibrary::GetCurrentMap(class AActor* InLevelActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetCurrentMap");

	Params::UCGFunctionLibrary_GetCurrentMap_Params Parms{};

	Parms.InLevelActor = InLevelActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetClockDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InForwardVector                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InArbitraryVector                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EClockDirection         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EClockDirection UCGFunctionLibrary::GetClockDirection(struct FVector& InForwardVector, struct FVector& InArbitraryVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetClockDirection");

	Params::UCGFunctionLibrary_GetClockDirection_Params Parms{};

	Parms.InForwardVector = InForwardVector;
	Parms.InArbitraryVector = InArbitraryVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetCGPawnBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMainPawnCpp*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMainPawnCpp* UCGFunctionLibrary::GetCGPawnBase(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetCGPawnBase");

	Params::UCGFunctionLibrary_GetCGPawnBase_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetCGGameModeBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGGameModeBase*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGGameModeBase* UCGFunctionLibrary::GetCGGameModeBase(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetCGGameModeBase");

	Params::UCGFunctionLibrary_GetCGGameModeBase_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetCGGameInstanceBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomGameInstance*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomGameInstance* UCGFunctionLibrary::GetCGGameInstanceBase(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetCGGameInstanceBase");

	Params::UCGFunctionLibrary_GetCGGameInstanceBase_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetAllKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FKey>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> UCGFunctionLibrary::GetAllKeys()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetAllKeys");

	Params::UCGFunctionLibrary_GetAllKeys_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.GetActorBoundsPoints
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UCGFunctionLibrary::GetActorBoundsPoints(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "GetActorBoundsPoints");

	Params::UCGFunctionLibrary_GetActorBoundsPoints_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.FormatDateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   DateTime                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Format                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGFunctionLibrary::FormatDateTime(struct FDateTime& DateTime, const class FString& Format)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "FormatDateTime");

	Params::UCGFunctionLibrary_FormatDateTime_Params Parms{};

	Parms.DateTime = DateTime;
	Parms.Format = Format;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.FindFirstContaining
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                Array                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                        PartialName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGFunctionLibrary::FindFirstContaining(TArray<class FName>& Array, class FName PartialName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "FindFirstContaining");

	Params::UCGFunctionLibrary_FindFirstContaining_Params Parms{};

	Parms.Array = Array;
	Parms.PartialName = PartialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.FindActiveItemID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ACGActiveItem>   InActiveItemClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGFunctionLibrary::FindActiveItemID(TSubclassOf<class ACGActiveItem> InActiveItemClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "FindActiveItemID");

	Params::UCGFunctionLibrary_FindActiveItemID_Params Parms{};

	Parms.InActiveItemClass = InActiveItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.EnableThermovisionStencilComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::EnableThermovisionStencilComponent(class UPrimitiveComponent* Component, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableThermovisionStencilComponent");

	Params::UCGFunctionLibrary_EnableThermovisionStencilComponent_Params Parms{};

	Parms.Component = Component;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.EnableThermovisionStencil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::EnableThermovisionStencil(class AActor* Actor, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableThermovisionStencil");

	Params::UCGFunctionLibrary_EnableThermovisionStencil_Params Parms{};

	Parms.Actor = Actor;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.EnableThermovisionForMissingActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGAICharacter*>      InCurrentActors                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::EnableThermovisionForMissingActors(class UObject* WorldContextObject, TArray<class ACGAICharacter*>& InCurrentActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableThermovisionForMissingActors");

	Params::UCGFunctionLibrary_EnableThermovisionForMissingActors_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InCurrentActors = InCurrentActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.EnableSlateCaching
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UCGFunctionLibrary::EnableSlateCaching()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableSlateCaching");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.EnableOutlineStencilComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::EnableOutlineStencilComponent(class UPrimitiveComponent* Component, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableOutlineStencilComponent");

	Params::UCGFunctionLibrary_EnableOutlineStencilComponent_Params Parms{};

	Parms.Component = Component;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.EnableOutlineStencil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::EnableOutlineStencil(class AActor* Actor, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "EnableOutlineStencil");

	Params::UCGFunctionLibrary_EnableOutlineStencil_Params Parms{};

	Parms.Actor = Actor;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.DrawTriangle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>             InVerts                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              InLifeTime                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InDepthPriority                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::DrawTriangle(class UObject* WorldContextObject, TArray<struct FVector>& InVerts, float InLifeTime, const struct FLinearColor& InColor, int32 InDepthPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DrawTriangle");

	Params::UCGFunctionLibrary_DrawTriangle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InVerts = InVerts;
	Parms.InLifeTime = InLifeTime;
	Parms.InColor = InColor;
	Parms.InDepthPriority = InDepthPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.DoesAISeeHero
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     InWorldContext                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAIType                 InAIType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::DoesAISeeHero(class UObject* InWorldContext, enum class EAIType InAIType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DoesAISeeHero");

	Params::UCGFunctionLibrary_DoesAISeeHero_Params Parms{};

	Parms.InWorldContext = InWorldContext;
	Parms.InAIType = InAIType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.DisableThermovisionForActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ACGAICharacter*>      InCurrentActors                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::DisableThermovisionForActors(TArray<class ACGAICharacter*>& InCurrentActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DisableThermovisionForActors");

	Params::UCGFunctionLibrary_DisableThermovisionForActors_Params Parms{};

	Parms.InCurrentActors = InCurrentActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.DisableSlateCaching
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UCGFunctionLibrary::DisableSlateCaching()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DisableSlateCaching");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.DisablePhysicalBody
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::DisablePhysicalBody(class USkeletalMeshComponent* InSkeletalMesh, class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DisablePhysicalBody");

	Params::UCGFunctionLibrary_DisablePhysicalBody_Params Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.DebugLogOnShipping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      String                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::DebugLogOnShipping(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "DebugLogOnShipping");

	Params::UCGFunctionLibrary_DebugLogOnShipping_Params Parms{};

	Parms.String = String;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.CompareFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                      ArrayA                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                      ArrayB                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              Threshold                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::CompareFloatArray(TArray<float>& ArrayA, TArray<float>& ArrayB, float Threshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CompareFloatArray");

	Params::UCGFunctionLibrary_CompareFloatArray_Params Parms{};

	Parms.ArrayA = ArrayA;
	Parms.ArrayB = ArrayB;
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CGSortCoversByVisibility
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACGCharacter*                InVisibilityTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGCover*>            InOutCovers                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ACGCover*>            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGCover*> UCGFunctionLibrary::CGSortCoversByVisibility(class ACGCharacter* InVisibilityTarget, TArray<class ACGCover*>& InOutCovers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGSortCoversByVisibility");

	Params::UCGFunctionLibrary_CGSortCoversByVisibility_Params Parms{};

	Parms.InVisibilityTarget = InVisibilityTarget;
	Parms.InOutCovers = InOutCovers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CGMultitrace
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCGMultitraceResult> OutHitResults                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                     InTraceStart                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTraceEnd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       InTraceChannel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              InActorsToIgnore                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bInTraceComplex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDebugEnabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDebugTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIgnoreCollisions                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::CGMultitrace(class UObject* WorldContextObject, TArray<struct FCGMultitraceResult>* OutHitResults, const struct FVector& InTraceStart, const struct FVector& InTraceEnd, enum class ECollisionChannel InTraceChannel, const TArray<class AActor*>& InActorsToIgnore, bool bInTraceComplex, bool bDebugEnabled, float InDebugTime, bool bIgnoreCollisions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGMultitrace");

	Params::UCGFunctionLibrary_CGMultitrace_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTraceStart = InTraceStart;
	Parms.InTraceEnd = InTraceEnd;
	Parms.InTraceChannel = InTraceChannel;
	Parms.InActorsToIgnore = InActorsToIgnore;
	Parms.bInTraceComplex = bInTraceComplex;
	Parms.bDebugEnabled = bDebugEnabled;
	Parms.InDebugTime = InDebugTime;
	Parms.bIgnoreCollisions = bIgnoreCollisions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);

}


// Function ChernobylGame.CGFunctionLibrary.CGGetPossibleCovers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPointToSearchFrom                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InSearchRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InSearchDeletionRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGCover*>            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGCover*> UCGFunctionLibrary::CGGetPossibleCovers(class UObject* WorldContextObject, struct FVector& InPointToSearchFrom, float InSearchRadius, float InSearchDeletionRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGGetPossibleCovers");

	Params::UCGFunctionLibrary_CGGetPossibleCovers_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPointToSearchFrom = InPointToSearchFrom;
	Parms.InSearchRadius = InSearchRadius;
	Parms.InSearchDeletionRadius = InSearchDeletionRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CGFilterCoversByCloser
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InCoveredCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InCloserThanTarget                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGCover*>            InOutCovers                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ACGCover*>            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGCover*> UCGFunctionLibrary::CGFilterCoversByCloser(class ACGAICharacter* InCoveredCharacter, struct FVector& InCloserThanTarget, TArray<class ACGCover*>& InOutCovers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGFilterCoversByCloser");

	Params::UCGFunctionLibrary_CGFilterCoversByCloser_Params Parms{};

	Parms.InCoveredCharacter = InCoveredCharacter;
	Parms.InCloserThanTarget = InCloserThanTarget;
	Parms.InOutCovers = InOutCovers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CGCheckIfItemIsResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::CGCheckIfItemIsResource(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGCheckIfItemIsResource");

	Params::UCGFunctionLibrary_CGCheckIfItemIsResource_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CGApplyDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACGCharacter*                InDamagedCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBaseDamage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InEventInstigator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InDamageCauser                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bInFakeDamage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGFunctionLibrary::CGApplyDamage(class ACGCharacter* InDamagedCharacter, float InBaseDamage, class AController* InEventInstigator, class AActor* InDamageCauser, struct FCGDamageEvent& InDamageEvent, bool bInFakeDamage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CGApplyDamage");

	Params::UCGFunctionLibrary_CGApplyDamage_Params Parms{};

	Parms.InDamagedCharacter = InDamagedCharacter;
	Parms.InBaseDamage = InBaseDamage;
	Parms.InEventInstigator = InEventInstigator;
	Parms.InDamageCauser = InDamageCauser;
	Parms.InDamageEvent = InDamageEvent;
	Parms.bInFakeDamage = bInFakeDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CallFunctionOnLevelActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InFunctionName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Args                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::CallFunctionOnLevelActor(class AActor* InActor, const class FString& InFunctionName, const class FString& Args)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CallFunctionOnLevelActor");

	Params::UCGFunctionLibrary_CallFunctionOnLevelActor_Params Parms{};

	Parms.InActor = InActor;
	Parms.InFunctionName = InFunctionName;
	Parms.Args = Args;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.CallFunctionOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InFunctionName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Args                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGFunctionLibrary::CallFunctionOnActor(class AActor* InActor, const class FString& InFunctionName, const class FString& Args)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "CallFunctionOnActor");

	Params::UCGFunctionLibrary_CallFunctionOnActor_Params Parms{};

	Parms.InActor = InActor;
	Parms.InFunctionName = InFunctionName;
	Parms.Args = Args;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.BenchmarkSaveFinalResults
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      MapName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBenchmarkFinalResult       Result                                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      GraphicQuality                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      BenchResolution                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      WindowModeSettings                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      VsyncSettings                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FrameRateLockSettings                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FovSettings                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ResulutionScaleSettings                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      TexturesSettings                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ShadowsSettings                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      EffectsSettings                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PPSettings                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      DrawDistanceSettings                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      AASettings                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FoliageQualitySettings                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      RayTracingSettings                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FSRSettings                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      DLSSSettings                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGFunctionLibrary::BenchmarkSaveFinalResults(const class FString& MapName, const struct FBenchmarkFinalResult& Result, const class FString& GraphicQuality, const class FString& BenchResolution, const class FString& WindowModeSettings, const class FString& VsyncSettings, const class FString& FrameRateLockSettings, const class FString& FovSettings, const class FString& ResulutionScaleSettings, const class FString& TexturesSettings, const class FString& ShadowsSettings, const class FString& EffectsSettings, const class FString& PPSettings, const class FString& DrawDistanceSettings, const class FString& AASettings, const class FString& FoliageQualitySettings, const class FString& RayTracingSettings, const class FString& FSRSettings, const class FString& DLSSSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "BenchmarkSaveFinalResults");

	Params::UCGFunctionLibrary_BenchmarkSaveFinalResults_Params Parms{};

	Parms.MapName = MapName;
	Parms.Result = Result;
	Parms.GraphicQuality = GraphicQuality;
	Parms.BenchResolution = BenchResolution;
	Parms.WindowModeSettings = WindowModeSettings;
	Parms.VsyncSettings = VsyncSettings;
	Parms.FrameRateLockSettings = FrameRateLockSettings;
	Parms.FovSettings = FovSettings;
	Parms.ResulutionScaleSettings = ResulutionScaleSettings;
	Parms.TexturesSettings = TexturesSettings;
	Parms.ShadowsSettings = ShadowsSettings;
	Parms.EffectsSettings = EffectsSettings;
	Parms.PPSettings = PPSettings;
	Parms.DrawDistanceSettings = DrawDistanceSettings;
	Parms.AASettings = AASettings;
	Parms.FoliageQualitySettings = FoliageQualitySettings;
	Parms.RayTracingSettings = RayTracingSettings;
	Parms.FSRSettings = FSRSettings;
	Parms.DLSSSettings = DLSSSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGFunctionLibrary.BenchmarkHardware
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FBenchmarkHardware          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBenchmarkHardware UCGFunctionLibrary::BenchmarkHardware()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "BenchmarkHardware");

	Params::UCGFunctionLibrary_BenchmarkHardware_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.BenchmarkGetMinXPercent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                      Elems                                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              Percent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UCGFunctionLibrary::BenchmarkGetMinXPercent(TArray<float>& Elems, float Percent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "BenchmarkGetMinXPercent");

	Params::UCGFunctionLibrary_BenchmarkGetMinXPercent_Params Parms{};

	Parms.Elems = Elems;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGFunctionLibrary.BenchmarkGetMaxXPercent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                      Elems                                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              Percent                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UCGFunctionLibrary::BenchmarkGetMaxXPercent(TArray<float>& Elems, float Percent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGFunctionLibrary", "BenchmarkGetMaxXPercent");

	Params::UCGFunctionLibrary_BenchmarkGetMaxXPercent_Params Parms{};

	Parms.Elems = Elems;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGGameModeBase
// (Actor)

class UClass* ACGGameModeBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGameModeBase");

	return Clss;
}


// CGGameModeBase ChernobylGame.Default__CGGameModeBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGGameModeBase* ACGGameModeBase::GetDefaultObj()
{
	static class ACGGameModeBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGGameModeBase*>(ACGGameModeBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGGameModeBase.UpgradeTrigger
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::UpgradeTrigger()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UpgradeTrigger");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.UpgradeScope
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::UpgradeScope()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UpgradeScope");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.UpgradeMagazine
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::UpgradeMagazine()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UpgradeMagazine");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.UpgradeHandle
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::UpgradeHandle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UpgradeHandle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.UpgradeBarrel
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::UpgradeBarrel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UpgradeBarrel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.UnloadMapAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::UnloadMapAsync(class FName Level)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "UnloadMapAsync");

	Params::ACGGameModeBase_UnloadMapAsync_Params Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.TimerSet
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::TimerSet(int32 Min)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "TimerSet");

	Params::ACGGameModeBase_TimerSet_Params Parms{};

	Parms.Min = Min;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.TimerRemove
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::TimerRemove(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "TimerRemove");

	Params::ACGGameModeBase_TimerRemove_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.TimerAdd
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::TimerAdd(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "TimerAdd");

	Params::ACGGameModeBase_TimerAdd_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SubtitleAddWhisperDefault
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::SubtitleAddWhisperDefault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SubtitleAddWhisperDefault");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SubtitleAddWhisper
// (Final, Exec, Native, Public, HasDefaults)
// Parameters:
// class FString                      SubtitleText                                                     (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SubtitleAddWhisper(const class FString& SubtitleText, float TimeShown, const struct FLinearColor& ActorColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SubtitleAddWhisper");

	Params::ACGGameModeBase_SubtitleAddWhisper_Params Parms{};

	Parms.SubtitleText = SubtitleText;
	Parms.TimeShown = TimeShown;
	Parms.ActorColor = ActorColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SubtitleAddDefault
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::SubtitleAddDefault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SubtitleAddDefault");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SubtitleAdd
// (Final, Exec, Native, Public, HasDefaults)
// Parameters:
// class FString                      ActorName                                                        (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SubtitleText                                                     (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SubtitleAdd(const class FString& ActorName, const class FString& SubtitleText, float TimeShown, const struct FLinearColor& ActorColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SubtitleAdd");

	Params::ACGGameModeBase_SubtitleAdd_Params Parms{};

	Parms.ActorName = ActorName;
	Parms.SubtitleText = SubtitleText;
	Parms.TimeShown = TimeShown;
	Parms.ActorColor = ActorColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.StaminaEnabled
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bEnabled                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::StaminaEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "StaminaEnabled");

	Params::ACGGameModeBase_StaminaEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ShouldAIDealDamage
// (Native, Public, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGGameModeBase::ShouldAIDealDamage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ShouldAIDealDamage");

	Params::ACGGameModeBase_ShouldAIDealDamage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.SetLODAI3
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewDistance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetLODAI3(float InNewDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetLODAI3");

	Params::ACGGameModeBase_SetLODAI3_Params Parms{};

	Parms.InNewDistance = InNewDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetLODAI2
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewDistance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetLODAI2(float InNewDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetLODAI2");

	Params::ACGGameModeBase_SetLODAI2_Params Parms{};

	Parms.InNewDistance = InNewDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetLODAI1
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewDistance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetLODAI1(float InNewDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetLODAI1");

	Params::ACGGameModeBase_SetLODAI1_Params Parms{};

	Parms.InNewDistance = InNewDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetLODAI0
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewDistance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetLODAI0(float InNewDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetLODAI0");

	Params::ACGGameModeBase_SetLODAI0_Params Parms{};

	Parms.InNewDistance = InNewDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetLevelTime
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetLevelTime(float InNewTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetLevelTime");

	Params::ACGGameModeBase_SetLevelTime_Params Parms{};

	Parms.InNewTime = InNewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetGodMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                               Enabled                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetGodMode(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetGodMode");

	Params::ACGGameModeBase_SetGodMode_Params Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetFullQuickSaveMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                               IsFullQuickSaveMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetFullQuickSaveMode(bool IsFullQuickSaveMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetFullQuickSaveMode");

	Params::ACGGameModeBase_SetFullQuickSaveMode_Params Parms{};

	Parms.IsFullQuickSaveMode = IsFullQuickSaveMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetForceDemoVersion
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInForceDemo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetForceDemoVersion(bool bInForceDemo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetForceDemoVersion");

	Params::ACGGameModeBase_SetForceDemoVersion_Params Parms{};

	Parms.bInForceDemo = bInForceDemo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetDebugSoldierEventLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                              NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetDebugSoldierEventLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetDebugSoldierEventLevel");

	Params::ACGGameModeBase_SetDebugSoldierEventLevel_Params Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SetDebugMonsterEventLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                              NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SetDebugMonsterEventLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SetDebugMonsterEventLevel");

	Params::ACGGameModeBase_SetDebugMonsterEventLevel_Params Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.SavePropertyLinkData
// (Final, Exec, Native, Public)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::SavePropertyLinkData(const class FString& SaveName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "SavePropertyLinkData");

	Params::ACGGameModeBase_SavePropertyLinkData_Params Parms{};

	Parms.SaveName = SaveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ResetRads
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::ResetRads()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ResetRads");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ResetForcedDLC
// (Final, Exec, Native, Public)
// Parameters:
// enum class EDLCType                Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::ResetForcedDLC(enum class EDLCType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ResetForcedDLC");

	Params::ACGGameModeBase_ResetForcedDLC_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ResetFirstTimeGameOpened
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::ResetFirstTimeGameOpened()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ResetFirstTimeGameOpened");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ResetAggroGlobal
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::ResetAggroGlobal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ResetAggroGlobal");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintPostLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::PrintPostLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintPostLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintPendingForceEvent
// (Final, Exec, Native, Public)
// Parameters:
// enum class EEventMap               MapID                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PrintPendingForceEvent(enum class EEventMap MapID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintPendingForceEvent");

	Params::ACGGameModeBase_PrintPendingForceEvent_Params Parms{};

	Parms.MapID = MapID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintLastWeeksEvents
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintLastWeeksEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintLastWeeksEvents");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintIsDLCLoaded
// (Final, Exec, Native, Public)
// Parameters:
// enum class EDLCType                Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PrintIsDLCLoaded(enum class EDLCType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintIsDLCLoaded");

	Params::ACGGameModeBase_PrintIsDLCLoaded_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintIsDemoVersion
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintIsDemoVersion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintIsDemoVersion");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintEventStatus
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintEventStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintEventStatus");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintCurrentSoldierEventLevel
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintCurrentSoldierEventLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintCurrentSoldierEventLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintCurrentEventLevelValues
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintCurrentEventLevelValues()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintCurrentEventLevelValues");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintAggroNum
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::PrintAggroNum()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintAggroNum");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintActiveEventsForMap
// (Final, Exec, Native, Public)
// Parameters:
// enum class EEventMap               MapID                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PrintActiveEventsForMap(enum class EEventMap MapID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintActiveEventsForMap");

	Params::ACGGameModeBase_PrintActiveEventsForMap_Params Parms{};

	Parms.MapID = MapID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrintActiveEvents
// (Final, Exec, Native, Public)
// Parameters:
// bool                               FullDetails                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PrintActiveEvents(bool FullDetails)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrintActiveEvents");

	Params::ACGGameModeBase_PrintActiveEvents_Params Parms{};

	Parms.FullDetails = FullDetails;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PrepareDataForFractalVR
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bPrepeare                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PrepareDataForFractalVR(bool bPrepeare)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PrepareDataForFractalVR");

	Params::ACGGameModeBase_PrepareDataForFractalVR_Params Parms{};

	Parms.bPrepeare = bPrepeare;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerRadRemove
// (Final, Exec, Native, Public)
// Parameters:
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerRadRemove(float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerRadRemove");

	Params::ACGGameModeBase_PlayerRadRemove_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerRadAdd
// (Final, Exec, Native, Public)
// Parameters:
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerRadAdd(float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerRadAdd");

	Params::ACGGameModeBase_PlayerRadAdd_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerMadnessModify
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerMadnessModify(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerMadnessModify");

	Params::ACGGameModeBase_PlayerMadnessModify_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerHpSet
// (Final, Exec, Native, Public)
// Parameters:
// float                              NewHp                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerHpSet(float NewHp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerHpSet");

	Params::ACGGameModeBase_PlayerHpSet_Params Parms{};

	Parms.NewHp = NewHp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerHpRemove
// (Final, Exec, Native, Public)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerHpRemove(float Damage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerHpRemove");

	Params::ACGGameModeBase_PlayerHpRemove_Params Parms{};

	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.PlayerHpAdd
// (Final, Exec, Native, Public)
// Parameters:
// float                              HealAmount                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::PlayerHpAdd(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "PlayerHpAdd");

	Params::ACGGameModeBase_PlayerHpAdd_Params Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.OnInputAnyKeyboardKey
// (Final, Native, Public)
// Parameters:

void ACGGameModeBase::OnInputAnyKeyboardKey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "OnInputAnyKeyboardKey");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.OnInputAnyGamepadKey
// (Final, Native, Public)
// Parameters:

void ACGGameModeBase::OnInputAnyGamepadKey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "OnInputAnyGamepadKey");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.OnInputAnyGamepadAxis
// (Final, Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::OnInputAnyGamepadAxis(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "OnInputAnyGamepadAxis");

	Params::ACGGameModeBase_OnInputAnyGamepadAxis_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.OnDebugEventStreamed
// (Final, Native, Public)
// Parameters:

void ACGGameModeBase::OnDebugEventStreamed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "OnDebugEventStreamed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.LoadMapAsync
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  Transfrom                                                        (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                     ObjToCall                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        FunctionToCall                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::LoadMapAsync(class FName Level, const struct FTransform& Transfrom, class UObject* ObjToCall, class FName FunctionToCall)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "LoadMapAsync");

	Params::ACGGameModeBase_LoadMapAsync_Params Parms{};

	Parms.Level = Level;
	Parms.Transfrom = Transfrom;
	Parms.ObjToCall = ObjToCall;
	Parms.FunctionToCall = FunctionToCall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.LetThereBeLight
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::LetThereBeLight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "LetThereBeLight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InventoryResize
// (Final, Exec, Native, Public)
// Parameters:
// int8                               X                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                               Y                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InventoryResize(int8 X, int8 Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InventoryResize");

	Params::ACGGameModeBase_InventoryResize_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InventoryRemoveIngredients
// (Final, Exec, Native, Public)
// Parameters:
// float                              Count                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InventoryRemoveIngredients(float Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InventoryRemoveIngredients");

	Params::ACGGameModeBase_InventoryRemoveIngredients_Params Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InventoryRemove
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Item                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Count                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InventoryRemove(class FName Item, float Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InventoryRemove");

	Params::ACGGameModeBase_InventoryRemove_Params Parms{};

	Parms.Item = Item;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InventoryAddIngredients
// (Final, Exec, Native, Public)
// Parameters:
// float                              Count                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InventoryAddIngredients(float Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InventoryAddIngredients");

	Params::ACGGameModeBase_InventoryAddIngredients_Params Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InventoryAdd
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Item                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Count                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InventoryAdd(class FName Item, float Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InventoryAdd");

	Params::ACGGameModeBase_InventoryAdd_Params Parms{};

	Parms.Item = Item;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.InteractionDebugInfoToggle
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::InteractionDebugInfoToggle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InteractionDebugInfoToggle");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.CGGameModeBase.InputDeviceChangedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                               NewInputIsGamepad                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::InputDeviceChangedDelegate__DelegateSignature(bool NewInputIsGamepad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "InputDeviceChangedDelegate__DelegateSignature");

	Params::ACGGameModeBase_InputDeviceChangedDelegate__DelegateSignature_Params Parms{};

	Parms.NewInputIsGamepad = NewInputIsGamepad;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGGameModeBase.GhostMode
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::GhostMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GhostMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.GetPersistentLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevel*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* ACGGameModeBase::GetPersistentLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetPersistentLevel");

	Params::ACGGameModeBase_GetPersistentLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetLODAI3
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGGameModeBase::GetLODAI3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetLODAI3");

	Params::ACGGameModeBase_GetLODAI3_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetLODAI2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGGameModeBase::GetLODAI2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetLODAI2");

	Params::ACGGameModeBase_GetLODAI2_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetLODAI1
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGGameModeBase::GetLODAI1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetLODAI1");

	Params::ACGGameModeBase_GetLODAI1_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetLODAI0
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGGameModeBase::GetLODAI0()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetLODAI0");

	Params::ACGGameModeBase_GetLODAI0_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetLevelTime
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::GetLevelTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetLevelTime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.GetIsPhotoModeActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGGameModeBase::GetIsPhotoModeActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetIsPhotoModeActive");

	Params::ACGGameModeBase_GetIsPhotoModeActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetCurrentControllerIconsSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGGameModeBase::GetCurrentControllerIconsSetting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetCurrentControllerIconsSetting");

	Params::ACGGameModeBase_GetCurrentControllerIconsSetting_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.GetAllMaterials
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::GetAllMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GetAllMaterials");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.CGGameModeBase.GeigerWaveFound__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                      InActorFoundByWave                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::GeigerWaveFound__DelegateSignature(class AActor* InActorFoundByWave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "GeigerWaveFound__DelegateSignature");

	Params::ACGGameModeBase_GeigerWaveFound__DelegateSignature_Params Parms{};

	Parms.InActorFoundByWave = InActorFoundByWave;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGGameModeBase.ForceEvent
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::ForceEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ForceEvent");

	Params::ACGGameModeBase_ForceEvent_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ForceDLC
// (Final, Exec, Native, Public)
// Parameters:
// enum class EDLCType                Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::ForceDLC(enum class EDLCType Type, bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ForceDLC");

	Params::ACGGameModeBase_ForceDLC_Params Parms{};

	Parms.Type = Type;
	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ExpAdd
// (Final, Exec, Native, Public)
// Parameters:
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::ExpAdd(float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ExpAdd");

	Params::ACGGameModeBase_ExpAdd_Params Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventUnstream
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EventUnstream(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventUnstream");

	Params::ACGGameModeBase_EventUnstream_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventSystemPrintPermanentLevels
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::EventSystemPrintPermanentLevels()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventSystemPrintPermanentLevels");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventSystemPrintActiveQuests
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::EventSystemPrintActiveQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventSystemPrintActiveQuests");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventSystemPrintActiveEvents
// (Final, Exec, Native, Public)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EventSystemPrintActiveEvents(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventSystemPrintActiveEvents");

	Params::ACGGameModeBase_EventSystemPrintActiveEvents_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventSystemGetFinishedQuests
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::EventSystemGetFinishedQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventSystemGetFinishedQuests");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventStream
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EventStream(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventStream");

	Params::ACGGameModeBase_EventStream_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventPrintCategories
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::EventPrintCategories()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventPrintCategories");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventDeactivate
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EventDeactivate(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventDeactivate");

	Params::ACGGameModeBase_EventDeactivate_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EventActivate
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EventActivate(class FName Event, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EventActivate");

	Params::ACGGameModeBase_EventActivate_Params Parms{};

	Parms.Event = Event;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableSuperGore
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableSuperGore(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableSuperGore");

	Params::ACGGameModeBase_EnableSuperGore_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableSoldierEventLevelDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableSoldierEventLevelDebug(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableSoldierEventLevelDebug");

	Params::ACGGameModeBase_EnableSoldierEventLevelDebug_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnablePS4GamepadDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnablePS4GamepadDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnablePS4GamepadDebug");

	Params::ACGGameModeBase_EnablePS4GamepadDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableMusicManagerDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableMusicManagerDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableMusicManagerDebug");

	Params::ACGGameModeBase_EnableMusicManagerDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableMultitraceDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableMultitraceDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableMultitraceDebug");

	Params::ACGGameModeBase_EnableMultitraceDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableMovementStateDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableMovementStateDebug(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableMovementStateDebug");

	Params::ACGGameModeBase_EnableMovementStateDebug_Params Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableMeleeDamageDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableMeleeDamageDebug(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableMeleeDamageDebug");

	Params::ACGGameModeBase_EnableMeleeDamageDebug_Params Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableLevelTimerDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInNewEnable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableLevelTimerDebug(bool bInNewEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableLevelTimerDebug");

	Params::ACGGameModeBase_EnableLevelTimerDebug_Params Parms{};

	Parms.bInNewEnable = bInNewEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableGateOfMadnessModeAvailability
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableGateOfMadnessModeAvailability(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableGateOfMadnessModeAvailability");

	Params::ACGGameModeBase_EnableGateOfMadnessModeAvailability_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableGateOfMadnessMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableGateOfMadnessMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableGateOfMadnessMode");

	Params::ACGGameModeBase_EnableGateOfMadnessMode_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableGateOfMadnessDefaultSaveSystem
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableGateOfMadnessDefaultSaveSystem(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableGateOfMadnessDefaultSaveSystem");

	Params::ACGGameModeBase_EnableGateOfMadnessDefaultSaveSystem_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableGamepadDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableGamepadDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableGamepadDebug");

	Params::ACGGameModeBase_EnableGamepadDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableDamageDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableDamageDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableDamageDebug");

	Params::ACGGameModeBase_EnableDamageDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableCrouchDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableCrouchDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableCrouchDebug");

	Params::ACGGameModeBase_EnableCrouchDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableCloseCollisionDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableCloseCollisionDebug(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableCloseCollisionDebug");

	Params::ACGGameModeBase_EnableCloseCollisionDebug_Params Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableBuildSystemDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableBuildSystemDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableBuildSystemDebug");

	Params::ACGGameModeBase_EnableBuildSystemDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableAggroDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableAggroDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableAggroDebug");

	Params::ACGGameModeBase_EnableAggroDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebugSquad
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebugSquad(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebugSquad");

	Params::ACGGameModeBase_EnableActorsDebugSquad_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebugSkeleton
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebugSkeleton(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebugSkeleton");

	Params::ACGGameModeBase_EnableActorsDebugSkeleton_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebugLevel
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebugLevel(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebugLevel");

	Params::ACGGameModeBase_EnableActorsDebugLevel_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebugIK
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebugIK(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebugIK");

	Params::ACGGameModeBase_EnableActorsDebugIK_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebugGib
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebugGib(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebugGib");

	Params::ACGGameModeBase_EnableActorsDebugGib_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorsDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorsDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorsDebug");

	Params::ACGGameModeBase_EnableActorsDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.EnableActorDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               InDebug                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::EnableActorDebug(bool InDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "EnableActorDebug");

	Params::ACGGameModeBase_EnableActorDebug_Params Parms{};

	Parms.InDebug = InDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.DumpPropertyLink
// (Final, Exec, Native, Public)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::DumpPropertyLink(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "DumpPropertyLink");

	Params::ACGGameModeBase_DumpPropertyLink_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.DumpAllExistingObjectsLinks
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::DumpAllExistingObjectsLinks()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "DumpAllExistingObjectsLinks");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.DebugSetSpecificDay
// (Final, Exec, Native, Public)
// Parameters:
// int32                              Day                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::DebugSetSpecificDay(int32 Day)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "DebugSetSpecificDay");

	Params::ACGGameModeBase_DebugSetSpecificDay_Params Parms{};

	Parms.Day = Day;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.DeactivatePhotoMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::DeactivatePhotoMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "DeactivatePhotoMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CustomBugItV2
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::CustomBugItV2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CustomBugItV2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CustomBugIt
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::CustomBugIt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CustomBugIt");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CrashGame
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::CrashGame()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CrashGame");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CraftingLearnRecipe
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Recipe                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::CraftingLearnRecipe(class FName Recipe)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CraftingLearnRecipe");

	Params::ACGGameModeBase_CraftingLearnRecipe_Params Parms{};

	Parms.Recipe = Recipe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CraftingLearnAllRecipes
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::CraftingLearnAllRecipes()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CraftingLearnAllRecipes");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ComparePropertyLinkData
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Base                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      New                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPropertyLinkResult     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPropertyLinkResult ACGGameModeBase::ComparePropertyLinkData(const class FString& Base, const class FString& New)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ComparePropertyLinkData");

	Params::ACGGameModeBase_ComparePropertyLinkData_Params Parms{};

	Parms.Base = Base;
	Parms.New = New;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGGameModeBase.CompanionStats
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::CompanionStats(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CompanionStats");

	Params::ACGGameModeBase_CompanionStats_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CompanionsPrintData
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::CompanionsPrintData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CompanionsPrintData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CompanionAdd
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        CompanionID                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::CompanionAdd(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CompanionAdd");

	Params::ACGGameModeBase_CompanionAdd_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ChangeLevelTimeLimits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LevelTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StormTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::ChangeLevelTimeLimits(int32 LevelTime, int32 StormTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ChangeLevelTimeLimits");

	Params::ACGGameModeBase_ChangeLevelTimeLimits_Params Parms{};

	Parms.LevelTime = LevelTime;
	Parms.StormTime = StormTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.CancelForceEvent
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::CancelForceEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "CancelForceEvent");

	Params::ACGGameModeBase_CancelForceEvent_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.AIKill
// (Final, Exec, Native, Public)
// Parameters:

void ACGGameModeBase::AIKill()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "AIKill");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.AddPerk
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        PerkName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGGameModeBase::AddPerk(class FName PerkName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "AddPerk");

	Params::ACGGameModeBase_AddPerk_Params Parms{};

	Parms.PerkName = PerkName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGameModeBase.ActivatePhotoMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGGameModeBase::ActivatePhotoMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGameModeBase", "ActivatePhotoMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGGameMode_VirtuaCop
// (Actor)

class UClass* ACGGameMode_VirtuaCop::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGameMode_VirtuaCop");

	return Clss;
}


// CGGameMode_VirtuaCop ChernobylGame.Default__CGGameMode_VirtuaCop
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGGameMode_VirtuaCop* ACGGameMode_VirtuaCop::GetDefaultObj()
{
	static class ACGGameMode_VirtuaCop* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGGameMode_VirtuaCop*>(ACGGameMode_VirtuaCop::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGGeigerBaseWidget
// (None)

class UClass* UCGGeigerBaseWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGeigerBaseWidget");

	return Clss;
}


// CGGeigerBaseWidget ChernobylGame.Default__CGGeigerBaseWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGGeigerBaseWidget* UCGGeigerBaseWidget::GetDefaultObj()
{
	static class UCGGeigerBaseWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGGeigerBaseWidget*>(UCGGeigerBaseWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGGeigerBaseWidget.UpdateEnviroRandomly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGeigerBaseWidget::UpdateEnviroRandomly(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGeigerBaseWidget", "UpdateEnviroRandomly");

	Params::UCGGeigerBaseWidget_UpdateEnviroRandomly_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGeigerBaseWidget.UpdateEnviro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Radiation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinRadiation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxRadiation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GeigerInaccuracyOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGeigerBaseWidget::UpdateEnviro(float Radiation, float MinRadiation, float MaxRadiation, float GeigerInaccuracyOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGeigerBaseWidget", "UpdateEnviro");

	Params::UCGGeigerBaseWidget_UpdateEnviro_Params Parms{};

	Parms.Radiation = Radiation;
	Parms.MinRadiation = MinRadiation;
	Parms.MaxRadiation = MaxRadiation;
	Parms.GeigerInaccuracyOffset = GeigerInaccuracyOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGeigerBaseWidget.SetupWidgetReferences
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextBlock*                  EnviroTextWidget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                      EnviroLineWidget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasPanel*                ArrowContainerWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                      ArrowWidget                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGeigerBaseWidget::SetupWidgetReferences(class UTextBlock* EnviroTextWidget, class UImage* EnviroLineWidget, class UCanvasPanel* ArrowContainerWidget, class UImage* ArrowWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGeigerBaseWidget", "SetupWidgetReferences");

	Params::UCGGeigerBaseWidget_SetupWidgetReferences_Params Parms{};

	Parms.EnviroTextWidget = EnviroTextWidget;
	Parms.EnviroLineWidget = EnviroLineWidget;
	Parms.ArrowContainerWidget = ArrowContainerWidget;
	Parms.ArrowWidget = ArrowWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGGhostState
// (Actor)

class UClass* ACGGhostState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGhostState");

	return Clss;
}


// CGGhostState ChernobylGame.Default__CGGhostState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGGhostState* ACGGhostState::GetDefaultObj()
{
	static class ACGGhostState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGGhostState*>(ACGGhostState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGGibActor
// (Actor)

class UClass* ACGGibActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGibActor");

	return Clss;
}


// CGGibActor ChernobylGame.Default__CGGibActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGGibActor* ACGGibActor::GetDefaultObj()
{
	static class ACGGibActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGGibActor*>(ACGGibActor::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGGibComponent
// (None)

class UClass* UCGGibComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGGibComponent");

	return Clss;
}


// CGGibComponent ChernobylGame.Default__CGGibComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGGibComponent* UCGGibComponent::GetDefaultObj()
{
	static class UCGGibComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGGibComponent*>(UCGGibComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGGibComponent.UpdateMaterialsForGib
// (Final, Native, Private, Const)
// Parameters:
// class UPrimitiveComponent*         InComponent                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EGibMaterialUpdateMode  InUpdateMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InAdditionalParamName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGibComponent::UpdateMaterialsForGib(class UPrimitiveComponent* InComponent, enum class EGibMaterialUpdateMode InUpdateMode, class FName InAdditionalParamName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "UpdateMaterialsForGib");

	Params::UCGGibComponent_UpdateMaterialsForGib_Params Parms{};

	Parms.InComponent = InComponent;
	Parms.InUpdateMode = InUpdateMode;
	Parms.InAdditionalParamName = InAdditionalParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.SpawnDetachedGib
// (Final, Native, Private, HasOutParams, Const)
// Parameters:
// struct FCGGibInfo                  InGibInfo                                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCGGibComponent::SpawnDetachedGib(struct FCGGibInfo* InGibInfo, struct FCGDamageEvent& InDamageEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "SpawnDetachedGib");

	Params::UCGGibComponent_SpawnDetachedGib_Params Parms{};

	Parms.InDamageEvent = InDamageEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InGibInfo != nullptr)
		*InGibInfo = std::move(Parms.InGibInfo);

}


// Function ChernobylGame.CGGibComponent.SpawnAttachedGib
// (Final, Native, Private, HasOutParams, Const)
// Parameters:
// struct FCGGibInfo                  InGibInfo                                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UCGGibComponent::SpawnAttachedGib(struct FCGGibInfo* InGibInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "SpawnAttachedGib");

	Params::UCGGibComponent_SpawnAttachedGib_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InGibInfo != nullptr)
		*InGibInfo = std::move(Parms.InGibInfo);

}


// Function ChernobylGame.CGGibComponent.SetGibOpacityParam
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                        InParamName                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGibComponent::SetGibOpacityParam(class FName& InParamName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "SetGibOpacityParam");

	Params::UCGGibComponent_SetGibOpacityParam_Params Parms{};

	Parms.InParamName = InParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.SetGibGodmode
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                               bInGodmode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGibComponent::SetGibGodmode(bool bInGodmode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "SetGibGodmode");

	Params::UCGGibComponent_SetGibGodmode_Params Parms{};

	Parms.bInGodmode = bInGodmode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.SchedulePhysicsChange
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class FName>                InBoneNames                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCGGibComponent::SchedulePhysicsChange(TArray<class FName>& InBoneNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "SchedulePhysicsChange");

	Params::UCGGibComponent_SchedulePhysicsChange_Params Parms{};

	Parms.InBoneNames = InBoneNames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.OnPhysicsStarted
// (Final, Native, Private)
// Parameters:

void UCGGibComponent::OnPhysicsStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "OnPhysicsStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.OnHPLost
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                      InComponentOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRemainingHpPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      InDamageDealer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDamage                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInKillingDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGGibComponent::OnHPLost(class AActor* InComponentOwner, float InRemainingHpPoints, float InRemainingHpPercent, struct FCGDamageEvent& InDamageEvent, class AActor* InDamageDealer, float InDamage, bool bInKillingDamage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "OnHPLost");

	Params::UCGGibComponent_OnHPLost_Params Parms{};

	Parms.InComponentOwner = InComponentOwner;
	Parms.InRemainingHpPoints = InRemainingHpPoints;
	Parms.InRemainingHpPercent = InRemainingHpPercent;
	Parms.InDamageEvent = InDamageEvent;
	Parms.InDamageDealer = InDamageDealer;
	Parms.InDamage = InDamage;
	Parms.bInKillingDamage = bInKillingDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.HideComponentsByName
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class UActorComponent*>     InSceneComps                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class FString>              InCompNames                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCGGibComponent::HideComponentsByName(TArray<class UActorComponent*>& InSceneComps, TArray<class FString>& InCompNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "HideComponentsByName");

	Params::UCGGibComponent_HideComponentsByName_Params Parms{};

	Parms.InSceneComps = InSceneComps;
	Parms.InCompNames = InCompNames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGGibComponent.CumulativeGibs
// (Final, Native, Private)
// Parameters:

void UCGGibComponent::CumulativeGibs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGGibComponent", "CumulativeGibs");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGHearingSense
// (None)

class UClass* UCGHearingSense::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGHearingSense");

	return Clss;
}


// CGHearingSense ChernobylGame.Default__CGHearingSense
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGHearingSense* UCGHearingSense::GetDefaultObj()
{
	static class UCGHearingSense* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGHearingSense*>(UCGHearingSense::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGHearingSense.ReceiveNoise
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      InInstigator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNoiseLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InNoiseStrength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InTag                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInIgnoreSenseBlock                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMaxDistanceToActivateCombat                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGHearingSense::ReceiveNoise(class AActor* InInstigator, float InNoiseRange, const struct FVector& InNoiseLocation, float InNoiseStrength, class FName InTag, bool bInIgnoreSenseBlock, float InMaxDistanceToActivateCombat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGHearingSense", "ReceiveNoise");

	Params::UCGHearingSense_ReceiveNoise_Params Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InNoiseRange = InNoiseRange;
	Parms.InNoiseLocation = InNoiseLocation;
	Parms.InNoiseStrength = InNoiseStrength;
	Parms.InTag = InTag;
	Parms.bInIgnoreSenseBlock = bInIgnoreSenseBlock;
	Parms.InMaxDistanceToActivateCombat = InMaxDistanceToActivateCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGHeroGhost
// (Actor)

class UClass* ACGHeroGhost::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGHeroGhost");

	return Clss;
}


// CGHeroGhost ChernobylGame.Default__CGHeroGhost
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGHeroGhost* ACGHeroGhost::GetDefaultObj()
{
	static class ACGHeroGhost* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGHeroGhost*>(ACGHeroGhost::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGHeroGhost.DeactivateGhost
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGHeroGhost::DeactivateGhost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGHeroGhost", "DeactivateGhost");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGHeroGhost.ActivateGhost
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGHeroGhost::ActivateGhost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGHeroGhost", "ActivateGhost");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGItemContinuousActivation
// (Actor)

class UClass* ACGItemContinuousActivation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGItemContinuousActivation");

	return Clss;
}


// CGItemContinuousActivation ChernobylGame.Default__CGItemContinuousActivation
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGItemContinuousActivation* ACGItemContinuousActivation::GetDefaultObj()
{
	static class ACGItemContinuousActivation* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGItemContinuousActivation*>(ACGItemContinuousActivation::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGLeanState
// (Actor)

class UClass* ACGLeanState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGLeanState");

	return Clss;
}


// CGLeanState ChernobylGame.Default__CGLeanState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGLeanState* ACGLeanState::GetDefaultObj()
{
	static class ACGLeanState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGLeanState*>(ACGLeanState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGLevelTimer
// (None)

class UClass* UCGLevelTimer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGLevelTimer");

	return Clss;
}


// CGLevelTimer ChernobylGame.Default__CGLevelTimer
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGLevelTimer* UCGLevelTimer::GetDefaultObj()
{
	static class UCGLevelTimer* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGLevelTimer*>(UCGLevelTimer::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGLevelTimer.OnTimerUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FString                      InNewStringTime                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewFloatTime                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGLevelTimer::OnTimerUpdate(const class FString& InNewStringTime, float NewFloatTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimer", "OnTimerUpdate");

	Params::UCGLevelTimer_OnTimerUpdate_Params Parms{};

	Parms.InNewStringTime = InNewStringTime;
	Parms.NewFloatTime = NewFloatTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimer.OnStop
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UCGLevelTimer::OnStop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimer", "OnStop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimer.OnStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UCGLevelTimer::OnStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimer", "OnStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimer.OnShowForDuration
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UCGLevelTimer::OnShowForDuration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimer", "OnShowForDuration");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimer.OnShowConstant
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UCGLevelTimer::OnShowConstant()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimer", "OnShowConstant");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGLevelTimerComponent
// (None)

class UClass* UCGLevelTimerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGLevelTimerComponent");

	return Clss;
}


// CGLevelTimerComponent ChernobylGame.Default__CGLevelTimerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGLevelTimerComponent* UCGLevelTimerComponent::GetDefaultObj()
{
	static class UCGLevelTimerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGLevelTimerComponent*>(UCGLevelTimerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGLevelTimerComponent.StronglyStopTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::StronglyStopTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "StronglyStopTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.StronglyEnableTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::StronglyEnableTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "StronglyEnableTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.StopTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::StopTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "StopTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.StartTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::StartTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "StartTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.StartAndEnableTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::StartAndEnableTimer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "StartAndEnableTimer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.SetRemainingTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InNewRemainingTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGLevelTimerComponent::SetRemainingTime(int32 InNewRemainingTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "SetRemainingTime");

	Params::UCGLevelTimerComponent_SetRemainingTime_Params Parms{};

	Parms.InNewRemainingTime = InNewRemainingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.SetEnableDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewEnable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGLevelTimerComponent::SetEnableDebug(bool bInNewEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "SetEnableDebug");

	Params::UCGLevelTimerComponent_SetEnableDebug_Params Parms{};

	Parms.bInNewEnable = bInNewEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.Reset
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "Reset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGLevelTimerComponent.GetRemainingTimeAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCGLevelTimerComponent::GetRemainingTimeAsString()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "GetRemainingTimeAsString");

	Params::UCGLevelTimerComponent_GetRemainingTimeAsString_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGLevelTimerComponent.GetRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGLevelTimerComponent::GetRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "GetRemainingTime");

	Params::UCGLevelTimerComponent_GetRemainingTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGLevelTimerComponent.FinishStorm
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCGLevelTimerComponent::FinishStorm()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGLevelTimerComponent", "FinishStorm");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGLookOnly
// (Actor)

class UClass* ACGLookOnly::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGLookOnly");

	return Clss;
}


// CGLookOnly ChernobylGame.Default__CGLookOnly
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGLookOnly* ACGLookOnly::GetDefaultObj()
{
	static class ACGLookOnly* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGLookOnly*>(ACGLookOnly::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGMath
// (None)

class UClass* UCGMath::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMath");

	return Clss;
}


// CGMath ChernobylGame.Default__CGMath
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGMath* UCGMath::GetDefaultObj()
{
	static class UCGMath* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGMath*>(UCGMath::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGMath.Step
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Step                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGMath::Step(float X, float Step, float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "Step");

	Params::UCGMath_Step_Params Parms{};

	Parms.X = X;
	Parms.Step = Step;
	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.SetAngularRotationOffset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPhysicsConstraintComponent* PhysicsConstraintComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Offset                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCGMath::SetAngularRotationOffset(class UPhysicsConstraintComponent* PhysicsConstraintComponent, const struct FRotator& Offset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "SetAngularRotationOffset");

	Params::UCGMath_SetAngularRotationOffset_Params Parms{};

	Parms.PhysicsConstraintComponent = PhysicsConstraintComponent;
	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMath.PolarToCartesian
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InRad                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAng                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutX                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutY                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGMath::PolarToCartesian(float InRad, float InAng, float* OutX, float* OutY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "PolarToCartesian");

	Params::UCGMath_PolarToCartesian_Params Parms{};

	Parms.InRad = InRad;
	Parms.InAng = InAng;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutX != nullptr)
		*OutX = Parms.OutX;

	if (OutY != nullptr)
		*OutY = Parms.OutY;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.PointOnSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InRadius                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InYaw                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPitch                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InOrigin                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCGMath::PointOnSphere(float& InRadius, float& InYaw, float& InPitch, const struct FVector& InOrigin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "PointOnSphere");

	Params::UCGMath_PointOnSphere_Params Parms{};

	Parms.InRadius = InRadius;
	Parms.InYaw = InYaw;
	Parms.InPitch = InPitch;
	Parms.InOrigin = InOrigin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.PointInsideRectangle2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   Start                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   End                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::PointInsideRectangle2D(const struct FVector2D& Start, const struct FVector2D& End, const struct FVector2D& Point)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "PointInsideRectangle2D");

	Params::UCGMath_PointInsideRectangle2D_Params Parms{};

	Parms.Start = Start;
	Parms.End = End;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.PointInsideCircle2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   SphereCenter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::PointInsideCircle2D(const struct FVector2D& Point, const struct FVector2D& SphereCenter, float Radius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "PointInsideCircle2D");

	Params::UCGMath_PointInsideCircle2D_Params Parms{};

	Parms.Point = Point;
	Parms.SphereCenter = SphereCenter;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.PointInNegativeHalfSpace2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   PlaneNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   PlanePoint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::PointInNegativeHalfSpace2D(const struct FVector2D& PlaneNormal, const struct FVector2D& PlanePoint, const struct FVector2D& Point)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "PointInNegativeHalfSpace2D");

	Params::UCGMath_PointInNegativeHalfSpace2D_Params Parms{};

	Parms.PlaneNormal = PlaneNormal;
	Parms.PlanePoint = PlanePoint;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.OuterProduct
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InLine1stPoint                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   InLine2ndPoint                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   InPoint                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGMath::OuterProduct(struct FVector2D& InLine1stPoint, struct FVector2D& InLine2ndPoint, struct FVector2D& InPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "OuterProduct");

	Params::UCGMath_OuterProduct_Params Parms{};

	Parms.InLine1stPoint = InLine1stPoint;
	Parms.InLine2ndPoint = InLine2ndPoint;
	Parms.InPoint = InPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.MapRectangleToCircle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   InPointInRect                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   InRectSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCGMath::MapRectangleToCircle(const struct FVector2D& InPointInRect, const struct FVector2D& InRectSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "MapRectangleToCircle");

	Params::UCGMath_MapRectangleToCircle_Params Parms{};

	Parms.InPointInRect = InPointInRect;
	Parms.InRectSize = InRectSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.MapCircleToRectangle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Uv                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   HalfRecSize                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCGMath::MapCircleToRectangle(const struct FVector2D& Uv, const struct FVector2D& HalfRecSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "MapCircleToRectangle");

	Params::UCGMath_MapCircleToRectangle_Params Parms{};

	Parms.Uv = Uv;
	Parms.HalfRecSize = HalfRecSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.LineSegmentPointCollision2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Start                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   End                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Epsilon                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::LineSegmentPointCollision2D(const struct FVector2D& Start, const struct FVector2D& End, const struct FVector2D& Point, float Epsilon)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "LineSegmentPointCollision2D");

	Params::UCGMath_LineSegmentPointCollision2D_Params Parms{};

	Parms.Start = Start;
	Parms.End = End;
	Parms.Point = Point;
	Parms.Epsilon = Epsilon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.IsInsideBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::IsInsideBox(const struct FVector2D& Point, float Width, float Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "IsInsideBox");

	Params::UCGMath_IsInsideBox_Params Parms{};

	Parms.Point = Point;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.IsFacingSpecifiedDirection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   DirectionA                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   DirectionB                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxAngle                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::IsFacingSpecifiedDirection(const struct FVector2D& DirectionA, const struct FVector2D& DirectionB, float MaxAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "IsFacingSpecifiedDirection");

	Params::UCGMath_IsFacingSpecifiedDirection_Params Parms{};

	Parms.DirectionA = DirectionA;
	Parms.DirectionB = DirectionB;
	Parms.MaxAngle = MaxAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.IsClose
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InCloseTo                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InVector                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::IsClose(const struct FVector& InCloseTo, float InRadius, const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "IsClose");

	Params::UCGMath_IsClose_Params Parms{};

	Parms.InCloseTo = InCloseTo;
	Parms.InRadius = InRadius;
	Parms.InVector = InVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.IntersetionOfIntArrays
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      InA                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      InB                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      OutIntersection                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCGMath::IntersetionOfIntArrays(TArray<int32>& InA, TArray<int32>& InB, TArray<int32>* OutIntersection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "IntersetionOfIntArrays");

	Params::UCGMath_IntersetionOfIntArrays_Params Parms{};

	Parms.InA = InA;
	Parms.InB = InB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIntersection != nullptr)
		*OutIntersection = std::move(Parms.OutIntersection);

}


// Function ChernobylGame.CGMath.IntersetionOfFloatArrays
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                      InA                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                      InB                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                      OutIntersection                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCGMath::IntersetionOfFloatArrays(TArray<float>& InA, TArray<float>& InB, TArray<float>* OutIntersection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "IntersetionOfFloatArrays");

	Params::UCGMath_IntersetionOfFloatArrays_Params Parms{};

	Parms.InA = InA;
	Parms.InB = InB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIntersection != nullptr)
		*OutIntersection = std::move(Parms.OutIntersection);

}


// Function ChernobylGame.CGMath.GetAverageDelta
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                      InArray                                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGMath::GetAverageDelta(TArray<float>& InArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "GetAverageDelta");

	Params::UCGMath_GetAverageDelta_Params Parms{};

	Parms.InArray = InArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.GetAverage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                      InArray                                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGMath::GetAverage(TArray<float>& InArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "GetAverage");

	Params::UCGMath_GetAverage_Params Parms{};

	Parms.InArray = InArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.GetAngleToTarget
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InStart                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InForward                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTarget                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGMath::GetAngleToTarget(const struct FVector& InStart, const struct FVector& InForward, const struct FVector& InTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "GetAngleToTarget");

	Params::UCGMath_GetAngleToTarget_Params Parms{};

	Parms.InStart = InStart;
	Parms.InForward = InForward;
	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.Gain
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              K                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGMath::Gain(float X, float K)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "Gain");

	Params::UCGMath_Gain_Params Parms{};

	Parms.X = X;
	Parms.K = K;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.CreateReflectionTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  OutTransform                                                     (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                      InPlane                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGMath::CreateReflectionTransform(struct FTransform* OutTransform, const struct FPlane& InPlane)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "CreateReflectionTransform");

	Params::UCGMath_CreateReflectionTransform_Params Parms{};

	Parms.InPlane = InPlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

}


// Function ChernobylGame.CGMath.ChangeRotationOrder
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRotator                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class EEulerRotationOrder     InOrder                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UCGMath::ChangeRotationOrder(struct FRotator& InRotator, enum class EEulerRotationOrder InOrder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "ChangeRotationOrder");

	Params::UCGMath_ChangeRotationOrder_Params Parms{};

	Parms.InRotator = InRotator;
	Parms.InOrder = InOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.CartesianToPolar
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InX                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InY                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutRad                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutAng                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCGMath::CartesianToPolar(float InX, float InY, float* OutRad, float* OutAng)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "CartesianToPolar");

	Params::UCGMath_CartesianToPolar_Params Parms{};

	Parms.InX = InX;
	Parms.InY = InY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRad != nullptr)
		*OutRad = Parms.OutRad;

	if (OutAng != nullptr)
		*OutAng = Parms.OutAng;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.ArrayToStack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                      InArray                                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              InNewElement                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UCGMath::ArrayToStack(TArray<float>& InArray, float InNewElement)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "ArrayToStack");

	Params::UCGMath_ArrayToStack_Params Parms{};

	Parms.InArray = InArray;
	Parms.InNewElement = InNewElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMath.AABB2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   StartA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   EndA                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   StartB                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   EndB                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGMath::AABB2D(const struct FVector2D& StartA, const struct FVector2D& EndA, const struct FVector2D& StartB, const struct FVector2D& EndB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMath", "AABB2D");

	Params::UCGMath_AABB2D_Params Parms{};

	Parms.StartA = StartA;
	Parms.EndA = EndA;
	Parms.StartB = StartB;
	Parms.EndB = EndB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGMultitraceInterface
// (None)

class UClass* ICGMultitraceInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMultitraceInterface");

	return Clss;
}


// CGMultitraceInterface ChernobylGame.Default__CGMultitraceInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ICGMultitraceInterface* ICGMultitraceInterface::GetDefaultObj()
{
	static class ICGMultitraceInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ICGMultitraceInterface*>(ICGMultitraceInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGMultitraceInterface.GetShouldIgnoreAfterFirstMultitraceHit
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICGMultitraceInterface::GetShouldIgnoreAfterFirstMultitraceHit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMultitraceInterface", "GetShouldIgnoreAfterFirstMultitraceHit");

	Params::ICGMultitraceInterface_GetShouldIgnoreAfterFirstMultitraceHit_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGMusicManager
// (Actor)

class UClass* ACGMusicManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMusicManager");

	return Clss;
}


// CGMusicManager ChernobylGame.Default__CGMusicManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGMusicManager* ACGMusicManager::GetDefaultObj()
{
	static class ACGMusicManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGMusicManager*>(ACGMusicManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGMusicManager.SetQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InQuestSignalName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGMusicManager::SetQuest(class FName InQuestSignalName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "SetQuest");

	Params::ACGMusicManager_SetQuest_Params Parms{};

	Parms.InQuestSignalName = InQuestSignalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMusicManager.SetMusicEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewEnabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMusicManager::SetMusicEnabled(bool bInNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "SetMusicEnabled");

	Params::ACGMusicManager_SetMusicEnabled_Params Parms{};

	Parms.bInNewEnabled = bInNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicManager.GetCurrentMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECGMapMusicMode         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECGMapMusicMode ACGMusicManager::GetCurrentMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "GetCurrentMode");

	Params::ACGMusicManager_GetCurrentMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMusicManager.GetCurrentEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECGMapMusicEvent        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECGMapMusicEvent ACGMusicManager::GetCurrentEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "GetCurrentEvent");

	Params::ACGMusicManager_GetCurrentEvent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGMusicManager.EnableAllEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECGMapMusicEvent        InEventType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMusicManager::EnableAllEvents(enum class ECGMapMusicEvent InEventType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "EnableAllEvents");

	Params::ACGMusicManager_EnableAllEvents_Params Parms{};

	Parms.InEventType = InEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicManager.DisableAllEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECGMapMusicEvent        InEventType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMusicManager::DisableAllEvents(enum class ECGMapMusicEvent InEventType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "DisableAllEvents");

	Params::ACGMusicManager_DisableAllEvents_Params Parms{};

	Parms.InEventType = InEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicManager.AlertInterval
// (Final, Native, Private)
// Parameters:

void ACGMusicManager::AlertInterval()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicManager", "AlertInterval");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGMusicVolume
// (Actor)

class UClass* ACGMusicVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGMusicVolume");

	return Clss;
}


// CGMusicVolume ChernobylGame.Default__CGMusicVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGMusicVolume* ACGMusicVolume::GetDefaultObj()
{
	static class ACGMusicVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGMusicVolume*>(ACGMusicVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGMusicVolume.SetVolumeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMusicVolume::SetVolumeEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicVolume", "SetVolumeEnabled");

	Params::ACGMusicVolume_SetVolumeEnabled_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicVolume.OnOverlapStart
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACGMusicVolume::OnOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicVolume", "OnOverlapStart");

	Params::ACGMusicVolume_OnOverlapStart_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicVolume.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*         OverlappedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGMusicVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicVolume", "OnOverlapEnd");

	Params::ACGMusicVolume_OnOverlapEnd_Params Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGMusicVolume.GetVolumeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGMusicVolume::GetVolumeEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGMusicVolume", "GetVolumeEnabled");

	Params::ACGMusicVolume_GetVolumeEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGNavTarget
// (Actor)

class UClass* ACGNavTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNavTarget");

	return Clss;
}


// CGNavTarget ChernobylGame.Default__CGNavTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNavTarget* ACGNavTarget::GetDefaultObj()
{
	static class ACGNavTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNavTarget*>(ACGNavTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNoCrouchArea
// (Actor)

class UClass* ACGNoCrouchArea::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNoCrouchArea");

	return Clss;
}


// CGNoCrouchArea ChernobylGame.Default__CGNoCrouchArea
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNoCrouchArea* ACGNoCrouchArea::GetDefaultObj()
{
	static class ACGNoCrouchArea* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNoCrouchArea*>(ACGNoCrouchArea::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNoInputGhostStateCam
// (Actor)

class UClass* ACGNoInputGhostStateCam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNoInputGhostStateCam");

	return Clss;
}


// CGNoInputGhostStateCam ChernobylGame.Default__CGNoInputGhostStateCam
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNoInputGhostStateCam* ACGNoInputGhostStateCam::GetDefaultObj()
{
	static class ACGNoInputGhostStateCam* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNoInputGhostStateCam*>(ACGNoInputGhostStateCam::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNoInputGhostStatePauseMenu
// (Actor)

class UClass* ACGNoInputGhostStatePauseMenu::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNoInputGhostStatePauseMenu");

	return Clss;
}


// CGNoInputGhostStatePauseMenu ChernobylGame.Default__CGNoInputGhostStatePauseMenu
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNoInputGhostStatePauseMenu* ACGNoInputGhostStatePauseMenu::GetDefaultObj()
{
	static class ACGNoInputGhostStatePauseMenu* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNoInputGhostStatePauseMenu*>(ACGNoInputGhostStatePauseMenu::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNoneState
// (Actor)

class UClass* ACGNoneState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNoneState");

	return Clss;
}


// CGNoneState ChernobylGame.Default__CGNoneState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNoneState* ACGNoneState::GetDefaultObj()
{
	static class ACGNoneState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNoneState*>(ACGNoneState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGNPC
// (Actor, Pawn)

class UClass* ACGNPC::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNPC");

	return Clss;
}


// CGNPC ChernobylGame.Default__CGNPC
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGNPC* ACGNPC::GetDefaultObj()
{
	static class ACGNPC* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGNPC*>(ACGNPC::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGNPC.UpdateStartingTransform_CPP
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGNPC::UpdateStartingTransform_CPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "UpdateStartingTransform_CPP");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGNPC.UpdateNPCTeams
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGNPC::UpdateNPCTeams()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "UpdateNPCTeams");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.ShowNPC
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGNPC::ShowNPC()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "ShowNPC");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGNPC.SetFrightened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGNPC::SetFrightened(bool bInValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "SetFrightened");

	Params::ACGNPC_SetFrightened_Params Parms{};

	Parms.bInValue = bInValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.SetBuildingInteractionStats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNPCBuildingInteractionStatsInStats                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGNPC::SetBuildingInteractionStats(struct FNPCBuildingInteractionStats& InStats)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "SetBuildingInteractionStats");

	Params::ACGNPC_SetBuildingInteractionStats_Params Parms{};

	Parms.InStats = InStats;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.OnHeroCombatLeft
// (Final, Native, Public)
// Parameters:

void ACGNPC::OnHeroCombatLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "OnHeroCombatLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.OnHeroCombatEntered
// (Final, Native, Public)
// Parameters:

void ACGNPC::OnHeroCombatEntered()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "OnHeroCombatEntered");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.ImportantQuestIntroduction
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGNPC::ImportantQuestIntroduction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "ImportantQuestIntroduction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPC.HideNPC
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGNPC::HideNPC()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "HideNPC");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGNPC.GetBuildingInteractionStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FNPCBuildingInteractionStatsReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNPCBuildingInteractionStats ACGNPC::GetBuildingInteractionStats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "GetBuildingInteractionStats");

	Params::ACGNPC_GetBuildingInteractionStats_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGNPC.FixStartingRotation_CPP
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGNPC::FixStartingRotation_CPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "FixStartingRotation_CPP");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGNPC.BindCombatDelegatesPostInit
// (Final, Native, Protected)
// Parameters:

void ACGNPC::BindCombatDelegatesPostInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPC", "BindCombatDelegatesPostInit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGNPCHeadTracingComponent
// (None)

class UClass* UCGNPCHeadTracingComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGNPCHeadTracingComponent");

	return Clss;
}


// CGNPCHeadTracingComponent ChernobylGame.Default__CGNPCHeadTracingComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGNPCHeadTracingComponent* UCGNPCHeadTracingComponent::GetDefaultObj()
{
	static class UCGNPCHeadTracingComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGNPCHeadTracingComponent*>(UCGNPCHeadTracingComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGNPCHeadTracingComponent.SetNPCHeadTracingEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewEnabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGNPCHeadTracingComponent::SetNPCHeadTracingEnabled(bool bInNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPCHeadTracingComponent", "SetNPCHeadTracingEnabled");

	Params::UCGNPCHeadTracingComponent_SetNPCHeadTracingEnabled_Params Parms{};

	Parms.bInNewEnabled = bInNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPCHeadTracingComponent.NPCHeadTracingTick
// (Final, Native, Private)
// Parameters:

void UCGNPCHeadTracingComponent::NPCHeadTracingTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPCHeadTracingComponent", "NPCHeadTracingTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGNPCHeadTracingComponent.GetHeroInTracing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGNPCHeadTracingComponent::GetHeroInTracing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGNPCHeadTracingComponent", "GetHeroInTracing");

	Params::UCGNPCHeadTracingComponent_GetHeroInTracing_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGOnScreenLog
// (None)

class UClass* UCGOnScreenLog::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGOnScreenLog");

	return Clss;
}


// CGOnScreenLog ChernobylGame.Default__CGOnScreenLog
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGOnScreenLog* UCGOnScreenLog::GetDefaultObj()
{
	static class UCGOnScreenLog* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGOnScreenLog*>(UCGOnScreenLog::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGOnScreenLog.OnAIDamageReceived
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                      InDamageCauser                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InDamageReceiver                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              InDamage                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGOnScreenLog::OnAIDamageReceived(class AActor* InDamageCauser, class AActor* InDamageReceiver, struct FCGDamageEvent& InDamageEvent, float InDamage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGOnScreenLog", "OnAIDamageReceived");

	Params::UCGOnScreenLog_OnAIDamageReceived_Params Parms{};

	Parms.InDamageCauser = InDamageCauser;
	Parms.InDamageReceiver = InDamageReceiver;
	Parms.InDamageEvent = InDamageEvent;
	Parms.InDamage = InDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGPathFollowingComponent
// (None)

class UClass* UCGPathFollowingComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPathFollowingComponent");

	return Clss;
}


// CGPathFollowingComponent ChernobylGame.Default__CGPathFollowingComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGPathFollowingComponent* UCGPathFollowingComponent::GetDefaultObj()
{
	static class UCGPathFollowingComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGPathFollowingComponent*>(UCGPathFollowingComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPathFollowingComponent.K2_GetRemainingPathCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCGPathFollowingComponent::K2_GetRemainingPathCost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPathFollowingComponent", "K2_GetRemainingPathCost");

	Params::UCGPathFollowingComponent_K2_GetRemainingPathCost_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGPathFollowingComponent.GetIsAIDecelerating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGPathFollowingComponent::GetIsAIDecelerating()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPathFollowingComponent", "GetIsAIDecelerating");

	Params::UCGPathFollowingComponent_GetIsAIDecelerating_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGPDAState
// (Actor)

class UClass* ACGPDAState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPDAState");

	return Clss;
}


// CGPDAState ChernobylGame.Default__CGPDAState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPDAState* ACGPDAState::GetDefaultObj()
{
	static class ACGPDAState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPDAState*>(ACGPDAState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPDAState.ShowingAnimFinished
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                InMontage                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InInterrupted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPDAState::ShowingAnimFinished(class UAnimMontage* InMontage, bool InInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPDAState", "ShowingAnimFinished");

	Params::ACGPDAState_ShowingAnimFinished_Params Parms{};

	Parms.InMontage = InMontage;
	Parms.InInterrupted = InInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPDAState.QueryFinished
// (Final, Native, Public)
// Parameters:
// enum class EState                  InInitialItemState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGActiveItem>   InInitialItemClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPDAState::QueryFinished(enum class EState InInitialItemState, TSubclassOf<class ACGActiveItem> InInitialItemClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPDAState", "QueryFinished");

	Params::ACGPDAState_QueryFinished_Params Parms{};

	Parms.InInitialItemState = InInitialItemState;
	Parms.InInitialItemClass = InInitialItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGPerceptionVolume
// (Actor)

class UClass* ACGPerceptionVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPerceptionVolume");

	return Clss;
}


// CGPerceptionVolume ChernobylGame.Default__CGPerceptionVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPerceptionVolume* ACGPerceptionVolume::GetDefaultObj()
{
	static class ACGPerceptionVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPerceptionVolume*>(ACGPerceptionVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPerceptionVolume.GetBPIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGPerceptionVolume::GetBPIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPerceptionVolume", "GetBPIndex");

	Params::ACGPerceptionVolume_GetBPIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGPhotoModeCameraController
// (Actor, PlayerController)

class UClass* ACGPhotoModeCameraController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeCameraController");

	return Clss;
}


// CGPhotoModeCameraController ChernobylGame.Default__CGPhotoModeCameraController
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeCameraController* ACGPhotoModeCameraController::GetDefaultObj()
{
	static class ACGPhotoModeCameraController* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeCameraController*>(ACGPhotoModeCameraController::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPhotoModeCameraController.SetViewRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewViewRoll                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeCameraController::SetViewRoll(float NewViewRoll)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "SetViewRoll");

	Params::ACGPhotoModeCameraController_SetViewRoll_Params Parms{};

	Parms.NewViewRoll = NewViewRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeCameraController.SetFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewFOV                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeCameraController::SetFOV(float NewFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "SetFOV");

	Params::ACGPhotoModeCameraController_SetFOV_Params Parms{};

	Parms.NewFOV = NewFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeCameraController.ScreenshotRequestProcessed
// (Final, Native, Private)
// Parameters:

void ACGPhotoModeCameraController::ScreenshotRequestProcessed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "ScreenshotRequestProcessed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeCameraController.ResetTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGPhotoModeCameraController::ResetTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "ResetTransform");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeCameraController.RequestScreenshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGPhotoModeCameraController::RequestScreenshot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "RequestScreenshot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeCameraController.OnPreUICreation
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGPhotoModeCameraController::OnPreUICreation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "OnPreUICreation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeCameraController.GetViewRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGPhotoModeCameraController::GetViewRoll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "GetViewRoll");

	Params::ACGPhotoModeCameraController_GetViewRoll_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGPhotoModeCameraController.GetPawnCameraComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*            ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ACGPhotoModeCameraController::GetPawnCameraComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "GetPawnCameraComponent");

	Params::ACGPhotoModeCameraController_GetPawnCameraComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGPhotoModeCameraController.GetFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGPhotoModeCameraController::GetFOV()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeCameraController", "GetFOV");

	Params::ACGPhotoModeCameraController_GetFOV_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGPhotoModeCameraManager
// (Actor)

class UClass* ACGPhotoModeCameraManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeCameraManager");

	return Clss;
}


// CGPhotoModeCameraManager ChernobylGame.Default__CGPhotoModeCameraManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeCameraManager* ACGPhotoModeCameraManager::GetDefaultObj()
{
	static class ACGPhotoModeCameraManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeCameraManager*>(ACGPhotoModeCameraManager::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGPhotoModeMovementState
// (Actor)

class UClass* ACGPhotoModeMovementState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeMovementState");

	return Clss;
}


// CGPhotoModeMovementState ChernobylGame.Default__CGPhotoModeMovementState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeMovementState* ACGPhotoModeMovementState::GetDefaultObj()
{
	static class ACGPhotoModeMovementState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeMovementState*>(ACGPhotoModeMovementState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPhotoModeMovementState.Utility_AnyKeyboardKey_Pressed
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Utility_AnyKeyboardKey_Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Utility_AnyKeyboardKey_Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Utility_AnyGamepadKey_Pressed
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Utility_AnyGamepadKey_Pressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Utility_AnyGamepadKey_Pressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_ZoomUp
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_ZoomUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_ZoomUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_ZoomDown
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_ZoomDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_ZoomDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUseScroll
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUseScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUseScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse8
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse8()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse8");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse7
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse7()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse7");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse6
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse6()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse6");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse5
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse5()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse5");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse4
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse3
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse2
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse1
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_QuickUse
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_QuickUse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_QuickUse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_Pause
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_MoveUp
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_MoveUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_MoveUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_MoveRight
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_MoveRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_MoveRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_MoveLeft
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_MoveLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_MoveLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_MoveDown
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_MoveDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_MoveDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_Map
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_Map()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_Map");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_Inventory
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_Inventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_Inventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_Grab_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_Grab_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_Grab_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Shortcuts_Grab
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Shortcuts_Grab()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Shortcuts_Grab");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Up
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Sprint_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Sprint_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Sprint_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Sprint
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Sprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Sprint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Right_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Right_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Right_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Right
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Left_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Left_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Left_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Left
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Jump_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Jump_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Jump_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Jump
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Jump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Jump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Down
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Crouch_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Crouch_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Crouch_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Movement_Crouch
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Movement_Crouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Movement_Crouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Use_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Use_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Use_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Use
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Use()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Use");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_UI_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_UI_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_UI_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_UI
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_UI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_UI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Tabs_Right
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Tabs_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Tabs_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Tabs_Left
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Tabs_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Tabs_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Scrap
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Scrap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Scrap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Reload_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Reload_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Reload_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Reload
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Reload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Reload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_HideWeapon
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_HideWeapon()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_HideWeapon");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Flashlight
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Flashlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Flashlight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_BuildSystem
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_BuildSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_BuildSystem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Attack_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Attack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Attack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Attack
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_AlternativeAttack_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_AlternativeAttack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_AlternativeAttack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_AlternativeAttack
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_AlternativeAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_AlternativeAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Accept_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Accept_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Accept_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_Interaction_Accept
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_Interaction_Accept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_Interaction_Accept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_CustomEscape
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_CustomEscape()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_CustomEscape");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.PC_CustomBackSpace
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::PC_CustomBackSpace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "PC_CustomBackSpace");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.OnAnyKey
// (Final, Native, Public)
// Parameters:

void ACGPhotoModeMovementState::OnAnyKey()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "OnAnyKey");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Global_Movement_UpDown
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Global_Movement_UpDown(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Global_Movement_UpDown");

	Params::ACGPhotoModeMovementState_Global_Movement_UpDown_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Global_Movement_RightLeft
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Global_Movement_RightLeft(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Global_Movement_RightLeft");

	Params::ACGPhotoModeMovementState_Global_Movement_RightLeft_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Global_Movement_Look_UpDown
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Global_Movement_Look_UpDown(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Global_Movement_Look_UpDown");

	Params::ACGPhotoModeMovementState_Global_Movement_Look_UpDown_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Global_Movement_Look_RightLeft
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Global_Movement_Look_RightLeft(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Global_Movement_Look_RightLeft");

	Params::ACGPhotoModeMovementState_Global_Movement_Look_RightLeft_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Global_Movement_Lean
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Global_Movement_Lean(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Global_Movement_Lean");

	Params::ACGPhotoModeMovementState_Global_Movement_Lean_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse4_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse4_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse4_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse4
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse3
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse2_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse2_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse2_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse2
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_QuickUse1
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_QuickUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_QuickUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Shortcuts_Pause
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Shortcuts_Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Shortcuts_Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Up
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Sprint_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Sprint_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Sprint_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Sprint
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Sprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Sprint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Rotate_Right
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Console_Movement_Rotate_Right(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Rotate_Right");

	Params::ACGPhotoModeMovementState_Console_Movement_Rotate_Right_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Rotate_Left
// (Native, Public)
// Parameters:
// float                              AxisValue                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModeMovementState::Console_Movement_Rotate_Left(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Rotate_Left");

	Params::ACGPhotoModeMovementState_Console_Movement_Rotate_Left_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Right
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Reloading_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Reloading_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Reloading_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Reloading
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Reloading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Reloading");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Left
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Jump_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Jump_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Jump_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Jump
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Jump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Jump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Down
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Crouch_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Crouch_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Crouch_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Movement_Crouch
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Movement_Crouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Movement_Crouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_UI_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_UI_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_UI_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_UI
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_UI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_UI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_Tabs_Right
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_Tabs_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_Tabs_Right");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_Tabs_Left
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_Tabs_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_Tabs_Left");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_Scrap
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_Scrap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_Scrap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_FlashLight
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_FlashLight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_FlashLight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_Attack_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_Attack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_Attack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_Attack
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_AlternativeAttack_Release
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_AlternativeAttack_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_AlternativeAttack_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModeMovementState.Console_Interaction_AlternativeAttack
// (Native, Public)
// Parameters:

void ACGPhotoModeMovementState::Console_Interaction_AlternativeAttack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeMovementState", "Console_Interaction_AlternativeAttack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGPhotoModeFreeCameraState
// (Actor)

class UClass* ACGPhotoModeFreeCameraState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeFreeCameraState");

	return Clss;
}


// CGPhotoModeFreeCameraState ChernobylGame.Default__CGPhotoModeFreeCameraState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeFreeCameraState* ACGPhotoModeFreeCameraState::GetDefaultObj()
{
	static class ACGPhotoModeFreeCameraState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeFreeCameraState*>(ACGPhotoModeFreeCameraState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGPhotoModePawn
// (Actor, Pawn)

class UClass* ACGPhotoModePawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModePawn");

	return Clss;
}


// CGPhotoModePawn ChernobylGame.Default__CGPhotoModePawn
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModePawn* ACGPhotoModePawn::GetDefaultObj()
{
	static class ACGPhotoModePawn* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModePawn*>(ACGPhotoModePawn::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPhotoModePawn.SetNewInputState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACGPhotoModeMovementState>NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPhotoModePawn::SetNewInputState(TSubclassOf<class ACGPhotoModeMovementState> NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModePawn", "SetNewInputState");

	Params::ACGPhotoModePawn_SetNewInputState_Params Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPhotoModePawn.GetCurrentInputState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGPhotoModeMovementState*   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGPhotoModeMovementState* ACGPhotoModePawn::GetCurrentInputState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModePawn", "GetCurrentInputState");

	Params::ACGPhotoModePawn_GetCurrentInputState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGPhotoModeScreenshotState
// (Actor)

class UClass* ACGPhotoModeScreenshotState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeScreenshotState");

	return Clss;
}


// CGPhotoModeScreenshotState ChernobylGame.Default__CGPhotoModeScreenshotState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeScreenshotState* ACGPhotoModeScreenshotState::GetDefaultObj()
{
	static class ACGPhotoModeScreenshotState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeScreenshotState*>(ACGPhotoModeScreenshotState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGPhotoModeUIState
// (Actor)

class UClass* ACGPhotoModeUIState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeUIState");

	return Clss;
}


// CGPhotoModeUIState ChernobylGame.Default__CGPhotoModeUIState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPhotoModeUIState* ACGPhotoModeUIState::GetDefaultObj()
{
	static class ACGPhotoModeUIState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPhotoModeUIState*>(ACGPhotoModeUIState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGPhotoModeWidget
// (None)

class UClass* UCGPhotoModeWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhotoModeWidget");

	return Clss;
}


// CGPhotoModeWidget ChernobylGame.Default__CGPhotoModeWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGPhotoModeWidget* UCGPhotoModeWidget::GetDefaultObj()
{
	static class UCGPhotoModeWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGPhotoModeWidget*>(UCGPhotoModeWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPhotoModeWidget.OnUIStateChange
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EPhotoModeUIState       NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGPhotoModeWidget::OnUIStateChange(enum class EPhotoModeUIState NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "OnUIStateChange");

	Params::UCGPhotoModeWidget_OnUIStateChange_Params Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGPhotoModeWidget.OnEnterUIState
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::OnEnterUIState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "OnEnterUIState");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputUpDown
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGPhotoModeWidget::InputUpDown(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputUpDown");

	Params::UCGPhotoModeWidget_InputUpDown_Params Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGPhotoModeWidget.InputUp
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputUp");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputToggleUI
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputToggleUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputToggleUI");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputToggleMode
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputToggleMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputToggleMode");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputRightReleased
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputRightReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputRightReleased");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputRight
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputRight");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputResetSettings
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputResetSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputResetSettings");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputRequestScreenshot
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputRequestScreenshot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputRequestScreenshot");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputLeftRight
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGPhotoModeWidget::InputLeftRight(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputLeftRight");

	Params::UCGPhotoModeWidget_InputLeftRight_Params Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGPhotoModeWidget.InputLeftReleased
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputLeftReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputLeftReleased");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputLeft
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputLeft");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputDown
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputDown");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGPhotoModeWidget.InputBack
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGPhotoModeWidget::InputBack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhotoModeWidget", "InputBack");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.CGPhysicalMaterial
// (None)

class UClass* UCGPhysicalMaterial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhysicalMaterial");

	return Clss;
}


// CGPhysicalMaterial ChernobylGame.Default__CGPhysicalMaterial
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGPhysicalMaterial* UCGPhysicalMaterial::GetDefaultObj()
{
	static class UCGPhysicalMaterial* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGPhysicalMaterial*>(UCGPhysicalMaterial::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGPhysicsUtil
// (None)

class UClass* UCGPhysicsUtil::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPhysicsUtil");

	return Clss;
}


// CGPhysicsUtil ChernobylGame.Default__CGPhysicsUtil
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGPhysicsUtil* UCGPhysicsUtil::GetDefaultObj()
{
	static class UCGPhysicsUtil* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGPhysicsUtil*>(UCGPhysicsUtil::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPhysicsUtil.GetAllCollisionChannels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<enum class ECollisionChannel>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<enum class ECollisionChannel> UCGPhysicsUtil::GetAllCollisionChannels()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPhysicsUtil", "GetAllCollisionChannels");

	Params::UCGPhysicsUtil_GetAllCollisionChannels_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGPlayCustomAnimInterface
// (None)

class UClass* ICGPlayCustomAnimInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPlayCustomAnimInterface");

	return Clss;
}


// CGPlayCustomAnimInterface ChernobylGame.Default__CGPlayCustomAnimInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ICGPlayCustomAnimInterface* ICGPlayCustomAnimInterface::GetDefaultObj()
{
	static class ICGPlayCustomAnimInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ICGPlayCustomAnimInterface*>(ICGPlayCustomAnimInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPlayCustomAnimInterface.Set
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ICGPlayCustomAnimInterface::Set()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayCustomAnimInterface", "Set");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPlayCustomAnimInterface.Init
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*           InCustomAnim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartPosition                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICGPlayCustomAnimInterface::Init(class UAnimSequenceBase* InCustomAnim, float InStartPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayCustomAnimInterface", "Init");

	Params::ICGPlayCustomAnimInterface_Init_Params Parms{};

	Parms.InCustomAnim = InCustomAnim;
	Parms.InStartPosition = InStartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGPlayerCameraManager
// (Actor)

class UClass* ACGPlayerCameraManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPlayerCameraManager");

	return Clss;
}


// CGPlayerCameraManager ChernobylGame.Default__CGPlayerCameraManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPlayerCameraManager* ACGPlayerCameraManager::GetDefaultObj()
{
	static class ACGPlayerCameraManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPlayerCameraManager*>(ACGPlayerCameraManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPlayerCameraManager.StartCameraFadeInOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InFadeInTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InFadeOutTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPlayerCameraManager::StartCameraFadeInOut(float InFadeInTime, float InFadeOutTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayerCameraManager", "StartCameraFadeInOut");

	Params::ACGPlayerCameraManager_StartCameraFadeInOut_Params Parms{};

	Parms.InFadeInTime = InFadeInTime;
	Parms.InFadeOutTime = InFadeOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPlayerCameraManager.SetCustomBlurModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Modifier                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPlayerCameraManager::SetCustomBlurModifier(bool bIsEnabled, float Modifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayerCameraManager", "SetCustomBlurModifier");

	Params::ACGPlayerCameraManager_SetCustomBlurModifier_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGPlayerController
// (Actor, PlayerController)

class UClass* ACGPlayerController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGPlayerController");

	return Clss;
}


// CGPlayerController ChernobylGame.Default__CGPlayerController
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGPlayerController* ACGPlayerController::GetDefaultObj()
{
	static class ACGPlayerController* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGPlayerController*>(ACGPlayerController::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGPlayerController.ReleaseAllKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGPlayerController::ReleaseAllKeys()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayerController", "ReleaseAllKeys");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGPlayerController.OnInputDeviceChanged
// (Final, Native, Private)
// Parameters:
// bool                               bIsGamepadInput                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGPlayerController::OnInputDeviceChanged(bool bIsGamepadInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGPlayerController", "OnInputDeviceChanged");

	Params::ACGPlayerController_OnInputDeviceChanged_Params Parms{};

	Parms.bIsGamepadInput = bIsGamepadInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGProjectile
// (Actor)

class UClass* ACGProjectile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGProjectile");

	return Clss;
}


// CGProjectile ChernobylGame.Default__CGProjectile
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGProjectile* ACGProjectile::GetDefaultObj()
{
	static class ACGProjectile* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGProjectile*>(ACGProjectile::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGProjectile.OnProjectileCollisionBeginOverlap
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         InOverlappedComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InOtherComp                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InOtherBodyIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFromSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  InSweepResult                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACGProjectile::OnProjectileCollisionBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGProjectile", "OnProjectileCollisionBeginOverlap");

	Params::ACGProjectile_OnProjectileCollisionBeginOverlap_Params Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = InSweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGRaportState
// (Actor)

class UClass* ACGRaportState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGRaportState");

	return Clss;
}


// CGRaportState ChernobylGame.Default__CGRaportState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGRaportState* ACGRaportState::GetDefaultObj()
{
	static class ACGRaportState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGRaportState*>(ACGRaportState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGResourceArea
// (Actor)

class UClass* ACGResourceArea::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGResourceArea");

	return Clss;
}


// CGResourceArea ChernobylGame.Default__CGResourceArea
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGResourceArea* ACGResourceArea::GetDefaultObj()
{
	static class ACGResourceArea* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGResourceArea*>(ACGResourceArea::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGResourceDistributor
// (Actor)

class UClass* ACGResourceDistributor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGResourceDistributor");

	return Clss;
}


// CGResourceDistributor ChernobylGame.Default__CGResourceDistributor
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGResourceDistributor* ACGResourceDistributor::GetDefaultObj()
{
	static class ACGResourceDistributor* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGResourceDistributor*>(ACGResourceDistributor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGResourceDistributor.SetMultiThread
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                               bTickAnywhere                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGResourceDistributor::SetMultiThread(bool bTickAnywhere)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGResourceDistributor", "SetMultiThread");

	Params::ACGResourceDistributor_SetMultiThread_Params Parms{};

	Parms.bTickAnywhere = bTickAnywhere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGResourceManager
// (Actor)

class UClass* ACGResourceManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGResourceManager");

	return Clss;
}


// CGResourceManager ChernobylGame.Default__CGResourceManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGResourceManager* ACGResourceManager::GetDefaultObj()
{
	static class ACGResourceManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGResourceManager*>(ACGResourceManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGResourceManager.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGResourceManager::Update()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGResourceManager", "Update");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGRichTextBlockImageDecorator
// (None)

class UClass* UCGRichTextBlockImageDecorator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGRichTextBlockImageDecorator");

	return Clss;
}


// CGRichTextBlockImageDecorator ChernobylGame.Default__CGRichTextBlockImageDecorator
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGRichTextBlockImageDecorator* UCGRichTextBlockImageDecorator::GetDefaultObj()
{
	static class UCGRichTextBlockImageDecorator* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGRichTextBlockImageDecorator*>(UCGRichTextBlockImageDecorator::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSense_Hearing
// (None)

class UClass* UCGSense_Hearing::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSense_Hearing");

	return Clss;
}


// CGSense_Hearing ChernobylGame.Default__CGSense_Hearing
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGSense_Hearing* UCGSense_Hearing::GetDefaultObj()
{
	static class UCGSense_Hearing* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGSense_Hearing*>(UCGSense_Hearing::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSense_Sight
// (None)

class UClass* UCGSense_Sight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSense_Sight");

	return Clss;
}


// CGSense_Sight ChernobylGame.Default__CGSense_Sight
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGSense_Sight* UCGSense_Sight::GetDefaultObj()
{
	static class UCGSense_Sight* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGSense_Sight*>(UCGSense_Sight::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSenseConfig_Hearing
// (None)

class UClass* UCGSenseConfig_Hearing::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSenseConfig_Hearing");

	return Clss;
}


// CGSenseConfig_Hearing ChernobylGame.Default__CGSenseConfig_Hearing
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGSenseConfig_Hearing* UCGSenseConfig_Hearing::GetDefaultObj()
{
	static class UCGSenseConfig_Hearing* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGSenseConfig_Hearing*>(UCGSenseConfig_Hearing::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSenseConfig_Sight
// (None)

class UClass* UCGSenseConfig_Sight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSenseConfig_Sight");

	return Clss;
}


// CGSenseConfig_Sight ChernobylGame.Default__CGSenseConfig_Sight
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGSenseConfig_Sight* UCGSenseConfig_Sight::GetDefaultObj()
{
	static class UCGSenseConfig_Sight* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGSenseConfig_Sight*>(UCGSenseConfig_Sight::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGShadow
// (Actor, Pawn)

class UClass* ACGShadow::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGShadow");

	return Clss;
}


// CGShadow ChernobylGame.Default__CGShadow
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGShadow* ACGShadow::GetDefaultObj()
{
	static class ACGShadow* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGShadow*>(ACGShadow::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGShadow.WallTeleportOutAnim_Finish
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                InAnimMontage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InWasInterrupted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::WallTeleportOutAnim_Finish(class UAnimMontage* InAnimMontage, bool InWasInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "WallTeleportOutAnim_Finish");

	Params::ACGShadow_WallTeleportOutAnim_Finish_Params Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InWasInterrupted = InWasInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.WallTeleportAnim_Finish
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                InAnimMontage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InWasInterrupted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::WallTeleportAnim_Finish(class UAnimMontage* InAnimMontage, bool InWasInterrupted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "WallTeleportAnim_Finish");

	Params::ACGShadow_WallTeleportAnim_Finish_Params Parms{};

	Parms.InAnimMontage = InAnimMontage;
	Parms.InWasInterrupted = InWasInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.ShadowUseTeleporter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportBase*       InTargetTeleporter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDuration                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                InMontageToPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::ShadowUseTeleporter(class ACGShadowTeleportBase* InTargetTeleporter, float InDuration, class UAnimMontage* InMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "ShadowUseTeleporter");

	Params::ACGShadow_ShadowUseTeleporter_Params Parms{};

	Parms.InTargetTeleporter = InTargetTeleporter;
	Parms.InDuration = InDuration;
	Parms.InMontageToPlay = InMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.ShadowComeOutOfTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportBase*       InTargetTeleporter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                InMontageToPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::ShadowComeOutOfTeleport(class ACGShadowTeleportBase* InTargetTeleporter, class UAnimMontage* InMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "ShadowComeOutOfTeleport");

	Params::ACGShadow_ShadowComeOutOfTeleport_Params Parms{};

	Parms.InTargetTeleporter = InTargetTeleporter;
	Parms.InMontageToPlay = InMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.SetNewTeleportingArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportingAreaBase*InNewArea                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::SetNewTeleportingArea(class ACGShadowTeleportingAreaBase* InNewArea)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "SetNewTeleportingArea");

	Params::ACGShadow_SetNewTeleportingArea_Params Parms{};

	Parms.InNewArea = InNewArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.SetDissolveDeathFunctionOverride
// (Native, Public, BlueprintCallable)
// Parameters:

void ACGShadow::SetDissolveDeathFunctionOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "SetDissolveDeathFunctionOverride");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.OnDeathDissolve
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGShadow::OnDeathDissolve()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "OnDeathDissolve");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGShadow.GetOverlappingTeleportAreas
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGShadowTeleportingAreaBase*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGShadowTeleportingAreaBase*> ACGShadow::GetOverlappingTeleportAreas()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "GetOverlappingTeleportAreas");

	Params::ACGShadow_GetOverlappingTeleportAreas_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.GetCurrentTeleportingArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGShadowTeleportingAreaBase*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportingAreaBase* ACGShadow::GetCurrentTeleportingArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "GetCurrentTeleportingArea");

	Params::ACGShadow_GetCurrentTeleportingArea_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.GetAssociatedCombatZones
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ACGShadowCombatZoneBase*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGShadowCombatZoneBase*> ACGShadow::GetAssociatedCombatZones()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "GetAssociatedCombatZones");

	Params::ACGShadow_GetAssociatedCombatZones_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.FindWarpProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInShouldDebug                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadow::FindWarpProperties(bool bInShouldDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "FindWarpProperties");

	Params::ACGShadow_FindWarpProperties_Params Parms{};

	Parms.bInShouldDebug = bInShouldDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.FindTeleportersInRadius
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACGShadowTeleportingAreaBase*InArea                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTargetLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMaxPathLength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGShadowTeleportBase*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGShadowTeleportBase*> ACGShadow::FindTeleportersInRadius(class ACGShadowTeleportingAreaBase* InArea, const struct FVector& InTargetLocation, float InRadius, float InMaxPathLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "FindTeleportersInRadius");

	Params::ACGShadow_FindTeleportersInRadius_Params Parms{};

	Parms.InArea = InArea;
	Parms.InTargetLocation = InTargetLocation;
	Parms.InRadius = InRadius;
	Parms.InMaxPathLength = InMaxPathLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.FindPossibleTeleportConnection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InTarget                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTeleportationRoutePair     ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTeleportationRoutePair ACGShadow::FindPossibleTeleportConnection(const struct FVector& InTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "FindPossibleTeleportConnection");

	Params::ACGShadow_FindPossibleTeleportConnection_Params Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.FindClosestTeleporter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportingAreaBase*InArea                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTargetLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGShadowTeleportBase*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportBase* ACGShadow::FindClosestTeleporter(class ACGShadowTeleportingAreaBase* InArea, const struct FVector& InTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "FindClosestTeleporter");

	Params::ACGShadow_FindClosestTeleporter_Params Parms{};

	Parms.InArea = InArea;
	Parms.InTargetLocation = InTargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadow.ClearAssociatedCombatZones
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGShadow::ClearAssociatedCombatZones()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "ClearAssociatedCombatZones");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadow.BeginPlayFindTP
// (Native, Protected, HasOutParams)
// Parameters:
// class ACGShadowTeleportingAreaBase*InInitialArea                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APatrolActor*>        InPatrolActors                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACGShadow::BeginPlayFindTP(class ACGShadowTeleportingAreaBase* InInitialArea, TArray<class APatrolActor*>* InPatrolActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "BeginPlayFindTP");

	Params::ACGShadow_BeginPlayFindTP_Params Parms{};

	Parms.InInitialArea = InInitialArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InPatrolActors != nullptr)
		*InPatrolActors = std::move(Parms.InPatrolActors);

}


// Function ChernobylGame.CGShadow.BeginPlayFindPatrol
// (Native, Protected, HasOutParams)
// Parameters:
// TArray<class APatrolActor*>        InPatrolActors                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACGShadow::BeginPlayFindPatrol(TArray<class APatrolActor*>* InPatrolActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadow", "BeginPlayFindPatrol");

	Params::ACGShadow_BeginPlayFindPatrol_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InPatrolActors != nullptr)
		*InPatrolActors = std::move(Parms.InPatrolActors);

}


// Class ChernobylGame.CGShadowAggroComponent
// (None)

class UClass* UCGShadowAggroComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGShadowAggroComponent");

	return Clss;
}


// CGShadowAggroComponent ChernobylGame.Default__CGShadowAggroComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGShadowAggroComponent* UCGShadowAggroComponent::GetDefaultObj()
{
	static class UCGShadowAggroComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGShadowAggroComponent*>(UCGShadowAggroComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGShadowCombatZoneBase
// (Actor)

class UClass* ACGShadowCombatZoneBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGShadowCombatZoneBase");

	return Clss;
}


// CGShadowCombatZoneBase ChernobylGame.Default__CGShadowCombatZoneBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGShadowCombatZoneBase* ACGShadowCombatZoneBase::GetDefaultObj()
{
	static class ACGShadowCombatZoneBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGShadowCombatZoneBase*>(ACGShadowCombatZoneBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGShadowCombatZoneBase.OnShadowLeft
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*         InOverlappedComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InOtherComp                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InOtherBodyIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadowCombatZoneBase::OnShadowLeft(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowCombatZoneBase", "OnShadowLeft");

	Params::ACGShadowCombatZoneBase_OnShadowLeft_Params Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGShadowCombatZoneBase.OnShadowEntered
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         InOverlappedComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InOtherComp                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InOtherBodyIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InbFromSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  InSweepResult                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACGShadowCombatZoneBase::OnShadowEntered(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool InbFromSweep, struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowCombatZoneBase", "OnShadowEntered");

	Params::ACGShadowCombatZoneBase_OnShadowEntered_Params Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.InbFromSweep = InbFromSweep;
	Parms.InSweepResult = InSweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGShadowTeleportBase
// (Actor)

class UClass* ACGShadowTeleportBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGShadowTeleportBase");

	return Clss;
}


// CGShadowTeleportBase ChernobylGame.Default__CGShadowTeleportBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGShadowTeleportBase* ACGShadowTeleportBase::GetDefaultObj()
{
	static class ACGShadowTeleportBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGShadowTeleportBase*>(ACGShadowTeleportBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGShadowTeleportBase.ScheduleEnabled
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadowTeleportBase::ScheduleEnabled(float InTime, bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "ScheduleEnabled");

	Params::ACGShadowTeleportBase_ScheduleEnabled_Params Parms{};

	Parms.InTime = InTime;
	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGShadowTeleportBase.OnLeaving
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGShadowTeleportBase::OnLeaving()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "OnLeaving");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGShadowTeleportBase.OnEntering
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGShadowTeleportBase::OnEntering()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "OnEntering");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGShadowTeleportBase.GetRandomValidTeleport
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGShadowTeleportBase*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportBase* ACGShadowTeleportBase::GetRandomValidTeleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "GetRandomValidTeleport");

	Params::ACGShadowTeleportBase_GetRandomValidTeleport_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadowTeleportBase.GetRandomNextTeleport
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ACGShadowTeleportBase*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportBase* ACGShadowTeleportBase::GetRandomNextTeleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "GetRandomNextTeleport");

	Params::ACGShadowTeleportBase_GetRandomNextTeleport_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadowTeleportBase.GetRandomNextPatrolPoint
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AShadowPatrolActor*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AShadowPatrolActor* ACGShadowTeleportBase::GetRandomNextPatrolPoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "GetRandomNextPatrolPoint");

	Params::ACGShadowTeleportBase_GetRandomNextPatrolPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadowTeleportBase.GetOverlappingArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGShadowTeleportingAreaBase*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGShadowTeleportingAreaBase* ACGShadowTeleportBase::GetOverlappingArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportBase", "GetOverlappingArea");

	Params::ACGShadowTeleportBase_GetOverlappingArea_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGShadowTeleportingAreaBase
// (Actor)

class UClass* ACGShadowTeleportingAreaBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGShadowTeleportingAreaBase");

	return Clss;
}


// CGShadowTeleportingAreaBase ChernobylGame.Default__CGShadowTeleportingAreaBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGShadowTeleportingAreaBase* ACGShadowTeleportingAreaBase::GetDefaultObj()
{
	static class ACGShadowTeleportingAreaBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGShadowTeleportingAreaBase*>(ACGShadowTeleportingAreaBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGShadowTeleportingAreaBase.GetRandomAreaFromAdjacent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAdjacentAreaQueryResult    InOutAdjacentAreaQuery                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               InShouldPrioritiseHero                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InChanceToChooseHero                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGShadowTeleportingAreaBase::GetRandomAreaFromAdjacent(struct FAdjacentAreaQueryResult* InOutAdjacentAreaQuery, bool InShouldPrioritiseHero, float InChanceToChooseHero)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportingAreaBase", "GetRandomAreaFromAdjacent");

	Params::ACGShadowTeleportingAreaBase_GetRandomAreaFromAdjacent_Params Parms{};

	Parms.InShouldPrioritiseHero = InShouldPrioritiseHero;
	Parms.InChanceToChooseHero = InChanceToChooseHero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InOutAdjacentAreaQuery != nullptr)
		*InOutAdjacentAreaQuery = std::move(Parms.InOutAdjacentAreaQuery);

}


// Function ChernobylGame.CGShadowTeleportingAreaBase.GetAssociatedTeleports
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGShadowTeleportBase*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGShadowTeleportBase*> ACGShadowTeleportingAreaBase::GetAssociatedTeleports()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportingAreaBase", "GetAssociatedTeleports");

	Params::ACGShadowTeleportingAreaBase_GetAssociatedTeleports_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGShadowTeleportingAreaBase.GetAssociatedPatrolActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APatrolActor*>        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APatrolActor*> ACGShadowTeleportingAreaBase::GetAssociatedPatrolActors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGShadowTeleportingAreaBase", "GetAssociatedPatrolActors");

	Params::ACGShadowTeleportingAreaBase_GetAssociatedPatrolActors_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGSlowModeState
// (Actor)

class UClass* ACGSlowModeState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSlowModeState");

	return Clss;
}


// CGSlowModeState ChernobylGame.Default__CGSlowModeState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGSlowModeState* ACGSlowModeState::GetDefaultObj()
{
	static class ACGSlowModeState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGSlowModeState*>(ACGSlowModeState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSmallTimer
// (None)

class UClass* UCGSmallTimer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSmallTimer");

	return Clss;
}


// CGSmallTimer ChernobylGame.Default__CGSmallTimer
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGSmallTimer* UCGSmallTimer::GetDefaultObj()
{
	static class UCGSmallTimer* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGSmallTimer*>(UCGSmallTimer::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSoldier
// (Actor, Pawn)

class UClass* ACGSoldier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSoldier");

	return Clss;
}


// CGSoldier ChernobylGame.Default__CGSoldier
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGSoldier* ACGSoldier::GetDefaultObj()
{
	static class ACGSoldier* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGSoldier*>(ACGSoldier::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGSoldier.VirtuaAimTickUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                              InAlpha                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::VirtuaAimTickUpdate(float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "VirtuaAimTickUpdate");

	Params::ACGSoldier_VirtuaAimTickUpdate_Params Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.UpdateMaxChaseTime
// (Final, Native, Private)
// Parameters:

void ACGSoldier::UpdateMaxChaseTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "UpdateMaxChaseTime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.StartInterrogationDialogue
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGSoldier::StartInterrogationDialogue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "StartInterrogationDialogue");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGSoldier.ShootTargetBullet
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAngleSpread                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InShootTarget                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InOptionalCustomStartLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InProjectileSweepSteps                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InProjectileSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInOptionalCustomStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGProjectile*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGProjectile* ACGSoldier::ShootTargetBullet(class ACGSoldier* InSoldier, float InAngleSpread, const struct FVector& InShootTarget, const struct FVector& InOptionalCustomStartLocation, int32 InProjectileSweepSteps, float InProjectileSpeed, bool bInOptionalCustomStart)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "ShootTargetBullet");

	Params::ACGSoldier_ShootTargetBullet_Params Parms{};

	Parms.InSoldier = InSoldier;
	Parms.InAngleSpread = InAngleSpread;
	Parms.InShootTarget = InShootTarget;
	Parms.InOptionalCustomStartLocation = InOptionalCustomStartLocation;
	Parms.InProjectileSweepSteps = InProjectileSweepSteps;
	Parms.InProjectileSpeed = InProjectileSpeed;
	Parms.bInOptionalCustomStart = bInOptionalCustomStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.ShootTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAngleSpread                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InShootTarget                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOutTargetHit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InOptionalCustomRayStartLocation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInOptionalCustomRayStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFakeShot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInDebug                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::ShootTarget(class ACGSoldier* InSoldier, float InAngleSpread, const struct FVector& InShootTarget, bool* bOutTargetHit, const struct FVector& InOptionalCustomRayStartLocation, bool bInOptionalCustomRayStart, bool bInFakeShot, bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "ShootTarget");

	Params::ACGSoldier_ShootTarget_Params Parms{};

	Parms.InSoldier = InSoldier;
	Parms.InAngleSpread = InAngleSpread;
	Parms.InShootTarget = InShootTarget;
	Parms.InOptionalCustomRayStartLocation = InOptionalCustomRayStartLocation;
	Parms.bInOptionalCustomRayStart = bInOptionalCustomRayStart;
	Parms.bInFakeShot = bInFakeShot;
	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bOutTargetHit != nullptr)
		*bOutTargetHit = Parms.bOutTargetHit;

}


// Function ChernobylGame.CGSoldier.Shoot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAngleSpread                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InOptionalCustomRayStartLocation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOutTargetHit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInOptionalCustomRayStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFakeShot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInDebug                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::Shoot(class ACGSoldier* InSoldier, float InAngleSpread, const struct FVector& InOptionalCustomRayStartLocation, bool* bOutTargetHit, bool bInOptionalCustomRayStart, bool bInFakeShot, bool bInDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "Shoot");

	Params::ACGSoldier_Shoot_Params Parms{};

	Parms.InSoldier = InSoldier;
	Parms.InAngleSpread = InAngleSpread;
	Parms.InOptionalCustomRayStartLocation = InOptionalCustomRayStartLocation;
	Parms.bInOptionalCustomRayStart = bInOptionalCustomRayStart;
	Parms.bInFakeShot = bInFakeShot;
	Parms.bInDebug = bInDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bOutTargetHit != nullptr)
		*bOutTargetHit = Parms.bOutTargetHit;

}


// Function ChernobylGame.CGSoldier.SetSquadManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSquadManager*             InNewSquad                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::SetSquadManager(class ACGSquadManager* InNewSquad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "SetSquadManager");

	Params::ACGSoldier_SetSquadManager_Params Parms{};

	Parms.InNewSquad = InNewSquad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.SetShooterCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewCooldown                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::SetShooterCooldown(float InNewCooldown)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "SetShooterCooldown");

	Params::ACGSoldier_SetShooterCooldown_Params Parms{};

	Parms.InNewCooldown = InNewCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.SetRandomShooterCooldownBetweenMinMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSoldier::SetRandomShooterCooldownBetweenMinMax()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "SetRandomShooterCooldownBetweenMinMax");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.SetCurrentCoverType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECoverType              InCoverType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::SetCurrentCoverType(enum class ECoverType InCoverType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "SetCurrentCoverType");

	Params::ACGSoldier_SetCurrentCoverType_Params Parms{};

	Parms.InCoverType = InCoverType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.PlaySoundWithSubtitles
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                  InSoundToPlay                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSoldier::PlaySoundWithSubtitles(class USoundBase* InSoundToPlay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "PlaySoundWithSubtitles");

	Params::ACGSoldier_PlaySoundWithSubtitles_Params Parms{};

	Parms.InSoundToPlay = InSoundToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.OnShootEvent
// (Event, Public, BlueprintEvent)
// Parameters:

void ACGSoldier::OnShootEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "OnShootEvent");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGSoldier.InterrogationDialogueBranch_Kill
// (Final, Native, Protected)
// Parameters:

void ACGSoldier::InterrogationDialogueBranch_Kill()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "InterrogationDialogueBranch_Kill");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.InterrogationDialogueBranch_Ignore
// (Final, Native, Protected)
// Parameters:

void ACGSoldier::InterrogationDialogueBranch_Ignore()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "InterrogationDialogueBranch_Ignore");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.InterrogationDialogueBranch_Attack
// (Final, Native, Protected)
// Parameters:

void ACGSoldier::InterrogationDialogueBranch_Attack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "InterrogationDialogueBranch_Attack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSoldier.GetSquadMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGSoldier*>          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGSoldier*> ACGSoldier::GetSquadMembers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetSquadMembers");

	Params::ACGSoldier_GetSquadMembers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetSquadManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGSquadManager*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGSquadManager* ACGSoldier::GetSquadManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetSquadManager");

	Params::ACGSoldier_GetSquadManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetShooterCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGSoldier::GetShooterCooldown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetShooterCooldown");

	Params::ACGSoldier_GetShooterCooldown_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetRandomNewShooterCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGSoldier::GetRandomNewShooterCooldown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetRandomNewShooterCooldown");

	Params::ACGSoldier_GetRandomNewShooterCooldown_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetIsHuntFacingHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSoldier::GetIsHuntFacingHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetIsHuntFacingHero");

	Params::ACGSoldier_GetIsHuntFacingHero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetInitializedSquadManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGSquadManager*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGSquadManager* ACGSoldier::GetInitializedSquadManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetInitializedSquadManager");

	Params::ACGSoldier_GetInitializedSquadManager_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetCurrentCoverType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECoverType              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECoverType ACGSoldier::GetCurrentCoverType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetCurrentCoverType");

	Params::ACGSoldier_GetCurrentCoverType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetCoverTypeValidityPerSoldier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACGCover*                    InCover                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGCharacter*                InTarget                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECoverType              InCoverType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSoldier::GetCoverTypeValidityPerSoldier(class ACGCover* InCover, class ACGCharacter* InTarget, enum class ECoverType InCoverType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetCoverTypeValidityPerSoldier");

	Params::ACGSoldier_GetCoverTypeValidityPerSoldier_Params Parms{};

	Parms.InCover = InCover;
	Parms.InTarget = InTarget;
	Parms.InCoverType = InCoverType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.GetComfortableCombatRadiusQuery
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     InLocation                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGComfortableCombatRadiusQueryReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCGComfortableCombatRadiusQuery ACGSoldier::GetComfortableCombatRadiusQuery(struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "GetComfortableCombatRadiusQuery");

	Params::ACGSoldier_GetComfortableCombatRadiusQuery_Params Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSoldier.FindCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGCover*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGCover* ACGSoldier::FindCover()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSoldier", "FindCover");

	Params::ACGSoldier_FindCover_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGSprintState
// (Actor)

class UClass* ACGSprintState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSprintState");

	return Clss;
}


// CGSprintState ChernobylGame.Default__CGSprintState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGSprintState* ACGSprintState::GetDefaultObj()
{
	static class ACGSprintState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGSprintState*>(ACGSprintState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGSquadManager
// (Actor)

class UClass* ACGSquadManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGSquadManager");

	return Clss;
}


// CGSquadManager ChernobylGame.Default__CGSquadManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGSquadManager* ACGSquadManager::GetDefaultObj()
{
	static class ACGSquadManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGSquadManager*>(ACGSquadManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGSquadManager.UpdateSquadHeroPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InNewHeroPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::UpdateSquadHeroPosition(struct FVector& InNewHeroPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "UpdateSquadHeroPosition");

	Params::ACGSquadManager_UpdateSquadHeroPosition_Params Parms{};

	Parms.InNewHeroPosition = InNewHeroPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.UpdateSquadHeroLastKnownPosFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InMaxOffset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::UpdateSquadHeroLastKnownPosFlag(float InMaxOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "UpdateSquadHeroLastKnownPosFlag");

	Params::ACGSquadManager_UpdateSquadHeroLastKnownPosFlag_Params Parms{};

	Parms.InMaxOffset = InMaxOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.UpdateMaxShootersCount
// (Final, Native, Private)
// Parameters:

void ACGSquadManager::UpdateMaxShootersCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "UpdateMaxShootersCount");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.TransitionSquad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSquadManager*             InSquadToTransitionTo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::TransitionSquad(class ACGSquadManager* InSquadToTransitionTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "TransitionSquad");

	Params::ACGSquadManager_TransitionSquad_Params Parms{};

	Parms.InSquadToTransitionTo = InSquadToTransitionTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SquadCleanup
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSquadManager::SquadCleanup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SquadCleanup");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SquadChatterTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSquadManager::SquadChatterTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SquadChatterTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SpreadTick
// (Final, Native, Private)
// Parameters:

void ACGSquadManager::SpreadTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SpreadTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SetSquadName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InNewSquadName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::SetSquadName(class FName InNewSquadName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SetSquadName");

	Params::ACGSquadManager_SetSquadName_Params Parms{};

	Parms.InNewSquadName = InNewSquadName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SetHeroOpenedFire
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InOpenedFire                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::SetHeroOpenedFire(bool InOpenedFire)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SetHeroOpenedFire");

	Params::ACGSquadManager_SetHeroOpenedFire_Params Parms{};

	Parms.InOpenedFire = InOpenedFire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SetChase
// (Final, Native, Public)
// Parameters:
// bool                               bInNewChase                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::SetChase(bool bInNewChase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SetChase");

	Params::ACGSquadManager_SetChase_Params Parms{};

	Parms.bInNewChase = bInNewChase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.SetAddShooterCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InCooldown                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::SetAddShooterCooldown(float InCooldown)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "SetAddShooterCooldown");

	Params::ACGSquadManager_SetAddShooterCooldown_Params Parms{};

	Parms.InCooldown = InCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.RemoveSquadMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSquadMemberToRemove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::RemoveSquadMember(class ACGSoldier* InSquadMemberToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "RemoveSquadMember");

	Params::ACGSquadManager_RemoveSquadMember_Params Parms{};

	Parms.InSquadMemberToRemove = InSquadMemberToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.RemoveShooter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::RemoveShooter(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "RemoveShooter");

	Params::ACGSquadManager_RemoveShooter_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.PatrolExitMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::PatrolExitMember(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "PatrolExitMember");

	Params::ACGSquadManager_PatrolExitMember_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.PatrolExit
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSquadManager::PatrolExit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "PatrolExit");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.PatrolBackInPlaceMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::PatrolBackInPlaceMember(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "PatrolBackInPlaceMember");

	Params::ACGSquadManager_PatrolBackInPlaceMember_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.OnSquadStateChangedImpl
// (Final, Native, Private)
// Parameters:
// enum class ESquadType              InState                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::OnSquadStateChangedImpl(enum class ESquadType InState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "OnSquadStateChangedImpl");

	Params::ACGSquadManager_OnSquadStateChangedImpl_Params Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.MonsterCheck
// (Final, Native, Private)
// Parameters:

void ACGSquadManager::MonsterCheck()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "MonsterCheck");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.GiveOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrderQuery                 InOrder                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACGSquadManager::GiveOrder(struct FOrderQuery& InOrder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GiveOrder");

	Params::ACGSquadManager_GiveOrder_Params Parms{};

	Parms.InOrder = InOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.GetSquadType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ESquadType              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESquadType ACGSquadManager::GetSquadType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadType");

	Params::ACGSquadManager_GetSquadType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadSeeHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetSquadSeeHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadSeeHero");

	Params::ACGSquadManager_GetSquadSeeHero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ACGSquadManager::GetSquadName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadName");

	Params::ACGSquadManager_GetSquadName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGSoldier*>          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGSoldier*> ACGSquadManager::GetSquadMembers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadMembers");

	Params::ACGSquadManager_GetSquadMembers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadHeroLastKnownPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGSquadManager::GetSquadHeroLastKnownPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadHeroLastKnownPosition");

	Params::ACGSquadManager_GetSquadHeroLastKnownPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadHasMemoryOfHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EPerceptionType         InPerceptionMemoryType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetSquadHasMemoryOfHero(enum class EPerceptionType InPerceptionMemoryType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadHasMemoryOfHero");

	Params::ACGSquadManager_GetSquadHasMemoryOfHero_Params Parms{};

	Parms.InPerceptionMemoryType = InPerceptionMemoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetSquadChaseTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGSquadManager::GetSquadChaseTimeElapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetSquadChaseTimeElapsed");

	Params::ACGSquadManager_GetSquadChaseTimeElapsed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetShooters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGSoldier*>          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGSoldier*> ACGSquadManager::GetShooters()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetShooters");

	Params::ACGSquadManager_GetShooters_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetPatrolExitRotationMember
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ACGSquadManager::GetPatrolExitRotationMember(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetPatrolExitRotationMember");

	Params::ACGSquadManager_GetPatrolExitRotationMember_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetPatrolExitLocationMember
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGSquadManager::GetPatrolExitLocationMember(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetPatrolExitLocationMember");

	Params::ACGSquadManager_GetPatrolExitLocationMember_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetPatrolExitLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACGSquadManager::GetPatrolExitLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetPatrolExitLocation");

	Params::ACGSquadManager_GetPatrolExitLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetMaxShooters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGSquadManager::GetMaxShooters()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetMaxShooters");

	Params::ACGSquadManager_GetMaxShooters_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetHeroOpenedFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetHeroOpenedFire()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetHeroOpenedFire");

	Params::ACGSquadManager_GetHeroOpenedFire_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetHeroNearLastKnownPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetHeroNearLastKnownPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetHeroNearLastKnownPosition");

	Params::ACGSquadManager_GetHeroNearLastKnownPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetForHowLongCantSeeHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGSquadManager::GetForHowLongCantSeeHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetForHowLongCantSeeHero");

	Params::ACGSquadManager_GetForHowLongCantSeeHero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetEngagedInOpenCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGSoldier*>          ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class ACGSoldier*> ACGSquadManager::GetEngagedInOpenCombat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetEngagedInOpenCombat");

	Params::ACGSquadManager_GetEngagedInOpenCombat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetCanSquadSeeHeroElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetCanSquadSeeHeroElapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetCanSquadSeeHeroElapsed");

	Params::ACGSquadManager_GetCanSquadSeeHeroElapsed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetCanSquadSeeHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetCanSquadSeeHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetCanSquadSeeHero");

	Params::ACGSquadManager_GetCanSquadSeeHero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetCanAddNewVirtuaShooter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::GetCanAddNewVirtuaShooter(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetCanAddNewVirtuaShooter");

	Params::ACGSquadManager_GetCanAddNewVirtuaShooter_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetAlertedSquadMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGSoldier*>          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGSoldier*> ACGSquadManager::GetAlertedSquadMembers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetAlertedSquadMembers");

	Params::ACGSquadManager_GetAlertedSquadMembers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.GetAddShooterCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACGSquadManager::GetAddShooterCooldown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "GetAddShooterCooldown");

	Params::ACGSquadManager_GetAddShooterCooldown_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.ForceSpreadTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSquadManager::ForceSpreadTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "ForceSpreadTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.EngageOpenCombat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::EngageOpenCombat(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "EngageOpenCombat");

	Params::ACGSquadManager_EngageOpenCombat_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.DisengageOpenCombat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::DisengageOpenCombat(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "DisengageOpenCombat");

	Params::ACGSquadManager_DisengageOpenCombat_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.ClearSquad
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGSquadManager::ClearSquad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "ClearSquad");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.AreMembersTogether
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     InOriginOfCheck                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InCheckRadius                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::AreMembersTogether(const struct FVector& InOriginOfCheck, float InCheckRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "AreMembersTogether");

	Params::ACGSquadManager_AreMembersTogether_Params Parms{};

	Parms.InOriginOfCheck = InOriginOfCheck;
	Parms.InCheckRadius = InCheckRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGSquadManager.AddSquadMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InNewSquadMember                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGSquadManager::AddSquadMember(class ACGSoldier* InNewSquadMember)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "AddSquadMember");

	Params::ACGSquadManager_AddSquadMember_Params Parms{};

	Parms.InNewSquadMember = InNewSquadMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGSquadManager.AddShooter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGSoldier*                  InSoldier                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGSquadManager::AddShooter(class ACGSoldier* InSoldier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGSquadManager", "AddShooter");

	Params::ACGSquadManager_AddShooter_Params Parms{};

	Parms.InSoldier = InSoldier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGStructs
// (None)

class UClass* UCGStructs::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGStructs");

	return Clss;
}


// CGStructs ChernobylGame.Default__CGStructs
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGStructs* UCGStructs::GetDefaultObj()
{
	static class UCGStructs* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGStructs*>(UCGStructs::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.PropertyLinkSave
// (None)

class UClass* UPropertyLinkSave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PropertyLinkSave");

	return Clss;
}


// PropertyLinkSave ChernobylGame.Default__PropertyLinkSave
// (Public, ClassDefaultObject, ArchetypeObject)

class UPropertyLinkSave* UPropertyLinkSave::GetDefaultObj()
{
	static class UPropertyLinkSave* Default = nullptr;

	if (!Default)
		Default = static_cast<UPropertyLinkSave*>(UPropertyLinkSave::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGTimelinePayloadWidget
// (None)

class UClass* UCGTimelinePayloadWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGTimelinePayloadWidget");

	return Clss;
}


// CGTimelinePayloadWidget ChernobylGame.Default__CGTimelinePayloadWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGTimelinePayloadWidget* UCGTimelinePayloadWidget::GetDefaultObj()
{
	static class UCGTimelinePayloadWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGTimelinePayloadWidget*>(UCGTimelinePayloadWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGTimelinePayloadWidget.RequestDestruct
// (Event, Public, BlueprintEvent)
// Parameters:

void UCGTimelinePayloadWidget::RequestDestruct()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGTimelinePayloadWidget", "RequestDestruct");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGTimelinePayloadWidget.InitPayload
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDialogueTimelinePayloadDataPayload                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCGTimelinePayloadWidget::InitPayload(struct FDialogueTimelinePayloadData& Payload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGTimelinePayloadWidget", "InitPayload");

	Params::UCGTimelinePayloadWidget_InitPayload_Params Parms{};

	Parms.Payload = Payload;

	UObject::ProcessEvent(Func, &Parms);

}


// Class ChernobylGame.CGTrainingPromptState
// (Actor)

class UClass* ACGTrainingPromptState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGTrainingPromptState");

	return Clss;
}


// CGTrainingPromptState ChernobylGame.Default__CGTrainingPromptState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGTrainingPromptState* ACGTrainingPromptState::GetDefaultObj()
{
	static class ACGTrainingPromptState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGTrainingPromptState*>(ACGTrainingPromptState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGTutorialState
// (Actor)

class UClass* ACGTutorialState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGTutorialState");

	return Clss;
}


// CGTutorialState ChernobylGame.Default__CGTutorialState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGTutorialState* ACGTutorialState::GetDefaultObj()
{
	static class ACGTutorialState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGTutorialState*>(ACGTutorialState::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGTutorialState.OnTutorialEnded
// (Final, Native, Private)
// Parameters:

void ACGTutorialState::OnTutorialEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGTutorialState", "OnTutorialEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGUtilities
// (None)

class UClass* UCGUtilities::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGUtilities");

	return Clss;
}


// CGUtilities ChernobylGame.Default__CGUtilities
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGUtilities* UCGUtilities::GetDefaultObj()
{
	static class UCGUtilities* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGUtilities*>(UCGUtilities::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGUtilities.IsInPIE
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldCtx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGUtilities::IsInPIE(class UObject* WorldCtx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "IsInPIE");

	Params::UCGUtilities_IsInPIE_Params Parms{};

	Parms.WorldCtx = WorldCtx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.IsInGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldCtx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGUtilities::IsInGame(class UObject* WorldCtx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "IsInGame");

	Params::UCGUtilities_IsInGame_Params Parms{};

	Parms.WorldCtx = WorldCtx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.IsInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldCtx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCGUtilities::IsInEditor(class UObject* WorldCtx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "IsInEditor");

	Params::UCGUtilities_IsInEditor_Params Parms{};

	Parms.WorldCtx = WorldCtx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.GetStringsByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTagContent>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTagContent> UCGUtilities::GetStringsByTag(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "GetStringsByTag");

	Params::UCGUtilities_GetStringsByTag_Params Parms{};

	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.GetParentClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                      Child                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UCGUtilities::GetParentClass(class UClass* Child)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "GetParentClass");

	Params::UCGUtilities_GetParentClass_Params Parms{};

	Parms.Child = Child;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.GetCurrentPersistantLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCGUtilities::GetCurrentPersistantLevel(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "GetCurrentPersistantLevel");

	Params::UCGUtilities_GetCurrentPersistantLevel_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.GetAllComponentsFromActorByInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      Interface                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCGUtilities::GetAllComponentsFromActorByInterface(class AActor* Actor, class UClass* Interface)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "GetAllComponentsFromActorByInterface");

	Params::UCGUtilities_GetAllComponentsFromActorByInterface_Params Parms{};

	Parms.Actor = Actor;
	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.ArraySubtractionFName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                ArrayA                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                ArrayB                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCGUtilities::ArraySubtractionFName(const TArray<class FName>& ArrayA, const TArray<class FName>& ArrayB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "ArraySubtractionFName");

	Params::UCGUtilities_ArraySubtractionFName_Params Parms{};

	Parms.ArrayA = ArrayA;
	Parms.ArrayB = ArrayB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGUtilities.ArrayIntersectionFName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                ArrayA                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                ArrayB                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCGUtilities::ArrayIntersectionFName(const TArray<class FName>& ArrayA, const TArray<class FName>& ArrayB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGUtilities", "ArrayIntersectionFName");

	Params::UCGUtilities_ArrayIntersectionFName_Params Parms{};

	Parms.ArrayA = ArrayA;
	Parms.ArrayB = ArrayB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CGVirtuaIndicator
// (None)

class UClass* UCGVirtuaIndicator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVirtuaIndicator");

	return Clss;
}


// CGVirtuaIndicator ChernobylGame.Default__CGVirtuaIndicator
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGVirtuaIndicator* UCGVirtuaIndicator::GetDefaultObj()
{
	static class UCGVirtuaIndicator* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGVirtuaIndicator*>(UCGVirtuaIndicator::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGVirtuaIndicator.Reverse
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                              InTimeElapsed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVirtuaIndicator::Reverse(float InTimeElapsed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicator", "Reverse");

	Params::UCGVirtuaIndicator_Reverse_Params Parms{};

	Parms.InTimeElapsed = InTimeElapsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaIndicator.Resume
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                              InTimeElapsed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVirtuaIndicator::Resume(float InTimeElapsed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicator", "Resume");

	Params::UCGVirtuaIndicator_Resume_Params Parms{};

	Parms.InTimeElapsed = InTimeElapsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaIndicator.Reset
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UCGVirtuaIndicator::Reset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicator", "Reset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVirtuaIndicator.GetVirtuaCrosshairAnimation
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UWidgetAnimation*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UCGVirtuaIndicator::GetVirtuaCrosshairAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicator", "GetVirtuaCrosshairAnimation");

	Params::UCGVirtuaIndicator_GetVirtuaCrosshairAnimation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGVirtuaIndicator.Finish
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               bInSuccess                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGAICharacter*              InCharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVirtuaIndicator::Finish(bool bInSuccess, class ACGAICharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicator", "Finish");

	Params::UCGVirtuaIndicator_Finish_Params Parms{};

	Parms.bInSuccess = bInSuccess;
	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGVirtuaIndicatorOffsight
// (None)

class UClass* UCGVirtuaIndicatorOffsight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVirtuaIndicatorOffsight");

	return Clss;
}


// CGVirtuaIndicatorOffsight ChernobylGame.Default__CGVirtuaIndicatorOffsight
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGVirtuaIndicatorOffsight* UCGVirtuaIndicatorOffsight::GetDefaultObj()
{
	static class UCGVirtuaIndicatorOffsight* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGVirtuaIndicatorOffsight*>(UCGVirtuaIndicatorOffsight::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGVirtuaIndicatorOffsight.Start
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVirtuaIndicatorOffsight::Start(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicatorOffsight", "Start");

	Params::UCGVirtuaIndicatorOffsight_Start_Params Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGVirtuaIndicatorOffsight.SetCustomVirtuaOffsightMaterial
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UMaterialInstance>CustomMaterial                                                   (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVirtuaIndicatorOffsight::SetCustomVirtuaOffsightMaterial(TSoftObjectPtr<class UMaterialInstance>& CustomMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicatorOffsight", "SetCustomVirtuaOffsightMaterial");

	Params::UCGVirtuaIndicatorOffsight_SetCustomVirtuaOffsightMaterial_Params Parms{};

	Parms.CustomMaterial = CustomMaterial;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGVirtuaIndicatorOffsight.End
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCGVirtuaIndicatorOffsight::End()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVirtuaIndicatorOffsight", "End");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.CGVisibilityModifierComponent
// (None)

class UClass* UCGVisibilityModifierComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVisibilityModifierComponent");

	return Clss;
}


// CGVisibilityModifierComponent ChernobylGame.Default__CGVisibilityModifierComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCGVisibilityModifierComponent* UCGVisibilityModifierComponent::GetDefaultObj()
{
	static class UCGVisibilityModifierComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCGVisibilityModifierComponent*>(UCGVisibilityModifierComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGVisibilityModifierComponent.OwnerEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                      InOverlappedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVisibilityModifierComponent::OwnerEndOverlap(class AActor* InOverlappedActor, class AActor* InOtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVisibilityModifierComponent", "OwnerEndOverlap");

	Params::UCGVisibilityModifierComponent_OwnerEndOverlap_Params Parms{};

	Parms.InOverlappedActor = InOverlappedActor;
	Parms.InOtherActor = InOtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGVisibilityModifierComponent.OwnerBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                      InOverlappedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCGVisibilityModifierComponent::OwnerBeginOverlap(class AActor* InOverlappedActor, class AActor* InOtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGVisibilityModifierComponent", "OwnerBeginOverlap");

	Params::UCGVisibilityModifierComponent_OwnerBeginOverlap_Params Parms{};

	Parms.InOverlappedActor = InOverlappedActor;
	Parms.InOtherActor = InOtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CGVisibilityModifierVolume
// (Actor)

class UClass* ACGVisibilityModifierVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVisibilityModifierVolume");

	return Clss;
}


// CGVisibilityModifierVolume ChernobylGame.Default__CGVisibilityModifierVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGVisibilityModifierVolume* ACGVisibilityModifierVolume::GetDefaultObj()
{
	static class ACGVisibilityModifierVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGVisibilityModifierVolume*>(ACGVisibilityModifierVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGVisibilityModifierVolume2
// (Actor)

class UClass* ACGVisibilityModifierVolume2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGVisibilityModifierVolume2");

	return Clss;
}


// CGVisibilityModifierVolume2 ChernobylGame.Default__CGVisibilityModifierVolume2
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGVisibilityModifierVolume2* ACGVisibilityModifierVolume2::GetDefaultObj()
{
	static class ACGVisibilityModifierVolume2* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGVisibilityModifierVolume2*>(ACGVisibilityModifierVolume2::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGWalkState
// (Actor)

class UClass* ACGWalkState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGWalkState");

	return Clss;
}


// CGWalkState ChernobylGame.Default__CGWalkState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGWalkState* ACGWalkState::GetDefaultObj()
{
	static class ACGWalkState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGWalkState*>(ACGWalkState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGWalkNoInputState
// (Actor)

class UClass* ACGWalkNoInputState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGWalkNoInputState");

	return Clss;
}


// CGWalkNoInputState ChernobylGame.Default__CGWalkNoInputState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGWalkNoInputState* ACGWalkNoInputState::GetDefaultObj()
{
	static class ACGWalkNoInputState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGWalkNoInputState*>(ACGWalkNoInputState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGWalkNoInputStateInteractable
// (Actor)

class UClass* ACGWalkNoInputStateInteractable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGWalkNoInputStateInteractable");

	return Clss;
}


// CGWalkNoInputStateInteractable ChernobylGame.Default__CGWalkNoInputStateInteractable
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGWalkNoInputStateInteractable* ACGWalkNoInputStateInteractable::GetDefaultObj()
{
	static class ACGWalkNoInputStateInteractable* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGWalkNoInputStateInteractable*>(ACGWalkNoInputStateInteractable::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGWalkSlowState
// (Actor)

class UClass* ACGWalkSlowState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGWalkSlowState");

	return Clss;
}


// CGWalkSlowState ChernobylGame.Default__CGWalkSlowState
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGWalkSlowState* ACGWalkSlowState::GetDefaultObj()
{
	static class ACGWalkSlowState* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGWalkSlowState*>(ACGWalkSlowState::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CGWeapon
// (Actor)

class UClass* ACGWeapon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CGWeapon");

	return Clss;
}


// CGWeapon ChernobylGame.Default__CGWeapon
// (Public, ClassDefaultObject, ArchetypeObject)

class ACGWeapon* ACGWeapon::GetDefaultObj()
{
	static class ACGWeapon* Default = nullptr;

	if (!Default)
		Default = static_cast<ACGWeapon*>(ACGWeapon::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CGWeapon.UseBullet
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGWeapon::UseBullet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "UseBullet");

	Params::ACGWeapon_UseBullet_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.UpdateSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::UpdateSkin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "UpdateSkin");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.UpdateMeshWithMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*> MeshComponents                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UMaterialInterface>>Materials                                                        (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void ACGWeapon::UpdateMeshWithMaterials(const TArray<class UPrimitiveComponent*>& MeshComponents, const TArray<TSoftObjectPtr<class UMaterialInterface>>& Materials)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "UpdateMeshWithMaterials");

	Params::ACGWeapon_UpdateMeshWithMaterials_Params Parms{};

	Parms.MeshComponents = MeshComponents;
	Parms.Materials = Materials;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.SpawnBulletShell
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystem*             InEmitterTemplate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InSpawnTransform                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     InVelocity                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InRadialVelocity                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InLifeTime                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::SpawnBulletShell(class UParticleSystem* InEmitterTemplate, struct FTransform& InSpawnTransform, struct FVector& InVelocity, struct FVector& InRadialVelocity, float InLifeTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "SpawnBulletShell");

	Params::ACGWeapon_SpawnBulletShell_Params Parms{};

	Parms.InEmitterTemplate = InEmitterTemplate;
	Parms.InSpawnTransform = InSpawnTransform;
	Parms.InVelocity = InVelocity;
	Parms.InRadialVelocity = InRadialVelocity;
	Parms.InLifeTime = InLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.SetNewWeaponState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EWeaponState            InNewWeaponState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EWeaponState            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWeaponState ACGWeapon::SetNewWeaponState(enum class EWeaponState InNewWeaponState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "SetNewWeaponState");

	Params::ACGWeapon_SetNewWeaponState_Params Parms{};

	Parms.InNewWeaponState = InNewWeaponState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.SetMaterialsDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                 MeshMesh                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCanBeCrafted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::SetMaterialsDisplay(class UStaticMeshComponent* MeshComp, class UStaticMesh* MeshMesh, bool bCanBeCrafted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "SetMaterialsDisplay");

	Params::ACGWeapon_SetMaterialsDisplay_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.MeshMesh = MeshMesh;
	Parms.bCanBeCrafted = bCanBeCrafted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.SetClipCurrentSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::SetClipCurrentSize(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "SetClipCurrentSize");

	Params::ACGWeapon_SetClipCurrentSize_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.ReloadFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EWeaponState            InPostReloadState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldBroadcast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInNoSwap                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::ReloadFinished(enum class EWeaponState InPostReloadState, bool bShouldBroadcast, bool bInNoSwap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ReloadFinished");

	Params::ACGWeapon_ReloadFinished_Params Parms{};

	Parms.InPostReloadState = InPostReloadState;
	Parms.bShouldBroadcast = bShouldBroadcast;
	Parms.bInNoSwap = bInNoSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.ReloadAmmoAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::ReloadAmmoAmount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ReloadAmmoAmount");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnUpdateAttachmentSkin
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                        UpgradeID                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::OnUpdateAttachmentSkin(class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnUpdateAttachmentSkin");

	Params::ACGWeapon_OnUpdateAttachmentSkin_Params Parms{};

	Parms.UpgradeID = UpgradeID;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnUnAim
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnUnAim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnUnAim");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnTriggerUpgrade
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCGTriggerProperties        InNewTriggerProperties                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGWeapon::OnTriggerUpgrade(struct FCGTriggerProperties& InNewTriggerProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnTriggerUpgrade");

	Params::ACGWeapon_OnTriggerUpgrade_Params Parms{};

	Parms.InNewTriggerProperties = InNewTriggerProperties;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnShellCollision
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                        InEventName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InEmitterTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InParticleTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLocation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InVelocity                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InDirection                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNormal                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*           InPhysMat                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::OnShellCollision(class FName InEventName, float InEmitterTime, int32 InParticleTime, const struct FVector& InLocation, const struct FVector& InVelocity, const struct FVector& InDirection, const struct FVector& InNormal, class FName InBoneName, class UPhysicalMaterial* InPhysMat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnShellCollision");

	Params::ACGWeapon_OnShellCollision_Params Parms{};

	Parms.InEventName = InEventName;
	Parms.InEmitterTime = InEmitterTime;
	Parms.InParticleTime = InParticleTime;
	Parms.InLocation = InLocation;
	Parms.InVelocity = InVelocity;
	Parms.InDirection = InDirection;
	Parms.InNormal = InNormal;
	Parms.InBoneName = InBoneName;
	Parms.InPhysMat = InPhysMat;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnScopeUpgrade
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCGScopeProperties          InNewScopeProperties                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGWeapon::OnScopeUpgrade(struct FCGScopeProperties& InNewScopeProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnScopeUpgrade");

	Params::ACGWeapon_OnScopeUpgrade_Params Parms{};

	Parms.InNewScopeProperties = InNewScopeProperties;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnReloadFailed
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnReloadFailed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnReloadFailed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnReload
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnReload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnReload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnMagazineUpgrade
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCGMagazineProperties       InNewMagazineProperties                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGWeapon::OnMagazineUpgrade(struct FCGMagazineProperties& InNewMagazineProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnMagazineUpgrade");

	Params::ACGWeapon_OnMagazineUpgrade_Params Parms{};

	Parms.InNewMagazineProperties = InNewMagazineProperties;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnLocalMeleeFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::OnLocalMeleeFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnLocalMeleeFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnLocalMelee
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGWeapon::OnLocalMelee()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnLocalMelee");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnHandleUpgrade
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCGHandleProperties         InNewHandleProperties                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGWeapon::OnHandleUpgrade(struct FCGHandleProperties& InNewHandleProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnHandleUpgrade");

	Params::ACGWeapon_OnHandleUpgrade_Params Parms{};

	Parms.InNewHandleProperties = InNewHandleProperties;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnForceReloadFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bInNoSwap                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACGWeapon::OnForceReloadFinished(bool bInNoSwap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnForceReloadFinished");

	Params::ACGWeapon_OnForceReloadFinished_Params Parms{};

	Parms.bInNoSwap = bInNoSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnEmptyAmmo
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnEmptyAmmo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnEmptyAmmo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnCooldownElapsed
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnCooldownElapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnCooldownElapsed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnBrokenWeaponUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGWeapon::OnBrokenWeaponUse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnBrokenWeaponUse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnBarrelUpgrade
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCGBarrelProperties         InNewBarrelProperties                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACGWeapon::OnBarrelUpgrade(struct FCGBarrelProperties& InNewBarrelProperties)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnBarrelUpgrade");

	Params::ACGWeapon_OnBarrelUpgrade_Params Parms{};

	Parms.InNewBarrelProperties = InNewBarrelProperties;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CGWeapon.OnAmmoSwitchForceFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGWeapon::OnAmmoSwitchForceFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnAmmoSwitchForceFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnAmmoSwitchFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::OnAmmoSwitchFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnAmmoSwitchFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnAmmoSwitchFailed
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnAmmoSwitchFailed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnAmmoSwitchFailed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnAmmoSwitch
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnAmmoSwitch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnAmmoSwitch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.OnAim
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACGWeapon::OnAim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "OnAim");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.K2_GetAttachmentSkinInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        UpgradeID                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttachmentSkinInfo         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAttachmentSkinInfo ACGWeapon::K2_GetAttachmentSkinInfo(class FName UpgradeID, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "K2_GetAttachmentSkinInfo");

	Params::ACGWeapon_K2_GetAttachmentSkinInfo_Params Parms{};

	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.GetOtherAmmoType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ACGWeapon::GetOtherAmmoType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "GetOtherAmmoType");

	Params::ACGWeapon_GetOtherAmmoType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.GetIsWeaponBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACGWeapon::GetIsWeaponBroken()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "GetIsWeaponBroken");

	Params::ACGWeapon_GetIsWeaponBroken_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.GetDefaultMeshMaterials
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<TSoftObjectPtr<class UMaterialInterface>>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UMaterialInterface>> ACGWeapon::GetDefaultMeshMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "GetDefaultMeshMaterials");

	Params::ACGWeapon_GetDefaultMeshMaterials_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.GetClipMaxSizeWithUpgrade
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGWeapon::GetClipMaxSizeWithUpgrade()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "GetClipMaxSizeWithUpgrade");

	Params::ACGWeapon_GetClipMaxSizeWithUpgrade_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.GetAdditionalBulletCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACGWeapon::GetAdditionalBulletCost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "GetAdditionalBulletCost");

	Params::ACGWeapon_GetAdditionalBulletCost_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.ForceReload
// (Native, Protected, BlueprintCallable)
// Parameters:

void ACGWeapon::ForceReload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ForceReload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.ForceOnCooldownElapsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::ForceOnCooldownElapsed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ForceOnCooldownElapsed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.ForceInitMagazine
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ACGWeapon::ForceInitMagazine()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ForceInitMagazine");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CGWeapon.FindAttachmentProperties
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bOutFound                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                  InDataTable                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InUpgradeName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGAttachmentProperties     ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGAttachmentProperties ACGWeapon::FindAttachmentProperties(bool* bOutFound, class UDataTable* InDataTable, class FName InUpgradeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "FindAttachmentProperties");

	Params::ACGWeapon_FindAttachmentProperties_Params Parms{};

	Parms.InDataTable = InDataTable;
	Parms.InUpgradeName = InUpgradeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bOutFound != nullptr)
		*bOutFound = Parms.bOutFound;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.DecreaseDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::DecreaseDurability()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "DecreaseDurability");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.ClampCurrentClipToInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ACGWeapon::ClampCurrentClipToInventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "ClampCurrentClipToInventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CGWeapon.CalculateRecoil
// (Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ACGWeapon::CalculateRecoil()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "CalculateRecoil");

	Params::ACGWeapon_CalculateRecoil_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.CalculateHipShot
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                               InShouldDebugTrace                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ACGWeapon::CalculateHipShot(bool InShouldDebugTrace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "CalculateHipShot");

	Params::ACGWeapon_CalculateHipShot_Params Parms{};

	Parms.InShouldDebugTrace = InShouldDebugTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.CalculateAimedShot
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               InShouldDebugTrace                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCGMultitraceResult> OutMultitraceResults                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bInShouldIgnoreCollisions                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCGShootResult>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FCGShootResult> ACGWeapon::CalculateAimedShot(bool InShouldDebugTrace, TArray<struct FCGMultitraceResult>* OutMultitraceResults, bool bInShouldIgnoreCollisions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "CalculateAimedShot");

	Params::ACGWeapon_CalculateAimedShot_Params Parms{};

	Parms.InShouldDebugTrace = InShouldDebugTrace;
	Parms.bInShouldIgnoreCollisions = bInShouldIgnoreCollisions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMultitraceResults != nullptr)
		*OutMultitraceResults = std::move(Parms.OutMultitraceResults);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CGWeapon.AmmoSwitchInternal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void ACGWeapon::AmmoSwitchInternal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CGWeapon", "AmmoSwitchInternal");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.Crafting
// (None)

class UClass* UCrafting::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Crafting");

	return Clss;
}


// Crafting ChernobylGame.Default__Crafting
// (Public, ClassDefaultObject, ArchetypeObject)

class UCrafting* UCrafting::GetDefaultObj()
{
	static class UCrafting* Default = nullptr;

	if (!Default)
		Default = static_cast<UCrafting*>(UCrafting::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.Crafting.TryCraftItemFromAnyRecipe
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        ItemType                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSuccess                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrafting::TryCraftItemFromAnyRecipe(class FName ItemType, bool* OutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "TryCraftItemFromAnyRecipe");

	Params::UCrafting_TryCraftItemFromAnyRecipe_Params Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

}


// Function ChernobylGame.Crafting.LearnRecipe
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        RecipeID                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrafting::LearnRecipe(class FName RecipeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "LearnRecipe");

	Params::UCrafting_LearnRecipe_Params Parms{};

	Parms.RecipeID = RecipeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Crafting.ForgetRecipe
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        RecipeID                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSomethingDeleted                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrafting::ForgetRecipe(class FName RecipeID, bool* OutSomethingDeleted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "ForgetRecipe");

	Params::UCrafting_ForgetRecipe_Params Parms{};

	Parms.RecipeID = RecipeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSomethingDeleted != nullptr)
		*OutSomethingDeleted = Parms.OutSomethingDeleted;

}


// Function ChernobylGame.Crafting.FindKnownRecipeForItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemType                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSuccess                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        OutRecipeID                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrafting::FindKnownRecipeForItem(class FName ItemType, bool* OutSuccess, class FName* OutRecipeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "FindKnownRecipeForItem");

	Params::UCrafting_FindKnownRecipeForItem_Params Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

	if (OutRecipeID != nullptr)
		*OutRecipeID = Parms.OutRecipeID;

}


// Function ChernobylGame.Crafting.FindAllKnownRecipesForItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemType                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                OutRecipeIDs                                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrafting::FindAllKnownRecipesForItem(class FName ItemType, TArray<class FName>* OutRecipeIDs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "FindAllKnownRecipesForItem");

	Params::UCrafting_FindAllKnownRecipesForItem_Params Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRecipeIDs != nullptr)
		*OutRecipeIDs = std::move(Parms.OutRecipeIDs);

}


// Function ChernobylGame.Crafting.Craft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        FromRecipe                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrafting::Craft(class FName FromRecipe)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "Craft");

	Params::UCrafting_Craft_Params Parms{};

	Parms.FromRecipe = FromRecipe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Crafting.CanCraftFromRecipe
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        RecipeID                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECraftingResult         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECraftingResult UCrafting::CanCraftFromRecipe(class FName RecipeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "CanCraftFromRecipe");

	Params::UCrafting_CanCraftFromRecipe_Params Parms{};

	Parms.RecipeID = RecipeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Crafting.CanCraftFromAnyRecipe
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ItemType                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECraftingResult         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECraftingResult UCrafting::CanCraftFromAnyRecipe(class FName ItemType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "CanCraftFromAnyRecipe");

	Params::UCrafting_CanCraftFromAnyRecipe_Params Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Crafting.ApplyPerks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrafting::ApplyPerks(float Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Crafting", "ApplyPerks");

	Params::UCrafting_ApplyPerks_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CraftingInput
// (None)

class UClass* ICraftingInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CraftingInput");

	return Clss;
}


// CraftingInput ChernobylGame.Default__CraftingInput
// (Public, ClassDefaultObject, ArchetypeObject)

class ICraftingInput* ICraftingInput::GetDefaultObj()
{
	static class ICraftingInput* Default = nullptr;

	if (!Default)
		Default = static_cast<ICraftingInput*>(ICraftingInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CraftingInput.InputUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputFaceRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputFaceRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputFaceRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputFaceDownRelease
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputFaceDownRelease()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputFaceDownRelease");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputFaceDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputFaceDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputFaceDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputDPadUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputDPadUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputDPadUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputDPadRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputDPadRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputDPadRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputDPadLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputDPadLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputDPadLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputDPadDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputDPadDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputDPadDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingInput.InputDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingInput::InputDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingInput", "InputDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CraftingNewInput
// (None)

class UClass* ICraftingNewInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CraftingNewInput");

	return Clss;
}


// CraftingNewInput ChernobylGame.Default__CraftingNewInput
// (Public, ClassDefaultObject, ArchetypeObject)

class ICraftingNewInput* ICraftingNewInput::GetDefaultObj()
{
	static class ICraftingNewInput* Default = nullptr;

	if (!Default)
		Default = static_cast<ICraftingNewInput*>(ICraftingNewInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CraftingNewInput.RightTab
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::RightTab()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "RightTab");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.RightItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::RightItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "RightItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.LeftTab
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::LeftTab()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "LeftTab");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.LeftItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::LeftItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "LeftItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.InputAnyKeyboard
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::InputAnyKeyboard()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "InputAnyKeyboard");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.InputAnyGamepad
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::InputAnyGamepad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "InputAnyGamepad");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.Craft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::Craft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "Craft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CraftingNewInput.Back
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICraftingNewInput::Back()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingNewInput", "Back");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CraftingUtilityFunctionsLibrary
// (None)

class UClass* UCraftingUtilityFunctionsLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CraftingUtilityFunctionsLibrary");

	return Clss;
}


// CraftingUtilityFunctionsLibrary ChernobylGame.Default__CraftingUtilityFunctionsLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UCraftingUtilityFunctionsLibrary* UCraftingUtilityFunctionsLibrary::GetDefaultObj()
{
	static class UCraftingUtilityFunctionsLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UCraftingUtilityFunctionsLibrary*>(UCraftingUtilityFunctionsLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CraftingUtilityFunctionsLibrary.ParseTextIntoFragmentsAndParameters
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      InText                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTextWithImagePart>  OutData                                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingUtilityFunctionsLibrary::ParseTextIntoFragmentsAndParameters(const class FString& InText, TArray<struct FTextWithImagePart>* OutData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CraftingUtilityFunctionsLibrary", "ParseTextIntoFragmentsAndParameters");

	Params::UCraftingUtilityFunctionsLibrary_ParseTextIntoFragmentsAndParameters_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

}


// Class ChernobylGame.CristalsGenerator
// (Actor)

class UClass* ACristalsGenerator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CristalsGenerator");

	return Clss;
}


// CristalsGenerator ChernobylGame.Default__CristalsGenerator
// (Public, ClassDefaultObject, ArchetypeObject)

class ACristalsGenerator* ACristalsGenerator::GetDefaultObj()
{
	static class ACristalsGenerator* Default = nullptr;

	if (!Default)
		Default = static_cast<ACristalsGenerator*>(ACristalsGenerator::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CristalsGenerator.Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAnimationsDirection    Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACristalsGenerator::Show(enum class EAnimationsDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CristalsGenerator", "Show");

	Params::ACristalsGenerator_Show_Params Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CristalsGenerator.Hide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAnimationsDirection    Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACristalsGenerator::Hide(enum class EAnimationsDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CristalsGenerator", "Hide");

	Params::ACristalsGenerator_Hide_Params Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CustomGameInstance
// (None)

class UClass* UCustomGameInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CustomGameInstance");

	return Clss;
}


// CustomGameInstance ChernobylGame.Default__CustomGameInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UCustomGameInstance* UCustomGameInstance::GetDefaultObj()
{
	static class UCustomGameInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UCustomGameInstance*>(UCustomGameInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CustomGameInstance.WriteAchievement
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EAchievementType        AchievementType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Progress                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::WriteAchievement(enum class EAchievementType AchievementType, float Progress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "WriteAchievement");

	Params::UCustomGameInstance_WriteAchievement_Params Parms{};

	Parms.AchievementType = AchievementType;
	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.WorldLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::WorldLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "WorldLoaded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ValidateArmor_CPP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bShowMessage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::ValidateArmor_CPP(bool bShowMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ValidateArmor_CPP");

	Params::UCustomGameInstance_ValidateArmor_CPP_Params Parms{};

	Parms.bShowMessage = bShowMessage;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.UseFoodFromTemporalStorage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::UseFoodFromTemporalStorage(float Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UseFoodFromTemporalStorage");

	Params::UCustomGameInstance_UseFoodFromTemporalStorage_Params Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.UseCustomSaves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Day                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::UseCustomSaves(const class FString& Day)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UseCustomSaves");

	Params::UCustomGameInstance_UseCustomSaves_Params Parms{};

	Parms.Day = Day;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.UpgradeSystemGetGlobalStatValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::UpgradeSystemGetGlobalStatValue(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpgradeSystemGetGlobalStatValue");

	Params::UCustomGameInstance_UpgradeSystemGetGlobalStatValue_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.UpgradeSystemGetGlobalStatInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUpgradeStat                ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FUpgradeStat UCustomGameInstance::UpgradeSystemGetGlobalStatInfo(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpgradeSystemGetGlobalStatInfo");

	Params::UCustomGameInstance_UpgradeSystemGetGlobalStatInfo_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.UpdateSkinForSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      SkeletalMeshComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::UpdateSkinForSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateSkinForSkeletalMeshComponent");

	Params::UCustomGameInstance_UpdateSkinForSkeletalMeshComponent_Params Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.UpdateRelevantDifficultySettingsToMatchSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::UpdateRelevantDifficultySettingsToMatchSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateRelevantDifficultySettingsToMatchSave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UpdateRaytracingParams
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::UpdateRaytracingParams()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateRaytracingParams");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.UpdateMaterialSharpen_CPP
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::UpdateMaterialSharpen_CPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateMaterialSharpen_CPP");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.UpdateFSRState
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::UpdateFSRState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateFSRState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UpdateFoodSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::UpdateFoodSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateFoodSystem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UpdateDLSSSettings
// (Final, Native, Public)
// Parameters:

void UCustomGameInstance::UpdateDLSSSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateDLSSSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UpdateDisplacementFromSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::UpdateDisplacementFromSetting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateDisplacementFromSetting");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UpdateCompanions
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::UpdateCompanions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UpdateCompanions");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.UnlockSaveAndLoadAfterDelay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCustomGameInstance::UnlockSaveAndLoadAfterDelay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "UnlockSaveAndLoadAfterDelay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.TrySetCompanionAtSpot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGNPC*                      Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnPositionActor                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseBuildSystemEntity*      Entity                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBuildEntityCompanionSpotComponent*SpotComponent                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::TrySetCompanionAtSpot(class ACGNPC* Companion, class AActor* ReturnPositionActor, class ABaseBuildSystemEntity* Entity, class UBuildEntityCompanionSpotComponent* SpotComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "TrySetCompanionAtSpot");

	Params::UCustomGameInstance_TrySetCompanionAtSpot_Params Parms{};

	Parms.Companion = Companion;
	Parms.ReturnPositionActor = ReturnPositionActor;
	Parms.Entity = Entity;
	Parms.SpotComponent = SpotComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.Test_LoadLevelByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::Test_LoadLevelByName(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "Test_LoadLevelByName");

	Params::UCustomGameInstance_Test_LoadLevelByName_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.TakeScreenshotForSaveSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               IsDaySave                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::TakeScreenshotForSaveSystem(bool IsDaySave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "TakeScreenshotForSaveSystem");

	Params::UCustomGameInstance_TakeScreenshotForSaveSystem_Params Parms{};

	Parms.IsDaySave = IsDaySave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.StopLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::StopLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "StopLoadingScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.StartLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                 Widget                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::StartLoadingScreen(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "StartLoadingScreen");

	Params::UCustomGameInstance_StartLoadingScreen_Params Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SquadLostTrack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACGSquadManager*             InSquad                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SquadLostTrack(class ACGSquadManager* InSquad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SquadLostTrack");

	Params::UCustomGameInstance_SquadLostTrack_Params Parms{};

	Parms.InSquad = InSquad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SquadGotTrack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACGSquadManager*             InSquad                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SquadGotTrack(class ACGSquadManager* InSquad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SquadGotTrack");

	Params::UCustomGameInstance_SquadGotTrack_Params Parms{};

	Parms.InSquad = InSquad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SpawnSuperHeavySoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnSuperHeavySoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnSuperHeavySoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnSoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnSoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnSoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnShadow
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnShadow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnShadow");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnSeregantSoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnSeregantSoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnSeregantSoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnLevelBulidingsIfNoneExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::SpawnLevelBulidingsIfNoneExist()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnLevelBulidingsIfNoneExist");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SpawnHeavySoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnHeavySoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnHeavySoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnEliteSoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnEliteSoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnEliteSoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnDeadSoldier
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnDeadSoldier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnDeadSoldier");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnChernoHost
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnChernoHost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnChernoHost");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SpawnBlackStalker
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::SpawnBlackStalker()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SpawnBlackStalker");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.SetWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetWeaponDurability(class FName UniqueId, float Offset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetWeaponDurability");

	Params::UCustomGameInstance_SetWeaponDurability_Params Parms{};

	Parms.UniqueId = UniqueId;
	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetStatsForCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompanionEntry             Info                                                             (Parm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetStatsForCompanion(class FName Name, const struct FCompanionEntry& Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetStatsForCompanion");

	Params::UCustomGameInstance_SetStatsForCompanion_Params Parms{};

	Parms.Name = Name;
	Parms.Info = Info;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetQuestForMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        OldQuestID                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetQuestForMap(enum class EEventMap Map, class FName QuestID, class FName* OldQuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetQuestForMap");

	Params::UCustomGameInstance_SetQuestForMap_Params Parms{};

	Parms.Map = Map;
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OldQuestID != nullptr)
		*OldQuestID = Parms.OldQuestID;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetProbabilityOfQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Probability                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetProbabilityOfQuest(class FName QuestID, enum class EEventMap Map, float Probability)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetProbabilityOfQuest");

	Params::UCustomGameInstance_SetProbabilityOfQuest_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;
	Parms.Probability = Probability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetPlayerDiedOnLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::SetPlayerDiedOnLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetPlayerDiedOnLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetIsPsycheDisabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInIsPsycheDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetIsPsycheDisabled(bool bInIsPsycheDisabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetIsPsycheDisabled");

	Params::UCustomGameInstance_SetIsPsycheDisabled_Params Parms{};

	Parms.bInIsPsycheDisabled = bInIsPsycheDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetIsGateOfMadnessSaveFile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInIsGateOfMadness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetIsGateOfMadnessSaveFile(bool bInIsGateOfMadness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetIsGateOfMadnessSaveFile");

	Params::UCustomGameInstance_SetIsGateOfMadnessSaveFile_Params Parms{};

	Parms.bInIsGateOfMadness = bInIsGateOfMadness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetFinishedGameAtLeastOnceMetadata
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::SetFinishedGameAtLeastOnceMetadata()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetFinishedGameAtLeastOnceMetadata");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetDLSSMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EUDLSSMode              Mode                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetDLSSMode(enum class EUDLSSMode Mode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetDLSSMode");

	Params::UCustomGameInstance_SetDLSSMode_Params Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetDayPart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDayPart                Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetDayPart(enum class EDayPart Current)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetDayPart");

	Params::UCustomGameInstance_SetDayPart_Params Parms{};

	Parms.Current = Current;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetCustomSoldierEventLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetCustomSoldierEventLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCustomSoldierEventLevel");

	Params::UCustomGameInstance_SetCustomSoldierEventLevel_Params Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetCurrentLevelBlackStalkerKilled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInKilled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SetCurrentLevelBlackStalkerKilled(bool bInKilled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCurrentLevelBlackStalkerKilled");

	Params::UCustomGameInstance_SetCurrentLevelBlackStalkerKilled_Params Parms{};

	Parms.bInKilled = bInKilled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SetCompanionToWantToLeaveAPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetCompanionToWantToLeaveAPlayer(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCompanionToWantToLeaveAPlayer");

	Params::UCustomGameInstance_SetCompanionToWantToLeaveAPlayer_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetCompanionToBeDeadInFight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetCompanionToBeDeadInFight(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCompanionToBeDeadInFight");

	Params::UCustomGameInstance_SetCompanionToBeDeadInFight_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetCompanionToBeAtPointOfHisDeath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetCompanionToBeAtPointOfHisDeath(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCompanionToBeAtPointOfHisDeath");

	Params::UCustomGameInstance_SetCompanionToBeAtPointOfHisDeath_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetCompanionsToBeConflict
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionA                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        CompanionB                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetCompanionsToBeConflict(class FName CompanionA, class FName CompanionB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetCompanionsToBeConflict");

	Params::UCustomGameInstance_SetCompanionsToBeConflict_Params Parms{};

	Parms.CompanionA = CompanionA;
	Parms.CompanionB = CompanionB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SetbContinueFromSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SetbContinueFromSave(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SetbContinueFromSave");

	Params::UCustomGameInstance_SetbContinueFromSave_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SaveScreenshotForSaveSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSaveScreenshotData         ScreenshotData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               IsDaySave                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::SaveScreenshotForSaveSystem(struct FSaveScreenshotData& ScreenshotData, bool IsDaySave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SaveScreenshotForSaveSystem");

	Params::UCustomGameInstance_SaveScreenshotForSaveSystem_Params Parms{};

	Parms.ScreenshotData = ScreenshotData;
	Parms.IsDaySave = IsDaySave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SaveNameToMetadataName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCustomGameInstance::SaveNameToMetadataName(const class FString& SaveName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SaveNameToMetadataName");

	Params::UCustomGameInstance_SaveNameToMetadataName_Params Parms{};

	Parms.SaveName = SaveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SaveGameToFile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SaveGameToFile()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SaveGameToFile");

	Params::UCustomGameInstance_SaveGameToFile_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.SaveGameGlobalMetadata
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::SaveGameGlobalMetadata()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SaveGameGlobalMetadata");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.SaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::SaveGame(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "SaveGame");

	Params::UCustomGameInstance_SaveGame_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RevertLastFinishedQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::RevertLastFinishedQuest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RevertLastFinishedQuest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RestoreHeroDataAfterFractalVRMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::RestoreHeroDataAfterFractalVRMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RestoreHeroDataAfterFractalVRMap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RestoreCompanionsToBuildings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FBuildingCompanionInfo>ViableCompanions                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCustomGameInstance::RestoreCompanionsToBuildings(const TArray<struct FBuildingCompanionInfo>& ViableCompanions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RestoreCompanionsToBuildings");

	Params::UCustomGameInstance_RestoreCompanionsToBuildings_Params Parms{};

	Parms.ViableCompanions = ViableCompanions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetUserAchivements
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetUserAchivements()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetUserAchivements");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetShouldShowTimelineDeathTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetShouldShowTimelineDeathTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetShouldShowTimelineDeathTutorial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetShouldShowHeistTutorialInBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetShouldShowHeistTutorialInBase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetShouldShowHeistTutorialInBase");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetSavedSoldierSpawnInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetSavedSoldierSpawnInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetSavedSoldierSpawnInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetQuestsRubberBandingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetQuestsRubberBandingValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetQuestsRubberBandingValue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetLastFinishedQuestInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetLastFinishedQuestInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetLastFinishedQuestInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetGateOfMadnessDifficulties
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetGateOfMadnessDifficulties()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetGateOfMadnessDifficulties");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetDefualtSkinCacheAndMaterialsForSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      SkeletalMeshComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::ResetDefualtSkinCacheAndMaterialsForSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetDefualtSkinCacheAndMaterialsForSkeletalMeshComponent");

	Params::UCustomGameInstance_ResetDefualtSkinCacheAndMaterialsForSkeletalMeshComponent_Params Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetCurrentLevelTimers
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetCurrentLevelTimers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetCurrentLevelTimers");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ResetCompanionLoyaltyRevertInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ResetCompanionLoyaltyRevertInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ResetCompanionLoyaltyRevertInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RemoveWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::RemoveWeaponDurability(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveWeaponDurability");

	Params::UCustomGameInstance_RemoveWeaponDurability_Params Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RemoveSaveAndMetadataInSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::RemoveSaveAndMetadataInSlot(const class FString& SaveName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveSaveAndMetadataInSlot");

	Params::UCustomGameInstance_RemoveSaveAndMetadataInSlot_Params Parms{};

	Parms.SaveName = SaveName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RemoveResourcesFromMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FResourcesForMap            Resources                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::RemoveResourcesFromMap(enum class EEventMap Map, const struct FResourcesForMap& Resources)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveResourcesFromMap");

	Params::UCustomGameInstance_RemoveResourcesFromMap_Params Parms{};

	Parms.Map = Map;
	Parms.Resources = Resources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RemoveOldDaySaves
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::RemoveOldDaySaves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveOldDaySaves");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RemoveDecisionFromCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        DecisionID                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CheckIfCompanionIsAvailable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::RemoveDecisionFromCompanion(class FName CompanionID, class FName DecisionID, bool CheckIfCompanionIsAvailable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveDecisionFromCompanion");

	Params::UCustomGameInstance_RemoveDecisionFromCompanion_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.DecisionID = DecisionID;
	Parms.CheckIfCompanionIsAvailable = CheckIfCompanionIsAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RemoveCurveAnimatedWidgetMaster
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                     InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::RemoveCurveAnimatedWidgetMaster(class UWidget* InWidget, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveCurveAnimatedWidgetMaster");

	Params::UCustomGameInstance_RemoveCurveAnimatedWidgetMaster_Params Parms{};

	Parms.InWidget = InWidget;
	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.RemoveCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::RemoveCompanion(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveCompanion");

	Params::UCustomGameInstance_RemoveCompanion_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RemoveBuffFromCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Modifier                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::RemoveBuffFromCompanion(class FName CompanionName, class FName Modifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveBuffFromCompanion");

	Params::UCustomGameInstance_RemoveBuffFromCompanion_Params Parms{};

	Parms.CompanionName = CompanionName;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RemoveAllSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::RemoveAllSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveAllSave");

	Params::UCustomGameInstance_RemoveAllSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.RemoveAllDecisionsFromCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CheckIfCompanionIsAvailable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::RemoveAllDecisionsFromCompanion(class FName CompanionID, bool CheckIfCompanionIsAvailable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RemoveAllDecisionsFromCompanion");

	Params::UCustomGameInstance_RemoveAllDecisionsFromCompanion_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.CheckIfCompanionIsAvailable = CheckIfCompanionIsAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.RaportPlayerAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EPlayerAction           Action                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::RaportPlayerAction(enum class EPlayerAction Action)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "RaportPlayerAction");

	Params::UCustomGameInstance_RaportPlayerAction_Params Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.PrintResourcesOnLevel
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::PrintResourcesOnLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PrintResourcesOnLevel");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.PrepareHeroDataForFractalVRMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::PrepareHeroDataForFractalVRMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PrepareHeroDataForFractalVRMap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentRemoveFromLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LimitDelta                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PowerManagmentRemoveFromLimit(int32 LimitDelta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentRemoveFromLimit");

	Params::UCustomGameInstance_PowerManagmentRemoveFromLimit_Params Parms{};

	Parms.LimitDelta = LimitDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentRemove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Power                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PowerManagmentRemove(int32 Power)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentRemove");

	Params::UCustomGameInstance_PowerManagmentRemove_Params Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentGetLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::PowerManagmentGetLimit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentGetLimit");

	Params::UCustomGameInstance_PowerManagmentGetLimit_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentGetCurrentUsage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::PowerManagmentGetCurrentUsage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentGetCurrentUsage");

	Params::UCustomGameInstance_PowerManagmentGetCurrentUsage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentCanAdd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Power                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PowerManagmentCanAdd(int32 Power)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentCanAdd");

	Params::UCustomGameInstance_PowerManagmentCanAdd_Params Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentAddToLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LimitDelta                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PowerManagmentAddToLimit(int32 LimitDelta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentAddToLimit");

	Params::UCustomGameInstance_PowerManagmentAddToLimit_Params Parms{};

	Parms.LimitDelta = LimitDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PowerManagmentAdd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Power                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PowerManagmentAdd(int32 Power)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PowerManagmentAdd");

	Params::UCustomGameInstance_PowerManagmentAdd_Params Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PostLoadMapWithWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UWorld*                      InWorld                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::PostLoadMapWithWorld(class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PostLoadMapWithWorld");

	Params::UCustomGameInstance_PostLoadMapWithWorld_Params Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.PlayerInitializationFinished
// (Final, Native, Private, BlueprintCallable)
// Parameters:

void UCustomGameInstance::PlayerInitializationFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PlayerInitializationFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.PermanentDataSetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         Entry                                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               NewVlaue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::PermanentDataSetValue(const struct FDataTableRowHandle& Entry, bool NewVlaue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PermanentDataSetValue");

	Params::UCustomGameInstance_PermanentDataSetValue_Params Parms{};

	Parms.Entry = Entry;
	Parms.NewVlaue = NewVlaue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.PermanentDataGetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         Entry                                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::PermanentDataGetValue(const struct FDataTableRowHandle& Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PermanentDataGetValue");

	Params::UCustomGameInstance_PermanentDataGetValue_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PerformQuickSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EQuickSaveResult        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EQuickSaveResult UCustomGameInstance::PerformQuickSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PerformQuickSave");

	Params::UCustomGameInstance_PerformQuickSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.PauseGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Enabled                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::PauseGame(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "PauseGame");

	Params::UCustomGameInstance_PauseGame_Params Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.OpenAsynchronouslyLoadedLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::OpenAsynchronouslyLoadedLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OpenAsynchronouslyLoadedLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.OnTemporalStorageDropped
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::OnTemporalStorageDropped()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnTemporalStorageDropped");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.OnQuestFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::OnQuestFinished(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnQuestFinished");

	Params::UCustomGameInstance_OnQuestFinished_Params Parms{};

	Parms.QuestID = QuestID;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.OnLoadGameFinished
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::OnLoadGameFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnLoadGameFinished");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.OnLevelAddedToWorld
// (Final, Native, Public)
// Parameters:
// class ULevel*                      Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                      InWorld                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::OnLevelAddedToWorld(class ULevel* Level, class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnLevelAddedToWorld");

	Params::UCustomGameInstance_OnLevelAddedToWorld_Params Parms{};

	Parms.Level = Level;
	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.OnGlobalSkinChanged
// (Final, Native, Public)
// Parameters:
// enum class EGlobalSkinType         SkinType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewSkinName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::OnGlobalSkinChanged(enum class EGlobalSkinType SkinType, class FName NewSkinName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnGlobalSkinChanged");

	Params::UCustomGameInstance_OnGlobalSkinChanged_Params Parms{};

	Parms.SkinType = SkinType;
	Parms.NewSkinName = NewSkinName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.OnCombatDifficultyChanged
// (Final, Native, Public)
// Parameters:

void UCustomGameInstance::OnCombatDifficultyChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "OnCombatDifficultyChanged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.NewGamePlus
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::NewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "NewGamePlus");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.MoveCompanionToARandomBuilding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGNPC*                      Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnPositionActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::MoveCompanionToARandomBuilding(class ACGNPC* Companion, class AActor* ReturnPositionActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "MoveCompanionToARandomBuilding");

	Params::UCustomGameInstance_MoveCompanionToARandomBuilding_Params Parms{};

	Parms.Companion = Companion;
	Parms.ReturnPositionActor = ReturnPositionActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.ModifyWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::ModifyWeaponDurability(class FName UniqueId, float Offset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ModifyWeaponDurability");

	Params::UCustomGameInstance_ModifyWeaponDurability_Params Parms{};

	Parms.UniqueId = UniqueId;
	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ModifyQuestsRubberBandingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Modifier                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::ModifyQuestsRubberBandingValue(float Modifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ModifyQuestsRubberBandingValue");

	Params::UCustomGameInstance_ModifyQuestsRubberBandingValue_Params Parms{};

	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.MakeScreenshotData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSaveScreenshotData         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSaveScreenshotData UCustomGameInstance::MakeScreenshotData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "MakeScreenshotData");

	Params::UCustomGameInstance_MakeScreenshotData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.LockSaveAndLoadForDuration
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCustomGameInstance::LockSaveAndLoadForDuration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LockSaveAndLoadForDuration");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.LoadingComplited
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::LoadingComplited()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadingComplited");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.LoadGameGlobalMetadata
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bOnlyWhenNull                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::LoadGameGlobalMetadata(bool bOnlyWhenNull)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadGameGlobalMetadata");

	Params::UCustomGameInstance_LoadGameGlobalMetadata_Params Parms{};

	Parms.bOnlyWhenNull = bOnlyWhenNull;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.LoadGameFromFile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::LoadGameFromFile()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadGameFromFile");

	Params::UCustomGameInstance_LoadGameFromFile_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.LoadGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BroadcastEvent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::LoadGame(class UObject* WorldContextObject, bool BroadcastEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadGame");

	Params::UCustomGameInstance_LoadGame_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BroadcastEvent = BroadcastEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.LoadDebugLevels
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::LoadDebugLevels()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadDebugLevels");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.LoadAsynchronouslyLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NewLevel                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Options                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::LoadAsynchronouslyLevel(class FName NewLevel, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "LoadAsynchronouslyLevel");

	Params::UCustomGameInstance_LoadAsynchronouslyLevel_Params Parms{};

	Parms.NewLevel = NewLevel;
	Parms.Options = Options;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.K2_GetWeaponSkinByType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EWeaponSkinType         WeaponSkinType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSuccess                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponSkinInfo             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponSkinInfo UCustomGameInstance::K2_GetWeaponSkinByType(enum class EWeaponSkinType WeaponSkinType, bool* OutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetWeaponSkinByType");

	Params::UCustomGameInstance_K2_GetWeaponSkinByType_Params Parms{};

	Parms.WeaponSkinType = WeaponSkinType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetSolidersEventLevelInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoldierEventLevel          Info                                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::K2_GetSolidersEventLevelInfo(int32 Level, struct FSoldierEventLevel* Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetSolidersEventLevelInfo");

	Params::UCustomGameInstance_K2_GetSolidersEventLevelInfo_Params Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetMonstersEventLevelInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Level                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMonsterEventLevel          Info                                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::K2_GetMonstersEventLevelInfo(int32 Level, struct FMonsterEventLevel* Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetMonstersEventLevelInfo");

	Params::UCustomGameInstance_K2_GetMonstersEventLevelInfo_Params Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetEnabledGlobalSkin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EGlobalSkinType         SkinType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSuccess                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGlobalSkinInfo             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGlobalSkinInfo UCustomGameInstance::K2_GetEnabledGlobalSkin(enum class EGlobalSkinType SkinType, bool* OutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetEnabledGlobalSkin");

	Params::UCustomGameInstance_K2_GetEnabledGlobalSkin_Params Parms{};

	Parms.SkinType = SkinType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetAvailableWeaponSkinsForType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWeaponSkinType         WeaponSkinType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWeaponSkinInfo>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponSkinInfo> UCustomGameInstance::K2_GetAvailableWeaponSkinsForType(enum class EWeaponSkinType WeaponSkinType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetAvailableWeaponSkinsForType");

	Params::UCustomGameInstance_K2_GetAvailableWeaponSkinsForType_Params Parms{};

	Parms.WeaponSkinType = WeaponSkinType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetAvailableGlobalSkinsForType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EGlobalSkinType         Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGlobalSkinInfo>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGlobalSkinInfo> UCustomGameInstance::K2_GetAvailableGlobalSkinsForType(enum class EGlobalSkinType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetAvailableGlobalSkinsForType");

	Params::UCustomGameInstance_K2_GetAvailableGlobalSkinsForType_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.K2_GetActorInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ActorName                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorInfo                  Info                                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::K2_GetActorInfo(class FName& ActorName, struct FActorInfo* Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "K2_GetActorInfo");

	Params::UCustomGameInstance_K2_GetActorInfo_Params Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.ItemIdToWeaponSkinType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EWeaponSkinType         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWeaponSkinType UCustomGameInstance::ItemIdToWeaponSkinType(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ItemIdToWeaponSkinType");

	Params::UCustomGameInstance_ItemIdToWeaponSkinType_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsWeaponDurabilityEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsWeaponDurabilityEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsWeaponDurabilityEnabled");

	Params::UCustomGameInstance_IsWeaponDurabilityEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsTimelineMorning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsTimelineMorning()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsTimelineMorning");

	Params::UCustomGameInstance_IsTimelineMorning_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsSaveAndLoadLocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsSaveAndLoadLocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsSaveAndLoadLocked");

	Params::UCustomGameInstance_IsSaveAndLoadLocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsMapEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsMapEnabled(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsMapEnabled");

	Params::UCustomGameInstance_IsMapEnabled_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsLoadedSoundbank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsLoadedSoundbank(const class FString& Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsLoadedSoundbank");

	Params::UCustomGameInstance_IsLoadedSoundbank_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsHeroDataPrepearedForFractalVR
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsHeroDataPrepearedForFractalVR()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsHeroDataPrepearedForFractalVR");

	Params::UCustomGameInstance_IsHeroDataPrepearedForFractalVR_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsFSREnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsFSREnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsFSREnabled");

	Params::UCustomGameInstance_IsFSREnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsDLSSEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsDLSSEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsDLSSEnabled");

	Params::UCustomGameInstance_IsDLSSEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsContinueSaveGameGOM
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsContinueSaveGameGOM()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsContinueSaveGameGOM");

	Params::UCustomGameInstance_IsContinueSaveGameGOM_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsCompanionLoyaltyRevertPossible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsCompanionLoyaltyRevertPossible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsCompanionLoyaltyRevertPossible");

	Params::UCustomGameInstance_IsCompanionLoyaltyRevertPossible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsCompanionEmployed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsCompanionEmployed(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsCompanionEmployed");

	Params::UCustomGameInstance_IsCompanionEmployed_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.IsCompanionAssignedToBuildingSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::IsCompanionAssignedToBuildingSlot(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IsCompanionAssignedToBuildingSlot");

	Params::UCustomGameInstance_IsCompanionAssignedToBuildingSlot_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.Internal_SetPostTransitionLevel
// (Final, Native, Public)
// Parameters:

void UCustomGameInstance::Internal_SetPostTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "Internal_SetPostTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.Internal_OpenTransitionLevel
// (Final, Native, Public)
// Parameters:

void UCustomGameInstance::Internal_OpenTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "Internal_OpenTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.Internal_CGOpenPostTransitionLevel
// (Final, Native, Public)
// Parameters:

void UCustomGameInstance::Internal_CGOpenPostTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "Internal_CGOpenPostTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.CustomGameInstance.InfluenceLevelUp__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                              AddedExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::InfluenceLevelUp__DelegateSignature(float AddedExp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "InfluenceLevelUp__DelegateSignature");

	Params::UCustomGameInstance_InfluenceLevelUp__DelegateSignature_Params Parms{};

	Parms.AddedExp = AddedExp;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.IncrementTimelineTutorialDeathCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::IncrementTimelineTutorialDeathCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IncrementTimelineTutorialDeathCount");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.IncreaseNumberOfSpaceTimeDistributors
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::IncreaseNumberOfSpaceTimeDistributors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "IncreaseNumberOfSpaceTimeDistributors");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.HaveBuffCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Modifier                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::HaveBuffCompanion(class FName CompanionName, class FName Modifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "HaveBuffCompanion");

	Params::UCustomGameInstance_HaveBuffCompanion_Params Parms{};

	Parms.CompanionName = CompanionName;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetWeatherCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetWeatherCPP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetWeatherCPP");

	Params::UCustomGameInstance_GetWeatherCPP_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetWeaponDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetWeaponDurability(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetWeaponDurability");

	Params::UCustomGameInstance_GetWeaponDurability_Params Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetTransitionalMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETransitionalMode       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ETransitionalMode UCustomGameInstance::GetTransitionalMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetTransitionalMode");

	Params::UCustomGameInstance_GetTransitionalMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetTemporalStorageCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetTemporalStorageCount(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetTemporalStorageCount");

	Params::UCustomGameInstance_GetTemporalStorageCount_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetSuccededQuests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GetSuccededQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetSuccededQuests");

	Params::UCustomGameInstance_GetSuccededQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetSteamUserID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCustomGameInstance::GetSteamUserID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetSteamUserID");

	Params::UCustomGameInstance_GetSteamUserID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetStatForCompanion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        Companion                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bClamped                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatsModifier              ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FStatsModifier UCustomGameInstance::GetStatForCompanion(class FName Companion, bool bClamped)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetStatForCompanion");

	Params::UCustomGameInstance_GetStatForCompanion_Params Parms{};

	Parms.Companion = Companion;
	Parms.bClamped = bClamped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetStartingMoraleForCompanion
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCompanionDefinition        CompanionDefinition                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetStartingMoraleForCompanion(struct FCompanionDefinition& CompanionDefinition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetStartingMoraleForCompanion");

	Params::UCustomGameInstance_GetStartingMoraleForCompanion_Params Parms{};

	Parms.CompanionDefinition = CompanionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetShouldUseDefaultSaveSystemForGateOfMadness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetShouldUseDefaultSaveSystemForGateOfMadness()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetShouldUseDefaultSaveSystemForGateOfMadness");

	Params::UCustomGameInstance_GetShouldUseDefaultSaveSystemForGateOfMadness_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetShouldShowTimelineDeathTutorial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetShouldShowTimelineDeathTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetShouldShowTimelineDeathTutorial");

	Params::UCustomGameInstance_GetShouldShowTimelineDeathTutorial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetShouldShowHeistTutorialInBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetShouldShowHeistTutorialInBase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetShouldShowHeistTutorialInBase");

	Params::UCustomGameInstance_GetShouldShowHeistTutorialInBase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetShouldPerformGateOfMadnessBackup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetShouldPerformGateOfMadnessBackup()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetShouldPerformGateOfMadnessBackup");

	Params::UCustomGameInstance_GetShouldPerformGateOfMadnessBackup_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetSaveTimestamp
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UCustomGameInstance::GetSaveTimestamp(const class FString& SaveName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetSaveTimestamp");

	Params::UCustomGameInstance_GetSaveTimestamp_Params Parms{};

	Parms.SaveName = SaveName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetSaveScreenshotPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCustomGameInstance::GetSaveScreenshotPath(const class FString& SaveName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetSaveScreenshotPath");

	Params::UCustomGameInstance_GetSaveScreenshotPath_Params Parms{};

	Parms.SaveName = SaveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetSaveGameMetadata
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      SaveName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomSaveGameMetadataInfo ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomSaveGameMetadataInfo UCustomGameInstance::GetSaveGameMetadata(const class FString& SaveName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetSaveGameMetadata");

	Params::UCustomGameInstance_GetSaveGameMetadata_Params Parms{};

	Parms.SaveName = SaveName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetRequiredExperiencePerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetRequiredExperiencePerLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetRequiredExperiencePerLevel");

	Params::UCustomGameInstance_GetRequiredExperiencePerLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetQuestRubberBandingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetQuestRubberBandingValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetQuestRubberBandingValue");

	Params::UCustomGameInstance_GetQuestRubberBandingValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetQuestResultText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMissionReportRequiredInformationQuestResultInfo                                                  (Parm, NativeAccessSpecifierPublic)
// struct FReportsTextsDataTableRow   ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FReportsTextsDataTableRow UCustomGameInstance::GetQuestResultText(const struct FMissionReportRequiredInformation& QuestResultInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetQuestResultText");

	Params::UCustomGameInstance_GetQuestResultText_Params Parms{};

	Parms.QuestResultInfo = QuestResultInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetQuestResultItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMissionReportRequiredInformationQuestResultInfo                                                  (Parm, NativeAccessSpecifierPublic)
// struct FReportItems                ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FReportItems UCustomGameInstance::GetQuestResultItems(const struct FMissionReportRequiredInformation& QuestResultInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetQuestResultItems");

	Params::UCustomGameInstance_GetQuestResultItems_Params Parms{};

	Parms.QuestResultInfo = QuestResultInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetQuestInfoBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuestInfoInput             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FQuestInfoInput UCustomGameInstance::GetQuestInfoBP(class FName QuestID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetQuestInfoBP");

	Params::UCustomGameInstance_GetQuestInfoBP_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetQuestDescription
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        DescID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDescriptionInfo            ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDescriptionInfo UCustomGameInstance::GetQuestDescription(class FName DescID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetQuestDescription");

	Params::UCustomGameInstance_GetQuestDescription_Params Parms{};

	Parms.DescID = DescID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetProbabilityOfQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetProbabilityOfQuest(class FName QuestID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetProbabilityOfQuest");

	Params::UCustomGameInstance_GetProbabilityOfQuest_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetPostTransitionLevelReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetPostTransitionLevelReady()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetPostTransitionLevelReady");

	Params::UCustomGameInstance_GetPostTransitionLevelReady_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetPostTransitionLevelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetPostTransitionLevelName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetPostTransitionLevelName");

	Params::UCustomGameInstance_GetPostTransitionLevelName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetMissionInfosForDay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Day                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMissionReportRequiredInformation>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMissionReportRequiredInformation> UCustomGameInstance::GetMissionInfosForDay(int32 Day)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetMissionInfosForDay");

	Params::UCustomGameInstance_GetMissionInfosForDay_Params Parms{};

	Parms.Day = Day;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetMapForActiveEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EEventMap UCustomGameInstance::GetMapForActiveEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetMapForActiveEvent");

	Params::UCustomGameInstance_GetMapForActiveEvent_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetMapEnumByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        MapName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EEventMap UCustomGameInstance::GetMapEnumByName(class FName MapName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetMapEnumByName");

	Params::UCustomGameInstance_GetMapEnumByName_Params Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetLastWeekEvents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FEventDeactivationTimeStamp>Result                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCustomGameInstance::GetLastWeekEvents(TArray<struct FEventDeactivationTimeStamp>* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetLastWeekEvents");

	Params::UCustomGameInstance_GetLastWeekEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

}


// Function ChernobylGame.CustomGameInstance.GetLastActiveQuestNameForMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetLastActiveQuestNameForMap(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetLastActiveQuestNameForMap");

	Params::UCustomGameInstance_GetLastActiveQuestNameForMap_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsUserInterfaceGloballyDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsUserInterfaceGloballyDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsUserInterfaceGloballyDisabled");

	Params::UCustomGameInstance_GetIsUserInterfaceGloballyDisabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsPsycheDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsPsycheDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsPsycheDisabled");

	Params::UCustomGameInstance_GetIsPsycheDisabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsGateOfMadnessModeAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsGateOfMadnessModeAvailable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsGateOfMadnessModeAvailable");

	Params::UCustomGameInstance_GetIsGateOfMadnessModeAvailable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsGateOfMadnessMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsGateOfMadnessMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsGateOfMadnessMode");

	Params::UCustomGameInstance_GetIsGateOfMadnessMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsDifficultyGateOfMadness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDifficultyType         DifficultyType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsDifficultyGateOfMadness(enum class EDifficultyType DifficultyType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsDifficultyGateOfMadness");

	Params::UCustomGameInstance_GetIsDifficultyGateOfMadness_Params Parms{};

	Parms.DifficultyType = DifficultyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsCustomSoldierEventLevelEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsCustomSoldierEventLevelEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsCustomSoldierEventLevelEnabled");

	Params::UCustomGameInstance_GetIsCustomSoldierEventLevelEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetIsBuildingRestrictedFromCurrentGameMode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBuildEntry                 BuildEntry                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetIsBuildingRestrictedFromCurrentGameMode(struct FBuildEntry& BuildEntry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetIsBuildingRestrictedFromCurrentGameMode");

	Params::UCustomGameInstance_GetIsBuildingRestrictedFromCurrentGameMode_Params Parms{};

	Parms.BuildEntry = BuildEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetInfluenceExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetInfluenceExp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetInfluenceExp");

	Params::UCustomGameInstance_GetInfluenceExp_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetGatheredItemsByCompanions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCompanionWithPrize> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCompanionWithPrize> UCustomGameInstance::GetGatheredItemsByCompanions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetGatheredItemsByCompanions");

	Params::UCustomGameInstance_GetGatheredItemsByCompanions_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetFinishedQuests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GetFinishedQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetFinishedQuests");

	Params::UCustomGameInstance_GetFinishedQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetFinishedGameAtLeastOnceMetadataOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetFinishedGameAtLeastOnceMetadataOnly()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetFinishedGameAtLeastOnceMetadataOnly");

	Params::UCustomGameInstance_GetFinishedGameAtLeastOnceMetadataOnly_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDLSSMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUDLSSMode              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EUDLSSMode UCustomGameInstance::GetDLSSMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDLSSMode");

	Params::UCustomGameInstance_GetDLSSMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDifficultyValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDifficultyType         DifficultyType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDifficultyValue        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDifficultyValue UCustomGameInstance::GetDifficultyValue(enum class EDifficultyType DifficultyType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDifficultyValue");

	Params::UCustomGameInstance_GetDifficultyValue_Params Parms{};

	Parms.DifficultyType = DifficultyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDifficultyModifierChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnOneOnFail                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetDifficultyModifierChecked(class FName Name, bool* OutResult, bool ReturnOneOnFail)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDifficultyModifierChecked");

	Params::UCustomGameInstance_GetDifficultyModifierChecked_Params Parms{};

	Parms.Name = Name;
	Parms.ReturnOneOnFail = ReturnOneOnFail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDifficultyModifierByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDifficultyModifierType Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnOneOnFail                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetDifficultyModifierByType(enum class EDifficultyModifierType Type, bool ReturnOneOnFail)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDifficultyModifierByType");

	Params::UCustomGameInstance_GetDifficultyModifierByType_Params Parms{};

	Parms.Type = Type;
	Parms.ReturnOneOnFail = ReturnOneOnFail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDifficultyModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnOneOnFail                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::GetDifficultyModifier(class FName Name, bool ReturnOneOnFail)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDifficultyModifier");

	Params::UCustomGameInstance_GetDifficultyModifier_Params Parms{};

	Parms.Name = Name;
	Parms.ReturnOneOnFail = ReturnOneOnFail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetDayPart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EDayPart                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EDayPart UCustomGameInstance::GetDayPart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetDayPart");

	Params::UCustomGameInstance_GetDayPart_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCustomSoldierEventLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetCustomSoldierEventLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCustomSoldierEventLevel");

	Params::UCustomGameInstance_GetCustomSoldierEventLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCustomSaves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCustomGameInstance::GetCustomSaves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCustomSaves");

	Params::UCustomGameInstance_GetCustomSaves_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCustomSaveNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECustomSaveType         CustomSaveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCustomGameInstance::GetCustomSaveNames(enum class ECustomSaveType CustomSaveType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCustomSaveNames");

	Params::UCustomGameInstance_GetCustomSaveNames_Params Parms{};

	Parms.CustomSaveType = CustomSaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentStatsForCompanion2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Valid                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompanionEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCompanionEntry UCustomGameInstance::GetCurrentStatsForCompanion2(class FName Name, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentStatsForCompanion2");

	Params::UCustomGameInstance_GetCurrentStatsForCompanion2_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentStatsForCompanion
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompanionEntry             Info                                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetCurrentStatsForCompanion(class FName Name, struct FCompanionEntry& Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentStatsForCompanion");

	Params::UCustomGameInstance_GetCurrentStatsForCompanion_Params Parms{};

	Parms.Name = Name;
	Parms.Info = Info;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentSoldierEventLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               SkipLevelModifiers                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetCurrentSoldierEventLevel(bool SkipLevelModifiers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentSoldierEventLevel");

	Params::UCustomGameInstance_GetCurrentSoldierEventLevel_Params Parms{};

	Parms.SkipLevelModifiers = SkipLevelModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentSaveGameFileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetCurrentSaveGameFileName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentSaveGameFileName");

	Params::UCustomGameInstance_GetCurrentSaveGameFileName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentMonsterEventLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               SkipLevelModifiers                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetCurrentMonsterEventLevel(bool SkipLevelModifiers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentMonsterEventLevel");

	Params::UCustomGameInstance_GetCurrentMonsterEventLevel_Params Parms{};

	Parms.SkipLevelModifiers = SkipLevelModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCurrentDay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetCurrentDay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCurrentDay");

	Params::UCustomGameInstance_GetCurrentDay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetContinueSaveGameFileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetContinueSaveGameFileName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetContinueSaveGameFileName");

	Params::UCustomGameInstance_GetContinueSaveGameFileName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetConflictForCurrentDay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FConflict                   ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FConflict UCustomGameInstance::GetConflictForCurrentDay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetConflictForCurrentDay");

	Params::UCustomGameInstance_GetConflictForCurrentDay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCompletedStoryQuestsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetCompletedStoryQuestsCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCompletedStoryQuestsCount");

	Params::UCustomGameInstance_GetCompletedStoryQuestsCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCompanionsModifiers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GetCompanionsModifiers(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCompanionsModifiers");

	Params::UCustomGameInstance_GetCompanionsModifiers_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCompanionsInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCompanionDefinition        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCompanionDefinition UCustomGameInstance::GetCompanionsInfo(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCompanionsInfo");

	Params::UCustomGameInstance_GetCompanionsInfo_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCompanionEquipmnetStatsModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInventoryEntry             ItemEntry                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCompanionEffectiveness     ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCompanionEffectiveness UCustomGameInstance::GetCompanionEquipmnetStatsModifier(struct FInventoryEntry& ItemEntry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCompanionEquipmnetStatsModifier");

	Params::UCustomGameInstance_GetCompanionEquipmnetStatsModifier_Params Parms{};

	Parms.ItemEntry = ItemEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetCompanionByActiveEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Valid                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::GetCompanionByActiveEvent(class FName EventID, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetCompanionByActiveEvent");

	Params::UCustomGameInstance_GetCompanionByActiveEvent_Params Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetClimbDebugEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetClimbDebugEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetClimbDebugEnabled");

	Params::UCustomGameInstance_GetClimbDebugEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetbFreeModeEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetbFreeModeEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetbFreeModeEvents");

	Params::UCustomGameInstance_GetbFreeModeEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetbFreeMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetbFreeMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetbFreeMode");

	Params::UCustomGameInstance_GetbFreeMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetbContinueFromSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GetbContinueFromSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetbContinueFromSave");

	Params::UCustomGameInstance_GetbContinueFromSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetBackend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABackend*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABackend* UCustomGameInstance::GetBackend()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetBackend");

	Params::UCustomGameInstance_GetBackend_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAvailableCompanions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCompanionEntry>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCompanionEntry> UCustomGameInstance::GetAvailableCompanions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAvailableCompanions");

	Params::UCustomGameInstance_GetAvailableCompanions_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAvaiableRecipies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GetAvaiableRecipies()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAvaiableRecipies");

	Params::UCustomGameInstance_GetAvaiableRecipies_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAutoDLSSQualityBasedOnPixels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Pixels                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EUDLSSMode              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EUDLSSMode UCustomGameInstance::GetAutoDLSSQualityBasedOnPixels(int32 Pixels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAutoDLSSQualityBasedOnPixels");

	Params::UCustomGameInstance_GetAutoDLSSQualityBasedOnPixels_Params Parms{};

	Parms.Pixels = Pixels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAdjustedSoldierEventLevel
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                               SkipLevelModifiers                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetAdjustedSoldierEventLevel(bool SkipLevelModifiers)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAdjustedSoldierEventLevel");

	Params::UCustomGameInstance_GetAdjustedSoldierEventLevel_Params Parms{};

	Parms.SkipLevelModifiers = SkipLevelModifiers;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetActiveQuests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<enum class EEventMap, struct FActiveQuestInfo>ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<enum class EEventMap, struct FActiveQuestInfo> UCustomGameInstance::GetActiveQuests()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetActiveQuests");

	Params::UCustomGameInstance_GetActiveQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetActiveQuestDifficultyModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::GetActiveQuestDifficultyModifier(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetActiveQuestDifficultyModifier");

	Params::UCustomGameInstance_GetActiveQuestDifficultyModifier_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetActiveEventsV2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GetActiveEventsV2(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetActiveEventsV2");

	Params::UCustomGameInstance_GetActiveEventsV2_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetActiveEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInnerEvent>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInnerEvent> UCustomGameInstance::GetActiveEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetActiveEvents");

	Params::UCustomGameInstance_GetActiveEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAchievementsFromSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<enum class EAchievementType, float>ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TMap<enum class EAchievementType, float> UCustomGameInstance::GetAchievementsFromSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAchievementsFromSave");

	Params::UCustomGameInstance_GetAchievementsFromSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GetAchievementInfo_K2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAchievementType        AchievementType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAchievementInfo            ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAchievementInfo UCustomGameInstance::GetAchievementInfo_K2(enum class EAchievementType AchievementType, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GetAchievementInfo_K2");

	Params::UCustomGameInstance_GetAchievementInfo_K2_Params Parms{};

	Parms.AchievementType = AchievementType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GameCharactersIsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CharacterID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GameCharactersIsEnabled(class FName CharacterID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GameCharactersIsEnabled");

	Params::UCustomGameInstance_GameCharactersIsEnabled_Params Parms{};

	Parms.CharacterID = CharacterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GameCharactersInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        CharacterID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameCharacter              Info                                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GameCharactersInfo(class FName CharacterID, struct FGameCharacter* Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GameCharactersInfo");

	Params::UCustomGameInstance_GameCharactersInfo_Params Parms{};

	Parms.CharacterID = CharacterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GameCharactersGet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::GameCharactersGet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GameCharactersGet");

	Params::UCustomGameInstance_GameCharactersGet_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GameCharactersEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CharacterID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GameCharactersEnable(class FName CharacterID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GameCharactersEnable");

	Params::UCustomGameInstance_GameCharactersEnable_Params Parms{};

	Parms.CharacterID = CharacterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.GameCharactersDisable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CharacterID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::GameCharactersDisable(class FName CharacterID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "GameCharactersDisable");

	Params::UCustomGameInstance_GameCharactersDisable_Params Parms{};

	Parms.CharacterID = CharacterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.ForceScreenshot
// (Exec, Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::ForceScreenshot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ForceScreenshot");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.FlushInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::FlushInventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "FlushInventory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.FinishQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMissionResult          Result                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::FinishQuest(class FName QuestID, enum class EEventMap Map, enum class EMissionResult Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "FinishQuest");

	Params::UCustomGameInstance_FinishQuest_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.FinishEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::FinishEvent(class FName EventID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "FinishEvent");

	Params::UCustomGameInstance_FinishEvent_Params Parms{};

	Parms.EventID = EventID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.FindFavouriteBuildEntities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::FindFavouriteBuildEntities(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "FindFavouriteBuildEntities");

	Params::UCustomGameInstance_FindFavouriteBuildEntities_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.FindDislikedBuildEntities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::FindDislikedBuildEntities(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "FindDislikedBuildEntities");

	Params::UCustomGameInstance_FindDislikedBuildEntities_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.EventStatusAdded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Status                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EventStatusAdded(class FName Event, class FName Status)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EventStatusAdded");

	Params::UCustomGameInstance_EventStatusAdded_Params Parms{};

	Parms.Event = Event;
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableWwiseForceFlush
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableWwiseForceFlush(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableWwiseForceFlush");

	Params::UCustomGameInstance_EnableWwiseForceFlush_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableSightDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableSightDebug(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableSightDebug");

	Params::UCustomGameInstance_EnableSightDebug_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableScreenshotOnSave
// (Final, Exec, Native, Public)
// Parameters:
// bool                               IsEnabled                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableScreenshotOnSave(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableScreenshotOnSave");

	Params::UCustomGameInstance_EnableScreenshotOnSave_Params Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableResourceSpawnDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableResourceSpawnDebug(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableResourceSpawnDebug");

	Params::UCustomGameInstance_EnableResourceSpawnDebug_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::EnableQuest(class FName QuestID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableQuest");

	Params::UCustomGameInstance_EnableQuest_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.EnablePatchPreviewText
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnablePatchPreviewText(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnablePatchPreviewText");

	Params::UCustomGameInstance_EnablePatchPreviewText_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::EnableMap(enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableMap");

	Params::UCustomGameInstance_EnableMap_Params Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.EnableExperimentalStreamingTimes
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableExperimentalStreamingTimes(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableExperimentalStreamingTimes");

	Params::UCustomGameInstance_EnableExperimentalStreamingTimes_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableExperimentalLoadScreen
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableExperimentalLoadScreen(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableExperimentalLoadScreen");

	Params::UCustomGameInstance_EnableExperimentalLoadScreen_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableEventV2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::EnableEventV2(class FName EventID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableEventV2");

	Params::UCustomGameInstance_EnableEventV2_Params Parms{};

	Parms.EventID = EventID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.EnableEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        Event                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::EnableEvent(class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableEvent");

	Params::UCustomGameInstance_EnableEvent_Params Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.EnableDebugStreamingManager
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableDebugStreamingManager(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableDebugStreamingManager");

	Params::UCustomGameInstance_EnableDebugStreamingManager_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableCustomSoldierEventLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableCustomSoldierEventLevel(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableCustomSoldierEventLevel");

	Params::UCustomGameInstance_EnableCustomSoldierEventLevel_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableConsoleMainMenuDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableConsoleMainMenuDebug(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableConsoleMainMenuDebug");

	Params::UCustomGameInstance_EnableConsoleMainMenuDebug_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.EnableClimbDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::EnableClimbDebug(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "EnableClimbDebug");

	Params::UCustomGameInstance_EnableClimbDebug_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DumpRefs
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class UObject>         UClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DumpRefs(TSubclassOf<class UObject> UClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DumpRefs");

	Params::UCustomGameInstance_DumpRefs_Params Parms{};

	Parms.UClass = UClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DumpOutermostObject
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class UObject>         UClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DumpOutermostObject(TSubclassOf<class UObject> UClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DumpOutermostObject");

	Params::UCustomGameInstance_DumpOutermostObject_Params Parms{};

	Parms.UClass = UClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DumpLastWidgetOuter
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class UObject>         UClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DumpLastWidgetOuter(TSubclassOf<class UObject> UClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DumpLastWidgetOuter");

	Params::UCustomGameInstance_DumpLastWidgetOuter_Params Parms{};

	Parms.UClass = UClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DumpFirstWidgetOuter
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class UObject>         UClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DumpFirstWidgetOuter(TSubclassOf<class UObject> UClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DumpFirstWidgetOuter");

	Params::UCustomGameInstance_DumpFirstWidgetOuter_Params Parms{};

	Parms.UClass = UClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DumpComponentOwners
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class UActorComponent> UClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DumpComponentOwners(TSubclassOf<class UActorComponent> UClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DumpComponentOwners");

	Params::UCustomGameInstance_DumpComponentOwners_Params Parms{};

	Parms.UClass = UClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DropItemsFromTemporalStorage
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::DropItemsFromTemporalStorage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DropItemsFromTemporalStorage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DoesCompanionWantToLeaveAPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::DoesCompanionWantToLeaveAPlayer(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DoesCompanionWantToLeaveAPlayer");

	Params::UCustomGameInstance_DoesCompanionWantToLeaveAPlayer_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.DisableQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::DisableQuest(class FName QuestID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DisableQuest");

	Params::UCustomGameInstance_DisableQuest_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.DisableFSROnMapLeave
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::DisableFSROnMapLeave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DisableFSROnMapLeave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DisableEventV2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::DisableEventV2(class FName EventID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DisableEventV2");

	Params::UCustomGameInstance_DisableEventV2_Params Parms{};

	Parms.EventID = EventID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.DisableAvailableQuestsByCategoryForNextUpdate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<enum class EQuestCategoryType>Categories                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomGameInstance::DisableAvailableQuestsByCategoryForNextUpdate(TArray<enum class EQuestCategoryType>& Categories)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DisableAvailableQuestsByCategoryForNextUpdate");

	Params::UCustomGameInstance_DisableAvailableQuestsByCategoryForNextUpdate_Params Parms{};

	Parms.Categories = Categories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DialogueSystemSetBool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DialogueSystemSetBool(const class FString& Name, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DialogueSystemSetBool");

	Params::UCustomGameInstance_DialogueSystemSetBool_Params Parms{};

	Parms.Name = Name;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DialogueSystemGetBool
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::DialogueSystemGetBool(const class FString& Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DialogueSystemGetBool");

	Params::UCustomGameInstance_DialogueSystemGetBool_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.DialogueSpawnInteractable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACGAICharacter*              InAICharacter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InItemName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::DialogueSpawnInteractable(class ACGAICharacter* InAICharacter, class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DialogueSpawnInteractable");

	Params::UCustomGameInstance_DialogueSpawnInteractable_Params Parms{};

	Parms.InAICharacter = InAICharacter;
	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DecreaseNumberOfSpaceTimeDistributors
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::DecreaseNumberOfSpaceTimeDistributors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DecreaseNumberOfSpaceTimeDistributors");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DecreaseDeathCounter
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::DecreaseDeathCounter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DecreaseDeathCounter");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.DeathPenaltyRemoveItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FName, float>           ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, float> UCustomGameInstance::DeathPenaltyRemoveItems()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "DeathPenaltyRemoveItems");

	Params::UCustomGameInstance_DeathPenaltyRemoveItems_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CreateCustomSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECustomSaveType         CustomSaveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::CreateCustomSave(enum class ECustomSaveType CustomSaveType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CreateCustomSave");

	Params::UCustomGameInstance_CreateCustomSave_Params Parms{};

	Parms.CustomSaveType = CustomSaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CompanionUnequipItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECompanionEquipmentSlotTypeSlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UCustomGameInstance::CompanionUnequipItem(class FName CompanionID, enum class ECompanionEquipmentSlotType SlotType, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionUnequipItem");

	Params::UCustomGameInstance_CompanionUnequipItem_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionSystemSetLoyaltyLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NameID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewLoyalty                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::CompanionSystemSetLoyaltyLevel(class FName NameID, int32 NewLoyalty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSystemSetLoyaltyLevel");

	Params::UCustomGameInstance_CompanionSystemSetLoyaltyLevel_Params Parms{};

	Parms.NameID = NameID;
	Parms.NewLoyalty = NewLoyalty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CompanionSystemSetLoyaltyExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NameID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewLoyalty                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::CompanionSystemSetLoyaltyExp(class FName NameID, float NewLoyalty)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSystemSetLoyaltyExp");

	Params::UCustomGameInstance_CompanionSystemSetLoyaltyExp_Params Parms{};

	Parms.NameID = NameID;
	Parms.NewLoyalty = NewLoyalty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CompanionSystemGetLoyaltyLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NameID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::CompanionSystemGetLoyaltyLevel(class FName NameID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSystemGetLoyaltyLevel");

	Params::UCustomGameInstance_CompanionSystemGetLoyaltyLevel_Params Parms{};

	Parms.NameID = NameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionSystemGetLoyaltyExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NameID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::CompanionSystemGetLoyaltyExp(class FName NameID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSystemGetLoyaltyExp");

	Params::UCustomGameInstance_CompanionSystemGetLoyaltyExp_Params Parms{};

	Parms.NameID = NameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionSystemDebugForceConflict
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CompanionSystemDebugForceConflict()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSystemDebugForceConflict");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CompanionSwapItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECompanionEquipmentSlotTypeSlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             NewItem                                                          (Parm, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UCustomGameInstance::CompanionSwapItem(class FName CompanionID, enum class ECompanionEquipmentSlotType SlotType, const struct FInventoryEntry& NewItem, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionSwapItem");

	Params::UCustomGameInstance_CompanionSwapItem_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.SlotType = SlotType;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionGetEquippedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECompanionEquipmentSlotTypeSlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UCustomGameInstance::CompanionGetEquippedItem(class FName CompanionID, enum class ECompanionEquipmentSlotType SlotType, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionGetEquippedItem");

	Params::UCustomGameInstance_CompanionGetEquippedItem_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECompanionEquipmentSlotTypeSlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             NewItem                                                          (Parm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::CompanionEquipItem(class FName CompanionID, enum class ECompanionEquipmentSlotType SlotType, const struct FInventoryEntry& NewItem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionEquipItem");

	Params::UCustomGameInstance_CompanionEquipItem_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.SlotType = SlotType;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CompanionCanEquipItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECompanionEquipmentSlotTypeSlotType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             Item                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::CompanionCanEquipItem(enum class ECompanionEquipmentSlotType SlotType, struct FInventoryEntry& Item)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CompanionCanEquipItem");

	Params::UCustomGameInstance_CompanionCanEquipItem_Params Parms{};

	Parms.SlotType = SlotType;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.ClearDisabledQuestsByCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ClearDisabledQuestsByCategory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ClearDisabledQuestsByCategory");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ClearCompanionsFromBuildingSpots
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ClearCompanionsFromBuildingSpots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ClearCompanionsFromBuildingSpots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.ClearAllCustomSaveSlotsToDefaultValuesYesIDont
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::ClearAllCustomSaveSlotsToDefaultValuesYesIDont()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ClearAllCustomSaveSlotsToDefaultValuesYesIDont");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CheckIfPlayerDiedOnLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::CheckIfPlayerDiedOnLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CheckIfPlayerDiedOnLevel");

	Params::UCustomGameInstance_CheckIfPlayerDiedOnLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.CheckCompanionsMissionStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CheckCompanionsMissionStatus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CheckCompanionsMissionStatus");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGSetPostTransitionalLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InTargetLevelName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETransitionalMode       InTransMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SkipSave                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bClearContinueFlag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::CGSetPostTransitionalLevel(class FName InTargetLevelName, enum class ETransitionalMode InTransMode, bool SkipSave, bool bClearContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGSetPostTransitionalLevel");

	Params::UCustomGameInstance_CGSetPostTransitionalLevel_Params Parms{};

	Parms.InTargetLevelName = InTargetLevelName;
	Parms.InTransMode = InTransMode;
	Parms.SkipSave = SkipSave;
	Parms.bClearContinueFlag = bClearContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGOpenTransitionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InTargetLevelName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETransitionalMode       InTransMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SkipSave                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bClearContinueFlag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::CGOpenTransitionLevel(class FName InTargetLevelName, enum class ETransitionalMode InTransMode, bool SkipSave, bool bClearContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGOpenTransitionLevel");

	Params::UCustomGameInstance_CGOpenTransitionLevel_Params Parms{};

	Parms.InTargetLevelName = InTargetLevelName;
	Parms.InTransMode = InTransMode;
	Parms.SkipSave = SkipSave;
	Parms.bClearContinueFlag = bClearContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGOpenPostTransitionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CGOpenPostTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGOpenPostTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGMarkAsContinueFromSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CGMarkAsContinueFromSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGMarkAsContinueFromSave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGLoadTransitionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CGLoadTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGLoadTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.CGLoadPostTransitionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::CGLoadPostTransitionLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "CGLoadPostTransitionLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemUpdateActiveTiers
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::BuildSystemUpdateActiveTiers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemUpdateActiveTiers");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemRemoveNewEntity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemRemoveNewEntity(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemRemoveNewEntity");

	Params::UCustomGameInstance_BuildSystemRemoveNewEntity_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemIsCurrentCatalogTreeComplete
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Tree                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemIsCurrentCatalogTreeComplete(TArray<class FName>& Tree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemIsCurrentCatalogTreeComplete");

	Params::UCustomGameInstance_BuildSystemIsCurrentCatalogTreeComplete_Params Parms{};

	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemInit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemInit");

	Params::UCustomGameInstance_BuildSystemInit_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGlobalStatsRecalculate
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UCustomGameInstance::BuildSystemGlobalStatsRecalculate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGlobalStatsRecalculate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetStatModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameInstance::BuildSystemGetStatModifier(class FName Name, float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetStatModifier");

	Params::UCustomGameInstance_BuildSystemGetStatModifier_Params Parms{};

	Parms.Name = Name;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetStartingValueForGlobalStat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBuildGlobalStat            GlobalStat                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::BuildSystemGetStartingValueForGlobalStat(struct FBuildGlobalStat& GlobalStat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetStartingValueForGlobalStat");

	Params::UCustomGameInstance_BuildSystemGetStartingValueForGlobalStat_Params Parms{};

	Parms.GlobalStat = GlobalStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetRootCatalogIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetRootCatalogIDs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetRootCatalogIDs");

	Params::UCustomGameInstance_BuildSystemGetRootCatalogIDs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetReadablePath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Path                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCustomGameInstance::BuildSystemGetReadablePath(TArray<class FName>& Path)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetReadablePath");

	Params::UCustomGameInstance_BuildSystemGetReadablePath_Params Parms{};

	Parms.Path = Path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetPathsContaing
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Tree                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetPathsContaing(TArray<class FName>& Tree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetPathsContaing");

	Params::UCustomGameInstance_BuildSystemGetPathsContaing_Params Parms{};

	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetNameByCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EBuildCategory          Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::BuildSystemGetNameByCategory(enum class EBuildCategory Category)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetNameByCategory");

	Params::UCustomGameInstance_BuildSystemGetNameByCategory_Params Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetItemsByPath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Tree                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FBuildEntryInternal> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBuildEntryInternal> UCustomGameInstance::BuildSystemGetItemsByPath(TArray<class FName>& Tree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetItemsByPath");

	Params::UCustomGameInstance_BuildSystemGetItemsByPath_Params Parms{};

	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetIsPowerSufficient
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemGetIsPowerSufficient()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetIsPowerSufficient");

	Params::UCustomGameInstance_BuildSystemGetIsPowerSufficient_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetIAllItemsByPath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               bIsWorkshop                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Path                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FBuildEntryInternal> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBuildEntryInternal> UCustomGameInstance::BuildSystemGetIAllItemsByPath(bool bIsWorkshop, TArray<class FName>& Path)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetIAllItemsByPath");

	Params::UCustomGameInstance_BuildSystemGetIAllItemsByPath_Params Parms{};

	Parms.bIsWorkshop = bIsWorkshop;
	Parms.Path = Path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetHasEnoughPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              RequiredPower                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemGetHasEnoughPower(float RequiredPower)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetHasEnoughPower");

	Params::UCustomGameInstance_BuildSystemGetHasEnoughPower_Params Parms{};

	Parms.RequiredPower = RequiredPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetGlobalStatValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::BuildSystemGetGlobalStatValue(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetGlobalStatValue");

	Params::UCustomGameInstance_BuildSystemGetGlobalStatValue_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetGlobalStatInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBuildGlobalStat            ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBuildGlobalStat UCustomGameInstance::BuildSystemGetGlobalStatInfo(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetGlobalStatInfo");

	Params::UCustomGameInstance_BuildSystemGetGlobalStatInfo_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetGlobalAddValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Removing                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::BuildSystemGetGlobalAddValue(class FName Name, int32 Delta, bool Removing)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetGlobalAddValue");

	Params::UCustomGameInstance_BuildSystemGetGlobalAddValue_Params Parms{};

	Parms.Name = Name;
	Parms.Delta = Delta;
	Parms.Removing = Removing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetEntityInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBuildEntryInternal         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBuildEntryInternal UCustomGameInstance::BuildSystemGetEntityInfo(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetEntityInfo");

	Params::UCustomGameInstance_BuildSystemGetEntityInfo_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetEntityCurrentCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameInstance::BuildSystemGetEntityCurrentCount(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetEntityCurrentCount");

	Params::UCustomGameInstance_BuildSystemGetEntityCurrentCount_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetCurrentStatTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EBuildSystemStatType    StatType                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBuildSystemStatTier    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EBuildSystemStatTier UCustomGameInstance::BuildSystemGetCurrentStatTier(enum class EBuildSystemStatType StatType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetCurrentStatTier");

	Params::UCustomGameInstance_BuildSystemGetCurrentStatTier_Params Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetCategoryByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        CategoryName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBuildCategory          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EBuildCategory UCustomGameInstance::BuildSystemGetCategoryByName(class FName CategoryName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetCategoryByName");

	Params::UCustomGameInstance_BuildSystemGetCategoryByName_Params Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetCatalogInfoByPath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Path                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBuildCatalogPath           ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBuildCatalogPath UCustomGameInstance::BuildSystemGetCatalogInfoByPath(TArray<class FName>& Path)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetCatalogInfoByPath");

	Params::UCustomGameInstance_BuildSystemGetCatalogInfoByPath_Params Parms{};

	Parms.Path = Path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetAvaiablePathIDs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Tree                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetAvaiablePathIDs(TArray<class FName>& Tree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetAvaiablePathIDs");

	Params::UCustomGameInstance_BuildSystemGetAvaiablePathIDs_Params Parms{};

	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetAllPathIDs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               bIsWorkshop                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Tree                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetAllPathIDs(bool bIsWorkshop, TArray<class FName>& Tree)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetAllPathIDs");

	Params::UCustomGameInstance_BuildSystemGetAllPathIDs_Params Parms{};

	Parms.bIsWorkshop = bIsWorkshop;
	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetAllEntities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FBuildEntryInternal> ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<struct FBuildEntryInternal> UCustomGameInstance::BuildSystemGetAllEntities()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetAllEntities");

	Params::UCustomGameInstance_BuildSystemGetAllEntities_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetAllAvaiableEntities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetAllAvaiableEntities()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetAllAvaiableEntities");

	Params::UCustomGameInstance_BuildSystemGetAllAvaiableEntities_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemGetActiveTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomGameInstance::BuildSystemGetActiveTier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemGetActiveTier");

	Params::UCustomGameInstance_BuildSystemGetActiveTier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemFilterByCategoryAndTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EBuildCategory          Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBuildEntryInternal> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBuildEntryInternal> UCustomGameInstance::BuildSystemFilterByCategoryAndTier(enum class EBuildCategory Category, class FName Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemFilterByCategoryAndTier");

	Params::UCustomGameInstance_BuildSystemFilterByCategoryAndTier_Params Parms{};

	Parms.Category = Category;
	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemFilterByCategoryAndCatalog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EBuildCategory          Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Catalog                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBuildEntryInternal> ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBuildEntryInternal> UCustomGameInstance::BuildSystemFilterByCategoryAndCatalog(enum class EBuildCategory Category, class FName Catalog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemFilterByCategoryAndCatalog");

	Params::UCustomGameInstance_BuildSystemFilterByCategoryAndCatalog_Params Parms{};

	Parms.Category = Category;
	Parms.Catalog = Catalog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemDeactivateTierName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemDeactivateTierName(class FName Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemDeactivateTierName");

	Params::UCustomGameInstance_BuildSystemDeactivateTierName_Params Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemCreatePathID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                Path                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomGameInstance::BuildSystemCreatePathID(TArray<class FName>& Path)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemCreatePathID");

	Params::UCustomGameInstance_BuildSystemCreatePathID_Params Parms{};

	Parms.Path = Path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemAddNewEntity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemAddNewEntity(class FName Name)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemAddNewEntity");

	Params::UCustomGameInstance_BuildSystemAddNewEntity_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BuildSystemActivateTierName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        Tier                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::BuildSystemActivateTierName(class FName Tier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BuildSystemActivateTierName");

	Params::UCustomGameInstance_BuildSystemActivateTierName_Params Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.BPRestoreDataForNewGamePlus
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::BPRestoreDataForNewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BPRestoreDataForNewGamePlus");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.BPPrepareDataForNewGamePlus
// (Event, Public, BlueprintEvent)
// Parameters:

void UCustomGameInstance::BPPrepareDataForNewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "BPPrepareDataForNewGamePlus");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.AreCompanionsInSecondConflict
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        CompanionA                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        CompanionB                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::AreCompanionsInSecondConflict(class FName CompanionA, class FName CompanionB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AreCompanionsInSecondConflict");

	Params::UCustomGameInstance_AreCompanionsInSecondConflict_Params Parms{};

	Parms.CompanionA = CompanionA;
	Parms.CompanionB = CompanionB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.AreCompanionsInConflict
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        CompanionA                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        CompanionB                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::AreCompanionsInConflict(class FName CompanionA, class FName CompanionB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AreCompanionsInConflict");

	Params::UCustomGameInstance_AreCompanionsInConflict_Params Parms{};

	Parms.CompanionA = CompanionA;
	Parms.CompanionB = CompanionB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.ApplyCompanionLoyaltyRevert
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCustomGameInstance::ApplyCompanionLoyaltyRevert()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "ApplyCompanionLoyaltyRevert");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.CustomGameInstance.AddResourcesToMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FResourcesForMap            Resources                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::AddResourcesToMap(enum class EEventMap Map, const struct FResourcesForMap& Resources)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddResourcesToMap");

	Params::UCustomGameInstance_AddResourcesToMap_Params Parms{};

	Parms.Map = Map;
	Parms.Resources = Resources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.AddInfluenceExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Exp                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddInfluenceExp(float Exp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddInfluenceExp");

	Params::UCustomGameInstance_AddInfluenceExp_Params Parms{};

	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.AddGateOfMadnessDifficulty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDifficultyType         DifficultyType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddGateOfMadnessDifficulty(enum class EDifficultyType DifficultyType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddGateOfMadnessDifficulty");

	Params::UCustomGameInstance_AddGateOfMadnessDifficulty_Params Parms{};

	Parms.DifficultyType = DifficultyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.AddDecisionToCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        DecisionID                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CheckIfCompanionIsAvailable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddDecisionToCompanion(class FName CompanionID, class FName DecisionID, bool CheckIfCompanionIsAvailable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddDecisionToCompanion");

	Params::UCustomGameInstance_AddDecisionToCompanion_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.DecisionID = DecisionID;
	Parms.CheckIfCompanionIsAvailable = CheckIfCompanionIsAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.AddCurveAnimatedWidgetMaster
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                     InWidget                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddCurveAnimatedWidgetMaster(class UWidget* InWidget, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddCurveAnimatedWidgetMaster");

	Params::UCustomGameInstance_AddCurveAnimatedWidgetMaster_Params Parms{};

	Parms.InWidget = InWidget;
	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.CustomGameInstance.AddCompanionLoyaltyRevertInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCompanionLoyaltyRevertInfo RevertInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddCompanionLoyaltyRevertInfo(const struct FCompanionLoyaltyRevertInfo& RevertInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddCompanionLoyaltyRevertInfo");

	Params::UCustomGameInstance_AddCompanionLoyaltyRevertInfo_Params Parms{};

	Parms.RevertInfo = RevertInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomGameInstance.AddCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::AddCompanion(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddCompanion");

	Params::UCustomGameInstance_AddCompanion_Params Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.AddBuffToCompanion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Modifier                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameInstance::AddBuffToCompanion(class FName CompanionName, class FName Modifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddBuffToCompanion");

	Params::UCustomGameInstance_AddBuffToCompanion_Params Parms{};

	Parms.CompanionName = CompanionName;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomGameInstance.AddAchievementToSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAchievementType        AchievementType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Progress                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomGameInstance::AddAchievementToSave(enum class EAchievementType AchievementType, float Progress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomGameInstance", "AddAchievementToSave");

	Params::UCustomGameInstance_AddAchievementToSave_Params Parms{};

	Parms.AchievementType = AchievementType;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CustomSaveGameMetadata
// (None)

class UClass* UCustomSaveGameMetadata::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CustomSaveGameMetadata");

	return Clss;
}


// CustomSaveGameMetadata ChernobylGame.Default__CustomSaveGameMetadata
// (Public, ClassDefaultObject, ArchetypeObject)

class UCustomSaveGameMetadata* UCustomSaveGameMetadata::GetDefaultObj()
{
	static class UCustomSaveGameMetadata* Default = nullptr;

	if (!Default)
		Default = static_cast<UCustomSaveGameMetadata*>(UCustomSaveGameMetadata::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CustomSaveGameGlobalMetadata
// (None)

class UClass* UCustomSaveGameGlobalMetadata::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CustomSaveGameGlobalMetadata");

	return Clss;
}


// CustomSaveGameGlobalMetadata ChernobylGame.Default__CustomSaveGameGlobalMetadata
// (Public, ClassDefaultObject, ArchetypeObject)

class UCustomSaveGameGlobalMetadata* UCustomSaveGameGlobalMetadata::GetDefaultObj()
{
	static class UCustomSaveGameGlobalMetadata* Default = nullptr;

	if (!Default)
		Default = static_cast<UCustomSaveGameGlobalMetadata*>(UCustomSaveGameGlobalMetadata::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.CustomSaveGame
// (None)

class UClass* UCustomSaveGame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CustomSaveGame");

	return Clss;
}


// CustomSaveGame ChernobylGame.Default__CustomSaveGame
// (Public, ClassDefaultObject, ArchetypeObject)

class UCustomSaveGame* UCustomSaveGame::GetDefaultObj()
{
	static class UCustomSaveGame* Default = nullptr;

	if (!Default)
		Default = static_cast<UCustomSaveGame*>(UCustomSaveGame::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CustomSaveGame.SaveDataToSlot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      InSlotName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Version                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InUserIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomGameInstance*         GameInstance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::SaveDataToSlot(const class FString& InSlotName, int32 Version, int32 InUserIndex, class UCustomGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "SaveDataToSlot");

	Params::UCustomSaveGame_SaveDataToSlot_Params Parms{};

	Parms.InSlotName = InSlotName;
	Parms.Version = Version;
	Parms.InUserIndex = InUserIndex;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.PrepareMetadataForSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomGameInstance*         GameInstance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomSaveGameMetadata*     CurrentMetadata                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::PrepareMetadataForSave(class UCustomGameInstance* GameInstance, class UCustomSaveGameMetadata* CurrentMetadata)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "PrepareMetadataForSave");

	Params::UCustomSaveGame_PrepareMetadataForSave_Params Parms{};

	Parms.GameInstance = GameInstance;
	Parms.CurrentMetadata = CurrentMetadata;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.LoadDataFromSlot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      InSlotName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Version                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InUserIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomSaveGame::LoadDataFromSlot(const class FString& InSlotName, int32 Version, int32 InUserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "LoadDataFromSlot");

	Params::UCustomSaveGame_LoadDataFromSlot_Params Parms{};

	Parms.InSlotName = InSlotName;
	Parms.Version = Version;
	Parms.InUserIndex = InUserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomSaveGame.GetSaveVersion
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                      SaveFileName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InUserIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomSaveGame::GetSaveVersion(const class FString& SaveFileName, int32 InUserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "GetSaveVersion");

	Params::UCustomSaveGame_GetSaveVersion_Params Parms{};

	Parms.SaveFileName = SaveFileName;
	Parms.InUserIndex = InUserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.CustomSaveGame.DebugPrintData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UCustomSaveGame::DebugPrintData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "DebugPrintData");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.ClearSave
// (Final, Native, Public)
// Parameters:

void UCustomSaveGame::ClearSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "ClearSave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.AquireOnlyGameInstance
// (Final, Native, Public)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::AquireOnlyGameInstance(class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "AquireOnlyGameInstance");

	Params::UCustomSaveGame_AquireOnlyGameInstance_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.AquireDataFromStreamedLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InLevelName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::AquireDataFromStreamedLevel(class UObject* InWorldContextObject, class FName InLevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "AquireDataFromStreamedLevel");

	Params::UCustomSaveGame_AquireDataFromStreamedLevel_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.AquireDataFromAllLevels
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::AquireDataFromAllLevels(class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "AquireDataFromAllLevels");

	Params::UCustomSaveGame_AquireDataFromAllLevels_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.ApplyOnlyGameInstance
// (Final, Native, Public)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::ApplyOnlyGameInstance(class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "ApplyOnlyGameInstance");

	Params::UCustomSaveGame_ApplyOnlyGameInstance_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.ApplyDataToStreamedLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InLevelName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BroadcastEvent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::ApplyDataToStreamedLevel(class UObject* InWorldContextObject, class FName InLevelName, bool BroadcastEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "ApplyDataToStreamedLevel");

	Params::UCustomSaveGame_ApplyDataToStreamedLevel_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InLevelName = InLevelName;
	Parms.BroadcastEvent = BroadcastEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CustomSaveGame.ApplyDataToAllLevels
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BroadcastEvent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomSaveGame::ApplyDataToAllLevels(class UObject* InWorldContextObject, bool BroadcastEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CustomSaveGame", "ApplyDataToAllLevels");

	Params::UCustomSaveGame_ApplyDataToAllLevels_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.BroadcastEvent = BroadcastEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.ChernobylGameAsyncSave
// (None)

class UClass* UChernobylGameAsyncSave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChernobylGameAsyncSave");

	return Clss;
}


// ChernobylGameAsyncSave ChernobylGame.Default__ChernobylGameAsyncSave
// (Public, ClassDefaultObject, ArchetypeObject)

class UChernobylGameAsyncSave* UChernobylGameAsyncSave::GetDefaultObj()
{
	static class UChernobylGameAsyncSave* Default = nullptr;

	if (!Default)
		Default = static_cast<UChernobylGameAsyncSave*>(UChernobylGameAsyncSave::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ChernobylGameAsyncSave.HandleAsyncSaveFinished
// (Final, Native, Protected)
// Parameters:

void UChernobylGameAsyncSave::HandleAsyncSaveFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncSave", "HandleAsyncSaveFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ChernobylGameAsyncSave.ChernobylGameAsyncSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBroadcastSaveFinished                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UChernobylGameAsyncSave*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChernobylGameAsyncSave* UChernobylGameAsyncSave::ChernobylGameAsyncSave(class UObject* WorldContextObject, bool bBroadcastSaveFinished)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncSave", "ChernobylGameAsyncSave");

	Params::UChernobylGameAsyncSave_ChernobylGameAsyncSave_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bBroadcastSaveFinished = bBroadcastSaveFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.ChernobylGameAsyncCustomSave
// (None)

class UClass* UChernobylGameAsyncCustomSave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChernobylGameAsyncCustomSave");

	return Clss;
}


// ChernobylGameAsyncCustomSave ChernobylGame.Default__ChernobylGameAsyncCustomSave
// (Public, ClassDefaultObject, ArchetypeObject)

class UChernobylGameAsyncCustomSave* UChernobylGameAsyncCustomSave::GetDefaultObj()
{
	static class UChernobylGameAsyncCustomSave* Default = nullptr;

	if (!Default)
		Default = static_cast<UChernobylGameAsyncCustomSave*>(UChernobylGameAsyncCustomSave::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ChernobylGameAsyncCustomSave.HandleAsyncSaveFinished
// (Final, Native, Protected)
// Parameters:

void UChernobylGameAsyncCustomSave::HandleAsyncSaveFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncCustomSave", "HandleAsyncSaveFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ChernobylGameAsyncCustomSave.ChernobylGameAsyncCustomSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECustomSaveType         CustomSaveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBroadcastSaveFinished                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UChernobylGameAsyncCustomSave*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChernobylGameAsyncCustomSave* UChernobylGameAsyncCustomSave::ChernobylGameAsyncCustomSave(class UObject* WorldContextObject, enum class ECustomSaveType CustomSaveType, bool bBroadcastSaveFinished)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncCustomSave", "ChernobylGameAsyncCustomSave");

	Params::UChernobylGameAsyncCustomSave_ChernobylGameAsyncCustomSave_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CustomSaveType = CustomSaveType;
	Parms.bBroadcastSaveFinished = bBroadcastSaveFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.ChernobylGameAsyncScreenshotSave
// (None)

class UClass* UChernobylGameAsyncScreenshotSave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChernobylGameAsyncScreenshotSave");

	return Clss;
}


// ChernobylGameAsyncScreenshotSave ChernobylGame.Default__ChernobylGameAsyncScreenshotSave
// (Public, ClassDefaultObject, ArchetypeObject)

class UChernobylGameAsyncScreenshotSave* UChernobylGameAsyncScreenshotSave::GetDefaultObj()
{
	static class UChernobylGameAsyncScreenshotSave* Default = nullptr;

	if (!Default)
		Default = static_cast<UChernobylGameAsyncScreenshotSave*>(UChernobylGameAsyncScreenshotSave::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ChernobylGameAsyncScreenshotSave.HandleAsyncSaveFinished
// (Final, Native, Protected)
// Parameters:

void UChernobylGameAsyncScreenshotSave::HandleAsyncSaveFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncScreenshotSave", "HandleAsyncSaveFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ChernobylGameAsyncScreenshotSave.ChernobylGameAsyncScreenshot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSaveScreenshotData         ScreenshotData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               IsDaySave                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               broadcastSaveFinished                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UChernobylGameAsyncScreenshotSave*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChernobylGameAsyncScreenshotSave* UChernobylGameAsyncScreenshotSave::ChernobylGameAsyncScreenshot(class UObject* WorldContextObject, struct FSaveScreenshotData& ScreenshotData, bool IsDaySave, bool broadcastSaveFinished)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncScreenshotSave", "ChernobylGameAsyncScreenshot");

	Params::UChernobylGameAsyncScreenshotSave_ChernobylGameAsyncScreenshot_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ScreenshotData = ScreenshotData;
	Parms.IsDaySave = IsDaySave;
	Parms.broadcastSaveFinished = broadcastSaveFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.ChernobylGameWaitForSave
// (None)

class UClass* UChernobylGameWaitForSave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChernobylGameWaitForSave");

	return Clss;
}


// ChernobylGameWaitForSave ChernobylGame.Default__ChernobylGameWaitForSave
// (Public, ClassDefaultObject, ArchetypeObject)

class UChernobylGameWaitForSave* UChernobylGameWaitForSave::GetDefaultObj()
{
	static class UChernobylGameWaitForSave* Default = nullptr;

	if (!Default)
		Default = static_cast<UChernobylGameWaitForSave*>(UChernobylGameWaitForSave::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ChernobylGameWaitForSave.WaitForAsyncSaveGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UChernobylGameWaitForSave*   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChernobylGameWaitForSave* UChernobylGameWaitForSave::WaitForAsyncSaveGame(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameWaitForSave", "WaitForAsyncSaveGame");

	Params::UChernobylGameWaitForSave_WaitForAsyncSaveGame_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ChernobylGameWaitForSave.HandleAsyncSaveFinished
// (Final, Native, Protected)
// Parameters:

void UChernobylGameWaitForSave::HandleAsyncSaveFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameWaitForSave", "HandleAsyncSaveFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.ChernobylGameAsyncScreenshot
// (None)

class UClass* UChernobylGameAsyncScreenshot::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChernobylGameAsyncScreenshot");

	return Clss;
}


// ChernobylGameAsyncScreenshot ChernobylGame.Default__ChernobylGameAsyncScreenshot
// (Public, ClassDefaultObject, ArchetypeObject)

class UChernobylGameAsyncScreenshot* UChernobylGameAsyncScreenshot::GetDefaultObj()
{
	static class UChernobylGameAsyncScreenshot* Default = nullptr;

	if (!Default)
		Default = static_cast<UChernobylGameAsyncScreenshot*>(UChernobylGameAsyncScreenshot::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ChernobylGameAsyncScreenshot.HandleAsyncScreenshotFinished
// (Final, Native, Protected)
// Parameters:
// TArray<struct FColor>              ColorData                                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UChernobylGameAsyncScreenshot::HandleAsyncScreenshotFinished(const TArray<struct FColor>& ColorData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncScreenshot", "HandleAsyncScreenshotFinished");

	Params::UChernobylGameAsyncScreenshot_HandleAsyncScreenshotFinished_Params Parms{};

	Parms.ColorData = ColorData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ChernobylGameAsyncScreenshot.AsyncMakeScreenshotData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UChernobylGameAsyncScreenshot*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChernobylGameAsyncScreenshot* UChernobylGameAsyncScreenshot::AsyncMakeScreenshotData(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChernobylGameAsyncScreenshot", "AsyncMakeScreenshotData");

	Params::UChernobylGameAsyncScreenshot_AsyncMakeScreenshotData_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.CutsceneInput
// (None)

class UClass* ICutsceneInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CutsceneInput");

	return Clss;
}


// CutsceneInput ChernobylGame.Default__CutsceneInput
// (Public, ClassDefaultObject, ArchetypeObject)

class ICutsceneInput* ICutsceneInput::GetDefaultObj()
{
	static class ICutsceneInput* Default = nullptr;

	if (!Default)
		Default = static_cast<ICutsceneInput*>(ICutsceneInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.CutsceneInput.TriggerPauseMenu
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::TriggerPauseMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "TriggerPauseMenu");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CutsceneInput.ShowUI
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::ShowUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "ShowUI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CutsceneInput.PC_Interaction_Accept_Release
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::PC_Interaction_Accept_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "PC_Interaction_Accept_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CutsceneInput.PC_Interaction_Accept
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::PC_Interaction_Accept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "PC_Interaction_Accept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CutsceneInput.HideUI
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::HideUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "HideUI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.CutsceneInput.AnyKeyPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ICutsceneInput::AnyKeyPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CutsceneInput", "AnyKeyPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.DashBuff
// (None)

class UClass* UDashBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DashBuff");

	return Clss;
}


// DashBuff ChernobylGame.Default__DashBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UDashBuff* UDashBuff::GetDefaultObj()
{
	static class UDashBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UDashBuff*>(UDashBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.DialogueComponentPayload
// (None)

class UClass* UDialogueComponentPayload::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueComponentPayload");

	return Clss;
}


// DialogueComponentPayload ChernobylGame.Default__DialogueComponentPayload
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueComponentPayload* UDialogueComponentPayload::GetDefaultObj()
{
	static class UDialogueComponentPayload* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueComponentPayload*>(UDialogueComponentPayload::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.DialogueComponentPayload.StartPayload
// (Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponentPayload::StartPayload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponentPayload", "StartPayload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponentPayload.FinishPayload
// (Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponentPayload::FinishPayload()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponentPayload", "FinishPayload");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.DialogueCompanionStatusPayload
// (None)

class UClass* UDialogueCompanionStatusPayload::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueCompanionStatusPayload");

	return Clss;
}


// DialogueCompanionStatusPayload ChernobylGame.Default__DialogueCompanionStatusPayload
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueCompanionStatusPayload* UDialogueCompanionStatusPayload::GetDefaultObj()
{
	static class UDialogueCompanionStatusPayload* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueCompanionStatusPayload*>(UDialogueCompanionStatusPayload::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.DialogueComponent
// (SceneComponent)

class UClass* UDialogueComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueComponent");

	return Clss;
}


// DialogueComponent ChernobylGame.Default__DialogueComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueComponent* UDialogueComponent::GetDefaultObj()
{
	static class UDialogueComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueComponent*>(UDialogueComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.DialogueComponent.StopFailedVO
// (Final, Native, Private)
// Parameters:

void UDialogueComponent::StopFailedVO()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "StopFailedVO");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.StartDialogueAtRow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGCharacter*                Instigator                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShouldBlockPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewStart                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDialogueSubtitleType   ForcedSubtitleType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      CustomCameraFocus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::StartDialogueAtRow(class ACGCharacter* Instigator, bool ShouldBlockPlayer, class FName NewStart, enum class EDialogueSubtitleType ForcedSubtitleType, class AActor* CustomCameraFocus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "StartDialogueAtRow");

	Params::UDialogueComponent_StartDialogueAtRow_Params Parms{};

	Parms.Instigator = Instigator;
	Parms.ShouldBlockPlayer = ShouldBlockPlayer;
	Parms.NewStart = NewStart;
	Parms.ForcedSubtitleType = ForcedSubtitleType;
	Parms.CustomCameraFocus = CustomCameraFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.StartDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Instigator                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShouldBlockPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInPossiblyUseGesture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDialogueSubtitleType   ForcedSubtitleType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      CustomCameraFocus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::StartDialogue(class AActor* Instigator, bool ShouldBlockPlayer, bool bInPossiblyUseGesture, enum class EDialogueSubtitleType ForcedSubtitleType, class AActor* CustomCameraFocus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "StartDialogue");

	Params::UDialogueComponent_StartDialogue_Params Parms{};

	Parms.Instigator = Instigator;
	Parms.ShouldBlockPlayer = ShouldBlockPlayer;
	Parms.bInPossiblyUseGesture = bInPossiblyUseGesture;
	Parms.ForcedSubtitleType = ForcedSubtitleType;
	Parms.CustomCameraFocus = CustomCameraFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.Skip
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponent::Skip()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "Skip");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.SetSkippable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewSkippable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::SetSkippable(bool bInNewSkippable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "SetSkippable");

	Params::UDialogueComponent_SetSkippable_Params Parms{};

	Parms.bInNewSkippable = bInNewSkippable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.SetShouldAutomaticallyFinishPayload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDialogueComponentPayload>PayloadType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::SetShouldAutomaticallyFinishPayload(TSubclassOf<class UDialogueComponentPayload> PayloadType, bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "SetShouldAutomaticallyFinishPayload");

	Params::UDialogueComponent_SetShouldAutomaticallyFinishPayload_Params Parms{};

	Parms.PayloadType = PayloadType;
	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.SetDialogCameraFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      FocusActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::SetDialogCameraFocus(class AActor* FocusActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "SetDialogCameraFocus");

	Params::UDialogueComponent_SetDialogCameraFocus_Params Parms{};

	Parms.FocusActor = FocusActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.SetBlockDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::SetBlockDialogue(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "SetBlockDialogue");

	Params::UDialogueComponent_SetBlockDialogue_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.Select
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponent::Select()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "Select");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.RemovePayloadByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDialogueComponentPayload>PayloadType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::RemovePayloadByClass(TSubclassOf<class UDialogueComponentPayload> PayloadType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "RemovePayloadByClass");

	Params::UDialogueComponent_RemovePayloadByClass_Params Parms{};

	Parms.PayloadType = PayloadType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.RemovePayload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDialogueComponentPayload*   Payload                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::RemovePayload(class UDialogueComponentPayload* Payload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "RemovePayload");

	Params::UDialogueComponent_RemovePayload_Params Parms{};

	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.OverrideCurrentTimerTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewTime                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::OverrideCurrentTimerTime(float NewTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "OverrideCurrentTimerTime");

	Params::UDialogueComponent_OverrideCurrentTimerTime_Params Parms{};

	Parms.NewTime = NewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.OnTranitionFinished
// (Final, Native, Private)
// Parameters:

void UDialogueComponent::OnTranitionFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "OnTranitionFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.OnDialogueLineEnded
// (Final, Native, Private)
// Parameters:

void UDialogueComponent::OnDialogueLineEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "OnDialogueLineEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.NPCDialogueEnded
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                      ComponentOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              InDamageEvent                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDialogueComponent::NPCDialogueEnded(class AActor* ComponentOwner, struct FCGDamageEvent& InDamageEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "NPCDialogueEnded");

	Params::UDialogueComponent_NPCDialogueEnded_Params Parms{};

	Parms.ComponentOwner = ComponentOwner;
	Parms.InDamageEvent = InDamageEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogueComponent::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "IsPlaying");

	Params::UDialogueComponent_IsPlaying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueComponent.InternalOnDialogueLineEnded
// (Final, Native, Private)
// Parameters:

void UDialogueComponent::InternalOnDialogueLineEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "InternalOnDialogueLineEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.GetPayloadByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UDialogueComponentPayload>PayloadType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueComponentPayload*   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDialogueComponentPayload* UDialogueComponent::GetPayloadByClass(TSubclassOf<class UDialogueComponentPayload> PayloadType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "GetPayloadByClass");

	Params::UDialogueComponent_GetPayloadByClass_Params Parms{};

	Parms.PayloadType = PayloadType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueComponent.GetIsSkippable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogueComponent::GetIsSkippable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "GetIsSkippable");

	Params::UDialogueComponent_GetIsSkippable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueComponent.ForceStopDialogue2
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponent::ForceStopDialogue2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "ForceStopDialogue2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.ForceStopDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              DelayMs                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::ForceStopDialogue(float DelayMs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "ForceStopDialogue");

	Params::UDialogueComponent_ForceStopDialogue_Params Parms{};

	Parms.DelayMs = DelayMs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.EstimateDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        RowName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDialogueComponent::EstimateDuration(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "EstimateDuration");

	Params::UDialogueComponent_EstimateDuration_Params Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueComponent.EndGamePausedDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponent::EndGamePausedDialogue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "EndGamePausedDialogue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.DebugDialogueAtRow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGCharacter*                Instigator                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewStart                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::DebugDialogueAtRow(class ACGCharacter* Instigator, class FName NewStart)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "DebugDialogueAtRow");

	Params::UDialogueComponent_DebugDialogueAtRow_Params Parms{};

	Parms.Instigator = Instigator;
	Parms.NewStart = NewStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.ClearOptions
// (Final, Native, Private)
// Parameters:

void UDialogueComponent::ClearOptions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "ClearOptions");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.BeginGamePausedDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UDialogueComponent::BeginGamePausedDialogue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "BeginGamePausedDialogue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueComponent.AddPayload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDialogueComponentPayload*   Payload                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueComponent::AddPayload(class UDialogueComponentPayload* Payload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueComponent", "AddPayload");

	Params::UDialogueComponent_AddPayload_Params Parms{};

	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.DialogueFunctionLibrary
// (None)

class UClass* UDialogueFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueFunctionLibrary");

	return Clss;
}


// DialogueFunctionLibrary ChernobylGame.Default__DialogueFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueFunctionLibrary* UDialogueFunctionLibrary::GetDefaultObj()
{
	static class UDialogueFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueFunctionLibrary*>(UDialogueFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.DialogueFunctionLibrary.SplitStringToArray
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              OutArray                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDialogueFunctionLibrary::SplitStringToArray(const class FString& InString, TArray<class FString>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "SplitStringToArray");

	Params::UDialogueFunctionLibrary_SplitStringToArray_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);

}


// Function ChernobylGame.DialogueFunctionLibrary.SetWidgetComponentPivot
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidgetComponent*            Target                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   NewPivot                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueFunctionLibrary::SetWidgetComponentPivot(class UWidgetComponent* Target, const struct FVector2D& NewPivot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "SetWidgetComponentPivot");

	Params::UDialogueFunctionLibrary_SetWidgetComponentPivot_Params Parms{};

	Parms.Target = Target;
	Parms.NewPivot = NewPivot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueFunctionLibrary.SetNewDialogueMetaData
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                  InNewDialogueMetaData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogueFunctionLibrary::SetNewDialogueMetaData(class AActor* InActor, class UDataTable* InNewDialogueMetaData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "SetNewDialogueMetaData");

	Params::UDialogueFunctionLibrary_SetNewDialogueMetaData_Params Parms{};

	Parms.InActor = InActor;
	Parms.InNewDialogueMetaData = InNewDialogueMetaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueFunctionLibrary.SetNewDialogueData
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                  InNewDialogueData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogueFunctionLibrary::SetNewDialogueData(class AActor* InActor, class UDataTable* InNewDialogueData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "SetNewDialogueData");

	Params::UDialogueFunctionLibrary_SetNewDialogueData_Params Parms{};

	Parms.InActor = InActor;
	Parms.InNewDialogueData = InNewDialogueData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueFunctionLibrary.PlayRandomChatterOfType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EChatterType            InChatterType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInPossiblyUseGesture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadiusOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceStopAnyDialogue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogueFunctionLibrary::PlayRandomChatterOfType(class AActor* InActor, enum class EChatterType InChatterType, bool bInPossiblyUseGesture, float InRadiusOverride, bool bForceStopAnyDialogue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "PlayRandomChatterOfType");

	Params::UDialogueFunctionLibrary_PlayRandomChatterOfType_Params Parms{};

	Parms.InActor = InActor;
	Parms.InChatterType = InChatterType;
	Parms.bInPossiblyUseGesture = bInPossiblyUseGesture;
	Parms.InRadiusOverride = InRadiusOverride;
	Parms.bForceStopAnyDialogue = bForceStopAnyDialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueFunctionLibrary.FindDatatable
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                      InDatatablePath                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UDialogueFunctionLibrary::FindDatatable(const class FString& InDatatablePath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "FindDatatable");

	Params::UDialogueFunctionLibrary_FindDatatable_Params Parms{};

	Parms.InDatatablePath = InDatatablePath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueFunctionLibrary.FindActorByName
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     InWorldContextObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InName                                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDialogueFunctionLibrary::FindActorByName(class UObject* InWorldContextObject, const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "FindActorByName");

	Params::UDialogueFunctionLibrary_FindActorByName_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueFunctionLibrary.CallFunctionByNameOnActor
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InFunctionName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSuccess                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueFunctionLibrary::CallFunctionByNameOnActor(class AActor* InActor, class FName InFunctionName, bool* OutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueFunctionLibrary", "CallFunctionByNameOnActor");

	Params::UDialogueFunctionLibrary_CallFunctionByNameOnActor_Params Parms{};

	Parms.InActor = InActor;
	Parms.InFunctionName = InFunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

}


// Class ChernobylGame.DialogueFunctionManager
// (Actor)

class UClass* ADialogueFunctionManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueFunctionManager");

	return Clss;
}


// DialogueFunctionManager ChernobylGame.Default__DialogueFunctionManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ADialogueFunctionManager* ADialogueFunctionManager::GetDefaultObj()
{
	static class ADialogueFunctionManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ADialogueFunctionManager*>(ADialogueFunctionManager::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.DialogueTimelinePayload
// (None)

class UClass* UDialogueTimelinePayload::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueTimelinePayload");

	return Clss;
}


// DialogueTimelinePayload ChernobylGame.Default__DialogueTimelinePayload
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueTimelinePayload* UDialogueTimelinePayload::GetDefaultObj()
{
	static class UDialogueTimelinePayload* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueTimelinePayload*>(UDialogueTimelinePayload::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.DialogueWidget
// (None)

class UClass* UDialogueWidget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueWidget");

	return Clss;
}


// DialogueWidget ChernobylGame.Default__DialogueWidget
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueWidget* UDialogueWidget::GetDefaultObj()
{
	static class UDialogueWidget* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueWidget*>(UDialogueWidget::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.DialogueWidget.Up
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UDialogueWidget::Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueWidget.SelectedIndex
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                               Enabled                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDialogueWidget::SelectedIndex(bool* Enabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "SelectedIndex");

	Params::UDialogueWidget_SelectedIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Enabled != nullptr)
		*Enabled = Parms.Enabled;

	return Parms.ReturnValue;

}


// Function ChernobylGame.DialogueWidget.Select
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UDialogueWidget::Select()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "Select");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueWidget.PostSelectionEvent
// (Event, Public, BlueprintEvent)
// Parameters:

void UDialogueWidget::PostSelectionEvent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "PostSelectionEvent");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.DialogueWidget.Init
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FDialogueSingleOptionData>Prompts                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDialogueWidget::Init(TArray<struct FDialogueSingleOptionData>& Prompts)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "Init");

	Params::UDialogueWidget_Init_Params Parms{};

	Parms.Prompts = Prompts;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.DialogueWidget.Down
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void UDialogueWidget::Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DialogueWidget", "Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.EndGameCreditsInput
// (None)

class UClass* IEndGameCreditsInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EndGameCreditsInput");

	return Clss;
}


// EndGameCreditsInput ChernobylGame.Default__EndGameCreditsInput
// (Public, ClassDefaultObject, ArchetypeObject)

class IEndGameCreditsInput* IEndGameCreditsInput::GetDefaultObj()
{
	static class IEndGameCreditsInput* Default = nullptr;

	if (!Default)
		Default = static_cast<IEndGameCreditsInput*>(IEndGameCreditsInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.EndGameCreditsInput.Interaction_Accept_Release
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IEndGameCreditsInput::Interaction_Accept_Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EndGameCreditsInput", "Interaction_Accept_Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EndGameCreditsInput.Interaction_Accept
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IEndGameCreditsInput::Interaction_Accept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EndGameCreditsInput", "Interaction_Accept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.EveningActivityManager
// (Actor)

class UClass* AEveningActivityManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EveningActivityManager");

	return Clss;
}


// EveningActivityManager ChernobylGame.Default__EveningActivityManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AEveningActivityManager* AEveningActivityManager::GetDefaultObj()
{
	static class AEveningActivityManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AEveningActivityManager*>(AEveningActivityManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.EveningActivityManager.UpdateCompanionStatsMission
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEveningActivityManager::UpdateCompanionStatsMission(class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EveningActivityManager", "UpdateCompanionStatsMission");

	Params::AEveningActivityManager_UpdateCompanionStatsMission_Params Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EveningActivityManager.UpdateAllCompanionsStatsMission
// (Final, Native, Protected, BlueprintCallable)
// Parameters:

void AEveningActivityManager::UpdateAllCompanionsStatsMission()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EveningActivityManager", "UpdateAllCompanionsStatsMission");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EveningActivityManager.Update
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCompanionsInConflict       Conflict                                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// enum class ECompanionConflictType  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECompanionConflictType AEveningActivityManager::Update(struct FCompanionsInConflict* Conflict)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EveningActivityManager", "Update");

	Params::AEveningActivityManager_Update_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Conflict != nullptr)
		*Conflict = std::move(Parms.Conflict);

	return Parms.ReturnValue;

}


// Function ChernobylGame.EveningActivityManager.HideCompanions
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEveningActivityManager::HideCompanions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EveningActivityManager", "HideCompanions");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.EventFunctionLibrary
// (None)

class UClass* UEventFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EventFunctionLibrary");

	return Clss;
}


// EventFunctionLibrary ChernobylGame.Default__EventFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UEventFunctionLibrary* UEventFunctionLibrary::GetDefaultObj()
{
	static class UEventFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UEventFunctionLibrary*>(UEventFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.EventFunctionLibrary.SortEventsByDate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FInnerEvent>         InOutArrayToSort                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::SortEventsByDate(TArray<struct FInnerEvent>& InOutArrayToSort)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "SortEventsByDate");

	Params::UEventFunctionLibrary_SortEventsByDate_Params Parms{};

	Parms.InOutArrayToSort = InOutArrayToSort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventFunctionLibrary.SetEventStatus
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        EventID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Status                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::SetEventStatus(class UObject* WorldContextObject, class FName EventID, class FName Status)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "SetEventStatus");

	Params::UEventFunctionLibrary_SetEventStatus_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventID = EventID;
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventFunctionLibrary.ParseReport
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      Report                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReportInfo                 Info                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEventFunctionLibrary::ParseReport(const class FString& Report, struct FReportInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "ParseReport");

	Params::UEventFunctionLibrary_ParseReport_Params Parms{};

	Parms.Report = Report;
	Parms.Info = Info;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventFunctionLibrary.MergeEventArraysRemoveDuplicates
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FInnerEvent>         InArray1                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FInnerEvent>         InArray2                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FInnerEvent>         OutMergedArray                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::MergeEventArraysRemoveDuplicates(TArray<struct FInnerEvent>& InArray1, TArray<struct FInnerEvent>& InArray2, TArray<struct FInnerEvent>* OutMergedArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "MergeEventArraysRemoveDuplicates");

	Params::UEventFunctionLibrary_MergeEventArraysRemoveDuplicates_Params Parms{};

	Parms.InArray1 = InArray1;
	Parms.InArray2 = InArray2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMergedArray != nullptr)
		*OutMergedArray = std::move(Parms.OutMergedArray);

}


// Function ChernobylGame.EventFunctionLibrary.IsEventActive
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        EventID                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::IsEventActive(class UObject* WorldContextObject, class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "IsEventActive");

	Params::UEventFunctionLibrary_IsEventActive_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventFunctionLibrary.InitEventsOnLevel
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelScriptActor*           ThisLevel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               ThisMap                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::InitEventsOnLevel(class ALevelScriptActor* ThisLevel, enum class EEventMap ThisMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "InitEventsOnLevel");

	Params::UEventFunctionLibrary_InitEventsOnLevel_Params Parms{};

	Parms.ThisLevel = ThisLevel;
	Parms.ThisMap = ThisMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventFunctionLibrary.GetEventResults
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEventResult>        Results                                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::GetEventResults(class UObject* WorldContextObject, TArray<struct FEventResult>* Results)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "GetEventResults");

	Params::UEventFunctionLibrary_GetEventResults_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);

}


// Function ChernobylGame.EventFunctionLibrary.GenerateReportInfo
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        FromEvent                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReportInfo                 OutInfo                                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::GenerateReportInfo(class UObject* WorldContextObject, class FName FromEvent, struct FReportInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "GenerateReportInfo");

	Params::UEventFunctionLibrary_GenerateReportInfo_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FromEvent = FromEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventFunctionLibrary.ForceActivateEvent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        EventID                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::ForceActivateEvent(class UObject* WorldContextObject, class FName EventID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "ForceActivateEvent");

	Params::UEventFunctionLibrary_ForceActivateEvent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventID = EventID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventFunctionLibrary.FilterNpcByAvailableEvents
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                InNpcs                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                InEvents                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                OutNpcs                                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::FilterNpcByAvailableEvents(class UObject* WorldContextObject, TArray<class FName>& InNpcs, TArray<class FName>& InEvents, TArray<class FName>* OutNpcs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "FilterNpcByAvailableEvents");

	Params::UEventFunctionLibrary_FilterNpcByAvailableEvents_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InNpcs = InNpcs;
	Parms.InEvents = InEvents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNpcs != nullptr)
		*OutNpcs = std::move(Parms.OutNpcs);

}


// Function ChernobylGame.EventFunctionLibrary.EnableEvent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::EnableEvent(class UObject* WorldContextObject, class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "EnableEvent");

	Params::UEventFunctionLibrary_EnableEvent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventFunctionLibrary.DisableEvent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Event                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::DisableEvent(class UObject* WorldContextObject, class FName Event)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "DisableEvent");

	Params::UEventFunctionLibrary_DisableEvent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventFunctionLibrary.ClearEventSystemStatuses
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::ClearEventSystemStatuses(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventFunctionLibrary", "ClearEventSystemStatuses");

	Params::UEventFunctionLibrary_ClearEventSystemStatuses_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.EventSystemBackend
// (Actor)

class UClass* AEventSystemBackend::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EventSystemBackend");

	return Clss;
}


// EventSystemBackend ChernobylGame.Default__EventSystemBackend
// (Public, ClassDefaultObject, ArchetypeObject)

class AEventSystemBackend* AEventSystemBackend::GetDefaultObj()
{
	static class AEventSystemBackend* Default = nullptr;

	if (!Default)
		Default = static_cast<AEventSystemBackend*>(AEventSystemBackend::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.EventSystemBackend.ValidateActiveQuests
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<enum class EEventMap, class FName>OutChangedQuests                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::ValidateActiveQuests(TMap<enum class EEventMap, class FName>* OutChangedQuests)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "ValidateActiveQuests");

	Params::AEventSystemBackend_ValidateActiveQuests_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutChangedQuests != nullptr)
		*OutChangedQuests = Parms.OutChangedQuests;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.UpdateCompanionsLoyaltyCache
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEventSystemBackend::UpdateCompanionsLoyaltyCache()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "UpdateCompanionsLoyaltyCache");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APrepassQuestActor*          Prepass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemBackend::Update(class APrepassQuestActor* Prepass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "Update");

	Params::AEventSystemBackend_Update_Params Parms{};

	Parms.Prepass = Prepass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         Entry                                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               NewVlaue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemBackend::SetValue(const struct FDataTableRowHandle& Entry, bool NewVlaue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "SetValue");

	Params::AEventSystemBackend_SetValue_Params Parms{};

	Parms.Entry = Entry;
	Parms.NewVlaue = NewVlaue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.SetMood
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        MoodID                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::SetMood(class FName MoodID, enum class EEventMap Map)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "SetMood");

	Params::AEventSystemBackend_SetMood_Params Parms{};

	Parms.MoodID = MoodID;
	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.SetCompanionForQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::SetCompanionForQuest(class FName CompanionID, class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "SetCompanionForQuest");

	Params::AEventSystemBackend_SetCompanionForQuest_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.Prepeare
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsNewGamePlus                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::Prepeare(bool bForce, bool bIsNewGamePlus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "Prepeare");

	Params::AEventSystemBackend_Prepeare_Params Parms{};

	Parms.bForce = bForce;
	Parms.bIsNewGamePlus = bIsNewGamePlus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.GetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDataTableRowHandle         Entry                                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::GetValue(const struct FDataTableRowHandle& Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "GetValue");

	Params::AEventSystemBackend_GetValue_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.ForceCustomFirstDayQuestBase
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemBackend::ForceCustomFirstDayQuestBase(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "ForceCustomFirstDayQuestBase");

	Params::AEventSystemBackend_ForceCustomFirstDayQuestBase_Params Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.FixMapOnOldSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EEventMap               InMap                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemBackend::FixMapOnOldSave(enum class EEventMap InMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "FixMapOnOldSave");

	Params::AEventSystemBackend_FixMapOnOldSave_Params Parms{};

	Parms.InMap = InMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.Clear
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEventSystemBackend::Clear()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "Clear");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.EventSystemBackend.CalculateEffectiveness
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               QuestMap                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEventSystemBackend::CalculateEffectiveness(class FName CompanionID, class FName QuestID, enum class EEventMap QuestMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "CalculateEffectiveness");

	Params::AEventSystemBackend_CalculateEffectiveness_Params Parms{};

	Parms.CompanionID = CompanionID;
	Parms.QuestID = QuestID;
	Parms.QuestMap = QuestMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.EventSystemBackend.ActivateQuestDebug
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                        QuestID                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEventMap               Map                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        CompanionID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventSystemBackend::ActivateQuestDebug(class FName QuestID, enum class EEventMap Map, class FName CompanionID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemBackend", "ActivateQuestDebug");

	Params::AEventSystemBackend_ActivateQuestDebug_Params Parms{};

	Parms.QuestID = QuestID;
	Parms.Map = Map;
	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.EventSystemLevelBackend
// (Actor)

class UClass* AEventSystemLevelBackend::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EventSystemLevelBackend");

	return Clss;
}


// EventSystemLevelBackend ChernobylGame.Default__EventSystemLevelBackend
// (Public, ClassDefaultObject, ArchetypeObject)

class AEventSystemLevelBackend* AEventSystemLevelBackend::GetDefaultObj()
{
	static class AEventSystemLevelBackend* Default = nullptr;

	if (!Default)
		Default = static_cast<AEventSystemLevelBackend*>(AEventSystemLevelBackend::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.EventSystemLevelBackend.Update
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EEventMap               CurrentMap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReturnLevelListOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                OutLevelsToStream                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bIsContinue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemLevelBackend::Update(enum class EEventMap CurrentMap, bool bReturnLevelListOnly, TArray<class FName>* OutLevelsToStream, bool bIsContinue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("EventSystemLevelBackend", "Update");

	Params::AEventSystemLevelBackend_Update_Params Parms{};

	Parms.CurrentMap = CurrentMap;
	Parms.bReturnLevelListOnly = bReturnLevelListOnly;
	Parms.bIsContinue = bIsContinue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutLevelsToStream != nullptr)
		*OutLevelsToStream = std::move(Parms.OutLevelsToStream);

}


// Class ChernobylGame.EventSystemStaticData
// (None)

class UClass* UEventSystemStaticData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EventSystemStaticData");

	return Clss;
}


// EventSystemStaticData ChernobylGame.Default__EventSystemStaticData
// (Public, ClassDefaultObject, ArchetypeObject)

class UEventSystemStaticData* UEventSystemStaticData::GetDefaultObj()
{
	static class UEventSystemStaticData* Default = nullptr;

	if (!Default)
		Default = static_cast<UEventSystemStaticData*>(UEventSystemStaticData::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.FakeRadarSphere
// (Actor)

class UClass* AFakeRadarSphere::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FakeRadarSphere");

	return Clss;
}


// FakeRadarSphere ChernobylGame.Default__FakeRadarSphere
// (Public, ClassDefaultObject, ArchetypeObject)

class AFakeRadarSphere* AFakeRadarSphere::GetDefaultObj()
{
	static class AFakeRadarSphere* Default = nullptr;

	if (!Default)
		Default = static_cast<AFakeRadarSphere*>(AFakeRadarSphere::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.FakeRadarSphere.SpawnFakeRadarWave
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InSpawnTransform                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AFakeRadarSphere*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFakeRadarSphere* AFakeRadarSphere::SpawnFakeRadarWave(class UObject* WorldContextObject, struct FTransform& InSpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FakeRadarSphere", "SpawnFakeRadarWave");

	Params::AFakeRadarSphere_SpawnFakeRadarWave_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSpawnTransform = InSpawnTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// DelegateFunction ChernobylGame.FakeRadarSphere.RadarSphereDestroyedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AFakeRadarSphere*            Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFakeRadarSphere::RadarSphereDestroyedDelegate__DelegateSignature(class AFakeRadarSphere* Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FakeRadarSphere", "RadarSphereDestroyedDelegate__DelegateSignature");

	Params::AFakeRadarSphere_RadarSphereDestroyedDelegate__DelegateSignature_Params Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction ChernobylGame.FakeRadarSphere.RadarDetectionDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AFakeRadarSphere*            Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ActorFound                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFakeRadarSphere::RadarDetectionDelegate__DelegateSignature(class AFakeRadarSphere* Target, class AActor* ActorFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FakeRadarSphere", "RadarDetectionDelegate__DelegateSignature");

	Params::AFakeRadarSphere_RadarDetectionDelegate__DelegateSignature_Params Parms{};

	Parms.Target = Target;
	Parms.ActorFound = ActorFound;

	UObject::ProcessEvent(Func, &Parms);

}


// Class ChernobylGame.FireVolume
// (Actor)

class UClass* AFireVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FireVolume");

	return Clss;
}


// FireVolume ChernobylGame.Default__FireVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AFireVolume* AFireVolume::GetDefaultObj()
{
	static class AFireVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AFireVolume*>(AFireVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.FPAnimSystemQueue
// (None)

class UClass* UFPAnimSystemQueue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FPAnimSystemQueue");

	return Clss;
}


// FPAnimSystemQueue ChernobylGame.Default__FPAnimSystemQueue
// (Public, ClassDefaultObject, ArchetypeObject)

class UFPAnimSystemQueue* UFPAnimSystemQueue::GetDefaultObj()
{
	static class UFPAnimSystemQueue* Default = nullptr;

	if (!Default)
		Default = static_cast<UFPAnimSystemQueue*>(UFPAnimSystemQueue::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.FPAnimSystemQueue.ReadQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFPAnimQuery                InQuery                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFPAnimSystemQueue::ReadQuery(struct FFPAnimQuery& InQuery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FPAnimSystemQueue", "ReadQuery");

	Params::UFPAnimSystemQueue_ReadQuery_Params Parms{};

	Parms.InQuery = InQuery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.FPAnimSystemQueue.QueryActivity
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFPAnimQuery                InAnimQuery                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               OutQueryResult                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FFPAnimQuery>        OutQueryQueue                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bInShouldBlockNewQueries                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAnimScale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFPAnimSystemQueue::QueryActivity(struct FFPAnimQuery& InAnimQuery, bool* OutQueryResult, TArray<struct FFPAnimQuery>* OutQueryQueue, bool bInShouldBlockNewQueries, float InAnimScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FPAnimSystemQueue", "QueryActivity");

	Params::UFPAnimSystemQueue_QueryActivity_Params Parms{};

	Parms.InAnimQuery = InAnimQuery;
	Parms.bInShouldBlockNewQueries = bInShouldBlockNewQueries;
	Parms.InAnimScale = InAnimScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutQueryResult != nullptr)
		*OutQueryResult = Parms.OutQueryResult;

	if (OutQueryQueue != nullptr)
		*OutQueryQueue = std::move(Parms.OutQueryQueue);

}


// Function ChernobylGame.FPAnimSystemQueue.LogPrintCurrentQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UFPAnimSystemQueue::LogPrintCurrentQueue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FPAnimSystemQueue", "LogPrintCurrentQueue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.FPAnimSystemQueue.GetGlobalAnimScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFPAnimSystemQueue::GetGlobalAnimScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FPAnimSystemQueue", "GetGlobalAnimScale");

	Params::UFPAnimSystemQueue_GetGlobalAnimScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.FPAnimSystemQueue.EnableNewQueries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InNewQueryiesEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFPAnimSystemQueue::EnableNewQueries(bool InNewQueryiesEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FPAnimSystemQueue", "EnableNewQueries");

	Params::UFPAnimSystemQueue_EnableNewQueries_Params Parms{};

	Parms.InNewQueryiesEnabled = InNewQueryiesEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PatrolActor
// (Actor)

class UClass* APatrolActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PatrolActor");

	return Clss;
}


// PatrolActor ChernobylGame.Default__PatrolActor
// (Public, ClassDefaultObject, ArchetypeObject)

class APatrolActor* APatrolActor::GetDefaultObj()
{
	static class APatrolActor* Default = nullptr;

	if (!Default)
		Default = static_cast<APatrolActor*>(APatrolActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PatrolActor.GetLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APatrolActor*>        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APatrolActor*> APatrolActor::GetLoop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PatrolActor", "GetLoop");

	Params::APatrolActor_GetLoop_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.FriendlyPatrolActor
// (Actor)

class UClass* AFriendlyPatrolActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FriendlyPatrolActor");

	return Clss;
}


// FriendlyPatrolActor ChernobylGame.Default__FriendlyPatrolActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AFriendlyPatrolActor* AFriendlyPatrolActor::GetDefaultObj()
{
	static class AFriendlyPatrolActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AFriendlyPatrolActor*>(AFriendlyPatrolActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.FriendlyPatrolActor.OnOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         InOverlappedComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InOtherActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         InOtherComp                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InOtherBodyIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFromSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  InSweepResult                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFriendlyPatrolActor::OnOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bInFromSweep, struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FriendlyPatrolActor", "OnOverlap");

	Params::AFriendlyPatrolActor_OnOverlap_Params Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bInFromSweep = bInFromSweep;
	Parms.InSweepResult = InSweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.GasBuff
// (None)

class UClass* UGasBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GasBuff");

	return Clss;
}


// GasBuff ChernobylGame.Default__GasBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UGasBuff* UGasBuff::GetDefaultObj()
{
	static class UGasBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UGasBuff*>(UGasBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.GetSubtitlesFromSoundAsyncNode
// (None)

class UClass* UGetSubtitlesFromSoundAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GetSubtitlesFromSoundAsyncNode");

	return Clss;
}


// GetSubtitlesFromSoundAsyncNode ChernobylGame.Default__GetSubtitlesFromSoundAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UGetSubtitlesFromSoundAsyncNode* UGetSubtitlesFromSoundAsyncNode::GetDefaultObj()
{
	static class UGetSubtitlesFromSoundAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UGetSubtitlesFromSoundAsyncNode*>(UGetSubtitlesFromSoundAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.GetSubtitlesFromSoundAsyncNode.GetSubtitlesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  Sound                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetSubtitlesFromSoundAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetSubtitlesFromSoundAsyncNode* UGetSubtitlesFromSoundAsyncNode::GetSubtitlesAsync(class UObject* WorldContextObject, class USoundWave* Sound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GetSubtitlesFromSoundAsyncNode", "GetSubtitlesAsync");

	Params::UGetSubtitlesFromSoundAsyncNode_GetSubtitlesAsync_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.GlobalSingleton
// (None)

class UClass* UGlobalSingleton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GlobalSingleton");

	return Clss;
}


// GlobalSingleton ChernobylGame.Default__GlobalSingleton
// (Public, ClassDefaultObject, ArchetypeObject)

class UGlobalSingleton* UGlobalSingleton::GetDefaultObj()
{
	static class UGlobalSingleton* Default = nullptr;

	if (!Default)
		Default = static_cast<UGlobalSingleton*>(UGlobalSingleton::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.GlobalSingletonLibrary
// (None)

class UClass* UGlobalSingletonLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GlobalSingletonLibrary");

	return Clss;
}


// GlobalSingletonLibrary ChernobylGame.Default__GlobalSingletonLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UGlobalSingletonLibrary* UGlobalSingletonLibrary::GetDefaultObj()
{
	static class UGlobalSingletonLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UGlobalSingletonLibrary*>(UGlobalSingletonLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.GlobalSingletonLibrary.GetSingleton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGlobalSingleton*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGlobalSingleton* UGlobalSingletonLibrary::GetSingleton(bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GlobalSingletonLibrary", "GetSingleton");

	Params::UGlobalSingletonLibrary_GetSingleton_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Class ChernobylGame.GlobalSlomoBuff
// (None)

class UClass* UGlobalSlomoBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GlobalSlomoBuff");

	return Clss;
}


// GlobalSlomoBuff ChernobylGame.Default__GlobalSlomoBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UGlobalSlomoBuff* UGlobalSlomoBuff::GetDefaultObj()
{
	static class UGlobalSlomoBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UGlobalSlomoBuff*>(UGlobalSlomoBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.GodmodeBuff
// (None)

class UClass* UGodmodeBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GodmodeBuff");

	return Clss;
}


// GodmodeBuff ChernobylGame.Default__GodmodeBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UGodmodeBuff* UGodmodeBuff::GetDefaultObj()
{
	static class UGodmodeBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UGodmodeBuff*>(UGodmodeBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.HackingFunctionLibrary
// (None)

class UClass* UHackingFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HackingFunctionLibrary");

	return Clss;
}


// HackingFunctionLibrary ChernobylGame.Default__HackingFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UHackingFunctionLibrary* UHackingFunctionLibrary::GetDefaultObj()
{
	static class UHackingFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UHackingFunctionLibrary*>(UHackingFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.HackingFunctionLibrary.MixStrings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      AlphaZero                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      AlphaOne                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::MixStrings(const class FString& AlphaZero, const class FString& AlphaOne, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "MixStrings");

	Params::UHackingFunctionLibrary_MixStrings_Params Parms{};

	Parms.AlphaZero = AlphaZero;
	Parms.AlphaOne = AlphaOne;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.InsertXmlTagsIntoBinary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      InTextWithBinary                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InTagBegin                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InTagEnd                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutText                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackingFunctionLibrary::InsertXmlTagsIntoBinary(const class FString& InTextWithBinary, const class FString& InTagBegin, const class FString& InTagEnd, class FString* OutText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "InsertXmlTagsIntoBinary");

	Params::UHackingFunctionLibrary_InsertXmlTagsIntoBinary_Params Parms{};

	Parms.InTextWithBinary = InTextWithBinary;
	Parms.InTagBegin = InTagBegin;
	Parms.InTagEnd = InTagEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);

}


// Function ChernobylGame.HackingFunctionLibrary.InsertWordsIntoRichString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      Source                                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Destination                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              Strings                                                          (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                      Positions                                                        (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>              OpeningXmlTags                                                   (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               IgnoreInsertedLength                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackingFunctionLibrary::InsertWordsIntoRichString(const class FString& Source, class FString* Destination, const TArray<class FString>& Strings, const TArray<int32>& Positions, const TArray<class FString>& OpeningXmlTags, bool IgnoreInsertedLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "InsertWordsIntoRichString");

	Params::UHackingFunctionLibrary_InsertWordsIntoRichString_Params Parms{};

	Parms.Source = Source;
	Parms.Strings = Strings;
	Parms.Positions = Positions;
	Parms.OpeningXmlTags = OpeningXmlTags;
	Parms.IgnoreInsertedLength = IgnoreInsertedLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Destination != nullptr)
		*Destination = std::move(Parms.Destination);

}


// Function ChernobylGame.HackingFunctionLibrary.InsertStrings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      Source                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Destination                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              Strings                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                      Positions                                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UHackingFunctionLibrary::InsertStrings(const class FString& Source, class FString* Destination, const TArray<class FString>& Strings, const TArray<int32>& Positions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "InsertStrings");

	Params::UHackingFunctionLibrary_InsertStrings_Params Parms{};

	Parms.Source = Source;
	Parms.Strings = Strings;
	Parms.Positions = Positions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Destination != nullptr)
		*Destination = std::move(Parms.Destination);

}


// Function ChernobylGame.HackingFunctionLibrary.GetLettersAtIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>              InWords                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              OutLetters                                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UHackingFunctionLibrary::GetLettersAtIndex(const TArray<class FString>& InWords, int32 Index, TArray<class FString>* OutLetters)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "GetLettersAtIndex");

	Params::UHackingFunctionLibrary_GetLettersAtIndex_Params Parms{};

	Parms.InWords = InWords;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutLetters != nullptr)
		*OutLetters = std::move(Parms.OutLetters);

}


// Function ChernobylGame.HackingFunctionLibrary.GetIndicesOfWordsWithThisLetterAtIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>              InWords                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              InIndex                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InLetter                                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      OutIndices                                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               NotThisLetter                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackingFunctionLibrary::GetIndicesOfWordsWithThisLetterAtIndex(TArray<class FString>& InWords, int32 InIndex, const class FString& InLetter, TArray<int32>* OutIndices, bool NotThisLetter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "GetIndicesOfWordsWithThisLetterAtIndex");

	Params::UHackingFunctionLibrary_GetIndicesOfWordsWithThisLetterAtIndex_Params Parms{};

	Parms.InWords = InWords;
	Parms.InIndex = InIndex;
	Parms.InLetter = InLetter;
	Parms.NotThisLetter = NotThisLetter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIndices != nullptr)
		*OutIndices = std::move(Parms.OutIndices);

}


// Function ChernobylGame.HackingFunctionLibrary.GetCharacterAt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::GetCharacterAt(const class FString& InString, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "GetCharacterAt");

	Params::UHackingFunctionLibrary_GetCharacterAt_Params Parms{};

	Parms.InString = InString;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.GenerateRandomBinaryString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Length                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::GenerateRandomBinaryString(int32 Length)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "GenerateRandomBinaryString");

	Params::UHackingFunctionLibrary_GenerateRandomBinaryString_Params Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.FindClosestFalse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<bool>                       InArray                                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                              StartIndex                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReversedOrder                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHackingFunctionLibrary::FindClosestFalse(const TArray<bool>& InArray, int32 StartIndex, bool ReversedOrder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "FindClosestFalse");

	Params::UHackingFunctionLibrary_FindClosestFalse_Params Parms{};

	Parms.InArray = InArray;
	Parms.StartIndex = StartIndex;
	Parms.ReversedOrder = ReversedOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.DivideRichTextIntoColumns
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Source                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      ColumnSizes                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::DivideRichTextIntoColumns(const class FString& Source, const TArray<int32>& ColumnSizes)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "DivideRichTextIntoColumns");

	Params::UHackingFunctionLibrary_DivideRichTextIntoColumns_Params Parms{};

	Parms.Source = Source;
	Parms.ColumnSizes = ColumnSizes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.DivideIntoColumns
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Source                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      ColumnSizes                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::DivideIntoColumns(const class FString& Source, const TArray<int32>& ColumnSizes)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "DivideIntoColumns");

	Params::UHackingFunctionLibrary_DivideIntoColumns_Params Parms{};

	Parms.Source = Source;
	Parms.ColumnSizes = ColumnSizes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.CreateRichTextTag
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                      Style                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Color                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::CreateRichTextTag(const class FString& Style, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "CreateRichTextTag");

	Params::UHackingFunctionLibrary_CreateRichTextTag_Params Parms{};

	Parms.Style = Style;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.ConvertToBinary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      UnparsedText                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHackingFunctionLibrary::ConvertToBinary(const class FString& UnparsedText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "ConvertToBinary");

	Params::UHackingFunctionLibrary_ConvertToBinary_Params Parms{};

	Parms.UnparsedText = UnparsedText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HackingFunctionLibrary.CompareColors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHackingFunctionLibrary::CompareColors(struct FLinearColor& A, struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HackingFunctionLibrary", "CompareColors");

	Params::UHackingFunctionLibrary_CompareColors_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.HealthComponent
// (None)

class UClass* UHealthComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HealthComponent");

	return Clss;
}


// HealthComponent ChernobylGame.Default__HealthComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UHealthComponent* UHealthComponent::GetDefaultObj()
{
	static class UHealthComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UHealthComponent*>(UHealthComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.HealthComponent.OverrideMaxHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewMaxHP                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OverrideMaxHP(float InNewMaxHP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent", "OverrideMaxHP");

	Params::UHealthComponent_OverrideMaxHP_Params Parms{};

	Parms.InNewMaxHP = InNewMaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent.OverrideCurrentHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewHP                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OverrideCurrentHP(float InNewHP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent", "OverrideCurrentHP");

	Params::UHealthComponent_OverrideCurrentHP_Params Parms{};

	Parms.InNewHP = InNewHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent.K2_DealDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              DamageType                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::K2_DealDamage(float Damage, struct FCGDamageEvent& DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent", "K2_DealDamage");

	Params::UHealthComponent_K2_DealDamage_Params Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent.Heal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              HpHealed                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::Heal(float HpHealed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent", "Heal");

	Params::UHealthComponent_Heal_Params Parms{};

	Parms.HpHealed = HpHealed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent.DealDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGDamageEvent              DamageType                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::DealDamage(float Damage, struct FCGDamageEvent& DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent", "DealDamage");

	Params::UHealthComponent_DealDamage_Params Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.HealthComponent2
// (None)

class UClass* UHealthComponent2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HealthComponent2");

	return Clss;
}


// HealthComponent2 ChernobylGame.Default__HealthComponent2
// (Public, ClassDefaultObject, ArchetypeObject)

class UHealthComponent2* UHealthComponent2::GetDefaultObj()
{
	static class UHealthComponent2* Default = nullptr;

	if (!Default)
		Default = static_cast<UHealthComponent2*>(UHealthComponent2::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.HealthComponent2.SetRadiationMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Multiplier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent2::SetRadiationMultiplier(float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "SetRadiationMultiplier");

	Params::UHealthComponent2_SetRadiationMultiplier_Params Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent2.SetGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Enable                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromCheat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent2::SetGodMode(bool Enable, bool bFromCheat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "SetGodMode");

	Params::UHealthComponent2_SetGodMode_Params Parms{};

	Parms.Enable = Enable;
	Parms.bFromCheat = bFromCheat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent2.RemoveRadSegments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Segments                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipGodMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent2::RemoveRadSegments(float Segments, bool bSkipGodMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "RemoveRadSegments");

	Params::UHealthComponent2_RemoveRadSegments_Params Parms{};

	Parms.Segments = Segments;
	Parms.bSkipGodMode = bSkipGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent2.ModifyMaximumHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              SegmentsPerStage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent2::ModifyMaximumHealth(int32 SegmentsPerStage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "ModifyMaximumHealth");

	Params::UHealthComponent2_ModifyMaximumHealth_Params Parms{};

	Parms.SegmentsPerStage = SegmentsPerStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent2.K2_ChangeHPSections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Sections                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     InDamageClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BypassMultiplayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::K2_ChangeHPSections(float Sections, TSubclassOf<class UDamageType> InDamageClass, bool BypassMultiplayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "K2_ChangeHPSections");

	Params::UHealthComponent2_K2_ChangeHPSections_Params Parms{};

	Parms.Sections = Sections;
	Parms.InDamageClass = InDamageClass;
	Parms.BypassMultiplayer = BypassMultiplayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.K2_ChangeHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Points                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     InDamageClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BypassMultiplayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::K2_ChangeHP(float Points, TSubclassOf<class UDamageType> InDamageClass, bool BypassMultiplayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "K2_ChangeHP");

	Params::UHealthComponent2_K2_ChangeHP_Params Parms{};

	Parms.Points = Points;
	Parms.InDamageClass = InDamageClass;
	Parms.BypassMultiplayer = BypassMultiplayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.InitInv
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UHealthComponent2::InitInv()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "InitInv");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.HealthComponent2.GetUIBarSegments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHealthComponent2::GetUIBarSegments()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetUIBarSegments");

	Params::UHealthComponent2_GetUIBarSegments_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetRadiationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetRadiationThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetRadiationThreshold");

	Params::UHealthComponent2_GetRadiationThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetRadiationMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetRadiationMultiplier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetRadiationMultiplier");

	Params::UHealthComponent2_GetRadiationMultiplier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetRadiationMaxDose
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetRadiationMaxDose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetRadiationMaxDose");

	Params::UHealthComponent2_GetRadiationMaxDose_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetMinRadiationForPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EHealthPhase            Phase                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetMinRadiationForPhase(enum class EHealthPhase Phase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetMinRadiationForPhase");

	Params::UHealthComponent2_GetMinRadiationForPhase_Params Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetMaxRadiationForPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EHealthPhase            Phase                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetMaxRadiationForPhase(enum class EHealthPhase Phase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetMaxRadiationForPhase");

	Params::UHealthComponent2_GetMaxRadiationForPhase_Params Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetMaxRadiation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetMaxRadiation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetMaxRadiation");

	Params::UHealthComponent2_GetMaxRadiation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetMaxHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetMaxHP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetMaxHP");

	Params::UHealthComponent2_GetMaxHP_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetMaxHealthForPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EHealthPhase            Phase                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetMaxHealthForPhase(enum class EHealthPhase Phase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetMaxHealthForPhase");

	Params::UHealthComponent2_GetMaxHealthForPhase_Params Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetGodModeFromCheat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::GetGodModeFromCheat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetGodModeFromCheat");

	Params::UHealthComponent2_GetGodModeFromCheat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetGodMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::GetGodMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetGodMode");

	Params::UHealthComponent2_GetGodMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetCurrentRadiationPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EHealthPhase            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EHealthPhase UHealthComponent2::GetCurrentRadiationPhase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetCurrentRadiationPhase");

	Params::UHealthComponent2_GetCurrentRadiationPhase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetCurrentRadiation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetCurrentRadiation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetCurrentRadiation");

	Params::UHealthComponent2_GetCurrentRadiation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetCurrentHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent2::GetCurrentHP()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetCurrentHP");

	Params::UHealthComponent2_GetCurrentHP_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.GetCurrentHealthPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EHealthPhase            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EHealthPhase UHealthComponent2::GetCurrentHealthPhase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "GetCurrentHealthPhase");

	Params::UHealthComponent2_GetCurrentHealthPhase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.ChangeRadPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PointsPercentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BypassMultiplayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::ChangeRadPercentage(float PointsPercentage, bool BypassMultiplayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "ChangeRadPercentage");

	Params::UHealthComponent2_ChangeRadPercentage_Params Parms{};

	Parms.PointsPercentage = PointsPercentage;
	Parms.BypassMultiplayer = BypassMultiplayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.ChangeRad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Points                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               BypassMultiplayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent2::ChangeRad(float Points, bool BypassMultiplayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "ChangeRad");

	Params::UHealthComponent2_ChangeRad_Params Parms{};

	Parms.Points = Points;
	Parms.BypassMultiplayer = BypassMultiplayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HealthComponent2.ChangeMaxHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Points                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent2::ChangeMaxHP(float Points)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthComponent2", "ChangeMaxHP");

	Params::UHealthComponent2_ChangeMaxHP_Params Parms{};

	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.HeroIntepolateTo
// (None)

class UClass* UHeroIntepolateTo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HeroIntepolateTo");

	return Clss;
}


// HeroIntepolateTo ChernobylGame.Default__HeroIntepolateTo
// (Public, ClassDefaultObject, ArchetypeObject)

class UHeroIntepolateTo* UHeroIntepolateTo::GetDefaultObj()
{
	static class UHeroIntepolateTo* Default = nullptr;

	if (!Default)
		Default = static_cast<UHeroIntepolateTo*>(UHeroIntepolateTo::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.HeroIntepolateTo.InterpolatePlayerToTransform
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  Transform                                                        (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InterpolationLengthSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHeroIntepolateTo*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHeroIntepolateTo* UHeroIntepolateTo::InterpolatePlayerToTransform(class UObject* WorldContextObject, const struct FTransform& Transform, float InterpolationLengthSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HeroIntepolateTo", "InterpolatePlayerToTransform");

	Params::UHeroIntepolateTo_InterpolatePlayerToTransform_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Transform = Transform;
	Parms.InterpolationLengthSeconds = InterpolationLengthSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.HeroIntepolateTo.InterpolatePlayerToLocation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InterpolationLengthSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               DisablePlayerInputOnStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               HidePlayerHandsOnStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               EnablePlayerInputOnCompleted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ShowPlayerHandsOnCompleted                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               EnableCollisionOnCompleted                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHeroIntepolateTo*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHeroIntepolateTo* UHeroIntepolateTo::InterpolatePlayerToLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FRotator& Rotation, float InterpolationLengthSeconds, bool DisablePlayerInputOnStart, bool HidePlayerHandsOnStart, bool EnablePlayerInputOnCompleted, bool ShowPlayerHandsOnCompleted, bool EnableCollisionOnCompleted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HeroIntepolateTo", "InterpolatePlayerToLocation");

	Params::UHeroIntepolateTo_InterpolatePlayerToLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.InterpolationLengthSeconds = InterpolationLengthSeconds;
	Parms.DisablePlayerInputOnStart = DisablePlayerInputOnStart;
	Parms.HidePlayerHandsOnStart = HidePlayerHandsOnStart;
	Parms.EnablePlayerInputOnCompleted = EnablePlayerInputOnCompleted;
	Parms.ShowPlayerHandsOnCompleted = ShowPlayerHandsOnCompleted;
	Parms.EnableCollisionOnCompleted = EnableCollisionOnCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.HungryBuff
// (None)

class UClass* UHungryBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HungryBuff");

	return Clss;
}


// HungryBuff ChernobylGame.Default__HungryBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UHungryBuff* UHungryBuff::GetDefaultObj()
{
	static class UHungryBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UHungryBuff*>(UHungryBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.InputFunctionLibrary
// (None)

class UClass* UInputFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputFunctionLibrary");

	return Clss;
}


// InputFunctionLibrary ChernobylGame.Default__InputFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputFunctionLibrary* UInputFunctionLibrary::GetDefaultObj()
{
	static class UInputFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputFunctionLibrary*>(UInputFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.InputFunctionLibrary.UsingKeyboardOrGamepad
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bUsingGamepad                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputFunctionLibrary::UsingKeyboardOrGamepad(bool* bUsingGamepad)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputFunctionLibrary", "UsingKeyboardOrGamepad");

	Params::UInputFunctionLibrary_UsingKeyboardOrGamepad_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bUsingGamepad != nullptr)
		*bUsingGamepad = Parms.bUsingGamepad;

}


// Function ChernobylGame.InputFunctionLibrary.IsGamepadConnected
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               Connected                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputFunctionLibrary::IsGamepadConnected(bool* Connected)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputFunctionLibrary", "IsGamepadConnected");

	Params::UInputFunctionLibrary_IsGamepadConnected_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Connected != nullptr)
		*Connected = Parms.Connected;

}


// Function ChernobylGame.InputFunctionLibrary.CountConnectedGamepads
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              GamepadCount                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputFunctionLibrary::CountConnectedGamepads(int32* GamepadCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputFunctionLibrary", "CountConnectedGamepads");

	Params::UInputFunctionLibrary_CountConnectedGamepads_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (GamepadCount != nullptr)
		*GamepadCount = Parms.GamepadCount;

}


// Class ChernobylGame.Interactable
// (None)

class UClass* IInteractable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Interactable");

	return Clss;
}


// Interactable ChernobylGame.Default__Interactable
// (Public, ClassDefaultObject, ArchetypeObject)

class IInteractable* IInteractable::GetDefaultObj()
{
	static class IInteractable* Default = nullptr;

	if (!Default)
		Default = static_cast<IInteractable*>(IInteractable::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.Interactable.UnlockInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IInteractable::UnlockInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "UnlockInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Interactable.SupportsOnlyFocusEvents
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractable::SupportsOnlyFocusEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "SupportsOnlyFocusEvents");

	Params::IInteractable_SupportsOnlyFocusEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.SetObjectVisible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bVisible                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::SetObjectVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "SetObjectVisible");

	Params::IInteractable_SetObjectVisible_Params Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Interactable.SetInteractionLocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bLocked                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::SetInteractionLocked(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "SetInteractionLocked");

	Params::IInteractable_SetInteractionLocked_Params Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Interactable.OnPlayerNearFocusLostComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentHit                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnPlayerNearFocusLostComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnPlayerNearFocusLostComponent");

	Params::IInteractable_OnPlayerNearFocusLostComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentHit = ComponentHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.OnPlayerNearFocusGainedComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentHit                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnPlayerNearFocusGainedComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnPlayerNearFocusGainedComponent");

	Params::IInteractable_OnPlayerNearFocusGainedComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentHit = ComponentHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.OnPlayerFocusLostComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentHit                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnPlayerFocusLostComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnPlayerFocusLostComponent");

	Params::IInteractable_OnPlayerFocusLostComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentHit = ComponentHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.OnPlayerFocusGainedComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentHit                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnPlayerFocusGainedComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnPlayerFocusGainedComponent");

	Params::IInteractable_OnPlayerFocusGainedComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentHit = ComponentHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.OnInteractionReleasedComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentPlayerWasInteractingWith                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnInteractionReleasedComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentPlayerWasInteractingWith)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnInteractionReleasedComponent");

	Params::IInteractable_OnInteractionReleasedComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentPlayerWasInteractingWith = ComponentPlayerWasInteractingWith;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.OnInteractionPressedComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMainPawnCpp*                PlayerPawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ComponentHit                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractable::OnInteractionPressedComponent(class AMainPawnCpp* PlayerPawn, class UActorComponent* ComponentHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "OnInteractionPressedComponent");

	Params::IInteractable_OnInteractionPressedComponent_Params Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.ComponentHit = ComponentHit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.Interactable.MaxInteractionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IInteractable::MaxInteractionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "MaxInteractionDistance");

	Params::IInteractable_MaxInteractionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.LockInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IInteractable::LockInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "LockInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.Interactable.IsObjectVisible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractable::IsObjectVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "IsObjectVisible");

	Params::IInteractable_IsObjectVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.IsInteractionUnlocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractable::IsInteractionUnlocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "IsInteractionUnlocked");

	Params::IInteractable_IsInteractionUnlocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetSkipChildComponentWhenOverlapping
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractable::GetSkipChildComponentWhenOverlapping()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetSkipChildComponentWhenOverlapping");

	Params::IInteractable_GetSkipChildComponentWhenOverlapping_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetShouldOverrideMaxInteractionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractable::GetShouldOverrideMaxInteractionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetShouldOverrideMaxInteractionDistance");

	Params::IInteractable_GetShouldOverrideMaxInteractionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetOverrideMaxInteractionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IInteractable::GetOverrideMaxInteractionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetOverrideMaxInteractionDistance");

	Params::IInteractable_GetOverrideMaxInteractionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetNearInteractionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IInteractable::GetNearInteractionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetNearInteractionDistance");

	Params::IInteractable_GetNearInteractionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetFarInteractionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IInteractable::GetFarInteractionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetFarInteractionDistance");

	Params::IInteractable_GetFarInteractionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetComponentTagToSkipWhenOverlappingSphere
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IInteractable::GetComponentTagToSkipWhenOverlappingSphere()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetComponentTagToSkipWhenOverlappingSphere");

	Params::IInteractable_GetComponentTagToSkipWhenOverlappingSphere_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.Interactable.GetActorInteractionAngle
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D IInteractable::GetActorInteractionAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Interactable", "GetActorInteractionAngle");

	Params::IInteractable_GetActorInteractionAngle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.InteractableStaticMesh
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UInteractableStaticMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InteractableStaticMesh");

	return Clss;
}


// InteractableStaticMesh ChernobylGame.Default__InteractableStaticMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class UInteractableStaticMesh* UInteractableStaticMesh::GetDefaultObj()
{
	static class UInteractableStaticMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<UInteractableStaticMesh*>(UInteractableStaticMesh::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.InterpolateFloatAsyncNode
// (None)

class UClass* UInterpolateFloatAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpolateFloatAsyncNode");

	return Clss;
}


// InterpolateFloatAsyncNode ChernobylGame.Default__InterpolateFloatAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpolateFloatAsyncNode* UInterpolateFloatAsyncNode::GetDefaultObj()
{
	static class UInterpolateFloatAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpolateFloatAsyncNode*>(UInterpolateFloatAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// DelegateFunction ChernobylGame.InterpolateFloatAsyncNode.InterpolateFloatAsyncNodeOutputPin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                              Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterpolateFloatAsyncNode*  Interpolator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpolateFloatAsyncNode::InterpolateFloatAsyncNodeOutputPin__DelegateSignature(float Current, class UInterpolateFloatAsyncNode* Interpolator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateFloatAsyncNode", "InterpolateFloatAsyncNodeOutputPin__DelegateSignature");

	Params::UInterpolateFloatAsyncNode_InterpolateFloatAsyncNodeOutputPin__DelegateSignature_Params Parms{};

	Parms.Current = Current;
	Parms.Interpolator = Interpolator;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.InterpolateFloatAsyncNode.FInterpToConstantAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              From                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              To                                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterpolateFloatAsyncNode*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInterpolateFloatAsyncNode* UInterpolateFloatAsyncNode::FInterpToConstantAsync(class UObject* WorldContextObject, float From, float To, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateFloatAsyncNode", "FInterpToConstantAsync");

	Params::UInterpolateFloatAsyncNode_FInterpToConstantAsync_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.From = From;
	Parms.To = To;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InterpolateFloatAsyncNode.FInterpToAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              From                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              To                                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterpolateFloatAsyncNode*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInterpolateFloatAsyncNode* UInterpolateFloatAsyncNode::FInterpToAsync(class UObject* WorldContextObject, float From, float To, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateFloatAsyncNode", "FInterpToAsync");

	Params::UInterpolateFloatAsyncNode_FInterpToAsync_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.From = From;
	Parms.To = To;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InterpolateFloatAsyncNode.Abort
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInterpolateFloatAsyncNode::Abort()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateFloatAsyncNode", "Abort");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.InterpolateRotatorAsyncNode
// (None)

class UClass* UInterpolateRotatorAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpolateRotatorAsyncNode");

	return Clss;
}


// InterpolateRotatorAsyncNode ChernobylGame.Default__InterpolateRotatorAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpolateRotatorAsyncNode* UInterpolateRotatorAsyncNode::GetDefaultObj()
{
	static class UInterpolateRotatorAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpolateRotatorAsyncNode*>(UInterpolateRotatorAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.InterpolateRotatorAsyncNode.RInterpToConstantAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Co                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    From                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    To                                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterpolateRotatorAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInterpolateRotatorAsyncNode* UInterpolateRotatorAsyncNode::RInterpToConstantAsync(class UObject* Co, const struct FRotator& From, const struct FRotator& To, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateRotatorAsyncNode", "RInterpToConstantAsync");

	Params::UInterpolateRotatorAsyncNode_RInterpToConstantAsync_Params Parms{};

	Parms.Co = Co;
	Parms.From = From;
	Parms.To = To;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// DelegateFunction ChernobylGame.InterpolateRotatorAsyncNode.InterpolateRotatorAsyncNodeOutputPin__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasDefaults)
// Parameters:
// struct FRotator                    Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UInterpolateRotatorAsyncNode*Interpolator                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpolateRotatorAsyncNode::InterpolateRotatorAsyncNodeOutputPin__DelegateSignature(const struct FRotator& Current, class UInterpolateRotatorAsyncNode* Interpolator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpolateRotatorAsyncNode", "InterpolateRotatorAsyncNodeOutputPin__DelegateSignature");

	Params::UInterpolateRotatorAsyncNode_InterpolateRotatorAsyncNodeOutputPin__DelegateSignature_Params Parms{};

	Parms.Current = Current;
	Parms.Interpolator = Interpolator;

	UObject::ProcessEvent(Func, &Parms);

}


// Class ChernobylGame.InventoryComponent2
// (None)

class UClass* UInventoryComponent2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InventoryComponent2");

	return Clss;
}


// InventoryComponent2 ChernobylGame.Default__InventoryComponent2
// (Public, ClassDefaultObject, ArchetypeObject)

class UInventoryComponent2* UInventoryComponent2::GetDefaultObj()
{
	static class UInventoryComponent2* Default = nullptr;

	if (!Default)
		Default = static_cast<UInventoryComponent2*>(UInventoryComponent2::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.InventoryComponent2.SortBySize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::SortBySize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "SortBySize");

	Params::UInventoryComponent2_SortBySize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.SendUpdateBroadcast
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInventoryComponent2::SendUpdateBroadcast()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "SendUpdateBroadcast");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.InventoryComponent2.Resize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   NewSize                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent2::Resize(const struct FVector2D& NewSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "Resize");

	Params::UInventoryComponent2_Resize_Params Parms{};

	Parms.NewSize = NewSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.InventoryComponent2.RemoveUpgrade
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Upgrade                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::RemoveUpgrade(const struct FVector2D& Position, class FName Upgrade, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "RemoveUpgrade");

	Params::UInventoryComponent2_RemoveUpgrade_Params Parms{};

	Parms.Position = Position;
	Parms.Upgrade = Upgrade;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.RemoveAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSendBroadcast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::RemoveAt(const struct FVector2D& Index, float Amount, bool Force, int32 StorageID, bool bSendBroadcast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "RemoveAt");

	Params::UInventoryComponent2_RemoveAt_Params Parms{};

	Parms.Index = Index;
	Parms.Amount = Amount;
	Parms.Force = Force;
	Parms.StorageID = StorageID;
	Parms.bSendBroadcast = bSendBroadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.Remove
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSendBroadcast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::Remove(class FName ItemId, float Amount, const struct FVector2D& Index, bool Force, int32 StorageID, bool bSendBroadcast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "Remove");

	Params::UInventoryComponent2_Remove_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Amount = Amount;
	Parms.Index = Index;
	Parms.Force = Force;
	Parms.StorageID = StorageID;
	Parms.bSendBroadcast = bSendBroadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.PrintDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInventoryComponent2::PrintDebug()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "PrintDebug");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.InventoryComponent2.IsValidIndex
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::IsValidIndex(const struct FVector2D& Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "IsValidIndex");

	Params::UInventoryComponent2_IsValidIndex_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.IsInventoryInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::IsInventoryInitialized()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "IsInventoryInitialized");

	Params::UInventoryComponent2_IsInventoryInitialized_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.HasItemWithInternalId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InternalId                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::HasItemWithInternalId(class FName InternalId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "HasItemWithInternalId");

	Params::UInventoryComponent2_HasItemWithInternalId_Params Parms{};

	Parms.InternalId = InternalId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetUpgrades
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInventoryEntry             Entry                                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UInventoryComponent2::GetUpgrades(struct FInventoryEntry& Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetUpgrades");

	Params::UInventoryComponent2_GetUpgrades_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInventoryComponent2::GetSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetSize");

	Params::UInventoryComponent2_GetSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetNameByResourceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UInventoryComponent2::GetNameByResourceType(enum class EResourceType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetNameByResourceType");

	Params::UInventoryComponent2_GetNameByResourceType_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetMaxSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInventoryComponent2::GetMaxSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetMaxSize");

	Params::UInventoryComponent2_GetMaxSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItemWithInternalId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InternalId                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UInventoryComponent2::GetItemWithInternalId(class FName InternalId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItemWithInternalId");

	Params::UInventoryComponent2_GetItemWithInternalId_Params Parms{};

	Parms.InternalId = InternalId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItemsWithStorageId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInventoryEntry>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInventoryEntry> UInventoryComponent2::GetItemsWithStorageId(int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItemsWithStorageId");

	Params::UInventoryComponent2_GetItemsWithStorageId_Params Parms{};

	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItemsSorted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInventoryEntry>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInventoryEntry> UInventoryComponent2::GetItemsSorted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItemsSorted");

	Params::UInventoryComponent2_GetItemsSorted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInventoryEntry>     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInventoryEntry> UInventoryComponent2::GetItems()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItems");

	Params::UInventoryComponent2_GetItems_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItemInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemEntry                  ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemEntry UInventoryComponent2::GetItemInfo(class FName Name, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItemInfo");

	Params::UInventoryComponent2_GetItemInfo_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetItemAtOrFirst
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UInventoryComponent2::GetItemAtOrFirst(class FName UniqueId, const struct FVector2D& Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetItemAtOrFirst");

	Params::UInventoryComponent2_GetItemAtOrFirst_Params Parms{};

	Parms.UniqueId = UniqueId;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetInternalItemId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInventoryEntry             Entry                                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UInventoryComponent2::GetInternalItemId(struct FInventoryEntry& Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetInternalItemId");

	Params::UInventoryComponent2_GetInternalItemId_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetCanBeDropped
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::GetCanBeDropped(const struct FVector2D& Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetCanBeDropped");

	Params::UInventoryComponent2_GetCanBeDropped_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetByIndex
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UInventoryComponent2::GetByIndex(const struct FVector2D& Index, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetByIndex");

	Params::UInventoryComponent2_GetByIndex_Params Parms{};

	Parms.Index = Index;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.GetAnyItemWithUniqueID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        UniqueId                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInventoryEntry             ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInventoryEntry UInventoryComponent2::GetAnyItemWithUniqueID(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "GetAnyItemWithUniqueID");

	Params::UInventoryComponent2_GetAnyItemWithUniqueID_Params Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.FlushItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInventoryComponent2::FlushItems()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "FlushItems");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.InventoryComponent2.CountUID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemUID                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::CountUID(class FName ItemUID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "CountUID");

	Params::UInventoryComponent2_CountUID_Params Parms{};

	Parms.ItemUID = ItemUID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.Count
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::Count(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "Count");

	Params::UInventoryComponent2_Count_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.CheckSpaceAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::CheckSpaceAt(class FName ItemId, const struct FVector2D& Index, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "CheckSpaceAt");

	Params::UInventoryComponent2_CheckSpaceAt_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Index = Index;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.CheckIfValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::CheckIfValid()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "CheckIfValid");

	Params::UInventoryComponent2_CheckIfValid_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.CanAddAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::CanAddAt(class FName ItemId, float Amount, const struct FVector2D& Index, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "CanAddAt");

	Params::UInventoryComponent2_CanAddAt_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Amount = Amount;
	Parms.Index = Index;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.CanAdd
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::CanAdd(class FName ItemId, float Amount, const struct FVector2D& Index, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "CanAdd");

	Params::UInventoryComponent2_CanAdd_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Amount = Amount;
	Parms.Index = Index;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.AddUpgrade
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Upgrade                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UniqueName                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent2::AddUpgrade(const struct FVector2D& Position, class FName Upgrade, class FName* UniqueName, int32 StorageID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "AddUpgrade");

	Params::UInventoryComponent2_AddUpgrade_Params Parms{};

	Parms.Position = Position;
	Parms.Upgrade = Upgrade;
	Parms.StorageID = StorageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (UniqueName != nullptr)
		*UniqueName = Parms.UniqueName;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.AddAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Upgrades                                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSendBroadcast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::AddAt(class FName ItemId, const TArray<class FName>& Upgrades, float Amount, const struct FVector2D& Index, int32 StorageID, bool bSendBroadcast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "AddAt");

	Params::UInventoryComponent2_AddAt_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Upgrades = Upgrades;
	Parms.Amount = Amount;
	Parms.Index = Index;
	Parms.StorageID = StorageID;
	Parms.bSendBroadcast = bSendBroadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.InventoryComponent2.Add
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Upgrades                                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StorageID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSendBroadcast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   MaxIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent2::Add(class FName ItemId, const TArray<class FName>& Upgrades, float Amount, const struct FVector2D& Index, int32 StorageID, bool bSendBroadcast, const struct FVector2D& MaxIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InventoryComponent2", "Add");

	Params::UInventoryComponent2_Add_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Upgrades = Upgrades;
	Parms.Amount = Amount;
	Parms.Index = Index;
	Parms.StorageID = StorageID;
	Parms.bSendBroadcast = bSendBroadcast;
	Parms.MaxIndex = MaxIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.IObjectWithEnableDisable
// (None)

class UClass* IIObjectWithEnableDisable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("IObjectWithEnableDisable");

	return Clss;
}


// IObjectWithEnableDisable ChernobylGame.Default__IObjectWithEnableDisable
// (Public, ClassDefaultObject, ArchetypeObject)

class IIObjectWithEnableDisable* IIObjectWithEnableDisable::GetDefaultObj()
{
	static class IIObjectWithEnableDisable* Default = nullptr;

	if (!Default)
		Default = static_cast<IIObjectWithEnableDisable*>(IIObjectWithEnableDisable::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.IObjectWithEnableDisable.SetInteractionEnabled
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               bEnabled                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIObjectWithEnableDisable::SetInteractionEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("IObjectWithEnableDisable", "SetInteractionEnabled");

	Params::IIObjectWithEnableDisable_SetInteractionEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.IObjectWithEnableDisable.IsInteractionEnabled
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IIObjectWithEnableDisable::IsInteractionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("IObjectWithEnableDisable", "IsInteractionEnabled");

	Params::IIObjectWithEnableDisable_IsInteractionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.IObjectWithEnableDisable.InteractionEnabledStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bEnabled                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIObjectWithEnableDisable::InteractionEnabledStateChanged(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("IObjectWithEnableDisable", "InteractionEnabledStateChanged");

	Params::IIObjectWithEnableDisable_InteractionEnabledStateChanged_Params Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.IObjectWithEnableDisable.EnableInteraction
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void IIObjectWithEnableDisable::EnableInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("IObjectWithEnableDisable", "EnableInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.IObjectWithEnableDisable.DisableInteraction
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void IIObjectWithEnableDisable::DisableInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("IObjectWithEnableDisable", "DisableInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LevelFunctionLibrary
// (None)

class UClass* ULevelFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelFunctionLibrary");

	return Clss;
}


// LevelFunctionLibrary ChernobylGame.Default__LevelFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelFunctionLibrary* ULevelFunctionLibrary::GetDefaultObj()
{
	static class ULevelFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelFunctionLibrary*>(ULevelFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LevelFunctionLibrary.GetSublevelsForCurrentPersistant
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldCtx                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULevelFunctionLibrary::GetSublevelsForCurrentPersistant(class UObject* WorldCtx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetSublevelsForCurrentPersistant");

	Params::ULevelFunctionLibrary_GetSublevelsForCurrentPersistant_Params Parms{};

	Parms.WorldCtx = WorldCtx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.GetSublevelName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      InActor                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutString                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelFunctionLibrary::GetSublevelName(class AActor* InActor, class FString* OutString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetSublevelName");

	Params::ULevelFunctionLibrary_GetSublevelName_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

}


// Function ChernobylGame.LevelFunctionLibrary.GetLevelNamesFromAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<TSoftObjectPtr<class UWorld>>Levels                                                           (ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULevelFunctionLibrary::GetLevelNamesFromAssets(const TArray<TSoftObjectPtr<class UWorld>>& Levels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetLevelNamesFromAssets");

	Params::ULevelFunctionLibrary_GetLevelNamesFromAssets_Params Parms{};

	Parms.Levels = Levels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.GetLevelNameFromAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UWorld>       Level                                                            (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULevelFunctionLibrary::GetLevelNameFromAsset(TSoftObjectPtr<class UWorld> Level)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetLevelNameFromAsset");

	Params::ULevelFunctionLibrary_GetLevelNameFromAsset_Params Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.GetLevelFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULevelFunctionLibrary::GetLevelFromActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetLevelFromActor");

	Params::ULevelFunctionLibrary_GetLevelFromActor_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.GetCurveValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRuntimeFloatCurve          InCurve                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              InX                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutY                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelFunctionLibrary::GetCurveValue(struct FRuntimeFloatCurve& InCurve, float InX, float* OutY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetCurveValue");

	Params::ULevelFunctionLibrary_GetCurveValue_Params Parms{};

	Parms.InCurve = InCurve;
	Parms.InX = InX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutY != nullptr)
		*OutY = Parms.OutY;

}


// Function ChernobylGame.LevelFunctionLibrary.GetCurrentStreamedLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldCtx                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULevelFunctionLibrary::GetCurrentStreamedLevels(class UObject* WorldCtx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetCurrentStreamedLevels");

	Params::ULevelFunctionLibrary_GetCurrentStreamedLevels_Params Parms{};

	Parms.WorldCtx = WorldCtx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.GetAllActorsFromLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>          Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     WorldCtx                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LevelName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ULevelFunctionLibrary::GetAllActorsFromLevel(TSubclassOf<class AActor> Class, class UObject* WorldCtx, class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "GetAllActorsFromLevel");

	Params::ULevelFunctionLibrary_GetAllActorsFromLevel_Params Parms{};

	Parms.Class = Class;
	Parms.WorldCtx = WorldCtx;
	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelFunctionLibrary.CallFunctionOnLevelRoomSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                      InLevel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InFunctionName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRoomLoadInformation        RoomInfo                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULevelFunctionLibrary::CallFunctionOnLevelRoomSystem(class ULevel* InLevel, const class FString& InFunctionName, const struct FRoomLoadInformation& RoomInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "CallFunctionOnLevelRoomSystem");

	Params::ULevelFunctionLibrary_CallFunctionOnLevelRoomSystem_Params Parms{};

	Parms.InLevel = InLevel;
	Parms.InFunctionName = InFunctionName;
	Parms.RoomInfo = RoomInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelFunctionLibrary.CallFunctionOnLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelStreaming*             InLevel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InFunctionName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelFunctionLibrary::CallFunctionOnLevel(class ULevelStreaming* InLevel, const class FString& InFunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelFunctionLibrary", "CallFunctionOnLevel");

	Params::ULevelFunctionLibrary_CallFunctionOnLevel_Params Parms{};

	Parms.InLevel = InLevel;
	Parms.InFunctionName = InFunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LevelStreamingAsyncNode
// (None)

class UClass* ULevelStreamingAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingAsyncNode");

	return Clss;
}


// LevelStreamingAsyncNode ChernobylGame.Default__LevelStreamingAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelStreamingAsyncNode* ULevelStreamingAsyncNode::GetDefaultObj()
{
	static class ULevelStreamingAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelStreamingAsyncNode*>(ULevelStreamingAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LevelStreamingAsyncNode.StreamLevelsAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelStreamingManager*      LevelManager                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Levels                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ULevelStreamingAsyncNode*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingAsyncNode* ULevelStreamingAsyncNode::StreamLevelsAsync(class UObject* WorldContextObject, class ALevelStreamingManager* LevelManager, TArray<class FName>& Levels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingAsyncNode", "StreamLevelsAsync");

	Params::ULevelStreamingAsyncNode_StreamLevelsAsync_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelManager = LevelManager;
	Parms.Levels = Levels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelStreamingAsyncNode.LevelLoadingFinished
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                        LevelName                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreamingAsyncNode::LevelLoadingFinished(class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingAsyncNode", "LevelLoadingFinished");

	Params::ULevelStreamingAsyncNode_LevelLoadingFinished_Params Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LevelStreamingManager
// (Actor)

class UClass* ALevelStreamingManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingManager");

	return Clss;
}


// LevelStreamingManager ChernobylGame.Default__LevelStreamingManager
// (Public, ClassDefaultObject, ArchetypeObject)

class ALevelStreamingManager* ALevelStreamingManager::GetDefaultObj()
{
	static class ALevelStreamingManager* Default = nullptr;

	if (!Default)
		Default = static_cast<ALevelStreamingManager*>(ALevelStreamingManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LevelStreamingManager.UnloadStreamingLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                        InLevelName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelStreamingManager::UnloadStreamingLevel(class FName InLevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "UnloadStreamingLevel");

	Params::ALevelStreamingManager_UnloadStreamingLevel_Params Parms{};

	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelStreamingManager.SetStreamingLevels
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                InLevelNames                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALevelStreamingManager::SetStreamingLevels(TArray<class FName>& InLevelNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "SetStreamingLevels");

	Params::ALevelStreamingManager_SetStreamingLevels_Params Parms{};

	Parms.InLevelNames = InLevelNames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelStreamingManager.LoadStreamingLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                        InLevelName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelStreamingManager::LoadStreamingLevel(class FName InLevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "LoadStreamingLevel");

	Params::ALevelStreamingManager_LoadStreamingLevel_Params Parms{};

	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelStreamingManager.IsLevelLoaded
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                        InLevelName                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelStreamingManager::IsLevelLoaded(class FName& InLevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "IsLevelLoaded");

	Params::ALevelStreamingManager_IsLevelLoaded_Params Parms{};

	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelStreamingManager.InternalOnUnloadFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ALevelStreamingManager::InternalOnUnloadFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "InternalOnUnloadFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelStreamingManager.InternalOnLoadFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ALevelStreamingManager::InternalOnLoadFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingManager", "InternalOnLoadFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LevelUnstreamingAsyncNode
// (None)

class UClass* ULevelUnstreamingAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelUnstreamingAsyncNode");

	return Clss;
}


// LevelUnstreamingAsyncNode ChernobylGame.Default__LevelUnstreamingAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelUnstreamingAsyncNode* ULevelUnstreamingAsyncNode::GetDefaultObj()
{
	static class ULevelUnstreamingAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelUnstreamingAsyncNode*>(ULevelUnstreamingAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LevelUnstreamingAsyncNode.UnstreamLevelsAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelStreamingManager*      LevelManager                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Levels                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ULevelUnstreamingAsyncNode*  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelUnstreamingAsyncNode* ULevelUnstreamingAsyncNode::UnstreamLevelsAsync(class UObject* WorldContextObject, class ALevelStreamingManager* LevelManager, TArray<class FName>& Levels)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelUnstreamingAsyncNode", "UnstreamLevelsAsync");

	Params::ULevelUnstreamingAsyncNode_UnstreamLevelsAsync_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelManager = LevelManager;
	Parms.Levels = Levels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LevelUnstreamingAsyncNode.LevelUnloadingFinished
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                        LevelName                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUnstreamingAsyncNode::LevelUnloadingFinished(class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelUnstreamingAsyncNode", "LevelUnloadingFinished");

	Params::ULevelUnstreamingAsyncNode_LevelUnloadingFinished_Params Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LevelUnstreamingAsyncNode.BeforeUnloadingFinished
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                        LevelName                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUnstreamingAsyncNode::BeforeUnloadingFinished(class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelUnstreamingAsyncNode", "BeforeUnloadingFinished");

	Params::ULevelUnstreamingAsyncNode_BeforeUnloadingFinished_Params Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LogTests
// (Actor)

class UClass* ALogTests::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LogTests");

	return Clss;
}


// LogTests ChernobylGame.Default__LogTests
// (Public, ClassDefaultObject, ArchetypeObject)

class ALogTests* ALogTests::GetDefaultObj()
{
	static class ALogTests* Default = nullptr;

	if (!Default)
		Default = static_cast<ALogTests*>(ALogTests::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LogTests.CategoryLogTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ALogTests::CategoryLogTest()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LogTests", "CategoryLogTest");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.LookAtArea
// (Actor)

class UClass* ALookAtArea::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LookAtArea");

	return Clss;
}


// LookAtArea ChernobylGame.Default__LookAtArea
// (Public, ClassDefaultObject, ArchetypeObject)

class ALookAtArea* ALookAtArea::GetDefaultObj()
{
	static class ALookAtArea* Default = nullptr;

	if (!Default)
		Default = static_cast<ALookAtArea*>(ALookAtArea::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.LookAtAreaInterface
// (None)

class UClass* ILookAtAreaInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LookAtAreaInterface");

	return Clss;
}


// LookAtAreaInterface ChernobylGame.Default__LookAtAreaInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ILookAtAreaInterface* ILookAtAreaInterface::GetDefaultObj()
{
	static class ILookAtAreaInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ILookAtAreaInterface*>(ILookAtAreaInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.LookAtAreaInterface.UnlockInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ILookAtAreaInterface::UnlockInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "UnlockInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LookAtAreaInterface.SetInteractionLocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               bLocked                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ILookAtAreaInterface::SetInteractionLocked(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "SetInteractionLocked");

	Params::ILookAtAreaInterface_SetInteractionLocked_Params Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LookAtAreaInterface.OnLookAtStarted
// (Event, Public, BlueprintEvent)
// Parameters:

void ILookAtAreaInterface::OnLookAtStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "OnLookAtStarted");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.LookAtAreaInterface.OnLookAtFinished
// (Event, Public, BlueprintEvent)
// Parameters:

void ILookAtAreaInterface::OnLookAtFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "OnLookAtFinished");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.LookAtAreaInterface.LockInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ILookAtAreaInterface::LockInteraction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "LockInteraction");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.LookAtAreaInterface.IsInteractionUnlocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ILookAtAreaInterface::IsInteractionUnlocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "IsInteractionUnlocked");

	Params::ILookAtAreaInterface_IsInteractionUnlocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.LookAtAreaInterface.GetMaxDetectionDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ILookAtAreaInterface::GetMaxDetectionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LookAtAreaInterface", "GetMaxDetectionDistance");

	Params::ILookAtAreaInterface_GetMaxDetectionDistance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.MadnessComponent
// (None)

class UClass* UMadnessComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MadnessComponent");

	return Clss;
}


// MadnessComponent ChernobylGame.Default__MadnessComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMadnessComponent* UMadnessComponent::GetDefaultObj()
{
	static class UMadnessComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMadnessComponent*>(UMadnessComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.MadnessComponent.UpdateUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UMadnessComponent::UpdateUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "UpdateUI");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MadnessComponent.ModifyMadness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipGodMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMadnessComponent::ModifyMadness(int32 Offset, bool bSkipGodMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "ModifyMadness");

	Params::UMadnessComponent_ModifyMadness_Params Parms{};

	Parms.Offset = Offset;
	Parms.bSkipGodMode = bSkipGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetMaximumPsycheOverall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMadnessComponent::GetMaximumPsycheOverall()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetMaximumPsycheOverall");

	Params::UMadnessComponent_GetMaximumPsycheOverall_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetMaximumPsycheAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMadnessComponent::GetMaximumPsycheAllowed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetMaximumPsycheAllowed");

	Params::UMadnessComponent_GetMaximumPsycheAllowed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetMaximumMadness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMadnessComponent::GetMaximumMadness()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetMaximumMadness");

	Params::UMadnessComponent_GetMaximumMadness_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetIsMadnessModificationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMadnessComponent::GetIsMadnessModificationEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetIsMadnessModificationEnabled");

	Params::UMadnessComponent_GetIsMadnessModificationEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetIsMadnessEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMadnessComponent::GetIsMadnessEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetIsMadnessEnabled");

	Params::UMadnessComponent_GetIsMadnessEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetCurrentPsyche
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMadnessComponent::GetCurrentPsyche()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetCurrentPsyche");

	Params::UMadnessComponent_GetCurrentPsyche_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MadnessComponent.GetCurrentMadness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMadnessComponent::GetCurrentMadness()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MadnessComponent", "GetCurrentMadness");

	Params::UMadnessComponent_GetCurrentMadness_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.MainPawnCpp
// (Actor, Pawn)

class UClass* AMainPawnCpp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MainPawnCpp");

	return Clss;
}


// MainPawnCpp ChernobylGame.Default__MainPawnCpp
// (Public, ClassDefaultObject, ArchetypeObject)

class AMainPawnCpp* AMainPawnCpp::GetDefaultObj()
{
	static class AMainPawnCpp* Default = nullptr;

	if (!Default)
		Default = static_cast<AMainPawnCpp*>(AMainPawnCpp::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.MainPawnCpp.UpdatePropertiesFromActiveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::UpdatePropertiesFromActiveItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "UpdatePropertiesFromActiveItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.UpdateCurrentItemLastEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::UpdateCurrentItemLastEntry()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "UpdateCurrentItemLastEntry");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.UpdateAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InCharacter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInIsAggroed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::UpdateAggro(class ACGAICharacter* InCharacter, bool bInIsAggroed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "UpdateAggro");

	Params::AMainPawnCpp_UpdateAggro_Params Parms{};

	Parms.InCharacter = InCharacter;
	Parms.bInIsAggroed = bInIsAggroed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.TryToSwitchAmmo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutSwitchSucceeded                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::TryToSwitchAmmo(bool* OutSwitchSucceeded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "TryToSwitchAmmo");

	Params::AMainPawnCpp_TryToSwitchAmmo_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSwitchSucceeded != nullptr)
		*OutSwitchSucceeded = Parms.OutSwitchSucceeded;

}


// Function ChernobylGame.MainPawnCpp.TryToShoot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutActivationSucceeded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::TryToShoot(bool* OutActivationSucceeded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "TryToShoot");

	Params::AMainPawnCpp_TryToShoot_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActivationSucceeded != nullptr)
		*OutActivationSucceeded = Parms.OutActivationSucceeded;

}


// Function ChernobylGame.MainPawnCpp.TryToReload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutReloadSucceeded                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::TryToReload(bool* OutReloadSucceeded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "TryToReload");

	Params::AMainPawnCpp_TryToReload_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutReloadSucceeded != nullptr)
		*OutReloadSucceeded = Parms.OutReloadSucceeded;

}


// Function ChernobylGame.MainPawnCpp.TryToAim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::TryToAim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "TryToAim");

	Params::AMainPawnCpp_TryToAim_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.SwapActiveItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACGActiveItem>   InNewActiveItemClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutSwapSuccessful                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SwapActiveItem(TSubclassOf<class ACGActiveItem> InNewActiveItemClass, bool* OutSwapSuccessful)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SwapActiveItem");

	Params::AMainPawnCpp_SwapActiveItem_Params Parms{};

	Parms.InNewActiveItemClass = InNewActiveItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSwapSuccessful != nullptr)
		*OutSwapSuccessful = Parms.OutSwapSuccessful;

}


// Function ChernobylGame.MainPawnCpp.ShowHideGameplayHands
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               NewHidden                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SpeedMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ShowHideGameplayHands(bool NewHidden, float SpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ShowHideGameplayHands");

	Params::AMainPawnCpp_ShowHideGameplayHands_Params Parms{};

	Parms.NewHidden = NewHidden;
	Parms.SpeedMultiplier = SpeedMultiplier;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.SetWasInteractionWithInteractableExecuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsExecuted                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetWasInteractionWithInteractableExecuted(bool bIsExecuted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetWasInteractionWithInteractableExecuted");

	Params::AMainPawnCpp_SetWasInteractionWithInteractableExecuted_Params Parms{};

	Parms.bIsExecuted = bIsExecuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetSkippableCurrentDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewSkippable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetSkippableCurrentDialogue(bool bInNewSkippable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetSkippableCurrentDialogue");

	Params::AMainPawnCpp_SetSkippableCurrentDialogue_Params Parms{};

	Parms.bInNewSkippable = bInNewSkippable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetPlayerBreathParameters
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              BreathPeriodDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BreathIntensity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetPlayerBreathParameters(float BreathPeriodDuration, float BreathIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetPlayerBreathParameters");

	Params::AMainPawnCpp_SetPlayerBreathParameters_Params Parms{};

	Parms.BreathPeriodDuration = BreathPeriodDuration;
	Parms.BreathIntensity = BreathIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetPDAToggleActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsActivated                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetPDAToggleActivated(bool bIsActivated)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetPDAToggleActivated");

	Params::AMainPawnCpp_SetPDAToggleActivated_Params Parms{};

	Parms.bIsActivated = bIsActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetMovementStateMachineEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetMovementStateMachineEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetMovementStateMachineEnabled");

	Params::AMainPawnCpp_SetMovementStateMachineEnabled_Params Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetGameplayHandsAndItemsVisibleTrue
// (Final, Native, Public)
// Parameters:

void AMainPawnCpp::SetGameplayHandsAndItemsVisibleTrue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetGameplayHandsAndItemsVisibleTrue");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetGameplayHandsAndItemsVisibleFalse
// (Final, Native, Public)
// Parameters:

void AMainPawnCpp::SetGameplayHandsAndItemsVisibleFalse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetGameplayHandsAndItemsVisibleFalse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetGameplayHandsAndItemsVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInVisible                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetGameplayHandsAndItemsVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetGameplayHandsAndItemsVisible");

	Params::AMainPawnCpp_SetGameplayHandsAndItemsVisible_Params Parms{};

	Parms.bInVisible = bInVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.SetFirstPersonCameraFocusCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      InFocusSorce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PossibleOffset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GalobalInterpMod                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Socket                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetFirstPersonCameraFocusCPP(class AActor* InFocusSorce, float PossibleOffset, float GalobalInterpMod, class FName Socket)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetFirstPersonCameraFocusCPP");

	Params::AMainPawnCpp_SetFirstPersonCameraFocusCPP_Params Parms{};

	Parms.InFocusSorce = InFocusSorce;
	Parms.PossibleOffset = PossibleOffset;
	Parms.GalobalInterpMod = GalobalInterpMod;
	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.SetExperienceGainBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsBlocked                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::SetExperienceGainBlocked(bool bIsBlocked)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "SetExperienceGainBlocked");

	Params::AMainPawnCpp_SetExperienceGainBlocked_Params Parms{};

	Parms.bIsBlocked = bIsBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.RestartSwayTimeline
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::RestartSwayTimeline()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "RestartSwayTimeline");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.ResetCurrentClipSizeCache
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::ResetCurrentClipSizeCache()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ResetCurrentClipSizeCache");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.ResetCrouch
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::ResetCrouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ResetCrouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.RequestForcedUncrouch
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::RequestForcedUncrouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "RequestForcedUncrouch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.RemovePerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        PerkName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::RemovePerk(class FName PerkName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "RemovePerk");

	Params::AMainPawnCpp_RemovePerk_Params Parms{};

	Parms.PerkName = PerkName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.RemoveInterrogation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InAI                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::RemoveInterrogation(class ACGAICharacter* InAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "RemoveInterrogation");

	Params::AMainPawnCpp_RemoveInterrogation_Params Parms{};

	Parms.InAI = InAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.RemoveAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InAI                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::RemoveAggro(class ACGAICharacter* InAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "RemoveAggro");

	Params::AMainPawnCpp_RemoveAggro_Params Parms{};

	Parms.InAI = InAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.ProcessFire
// (Final, Native, Public)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ProcessFire(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ProcessFire");

	Params::AMainPawnCpp_ProcessFire_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.PlayReactionShakeABP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFPReaction                 InReaction                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              InScale                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::PlayReactionShakeABP(struct FFPReaction& InReaction, float InScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PlayReactionShakeABP");

	Params::AMainPawnCpp_PlayReactionShakeABP_Params Parms{};

	Parms.InReaction = InReaction;
	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.PlayReactionShake
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFPReaction                 InReaction                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              InScale                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::PlayReactionShake(struct FFPReaction& InReaction, float InScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PlayReactionShake");

	Params::AMainPawnCpp_PlayReactionShake_Params Parms{};

	Parms.InReaction = InReaction;
	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.PlayCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMovieSceneSequencePlayer*   InSequencePlayer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InFakeHeroStart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      InFakeHeroEnd                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACGAICharacter*>      InSequencerActors                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                              InHideWeaponAnimScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InHeroInterpolationToStartLength                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InCameraInterpolationToStartLength                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InCameraInterpolationToEndLength                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InAICharactersBlendOutLength                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInRestore                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::PlayCutscene(class UMovieSceneSequencePlayer* InSequencePlayer, class AActor* InFakeHeroStart, class AActor* InFakeHeroEnd, const TArray<class ACGAICharacter*>& InSequencerActors, float InHideWeaponAnimScale, float InHeroInterpolationToStartLength, float InCameraInterpolationToStartLength, float InCameraInterpolationToEndLength, float InAICharactersBlendOutLength, bool bInRestore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PlayCutscene");

	Params::AMainPawnCpp_PlayCutscene_Params Parms{};

	Parms.InSequencePlayer = InSequencePlayer;
	Parms.InFakeHeroStart = InFakeHeroStart;
	Parms.InFakeHeroEnd = InFakeHeroEnd;
	Parms.InSequencerActors = InSequencerActors;
	Parms.InHideWeaponAnimScale = InHideWeaponAnimScale;
	Parms.InHeroInterpolationToStartLength = InHeroInterpolationToStartLength;
	Parms.InCameraInterpolationToStartLength = InCameraInterpolationToStartLength;
	Parms.InCameraInterpolationToEndLength = InCameraInterpolationToEndLength;
	Parms.InAICharactersBlendOutLength = InAICharactersBlendOutLength;
	Parms.bInRestore = bInRestore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.PlayCustomAnim
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*               InSequence                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InTransform                                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlayCustomAnimProperties   InProperties                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ACGFakeHero*                 OutFakeHero                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendInTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendInCameraTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendOutCameraTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInShouldInterpolate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInSholdEnableMovementAfter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInShouldApplyGodmodeForDuration                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInShouldHideCustomHands                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInShouldUncrouch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOldBehavior                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOffsetByHalfCapsule                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMainPawnCpp::PlayCustomAnim(class UAnimSequence* InSequence, const struct FTransform& InTransform, const struct FPlayCustomAnimProperties& InProperties, class ACGFakeHero** OutFakeHero, float InBlendInTime, float InBlendInCameraTime, float InBlendOutCameraTime, bool bInShouldInterpolate, bool bInSholdEnableMovementAfter, bool bInShouldApplyGodmodeForDuration, bool bInShouldHideCustomHands, bool bInShouldUncrouch, bool bOldBehavior, bool bOffsetByHalfCapsule)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PlayCustomAnim");

	Params::AMainPawnCpp_PlayCustomAnim_Params Parms{};

	Parms.InSequence = InSequence;
	Parms.InTransform = InTransform;
	Parms.InProperties = InProperties;
	Parms.InBlendInTime = InBlendInTime;
	Parms.InBlendInCameraTime = InBlendInCameraTime;
	Parms.InBlendOutCameraTime = InBlendOutCameraTime;
	Parms.bInShouldInterpolate = bInShouldInterpolate;
	Parms.bInSholdEnableMovementAfter = bInSholdEnableMovementAfter;
	Parms.bInShouldApplyGodmodeForDuration = bInShouldApplyGodmodeForDuration;
	Parms.bInShouldHideCustomHands = bInShouldHideCustomHands;
	Parms.bInShouldUncrouch = bInShouldUncrouch;
	Parms.bOldBehavior = bOldBehavior;
	Parms.bOffsetByHalfCapsule = bOffsetByHalfCapsule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutFakeHero != nullptr)
		*OutFakeHero = Parms.OutFakeHero;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.PerformFullQuickSave
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::PerformFullQuickSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PerformFullQuickSave");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.PerformCopyQuickSave
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::PerformCopyQuickSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "PerformCopyQuickSave");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.OverrideLastDamageEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGDamageEvent              InNewLastDamage                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMainPawnCpp::OverrideLastDamageEvent(struct FCGDamageEvent& InNewLastDamage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OverrideLastDamageEvent");

	Params::AMainPawnCpp_OverrideLastDamageEvent_Params Parms{};

	Parms.InNewLastDamage = InNewLastDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OpenBuildSystem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::OpenBuildSystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OpenBuildSystem");

	Params::AMainPawnCpp_OpenBuildSystem_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.OnRadiationPhaseChanged
// (Final, Native, Public)
// Parameters:
// enum class EHealthPhase            InOldPhase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EHealthPhase            InNewPhase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnRadiationPhaseChanged(enum class EHealthPhase InOldPhase, enum class EHealthPhase InNewPhase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnRadiationPhaseChanged");

	Params::AMainPawnCpp_OnRadiationPhaseChanged_Params Parms{};

	Parms.InOldPhase = InOldPhase;
	Parms.InNewPhase = InNewPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnMeleeActivated
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnMeleeActivated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnMeleeActivated");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.OnHideShowFinished
// (Final, Native, Public)
// Parameters:
// bool                               InResult                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EFPAnimSystemActivity   InTargetState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnHideShowFinished(bool InResult, enum class EFPAnimSystemActivity InTargetState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnHideShowFinished");

	Params::AMainPawnCpp_OnHideShowFinished_Params Parms{};

	Parms.InResult = InResult;
	Parms.InTargetState = InTargetState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnHealthPhaseChanged
// (Final, Native, Public)
// Parameters:
// enum class EHealthPhase            InOldPhase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EHealthPhase            InNewPhase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     InDamageType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnHealthPhaseChanged(enum class EHealthPhase InOldPhase, enum class EHealthPhase InNewPhase, TSubclassOf<class UDamageType> InDamageType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnHealthPhaseChanged");

	Params::AMainPawnCpp_OnHealthPhaseChanged_Params Parms{};

	Parms.InOldPhase = InOldPhase;
	Parms.InNewPhase = InNewPhase;
	Parms.InDamageType = InDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnGasMaskFilterChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnGasMaskFilterChanged()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnGasMaskFilterChanged");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnEndOverlapWithComponent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         OverlappedComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnEndOverlapWithComponent(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnEndOverlapWithComponent");

	Params::AMainPawnCpp_OnEndOverlapWithComponent_Params Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnDeath
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnDeath");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnDash
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EDashDirection          InDirection                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnDash(enum class EDashDirection InDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnDash");

	Params::AMainPawnCpp_OnDash_Params Parms{};

	Parms.InDirection = InDirection;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.OnCustomSequenceFinished
// (Final, Native, Private)
// Parameters:

void AMainPawnCpp::OnCustomSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnCustomSequenceFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.OnCrouch
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnCrouch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnCrouch");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.OnClimb
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnClimb()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnClimb");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.OnChernobyliteDrugBlendOut
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::OnChernobyliteDrugBlendOut()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnChernobyliteDrugBlendOut");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.OnBeginOverlapWithComponent
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         OverlappedComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMainPawnCpp::OnBeginOverlapWithComponent(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "OnBeginOverlapWithComponent");

	Params::AMainPawnCpp_OnBeginOverlapWithComponent_Params Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.MovementStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACGMovementState>InInitialMovementState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::MovementStart(TSubclassOf<class ACGMovementState> InInitialMovementState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "MovementStart");

	Params::AMainPawnCpp_MovementStart_Params Parms{};

	Parms.InInitialMovementState = InInitialMovementState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.LevelTimerRanOut
// (Final, Native, Public)
// Parameters:

void AMainPawnCpp::LevelTimerRanOut()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "LevelTimerRanOut");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.IsStealthKillEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::IsStealthKillEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "IsStealthKillEnabled");

	Params::AMainPawnCpp_IsStealthKillEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.IsPlayerWearingGasMask
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::IsPlayerWearingGasMask()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "IsPlayerWearingGasMask");

	Params::AMainPawnCpp_IsPlayerWearingGasMask_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.InvokePauseMenu
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::InvokePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "InvokePauseMenu");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.HideShowActiveItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutActionSuccessful                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFastAction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::HideShowActiveItem(bool* OutActionSuccessful, bool bInFastAction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "HideShowActiveItem");

	Params::AMainPawnCpp_HideShowActiveItem_Params Parms{};

	Parms.bInFastAction = bInFastAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActionSuccessful != nullptr)
		*OutActionSuccessful = Parms.OutActionSuccessful;

}


// Function ChernobylGame.MainPawnCpp.HideCurrentActiveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::HideCurrentActiveItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "HideCurrentActiveItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.HasParkourExpert
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::HasParkourExpert()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "HasParkourExpert");

	Params::AMainPawnCpp_HasParkourExpert_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetWasInteractionWithInteractableExectued
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetWasInteractionWithInteractableExectued()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetWasInteractionWithInteractableExectued");

	Params::AMainPawnCpp_GetWasInteractionWithInteractableExectued_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetThreatPerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class ACGAICharacter*, float> ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class ACGAICharacter*, float> AMainPawnCpp::GetThreatPerCharacter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetThreatPerCharacter");

	Params::AMainPawnCpp_GetThreatPerCharacter_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetPlayerStamina
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMainPawnCpp::GetPlayerStamina()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetPlayerStamina");

	Params::AMainPawnCpp_GetPlayerStamina_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetPlayerMovementStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetPlayerMovementStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetPlayerMovementStarted");

	Params::AMainPawnCpp_GetPlayerMovementStarted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetNumAvailableGasMaskFilters
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMainPawnCpp::GetNumAvailableGasMaskFilters()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetNumAvailableGasMaskFilters");

	Params::AMainPawnCpp_GetNumAvailableGasMaskFilters_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetLeanAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMainPawnCpp::GetLeanAxis()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetLeanAxis");

	Params::AMainPawnCpp_GetLeanAxis_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetIsWWiseMediumOrHeavySprintState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetIsWWiseMediumOrHeavySprintState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetIsWWiseMediumOrHeavySprintState");

	Params::AMainPawnCpp_GetIsWWiseMediumOrHeavySprintState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetIsPlayerSprinting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetIsPlayerSprinting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetIsPlayerSprinting");

	Params::AMainPawnCpp_GetIsPlayerSprinting_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetIsPDAToggleActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetIsPDAToggleActivated()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetIsPDAToggleActivated");

	Params::AMainPawnCpp_GetIsPDAToggleActivated_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetIsExperienceGainBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::GetIsExperienceGainBlocked()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetIsExperienceGainBlocked");

	Params::AMainPawnCpp_GetIsExperienceGainBlocked_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetHighestThreat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGAICharacter*              OutHighestThreatCharacter                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHighestFloat                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::GetHighestThreat(class ACGAICharacter** OutHighestThreatCharacter, float* OutHighestFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetHighestThreat");

	Params::AMainPawnCpp_GetHighestThreat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHighestThreatCharacter != nullptr)
		*OutHighestThreatCharacter = Parms.OutHighestThreatCharacter;

	if (OutHighestFloat != nullptr)
		*OutHighestFloat = Parms.OutHighestFloat;

}


// Function ChernobylGame.MainPawnCpp.GetGasMaskPostprocessInstanceDynamic
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AMainPawnCpp::GetGasMaskPostprocessInstanceDynamic()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetGasMaskPostprocessInstanceDynamic");

	Params::AMainPawnCpp_GetGasMaskPostprocessInstanceDynamic_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetCurrentResourceType
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EScannableResourceType  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EScannableResourceType AMainPawnCpp::GetCurrentResourceType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetCurrentResourceType");

	Params::AMainPawnCpp_GetCurrentResourceType_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetCurrentAggroList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGAICharacter*>      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGAICharacter*> AMainPawnCpp::GetCurrentAggroList()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetCurrentAggroList");

	Params::AMainPawnCpp_GetCurrentAggroList_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetCumulatedVisionAlertModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMainPawnCpp::GetCumulatedVisionAlertModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetCumulatedVisionAlertModifier");

	Params::AMainPawnCpp_GetCumulatedVisionAlertModifier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.GetClimbPossibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCGClimbQuery               ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCGClimbQuery AMainPawnCpp::GetClimbPossibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "GetClimbPossibility");

	Params::AMainPawnCpp_GetClimbPossibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.FullQueryFinished
// (Final, Native, Private)
// Parameters:
// enum class EState                  InQueryInitialItemState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACGActiveItem>   InQueryInitialItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::FullQueryFinished(enum class EState InQueryInitialItemState, TSubclassOf<class ACGActiveItem> InQueryInitialItemClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "FullQueryFinished");

	Params::AMainPawnCpp_FullQueryFinished_Params Parms{};

	Parms.InQueryInitialItemState = InQueryInitialItemState;
	Parms.InQueryInitialItemClass = InQueryInitialItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.ForceInteractionFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             InComponent                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ForceInteractionFinished(class UActorComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ForceInteractionFinished");

	Params::AMainPawnCpp_ForceInteractionFinished_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.FindActiveItemInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACGActiveItem>   InActiveItemClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACGActiveItem*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGActiveItem* AMainPawnCpp::FindActiveItemInInventory(TSubclassOf<class ACGActiveItem> InActiveItemClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "FindActiveItemInInventory");

	Params::AMainPawnCpp_FindActiveItemInInventory_Params Parms{};

	Parms.InActiveItemClass = InActiveItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.FadeAudioMaster
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               InAudioOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::FadeAudioMaster(bool InAudioOn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "FadeAudioMaster");

	Params::AMainPawnCpp_FadeAudioMaster_Params Parms{};

	Parms.InAudioOn = InAudioOn;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.EnableInteractionsWithInteractable
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::EnableInteractionsWithInteractable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "EnableInteractionsWithInteractable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DropItem
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                Upgrades                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMainPawnCpp::DropItem(class FName ItemId, float Amount, TArray<class FName>& Upgrades)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DropItem");

	Params::AMainPawnCpp_DropItem_Params Parms{};

	Parms.ItemId = ItemId;
	Parms.Amount = Amount;
	Parms.Upgrades = Upgrades;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.DisableJumpSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OverwriteExisting                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::DisableJumpSound(float Duration, bool OverwriteExisting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DisableJumpSound");

	Params::AMainPawnCpp_DisableJumpSound_Params Parms{};

	Parms.Duration = Duration;
	Parms.OverwriteExisting = OverwriteExisting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DisableInteractionsWithInteractable
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::DisableInteractionsWithInteractable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DisableInteractionsWithInteractable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DisableFallDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInNewDisabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::DisableFallDamage(bool bInNewDisabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DisableFallDamage");

	Params::AMainPawnCpp_DisableFallDamage_Params Parms{};

	Parms.bInNewDisabled = bInNewDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DialogueShowSkipPrompt
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::DialogueShowSkipPrompt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DialogueShowSkipPrompt");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DialogueSetFocues
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      ActorToFocus                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::DialogueSetFocues(class AActor* ActorToFocus)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DialogueSetFocues");

	Params::AMainPawnCpp_DialogueSetFocues_Params Parms{};

	Parms.ActorToFocus = ActorToFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DialogueHideSkipPrompt
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::DialogueHideSkipPrompt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DialogueHideSkipPrompt");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DialogueEndFocues
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::DialogueEndFocues()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DialogueEndFocues");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.DecreaseGasMaskFiltersCount
// (Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::DecreaseGasMaskFiltersCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DecreaseGasMaskFiltersCount");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.MainPawnCpp.DebugPsycheModify
// (Exec, Event, Public, BlueprintEvent)
// Parameters:
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::DebugPsycheModify(float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DebugPsycheModify");

	Params::AMainPawnCpp_DebugPsycheModify_Params Parms{};

	Parms.Delta = Delta;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.DamageReceivedReactionCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              InDivideScale                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::DamageReceivedReactionCPP(float InDivideScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "DamageReceivedReactionCPP");

	Params::AMainPawnCpp_DamageReceivedReactionCPP_Params Parms{};

	Parms.InDivideScale = InDivideScale;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceUpdateHero
// (Final, Native, Private)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::Cutscenes_SequenceUpdateHero(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceUpdateHero");

	Params::AMainPawnCpp_Cutscenes_SequenceUpdateHero_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceUpdateCharacters
// (Final, Native, Private)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::Cutscenes_SequenceUpdateCharacters(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceUpdateCharacters");

	Params::AMainPawnCpp_Cutscenes_SequenceUpdateCharacters_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceUpdate
// (Final, Native, Private)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::Cutscenes_SequenceUpdate(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceUpdate");

	Params::AMainPawnCpp_Cutscenes_SequenceUpdate_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceFinishHero
// (Final, Native, Private)
// Parameters:

void AMainPawnCpp::Cutscenes_SequenceFinishHero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceFinishHero");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceFinishCharacters
// (Final, Native, Private)
// Parameters:

void AMainPawnCpp::Cutscenes_SequenceFinishCharacters()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceFinishCharacters");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_SequenceFinish
// (Final, Native, Private)
// Parameters:

void AMainPawnCpp::Cutscenes_SequenceFinish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_SequenceFinish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_InterpHeroToStartUpdate
// (Final, Native, Private)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::Cutscenes_InterpHeroToStartUpdate(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_InterpHeroToStartUpdate");

	Params::AMainPawnCpp_Cutscenes_InterpHeroToStartUpdate_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.Cutscenes_InterpHeroToStartFinish
// (Final, Native, Private)
// Parameters:

void AMainPawnCpp::Cutscenes_InterpHeroToStartFinish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Cutscenes_InterpHeroToStartFinish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.CloseInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::CloseInventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "CloseInventory");

	Params::AMainPawnCpp_CloseInventory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.Climb
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCGClimbQuery               InQuery                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMainPawnCpp::Climb(struct FCGClimbQuery& InQuery)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "Climb");

	Params::AMainPawnCpp_Climb_Params Parms{};

	Parms.InQuery = InQuery;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.CheckUncrouchPossibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::CheckUncrouchPossibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "CheckUncrouchPossibility");

	Params::AMainPawnCpp_CheckUncrouchPossibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.CheckPerk
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        PerkName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ValueA                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ValueB                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReturnOneIfNotFound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::CheckPerk(class FName PerkName, float* ValueA, float* ValueB, bool bReturnOneIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "CheckPerk");

	Params::AMainPawnCpp_CheckPerk_Params Parms{};

	Parms.PerkName = PerkName;
	Parms.bReturnOneIfNotFound = bReturnOneIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ValueA != nullptr)
		*ValueA = Parms.ValueA;

	if (ValueB != nullptr)
		*ValueB = Parms.ValueB;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.CheckIfBuildSystemIsAbleToOpen
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::CheckIfBuildSystemIsAbleToOpen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "CheckIfBuildSystemIsAbleToOpen");

	Params::AMainPawnCpp_CheckIfBuildSystemIsAbleToOpen_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.CheckCrouchPossibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::CheckCrouchPossibility()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "CheckCrouchPossibility");

	Params::AMainPawnCpp_CheckCrouchPossibility_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.ChangePsyche_CPP
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ChangePsyche_CPP(float Delta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ChangePsyche_CPP");

	Params::AMainPawnCpp_ChangePsyche_CPP_Params Parms{};

	Parms.Delta = Delta;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.ChangeGasMaskFilter
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void AMainPawnCpp::ChangeGasMaskFilter()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ChangeGasMaskFilter");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.BroadcastCPP_OnDialogueStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::BroadcastCPP_OnDialogueStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "BroadcastCPP_OnDialogueStarted");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.BroadcastCPP_OnDialogueEnded
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMainPawnCpp::BroadcastCPP_OnDialogueEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "BroadcastCPP_OnDialogueEnded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.AreInteractionsWithInteractableEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::AreInteractionsWithInteractableEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AreInteractionsWithInteractableEnabled");

	Params::AMainPawnCpp_AreInteractionsWithInteractableEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.AddPerkCPP
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                        PerkName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::AddPerkCPP(class FName PerkName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AddPerkCPP");

	Params::AMainPawnCpp_AddPerkCPP_Params Parms{};

	Parms.PerkName = PerkName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.MainPawnCpp.AddPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        PerkName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::AddPerk(class FName PerkName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AddPerk");

	Params::AMainPawnCpp_AddPerk_Params Parms{};

	Parms.PerkName = PerkName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.AddInterrogation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InAI                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::AddInterrogation(class ACGAICharacter* InAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AddInterrogation");

	Params::AMainPawnCpp_AddInterrogation_Params Parms{};

	Parms.InAI = InAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.AddAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACGAICharacter*              InAI                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::AddAggro(class ACGAICharacter* InAI)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AddAggro");

	Params::AMainPawnCpp_AddAggro_Params Parms{};

	Parms.InAI = InAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MainPawnCpp.ActiveItem_TryAlternativeActivate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutActivationSucceeded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ActiveItem_TryAlternativeActivate(bool* OutActivationSucceeded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ActiveItem_TryAlternativeActivate");

	Params::AMainPawnCpp_ActiveItem_TryAlternativeActivate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActivationSucceeded != nullptr)
		*OutActivationSucceeded = Parms.OutActivationSucceeded;

}


// Function ChernobylGame.MainPawnCpp.ActiveItem_TryActivate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               OutActivationSucceeded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainPawnCpp::ActiveItem_TryActivate(bool* OutActivationSucceeded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ActiveItem_TryActivate");

	Params::AMainPawnCpp_ActiveItem_TryActivate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActivationSucceeded != nullptr)
		*OutActivationSucceeded = Parms.OutActivationSucceeded;

}


// Function ChernobylGame.MainPawnCpp.ActiveItem_Melee
// (Final, Native, Public)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::ActiveItem_Melee()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "ActiveItem_Melee");

	Params::AMainPawnCpp_ActiveItem_Melee_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MainPawnCpp.AccessInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainPawnCpp::AccessInventory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MainPawnCpp", "AccessInventory");

	Params::AMainPawnCpp_AccessInventory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.MengerSpongeFractal
// (Actor)

class UClass* AMengerSpongeFractal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MengerSpongeFractal");

	return Clss;
}


// MengerSpongeFractal ChernobylGame.Default__MengerSpongeFractal
// (Public, ClassDefaultObject, ArchetypeObject)

class AMengerSpongeFractal* AMengerSpongeFractal::GetDefaultObj()
{
	static class AMengerSpongeFractal* Default = nullptr;

	if (!Default)
		Default = static_cast<AMengerSpongeFractal*>(AMengerSpongeFractal::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.MiniStorage
// (None)

class UClass* UMiniStorage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MiniStorage");

	return Clss;
}


// MiniStorage ChernobylGame.Default__MiniStorage
// (Public, ClassDefaultObject, ArchetypeObject)

class UMiniStorage* UMiniStorage::GetDefaultObj()
{
	static class UMiniStorage* Default = nullptr;

	if (!Default)
		Default = static_cast<UMiniStorage*>(UMiniStorage::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.MiniStorage.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMiniStorage::Remove(enum class EResourceType Type, float Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MiniStorage", "Remove");

	Params::UMiniStorage_Remove_Params Parms{};

	Parms.Type = Type;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.MiniStorage.Count
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMiniStorage::Count(enum class EResourceType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MiniStorage", "Count");

	Params::UMiniStorage_Count_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MiniStorage.Add
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMiniStorage::Add(enum class EResourceType Type, float Amount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MiniStorage", "Add");

	Params::UMiniStorage_Add_Params Parms{};

	Parms.Type = Type;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.MorningActivityManager
// (Actor)

class UClass* AMorningActivityManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MorningActivityManager");

	return Clss;
}


// MorningActivityManager ChernobylGame.Default__MorningActivityManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AMorningActivityManager* AMorningActivityManager::GetDefaultObj()
{
	static class AMorningActivityManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AMorningActivityManager*>(AMorningActivityManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.MorningActivityManager.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMorningActivityInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMorningActivityInfo AMorningActivityManager::Update()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MorningActivityManager", "Update");

	Params::AMorningActivityManager_Update_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.MorningActivityManager.HideCompanions
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AMorningActivityManager::HideCompanions()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MorningActivityManager", "HideCompanions");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.NPCBase
// (Actor, Pawn)

class UClass* ANPCBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NPCBase");

	return Clss;
}


// NPCBase ChernobylGame.Default__NPCBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ANPCBase* ANPCBase::GetDefaultObj()
{
	static class ANPCBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ANPCBase*>(ANPCBase::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.OverheatingFlashlight
// (SceneComponent)

class UClass* UOverheatingFlashlight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OverheatingFlashlight");

	return Clss;
}


// OverheatingFlashlight ChernobylGame.Default__OverheatingFlashlight
// (Public, ClassDefaultObject, ArchetypeObject)

class UOverheatingFlashlight* UOverheatingFlashlight::GetDefaultObj()
{
	static class UOverheatingFlashlight* Default = nullptr;

	if (!Default)
		Default = static_cast<UOverheatingFlashlight*>(UOverheatingFlashlight::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.OverheatingFlashlight.UpdateWaterCausticsFlashLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UOverheatingFlashlight::UpdateWaterCausticsFlashLight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "UpdateWaterCausticsFlashLight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.OverheatingFlashlight.ToggleTurnedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverheatingFlashlight::ToggleTurnedOn(bool Force)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "ToggleTurnedOn");

	Params::UOverheatingFlashlight_ToggleTurnedOn_Params Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.OverheatingFlashlight.SetTurnedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               On                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverheatingFlashlight::SetTurnedOn(bool On, bool Force)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "SetTurnedOn");

	Params::UOverheatingFlashlight_SetTurnedOn_Params Parms{};

	Parms.On = On;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.OverheatingFlashlight.OverheatingFlashlightEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UOverheatingFlashlight*      Object                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverheatingFlashlight::OverheatingFlashlightEvent__DelegateSignature(class UOverheatingFlashlight* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "OverheatingFlashlightEvent__DelegateSignature");

	Params::UOverheatingFlashlight_OverheatingFlashlightEvent__DelegateSignature_Params Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.OverheatingFlashlight.IsTurnedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOverheatingFlashlight::IsTurnedOn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "IsTurnedOn");

	Params::UOverheatingFlashlight_IsTurnedOn_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.OverheatingFlashlight.FlashlightSetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InIntensity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverheatingFlashlight::FlashlightSetIntensity(float InIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OverheatingFlashlight", "FlashlightSetIntensity");

	Params::UOverheatingFlashlight_FlashlightSetIntensity_Params Parms{};

	Parms.InIntensity = InIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PassiveDialogueActions
// (None)

class UClass* UPassiveDialogueActions::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PassiveDialogueActions");

	return Clss;
}


// PassiveDialogueActions ChernobylGame.Default__PassiveDialogueActions
// (Public, ClassDefaultObject, ArchetypeObject)

class UPassiveDialogueActions* UPassiveDialogueActions::GetDefaultObj()
{
	static class UPassiveDialogueActions* Default = nullptr;

	if (!Default)
		Default = static_cast<UPassiveDialogueActions*>(UPassiveDialogueActions::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PassiveDialogueActions.Update
// (Final, Native, Public)
// Parameters:

void UPassiveDialogueActions::Update()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "Update");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PassiveDialogueActions.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPassiveDialogueActions::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PassiveDialogueActions.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPassiveDialogueActions::Play()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "Play");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PassiveDialogueActions.IsDislikedBuildEntityInBase
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::IsDislikedBuildEntityInBase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "IsDislikedBuildEntityInBase");

	Params::UPassiveDialogueActions_IsDislikedBuildEntityInBase_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.IsCompanionInConflict
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::IsCompanionInConflict()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "IsCompanionInConflict");

	Params::UPassiveDialogueActions_IsCompanionInConflict_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.IsCompanionHurt
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::IsCompanionHurt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "IsCompanionHurt");

	Params::UPassiveDialogueActions_IsCompanionHurt_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.HasPlayerHaveLowPsyche
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::HasPlayerHaveLowPsyche()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "HasPlayerHaveLowPsyche");

	Params::UPassiveDialogueActions_HasPlayerHaveLowPsyche_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.HasPlayerDoneTraining
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::HasPlayerDoneTraining()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "HasPlayerDoneTraining");

	Params::UPassiveDialogueActions_HasPlayerDoneTraining_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.HasCompanionLowMorale
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPassiveDialogueInfo        ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPassiveDialogueInfo UPassiveDialogueActions::HasCompanionLowMorale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "HasCompanionLowMorale");

	Params::UPassiveDialogueActions_HasCompanionLowMorale_Params Parms{};


	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.GetNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACGNPC*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACGNPC* UPassiveDialogueActions::GetNPC()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "GetNPC");

	Params::UPassiveDialogueActions_GetNPC_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PassiveDialogueActions.DialogueStepComplited
// (Final, Native, Private)
// Parameters:

void UPassiveDialogueActions::DialogueStepComplited()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PassiveDialogueActions", "DialogueStepComplited");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PdaInput
// (None)

class UClass* IPdaInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PdaInput");

	return Clss;
}


// PdaInput ChernobylGame.Default__PdaInput
// (Public, ClassDefaultObject, ArchetypeObject)

class IPdaInput* IPdaInput::GetDefaultObj()
{
	static class IPdaInput* Default = nullptr;

	if (!Default)
		Default = static_cast<IPdaInput*>(IPdaInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PdaInput.SwitchApp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                              InAppIndx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::SwitchApp(int32 InAppIndx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "SwitchApp");

	Params::IPdaInput_SwitchApp_Params Parms{};

	Parms.InAppIndx = InAppIndx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.OpenMap
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::OpenMap()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "OpenMap");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.OpenApp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                              InAppIndx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::OpenApp(int32 InAppIndx)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "OpenApp");

	Params::IPdaInput_OpenApp_Params Parms{};

	Parms.InAppIndx = InAppIndx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputZoomUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputZoomUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputZoomUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputZoomDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputZoomDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputZoomDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputUpDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::InputUpDown(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputUpDown");

	Params::IPdaInput_InputUpDown_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputUIAccept
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputUIAccept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputUIAccept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRUpDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::InputRUpDown(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRUpDown");

	Params::IPdaInput_InputRUpDown_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRLeftRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::InputRLeftRight(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRLeftRight");

	Params::IPdaInput_InputRLeftRight_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRightStick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRightStick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRightStick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputRDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputRDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputRDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputR2
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputR2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputR2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputR1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputR1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputR1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse8
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse8()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse8");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse7
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse7()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse7");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse6
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse6()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse6");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse5
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse5()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse5");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse4
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse3
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse2
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputQuickUse1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputQuickUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputQuickUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputLeftStick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputLeftStick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputLeftStick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputLeftRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPdaInput::InputLeftRight(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputLeftRight");

	Params::IPdaInput_InputLeftRight_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputL2
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputL2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputL2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputL1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputL1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputL1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputForceLeave
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputForceLeave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputForceLeave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceUpReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceUpReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceUpReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceRightReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceRightReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceRightReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceLeftReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceLeftReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceLeftReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceDownReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceDownReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceDownReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputFaceDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputFaceDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputFaceDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputDPadUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputDPadUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputDPadUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputDPadRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputDPadRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputDPadRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputDPadLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputDPadLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputDPadLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputDPadDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputDPadDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputDPadDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputClose
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.InputAssign
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::InputAssign()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "InputAssign");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PdaInput.ForceDropItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IPdaInput::ForceDropItem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PdaInput", "ForceDropItem");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PickableObject
// (None)

class UClass* IPickableObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PickableObject");

	return Clss;
}


// PickableObject ChernobylGame.Default__PickableObject
// (Public, ClassDefaultObject, ArchetypeObject)

class IPickableObject* IPickableObject::GetDefaultObj()
{
	static class IPickableObject* Default = nullptr;

	if (!Default)
		Default = static_cast<IPickableObject*>(IPickableObject::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PickableObject.SetItemFromDistributor
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void IPickableObject::SetItemFromDistributor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PickableObject", "SetItemFromDistributor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PickableObject.SetItemAndAmount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EResourceType           Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amount                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                 SM                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseAmountValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPickableObject::SetItemAndAmount(enum class EResourceType Type, float Amount, class UStaticMesh* SM, float BaseAmountValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PickableObject", "SetItemAndAmount");

	Params::IPickableObject_SetItemAndAmount_Params Parms{};

	Parms.Type = Type;
	Parms.Amount = Amount;
	Parms.SM = SM;
	Parms.BaseAmountValue = BaseAmountValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PickableObject.GetItemFromDistributor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IPickableObject::GetItemFromDistributor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PickableObject", "GetItemFromDistributor");

	Params::IPickableObject_GetItemFromDistributor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.PlayDialogueCustomPose
// (None)

class UClass* UPlayDialogueCustomPose::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayDialogueCustomPose");

	return Clss;
}


// PlayDialogueCustomPose ChernobylGame.Default__PlayDialogueCustomPose
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayDialogueCustomPose* UPlayDialogueCustomPose::GetDefaultObj()
{
	static class UPlayDialogueCustomPose* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayDialogueCustomPose*>(UPlayDialogueCustomPose::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PlayDialogueCustomPose.PlayDialogueCustomPose
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     InWorldContextObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCGCustomDialogueAction>InCustomDialogueActionArray                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              InInterpolationLength                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayDialogueCustomPose*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayDialogueCustomPose* UPlayDialogueCustomPose::PlayDialogueCustomPose(class UObject* InWorldContextObject, TArray<struct FCGCustomDialogueAction>& InCustomDialogueActionArray, float InInterpolationLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayDialogueCustomPose", "PlayDialogueCustomPose");

	Params::UPlayDialogueCustomPose_PlayDialogueCustomPose_Params Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InCustomDialogueActionArray = InCustomDialogueActionArray;
	Parms.InInterpolationLength = InInterpolationLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlayDialogueCustomPose.Finish
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPlayDialogueCustomPose::Finish()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayDialogueCustomPose", "Finish");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PlayQuickTimeEventNode
// (None)

class UClass* UPlayQuickTimeEventNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayQuickTimeEventNode");

	return Clss;
}


// PlayQuickTimeEventNode ChernobylGame.Default__PlayQuickTimeEventNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayQuickTimeEventNode* UPlayQuickTimeEventNode::GetDefaultObj()
{
	static class UPlayQuickTimeEventNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayQuickTimeEventNode*>(UPlayQuickTimeEventNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PlayQuickTimeEventNode.Update
// (Final, Native, Private)
// Parameters:
// float                              Progress                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayQuickTimeEventNode::Update(float Progress)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "Update");

	Params::UPlayQuickTimeEventNode_Update_Params Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PlayQuickTimeEventNode.PlayQuickTimeEventRaw
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuickTimeEventData         QuickTimeEvent                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayQuickTimeEventNode*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayQuickTimeEventNode* UPlayQuickTimeEventNode::PlayQuickTimeEventRaw(class UObject* WorldContextObject, struct FQuickTimeEventData& QuickTimeEvent, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "PlayQuickTimeEventRaw");

	Params::UPlayQuickTimeEventNode_PlayQuickTimeEventRaw_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.QuickTimeEvent = QuickTimeEvent;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlayQuickTimeEventNode.PlayQuickTimeEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UQuickTimeEvent*             QuickTimeEvent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayQuickTimeEventNode*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayQuickTimeEventNode* UPlayQuickTimeEventNode::PlayQuickTimeEvent(class UObject* WorldContextObject, class UQuickTimeEvent* QuickTimeEvent, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "PlayQuickTimeEvent");

	Params::UPlayQuickTimeEventNode_PlayQuickTimeEvent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.QuickTimeEvent = QuickTimeEvent;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlayQuickTimeEventNode.GetCurrentPlatformBrush_Raw
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                 OutBrush                                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FQuickTimeEventData         EventData                                                        (Parm, NativeAccessSpecifierPublic)

void UPlayQuickTimeEventNode::GetCurrentPlatformBrush_Raw(struct FSlateBrush* OutBrush, const struct FQuickTimeEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "GetCurrentPlatformBrush_Raw");

	Params::UPlayQuickTimeEventNode_GetCurrentPlatformBrush_Raw_Params Parms{};

	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutBrush != nullptr)
		*OutBrush = std::move(Parms.OutBrush);

}


// Function ChernobylGame.PlayQuickTimeEventNode.Failed
// (Final, Native, Private)
// Parameters:

void UPlayQuickTimeEventNode::Failed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "Failed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PlayQuickTimeEventNode.Completed
// (Final, Native, Private)
// Parameters:

void UPlayQuickTimeEventNode::Completed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayQuickTimeEventNode", "Completed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PlaySoundWithSubtitlesAsyncNode
// (None)

class UClass* UPlaySoundWithSubtitlesAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlaySoundWithSubtitlesAsyncNode");

	return Clss;
}


// PlaySoundWithSubtitlesAsyncNode ChernobylGame.Default__PlaySoundWithSubtitlesAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlaySoundWithSubtitlesAsyncNode* UPlaySoundWithSubtitlesAsyncNode::GetDefaultObj()
{
	static class UPlaySoundWithSubtitlesAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlaySoundWithSubtitlesAsyncNode*>(UPlaySoundWithSubtitlesAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PlaySoundWithSubtitlesAsyncNode.ShowSubtitle
// (Final, Native, Private)
// Parameters:
// class USubtitlesManager*           SubtitlesManager                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Subtitle                                                         (Parm, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaySoundWithSubtitlesAsyncNode::ShowSubtitle(class USubtitlesManager* SubtitlesManager, class FText Subtitle, float TimeShown)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlaySoundWithSubtitlesAsyncNode", "ShowSubtitle");

	Params::UPlaySoundWithSubtitlesAsyncNode_ShowSubtitle_Params Parms{};

	Parms.SubtitlesManager = SubtitlesManager;
	Parms.Subtitle = Subtitle;
	Parms.TimeShown = TimeShown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.PlaySoundWithSubtitlesAsyncNode.PlaySoundAttachedToComponentWithSubtitlesFromAudio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ActorName                                                        (Parm, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsWhisper                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlaySoundWithSubtitlesAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlaySoundWithSubtitlesAsyncNode* UPlaySoundWithSubtitlesAsyncNode::PlaySoundAttachedToComponentWithSubtitlesFromAudio(class UObject* WorldContextObject, class USoundWave* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, class FText ActorName, const struct FLinearColor& ActorColor, bool IsWhisper, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, class USoundConcurrency* ConcurrencySettings, class USoundAttenuation* AttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlaySoundWithSubtitlesAsyncNode", "PlaySoundAttachedToComponentWithSubtitlesFromAudio");

	Params::UPlaySoundWithSubtitlesAsyncNode_PlaySoundAttachedToComponentWithSubtitlesFromAudio_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.ActorName = ActorName;
	Parms.ActorColor = ActorColor;
	Parms.IsWhisper = IsWhisper;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.AttenuationSettings = AttenuationSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlaySoundWithSubtitlesAsyncNode.PlaySoundAtLocationWithSubtitlesFromAudio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ActorName                                                        (Parm, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsWhisper                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlaySoundWithSubtitlesAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlaySoundWithSubtitlesAsyncNode* UPlaySoundWithSubtitlesAsyncNode::PlaySoundAtLocationWithSubtitlesFromAudio(class UObject* WorldContextObject, class USoundWave* Sound, class FText ActorName, const struct FLinearColor& ActorColor, const struct FVector& Location, bool IsWhisper, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, class USoundConcurrency* ConcurrencySettings, class USoundAttenuation* AttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlaySoundWithSubtitlesAsyncNode", "PlaySoundAtLocationWithSubtitlesFromAudio");

	Params::UPlaySoundWithSubtitlesAsyncNode_PlaySoundAtLocationWithSubtitlesFromAudio_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.ActorName = ActorName;
	Parms.ActorColor = ActorColor;
	Parms.Location = Location;
	Parms.IsWhisper = IsWhisper;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.AttenuationSettings = AttenuationSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlaySoundWithSubtitlesAsyncNode.PlaySound2DWithSubtitlesFromAudio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ActorName                                                        (Parm, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsWhisper                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlaySoundWithSubtitlesAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlaySoundWithSubtitlesAsyncNode* UPlaySoundWithSubtitlesAsyncNode::PlaySound2DWithSubtitlesFromAudio(class UObject* WorldContextObject, class USoundWave* Sound, class FText ActorName, const struct FLinearColor& ActorColor, bool IsWhisper, float VolumeMultiplier, float PitchMultiplier, class USoundConcurrency* ConcurrencySettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlaySoundWithSubtitlesAsyncNode", "PlaySound2DWithSubtitlesFromAudio");

	Params::UPlaySoundWithSubtitlesAsyncNode_PlaySound2DWithSubtitlesFromAudio_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.ActorName = ActorName;
	Parms.ActorColor = ActorColor;
	Parms.IsWhisper = IsWhisper;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.ConcurrencySettings = ConcurrencySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.PlaySoundWithSubtitlesAsyncNode.ClearNativeEventsBoundToAudioFinished
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*             AudioComponent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaySoundWithSubtitlesAsyncNode::ClearNativeEventsBoundToAudioFinished(class UAudioComponent* AudioComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlaySoundWithSubtitlesAsyncNode", "ClearNativeEventsBoundToAudioFinished");

	Params::UPlaySoundWithSubtitlesAsyncNode_ClearNativeEventsBoundToAudioFinished_Params Parms{};

	Parms.AudioComponent = AudioComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.PoisonDebuff
// (None)

class UClass* UPoisonDebuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoisonDebuff");

	return Clss;
}


// PoisonDebuff ChernobylGame.Default__PoisonDebuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UPoisonDebuff* UPoisonDebuff::GetDefaultObj()
{
	static class UPoisonDebuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UPoisonDebuff*>(UPoisonDebuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.PrepassQuestActor
// (Actor)

class UClass* APrepassQuestActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrepassQuestActor");

	return Clss;
}


// PrepassQuestActor ChernobylGame.Default__PrepassQuestActor
// (Public, ClassDefaultObject, ArchetypeObject)

class APrepassQuestActor* APrepassQuestActor::GetDefaultObj()
{
	static class APrepassQuestActor* Default = nullptr;

	if (!Default)
		Default = static_cast<APrepassQuestActor*>(APrepassQuestActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.PrepassQuestActor.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void APrepassQuestActor::Update()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrepassQuestActor", "Update");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.QteUIBase
// (None)

class UClass* UQteUIBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QteUIBase");

	return Clss;
}


// QteUIBase ChernobylGame.Default__QteUIBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UQteUIBase* UQteUIBase::GetDefaultObj()
{
	static class UQteUIBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UQteUIBase*>(UQteUIBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.QteUIBase.UpdateProgress
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              ProgressPercent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQteUIBase::UpdateProgress(float ProgressPercent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QteUIBase", "UpdateProgress");

	Params::UQteUIBase_UpdateProgress_Params Parms{};

	Parms.ProgressPercent = ProgressPercent;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.QteUIBase.Finished
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void UQteUIBase::Finished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QteUIBase", "Finished");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.QuickMenuComponent
// (None)

class UClass* UQuickMenuComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuickMenuComponent");

	return Clss;
}


// QuickMenuComponent ChernobylGame.Default__QuickMenuComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuickMenuComponent* UQuickMenuComponent::GetDefaultObj()
{
	static class UQuickMenuComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuickMenuComponent*>(UQuickMenuComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.QuickMenuComponent.Use
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EQuickMenuSlot          Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuickMenuComponent::Use(enum class EQuickMenuSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "Use");

	Params::UQuickMenuComponent_Use_Params Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.SetQuickUseScrollEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsEnabled                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickMenuComponent::SetQuickUseScrollEnabled(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "SetQuickUseScrollEnabled");

	Params::UQuickMenuComponent_SetQuickUseScrollEnabled_Params Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickMenuComponent.SetQMenuActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewActive                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickMenuComponent::SetQMenuActive(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "SetQMenuActive");

	Params::UQuickMenuComponent_SetQMenuActive_Params Parms{};

	Parms.bNewActive = bNewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickMenuComponent.SetLeaveDuplicates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EQuickMenuSlot          Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuickMenuComponent::SetLeaveDuplicates(enum class EQuickMenuSlot Slot, class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "SetLeaveDuplicates");

	Params::UQuickMenuComponent_SetLeaveDuplicates_Params Parms{};

	Parms.Slot = Slot;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.SetFirstFreeSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuickMenuComponent::SetFirstFreeSlot(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "SetFirstFreeSlot");

	Params::UQuickMenuComponent_SetFirstFreeSlot_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.Set
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EQuickMenuSlot          Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuickMenuComponent::Set(enum class EQuickMenuSlot Slot, class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "Set");

	Params::UQuickMenuComponent_Set_Params Parms{};

	Parms.Slot = Slot;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.ResetSelectedSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuickMenuComponent::ResetSelectedSlot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "ResetSelectedSlot");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickMenuComponent.RemoveDuplicates
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuickMenuComponent::RemoveDuplicates()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "RemoveDuplicates");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickMenuComponent.GetQuickUseScrollEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuickMenuComponent::GetQuickUseScrollEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "GetQuickUseScrollEnabled");

	Params::UQuickMenuComponent_GetQuickUseScrollEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.GetFirstSlotWithName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Name                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EQuickMenuSlot          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EQuickMenuSlot UQuickMenuComponent::GetFirstSlotWithName(class FName Name, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "GetFirstSlotWithName");

	Params::UQuickMenuComponent_GetFirstSlotWithName_Params Parms{};

	Parms.Name = Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.Get
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EQuickMenuSlot          Slot                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UQuickMenuComponent::Get(enum class EQuickMenuSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "Get");

	Params::UQuickMenuComponent_Get_Params Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickMenuComponent.EquipItemFromInventory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInventoryEntry             Entry                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuickMenuComponent::EquipItemFromInventory(struct FInventoryEntry& Entry)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "EquipItemFromInventory");

	Params::UQuickMenuComponent_EquipItemFromInventory_Params Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickMenuComponent.ClearAllSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UQuickMenuComponent::ClearAllSlots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickMenuComponent", "ClearAllSlots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.QuickTimeEvent
// (None)

class UClass* UQuickTimeEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuickTimeEvent");

	return Clss;
}


// QuickTimeEvent ChernobylGame.Default__QuickTimeEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UQuickTimeEvent* UQuickTimeEvent::GetDefaultObj()
{
	static class UQuickTimeEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UQuickTimeEvent*>(UQuickTimeEvent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.QuickTimeEvent.UnbindInputs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::UnbindInputs(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "UnbindInputs");

	Params::UQuickTimeEvent_UnbindInputs_Params Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.StickRotationVertical
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::StickRotationVertical(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "StickRotationVertical");

	Params::UQuickTimeEvent_StickRotationVertical_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.StickRotationHorizontal
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::StickRotationHorizontal(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "StickRotationHorizontal");

	Params::UQuickTimeEvent_StickRotationHorizontal_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.QuickTimeEvent.QTEUpdateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                              PercentCompleted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::QTEUpdateDelegate__DelegateSignature(float PercentCompleted)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "QTEUpdateDelegate__DelegateSignature");

	Params::UQuickTimeEvent_QTEUpdateDelegate__DelegateSignature_Params Parms{};

	Parms.PercentCompleted = PercentCompleted;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction ChernobylGame.QuickTimeEvent.QTEFinishedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:

void UQuickTimeEvent::QTEFinishedDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "QTEFinishedDelegate__DelegateSignature");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.QuickTimeEvent.OnWrongButtonPressed
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::OnWrongButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "OnWrongButtonPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.OnTimeOut
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::OnTimeOut()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "OnTimeOut");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.OnFail
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::OnFail()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "OnFail");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.HoldButtonTick
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::HoldButtonTick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "HoldButtonTick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.HoldButtonStop
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::HoldButtonStop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "HoldButtonStop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.HoldButtonStart
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::HoldButtonStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "HoldButtonStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.GetRemainingTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UQuickTimeEvent::GetRemainingTimePercent(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "GetRemainingTimePercent");

	Params::UQuickTimeEvent_GetRemainingTimePercent_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickTimeEvent.GetRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UQuickTimeEvent::GetRemainingTime(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "GetRemainingTime");

	Params::UQuickTimeEvent_GetRemainingTime_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.QuickTimeEvent.GetCurrentPlatformBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                 OutBrush                                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuickTimeEvent::GetCurrentPlatformBrush(struct FSlateBrush* OutBrush)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "GetCurrentPlatformBrush");

	Params::UQuickTimeEvent_GetCurrentPlatformBrush_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutBrush != nullptr)
		*OutBrush = std::move(Parms.OutBrush);

}


// Function ChernobylGame.QuickTimeEvent.ButtonPressed
// (Final, Native, Private)
// Parameters:

void UQuickTimeEvent::ButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "ButtonPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.BindInputs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::BindInputs(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "BindInputs");

	Params::UQuickTimeEvent_BindInputs_Params Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.AxisPressed
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::AxisPressed(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "AxisPressed");

	Params::UQuickTimeEvent_AxisPressed_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickTimeEvent.AxisHeld
// (Final, Native, Private)
// Parameters:
// float                              AxisValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEvent::AxisHeld(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickTimeEvent", "AxisHeld");

	Params::UQuickTimeEvent_AxisHeld_Params Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.QuickUseUI
// (None)

class UClass* IQuickUseUI::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("QuickUseUI");

	return Clss;
}


// QuickUseUI ChernobylGame.Default__QuickUseUI
// (Public, ClassDefaultObject, ArchetypeObject)

class IQuickUseUI* IQuickUseUI::GetDefaultObj()
{
	static class IQuickUseUI* Default = nullptr;

	if (!Default)
		Default = static_cast<IQuickUseUI*>(IQuickUseUI::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.QuickUseUI.ShowWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::ShowWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "ShowWidget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QUse4
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QUse4()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QUse4");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QUse3
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QUse3()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QUse3");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QUse2
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QUse2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QUse2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QUse1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QUse1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QUse1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QScrollUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QScrollUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QScrollUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QScrollDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QScrollDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QScrollDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QInputEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QInputEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QInputEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QInputAssign
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QInputAssign()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QInputAssign");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QEnableScroll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QEnableScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QEnableScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QDisableScroll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QDisableScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QDisableScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QDeclineScroll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QDeclineScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QDeclineScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.QAcceptScroll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::QAcceptScroll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "QAcceptScroll");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.HideWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::HideWidget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "HideWidget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.Enable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::Enable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "Enable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.QuickUseUI.Disable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IQuickUseUI::Disable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("QuickUseUI", "Disable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.RadarAfterImage
// (Actor)

class UClass* ARadarAfterImage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadarAfterImage");

	return Clss;
}


// RadarAfterImage ChernobylGame.Default__RadarAfterImage
// (Public, ClassDefaultObject, ArchetypeObject)

class ARadarAfterImage* ARadarAfterImage::GetDefaultObj()
{
	static class ARadarAfterImage* Default = nullptr;

	if (!Default)
		Default = static_cast<ARadarAfterImage*>(ARadarAfterImage::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.RadarAfterImage.SpawnParticleEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*    ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* ARadarAfterImage::SpawnParticleEffect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "SpawnParticleEffect");

	Params::ARadarAfterImage_SpawnParticleEffect_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.RadarAfterImage.RemoveOutline
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ARadarAfterImage::RemoveOutline()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "RemoveOutline");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.RadarAfterImage.GetHeldActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARadarAfterImage::GetHeldActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "GetHeldActor");

	Params::ARadarAfterImage_GetHeldActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.RadarAfterImage.GetDynamicMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ARadarAfterImage::GetDynamicMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "GetDynamicMaterial");

	Params::ARadarAfterImage_GetDynamicMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.RadarAfterImage.GetCurrentLifetime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARadarAfterImage::GetCurrentLifetime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "GetCurrentLifetime");

	Params::ARadarAfterImage_GetCurrentLifetime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.RadarAfterImage.DestroyParticleEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ARadarAfterImage::DestroyParticleEffect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarAfterImage", "DestroyParticleEffect");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.RadarHighlightDataAsset
// (None)

class UClass* URadarHighlightDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadarHighlightDataAsset");

	return Clss;
}


// RadarHighlightDataAsset ChernobylGame.Default__RadarHighlightDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class URadarHighlightDataAsset* URadarHighlightDataAsset::GetDefaultObj()
{
	static class URadarHighlightDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<URadarHighlightDataAsset*>(URadarHighlightDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.RadarSphere
// (Actor)

class UClass* ARadarSphere::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadarSphere");

	return Clss;
}


// RadarSphere ChernobylGame.Default__RadarSphere
// (Public, ClassDefaultObject, ArchetypeObject)

class ARadarSphere* ARadarSphere::GetDefaultObj()
{
	static class ARadarSphere* Default = nullptr;

	if (!Default)
		Default = static_cast<ARadarSphere*>(ARadarSphere::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.RadarSphere.UpdateHighlightsToANewType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARadarSphere::UpdateHighlightsToANewType(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "UpdateHighlightsToANewType");

	Params::ARadarSphere_UpdateHighlightsToANewType_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.RadarSphere.SpawnRadarWave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARadarSphere*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARadarSphere* ARadarSphere::SpawnRadarWave(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "SpawnRadarWave");

	Params::ARadarSphere_SpawnRadarWave_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.RadarSphere.RemoveHightlightFromActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutCurrentLifetime                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARadarSphere::RemoveHightlightFromActor(class UObject* WorldContextObject, class AActor* Actor, float* OutCurrentLifetime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "RemoveHightlightFromActor");

	Params::ARadarSphere_RemoveHightlightFromActor_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutCurrentLifetime != nullptr)
		*OutCurrentLifetime = Parms.OutCurrentLifetime;

	return Parms.ReturnValue;

}


// DelegateFunction ChernobylGame.RadarSphere.RadarSphereDestroyedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARadarSphere*                Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARadarSphere::RadarSphereDestroyedDelegate__DelegateSignature(class ARadarSphere* Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "RadarSphereDestroyedDelegate__DelegateSignature");

	Params::ARadarSphere_RadarSphereDestroyedDelegate__DelegateSignature_Params Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction ChernobylGame.RadarSphere.RadarImageCreatedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARadarSphere*                Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARadarAfterImage*            RadarImage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARadarSphere::RadarImageCreatedDelegate__DelegateSignature(class ARadarSphere* Target, class ARadarAfterImage* RadarImage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "RadarImageCreatedDelegate__DelegateSignature");

	Params::ARadarSphere_RadarImageCreatedDelegate__DelegateSignature_Params Parms{};

	Parms.Target = Target;
	Parms.RadarImage = RadarImage;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction ChernobylGame.RadarSphere.RadarDetectionDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARadarSphere*                Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ActorFound                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARadarSphere::RadarDetectionDelegate__DelegateSignature(class ARadarSphere* Target, class AActor* ActorFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "RadarDetectionDelegate__DelegateSignature");

	Params::ARadarSphere_RadarDetectionDelegate__DelegateSignature_Params Parms{};

	Parms.Target = Target;
	Parms.ActorFound = ActorFound;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.RadarSphere.CreateHighlightForActorStartingAtDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartingDuration                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UseForce                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARadarAfterImage*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARadarAfterImage* ARadarSphere::CreateHighlightForActorStartingAtDuration(class UObject* WorldContextObject, class AActor* Actor, float StartingDuration, bool UseForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadarSphere", "CreateHighlightForActorStartingAtDuration");

	Params::ARadarSphere_CreateHighlightForActorStartingAtDuration_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;
	Parms.StartingDuration = StartingDuration;
	Parms.UseForce = UseForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.RadiationBuff
// (None)

class UClass* URadiationBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadiationBuff");

	return Clss;
}


// RadiationBuff ChernobylGame.Default__RadiationBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class URadiationBuff* URadiationBuff::GetDefaultObj()
{
	static class URadiationBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<URadiationBuff*>(URadiationBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.ReportInput
// (None)

class UClass* IReportInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReportInput");

	return Clss;
}


// ReportInput ChernobylGame.Default__ReportInput
// (Public, ClassDefaultObject, ArchetypeObject)

class IReportInput* IReportInput::GetDefaultObj()
{
	static class IReportInput* Default = nullptr;

	if (!Default)
		Default = static_cast<IReportInput*>(IReportInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ReportInput.InputUpDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IReportInput::InputUpDown(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputUpDown");

	Params::IReportInput_InputUpDown_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputRightStick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputRightStick()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputRightStick");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputR2Release
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputR2Release()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputR2Release");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputR2
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputR2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputR2");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputR1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputR1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputR1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputLeftRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                              Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IReportInput::InputLeftRight(float Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputLeftRight");

	Params::IReportInput_InputLeftRight_Params Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputL1
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputL1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputL1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputFaceUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputFaceUp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputFaceUp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputFaceDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputFaceDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputFaceDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputDPadRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputDPadRight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputDPadRight");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputDPadLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputDPadLeft()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputDPadLeft");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputDown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputDown");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputClose
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputClose()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputClose");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputBack
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputBack()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputBack");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputAcceptReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputAcceptReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputAcceptReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ReportInput.InputAccept
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IReportInput::InputAccept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ReportInput", "InputAccept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.ResearchText
// (None)

class UClass* UResearchText::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ResearchText");

	return Clss;
}


// ResearchText ChernobylGame.Default__ResearchText
// (Public, ClassDefaultObject, ArchetypeObject)

class UResearchText* UResearchText::GetDefaultObj()
{
	static class UResearchText* Default = nullptr;

	if (!Default)
		Default = static_cast<UResearchText*>(UResearchText::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ResearchText.WordSelectedVisualChange
// (Final, Native, Private)
// Parameters:
// class UBorder*                     Border                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UResearchText::WordSelectedVisualChange(class UBorder* Border)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ResearchText", "WordSelectedVisualChange");

	Params::UResearchText_WordSelectedVisualChange_Params Parms{};

	Parms.Border = Border;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ResearchText.OnSelected
// (Final, Native, Private)
// Parameters:
// class USelectableTextBase*         Caller                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Correct                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UResearchText::OnSelected(class USelectableTextBase* Caller, bool Correct)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ResearchText", "OnSelected");

	Params::UResearchText_OnSelected_Params Parms{};

	Parms.Caller = Caller;
	Parms.Correct = Correct;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.ResearchText.FinishTextSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InPlayerChoosedCorrectly                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UResearchText::FinishTextSelection(bool InPlayerChoosedCorrectly)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ResearchText", "FinishTextSelection");

	Params::UResearchText_FinishTextSelection_Params Parms{};

	Parms.InPlayerChoosedCorrectly = InPlayerChoosedCorrectly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.SaveableObject
// (None)

class UClass* ISaveableObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SaveableObject");

	return Clss;
}


// SaveableObject ChernobylGame.Default__SaveableObject
// (Public, ClassDefaultObject, ArchetypeObject)

class ISaveableObject* ISaveableObject::GetDefaultObj()
{
	static class ISaveableObject* Default = nullptr;

	if (!Default)
		Default = static_cast<ISaveableObject*>(ISaveableObject::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SaveableObject.ShouldUpdateOverlapsOnLoad
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISaveableObject::ShouldUpdateOverlapsOnLoad()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveableObject", "ShouldUpdateOverlapsOnLoad");

	Params::ISaveableObject_ShouldUpdateOverlapsOnLoad_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SaveableObject.PrepareDataForSave
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ISaveableObject::PrepareDataForSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveableObject", "PrepareDataForSave");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.SaveableObject.LoadingFinished
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ISaveableObject::LoadingFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveableObject", "LoadingFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.SaveableObject.HasObjectsToSave
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISaveableObject::HasObjectsToSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveableObject", "HasObjectsToSave");

	Params::ISaveableObject_HasObjectsToSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SaveableObject.GetObjectsToSave
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TArray<class UObject*>             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> ISaveableObject::GetObjectsToSave()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveableObject", "GetObjectsToSave");

	Params::ISaveableObject_GetObjectsToSave_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.SaveGameActor
// (Actor)

class UClass* ASaveGameActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SaveGameActor");

	return Clss;
}


// SaveGameActor ChernobylGame.Default__SaveGameActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASaveGameActor* ASaveGameActor::GetDefaultObj()
{
	static class ASaveGameActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASaveGameActor*>(ASaveGameActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SaveGameActor.SaveGameAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FDelegateProperty_                 Callback                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASaveGameActor::SaveGameAsync(FDelegateProperty_ Callback, const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveGameActor", "SaveGameAsync");

	Params::ASaveGameActor_SaveGameAsync_Params Parms{};

	Parms.Callback = Callback;
	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SaveGameActor.SaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASaveGameActor::SaveGame(const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveGameActor", "SaveGame");

	Params::ASaveGameActor_SaveGame_Params Parms{};

	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SaveGameActor.LoadGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASaveGameActor::LoadGame(const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SaveGameActor", "LoadGame");

	Params::ASaveGameActor_LoadGame_Params Parms{};

	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.SaveGameFormat
// (None)

class UClass* USaveGameFormat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SaveGameFormat");

	return Clss;
}


// SaveGameFormat ChernobylGame.Default__SaveGameFormat
// (Public, ClassDefaultObject, ArchetypeObject)

class USaveGameFormat* USaveGameFormat::GetDefaultObj()
{
	static class USaveGameFormat* Default = nullptr;

	if (!Default)
		Default = static_cast<USaveGameFormat*>(USaveGameFormat::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.ScannableObject
// (None)

class UClass* IScannableObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ScannableObject");

	return Clss;
}


// ScannableObject ChernobylGame.Default__ScannableObject
// (Public, ClassDefaultObject, ArchetypeObject)

class IScannableObject* IScannableObject::GetDefaultObj()
{
	static class IScannableObject* Default = nullptr;

	if (!Default)
		Default = static_cast<IScannableObject*>(IScannableObject::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ScannableObject.ShouldIgnoreScan
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IScannableObject::ShouldIgnoreScan()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "ShouldIgnoreScan");

	Params::IScannableObject_ShouldIgnoreScan_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ScannableObject.ShouldBeHightlighted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IScannableObject::ShouldBeHightlighted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "ShouldBeHightlighted");

	Params::IScannableObject_ShouldBeHightlighted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ScannableObject.GetResourceType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// enum class EScannableResourceType  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EScannableResourceType IScannableObject::GetResourceType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "GetResourceType");

	Params::IScannableObject_GetResourceType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ScannableObject.GetMeshesToSkipDuringHighlight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftObjectPtr<class UPrimitiveComponent>>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UPrimitiveComponent>> IScannableObject::GetMeshesToSkipDuringHighlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "GetMeshesToSkipDuringHighlight");

	Params::IScannableObject_GetMeshesToSkipDuringHighlight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ScannableObject.GetForcedMeshesToHighlight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USkeletalMeshComponent*>ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class USkeletalMeshComponent*> IScannableObject::GetForcedMeshesToHighlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "GetForcedMeshesToHighlight");

	Params::IScannableObject_GetForcedMeshesToHighlight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ScannableObject.GetAdditionalActorsToHighlight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> IScannableObject::GetAdditionalActorsToHighlight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ScannableObject", "GetAdditionalActorsToHighlight");

	Params::IScannableObject_GetAdditionalActorsToHighlight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.SceneCaptureActor
// (Actor)

class UClass* ASceneCaptureActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCaptureActor");

	return Clss;
}


// SceneCaptureActor ChernobylGame.Default__SceneCaptureActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASceneCaptureActor* ASceneCaptureActor::GetDefaultObj()
{
	static class ASceneCaptureActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASceneCaptureActor*>(ASceneCaptureActor::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.SelectableTextBase
// (None)

class UClass* USelectableTextBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SelectableTextBase");

	return Clss;
}


// SelectableTextBase ChernobylGame.Default__SelectableTextBase
// (Public, ClassDefaultObject, ArchetypeObject)

class USelectableTextBase* USelectableTextBase::GetDefaultObj()
{
	static class USelectableTextBase* Default = nullptr;

	if (!Default)
		Default = static_cast<USelectableTextBase*>(USelectableTextBase::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SelectableTextBase.PopulateWordGroups
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      InString                                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                      OutWordsMapping                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FWordGroup>          OutGroups                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UTextBlock*>          OutWordsList                                                     (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USelectableTextBase::PopulateWordGroups(const class FString& InString, TArray<uint8>* OutWordsMapping, TArray<struct FWordGroup>* OutGroups, TArray<class UTextBlock*>* OutWordsList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SelectableTextBase", "PopulateWordGroups");

	Params::USelectableTextBase_PopulateWordGroups_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutWordsMapping != nullptr)
		*OutWordsMapping = std::move(Parms.OutWordsMapping);

	if (OutGroups != nullptr)
		*OutGroups = std::move(Parms.OutGroups);

	if (OutWordsList != nullptr)
		*OutWordsList = std::move(Parms.OutWordsList);

}


// Function ChernobylGame.SelectableTextBase.CreateTextBlockWidget
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTextBlock*                  OutTextBlock                                                     (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBorder*                     OutBorder                                                        (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectableTextBase::CreateTextBlockWidget(class FText& InText, class UTextBlock** OutTextBlock, class UBorder** OutBorder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SelectableTextBase", "CreateTextBlockWidget");

	Params::USelectableTextBase_CreateTextBlockWidget_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTextBlock != nullptr)
		*OutTextBlock = Parms.OutTextBlock;

	if (OutBorder != nullptr)
		*OutBorder = Parms.OutBorder;

}


// Function ChernobylGame.SelectableTextBase.BroadcastWordSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InCorrectSelection                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectableTextBase::BroadcastWordSelection(bool InCorrectSelection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SelectableTextBase", "BroadcastWordSelection");

	Params::USelectableTextBase_BroadcastWordSelection_Params Parms{};

	Parms.InCorrectSelection = InCorrectSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.ShadowPatrolActor
// (Actor)

class UClass* AShadowPatrolActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ShadowPatrolActor");

	return Clss;
}


// ShadowPatrolActor ChernobylGame.Default__ShadowPatrolActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AShadowPatrolActor* AShadowPatrolActor::GetDefaultObj()
{
	static class AShadowPatrolActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AShadowPatrolActor*>(AShadowPatrolActor::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.ShadowPatrolActor.GetNextCombinedTeleports
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACGShadowTeleportBase*>ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACGShadowTeleportBase*> AShadowPatrolActor::GetNextCombinedTeleports()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ShadowPatrolActor", "GetNextCombinedTeleports");

	Params::AShadowPatrolActor_GetNextCombinedTeleports_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ShadowPatrolActor.GetNextCombinedPatrols
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APatrolActor*>        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APatrolActor*> AShadowPatrolActor::GetNextCombinedPatrols()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ShadowPatrolActor", "GetNextCombinedPatrols");

	Params::AShadowPatrolActor_GetNextCombinedPatrols_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ShadowPatrolActor.GetClosestTeleportRoute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AShadowPatrolActor::GetClosestTeleportRoute()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ShadowPatrolActor", "GetClosestTeleportRoute");

	Params::AShadowPatrolActor_GetClosestTeleportRoute_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.ShadowPatrolActor.FindNextNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AShadowPatrolActor::FindNextNode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ShadowPatrolActor", "FindNextNode");

	Params::AShadowPatrolActor_FindNextNode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.StaggerBuff
// (None)

class UClass* UStaggerBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaggerBuff");

	return Clss;
}


// StaggerBuff ChernobylGame.Default__StaggerBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UStaggerBuff* UStaggerBuff::GetDefaultObj()
{
	static class UStaggerBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UStaggerBuff*>(UStaggerBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.StaticBuffManager
// (None)

class UClass* UStaticBuffManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaticBuffManager");

	return Clss;
}


// StaticBuffManager ChernobylGame.Default__StaticBuffManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UStaticBuffManager* UStaticBuffManager::GetDefaultObj()
{
	static class UStaticBuffManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UStaticBuffManager*>(UStaticBuffManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.StaticBuffManager.RemoveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EStaticBuff             Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaticBuffManager::RemoveBuff(enum class EStaticBuff Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticBuffManager", "RemoveBuff");

	Params::UStaticBuffManager_RemoveBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.StaticBuffManager.HaveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EStaticBuff             Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaticBuffManager::HaveBuff(enum class EStaticBuff Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticBuffManager", "HaveBuff");

	Params::UStaticBuffManager_HaveBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.StaticBuffManager.AddBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EStaticBuff             Buff                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaticBuffManager::AddBuff(enum class EStaticBuff Buff)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticBuffManager", "AddBuff");

	Params::UStaticBuffManager_AddBuff_Params Parms{};

	Parms.Buff = Buff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.SubtitleEntry
// (None)

class UClass* USubtitleEntry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SubtitleEntry");

	return Clss;
}


// SubtitleEntry ChernobylGame.Default__SubtitleEntry
// (Public, ClassDefaultObject, ArchetypeObject)

class USubtitleEntry* USubtitleEntry::GetDefaultObj()
{
	static class USubtitleEntry* Default = nullptr;

	if (!Default)
		Default = static_cast<USubtitleEntry*>(USubtitleEntry::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SubtitleEntry.SetToRemove
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void USubtitleEntry::SetToRemove()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitleEntry", "SetToRemove");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.SubtitleEntry.ForceRemoveNow
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void USubtitleEntry::ForceRemoveNow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitleEntry", "ForceRemoveNow");



	UObject::ProcessEvent(Func, nullptr);

}


// Class ChernobylGame.SubtitlesManager
// (None)

class UClass* USubtitlesManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SubtitlesManager");

	return Clss;
}


// SubtitlesManager ChernobylGame.Default__SubtitlesManager
// (Public, ClassDefaultObject, ArchetypeObject)

class USubtitlesManager* USubtitlesManager::GetDefaultObj()
{
	static class USubtitlesManager* Default = nullptr;

	if (!Default)
		Default = static_cast<USubtitlesManager*>(USubtitlesManager::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SubtitlesManager.SubtitlesAreInDebugMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesManager::SubtitlesAreInDebugMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "SubtitlesAreInDebugMode");

	Params::USubtitlesManager_SubtitlesAreInDebugMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SubtitlesManager.RemoveWhisperOrSubtitle
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                 Whisper                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesManager::RemoveWhisperOrSubtitle(class UUserWidget* Whisper)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "RemoveWhisperOrSubtitle");

	Params::USubtitlesManager_RemoveWhisperOrSubtitle_Params Parms{};

	Parms.Whisper = Whisper;

	UObject::ProcessEvent(Func, &Parms);

}


// Function ChernobylGame.SubtitlesManager.GetSubtitlesManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubtitlesManager*           ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubtitlesManager* USubtitlesManager::GetSubtitlesManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "GetSubtitlesManager");

	Params::USubtitlesManager_GetSubtitlesManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SubtitlesManager.GetSubtitlesFromSoundWave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USoundWave*                  SoundWave                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSubtitleCueBP>      OutSubtitleCues                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USubtitlesManager::GetSubtitlesFromSoundWave(class USoundWave* SoundWave, TArray<struct FSubtitleCueBP>* OutSubtitleCues)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "GetSubtitlesFromSoundWave");

	Params::USubtitlesManager_GetSubtitlesFromSoundWave_Params Parms{};

	Parms.SoundWave = SoundWave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSubtitleCues != nullptr)
		*OutSubtitleCues = std::move(Parms.OutSubtitleCues);

}


// Function ChernobylGame.SubtitlesManager.AddWhisper
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        WhisperText                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                 ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* USubtitlesManager::AddWhisper(class FText& WhisperText, float TimeShown, const struct FLinearColor& TextColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "AddWhisper");

	Params::USubtitlesManager_AddWhisper_Params Parms{};

	Parms.WhisperText = WhisperText;
	Parms.TimeShown = TimeShown;
	Parms.TextColor = TextColor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.SubtitlesManager.AddSubtitle
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ActorName                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        SubtitleText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubtitleEntry*              ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubtitleEntry* USubtitlesManager::AddSubtitle(class FText& ActorName, class FText& SubtitleText, float TimeShown, const struct FLinearColor& ActorColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "AddSubtitle");

	Params::USubtitlesManager_AddSubtitle_Params Parms{};

	Parms.ActorName = ActorName;
	Parms.SubtitleText = SubtitleText;
	Parms.TimeShown = TimeShown;
	Parms.ActorColor = ActorColor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function ChernobylGame.SubtitlesManager.AddAvatarSubtitle
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                        ActorName                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        SubtitleText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                        ActorId                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeShown                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ActorColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsPlaceholderText                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubtitleEntry*              ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubtitleEntry* USubtitlesManager::AddAvatarSubtitle(class FText& ActorName, class FText& SubtitleText, class FName ActorId, float TimeShown, const struct FLinearColor& ActorColor, bool IsPlaceholderText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubtitlesManager", "AddAvatarSubtitle");

	Params::USubtitlesManager_AddAvatarSubtitle_Params Parms{};

	Parms.ActorName = ActorName;
	Parms.SubtitleText = SubtitleText;
	Parms.ActorId = ActorId;
	Parms.TimeShown = TimeShown;
	Parms.ActorColor = ActorColor;
	Parms.IsPlaceholderText = IsPlaceholderText;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Class ChernobylGame.SuperEkstraMegaFractal
// (Actor)

class UClass* ASuperEkstraMegaFractal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SuperEkstraMegaFractal");

	return Clss;
}


// SuperEkstraMegaFractal ChernobylGame.Default__SuperEkstraMegaFractal
// (Public, ClassDefaultObject, ArchetypeObject)

class ASuperEkstraMegaFractal* ASuperEkstraMegaFractal::GetDefaultObj()
{
	static class ASuperEkstraMegaFractal* Default = nullptr;

	if (!Default)
		Default = static_cast<ASuperEkstraMegaFractal*>(ASuperEkstraMegaFractal::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.SwitchHeroToCustomView
// (None)

class UClass* USwitchHeroToCustomView::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SwitchHeroToCustomView");

	return Clss;
}


// SwitchHeroToCustomView ChernobylGame.Default__SwitchHeroToCustomView
// (Public, ClassDefaultObject, ArchetypeObject)

class USwitchHeroToCustomView* USwitchHeroToCustomView::GetDefaultObj()
{
	static class USwitchHeroToCustomView* Default = nullptr;

	if (!Default)
		Default = static_cast<USwitchHeroToCustomView*>(USwitchHeroToCustomView::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.SwitchHeroToCustomView.UncrouchFinished
// (Final, Native, Private)
// Parameters:

void USwitchHeroToCustomView::UncrouchFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SwitchHeroToCustomView", "UncrouchFinished");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction ChernobylGame.SwitchHeroToCustomView.SwitchHeroToCustomViewOutputPin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:

void USwitchHeroToCustomView::SwitchHeroToCustomViewOutputPin__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SwitchHeroToCustomView", "SwitchHeroToCustomViewOutputPin__DelegateSignature");



	UObject::ProcessEvent(Func, nullptr);

}


// Function ChernobylGame.SwitchHeroToCustomView.FSwitchHeroToGameplayView
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AMainPawnCpp*                InHero                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InBlendToTransform                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InBlendInTime                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USwitchHeroToCustomView*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USwitchHeroToCustomView* USwitchHeroToCustomView::FSwitchHeroToGameplayView(class AMainPawnCpp* InHero, const struct FTransform& InBlendToTransform, float InBlendInTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SwitchHeroToCustomView", "FSwitchHeroToGameplayView");

	Params::USwitchHeroToCustomView_FSwitchHeroToGameplayView_Params Parms{};

	Parms.InHero = InHero;
	Parms.InBlendToTransform = InBlendToTransform;
	Parms.InBlendInTime = InBlendInTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.SwitchHeroToCustomView.FSwitchHeroToCustomView
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AMainPawnCpp*                InHero                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InBlendToTransform                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              InBlendInTime                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendInCameraTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInShouldUncrouch                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInNoInputCam                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USwitchHeroToCustomView*     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USwitchHeroToCustomView* USwitchHeroToCustomView::FSwitchHeroToCustomView(class AMainPawnCpp* InHero, const struct FTransform& InBlendToTransform, float InBlendInTime, float InBlendInCameraTime, bool bInShouldUncrouch, bool bInNoInputCam)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SwitchHeroToCustomView", "FSwitchHeroToCustomView");

	Params::USwitchHeroToCustomView_FSwitchHeroToCustomView_Params Parms{};

	Parms.InHero = InHero;
	Parms.InBlendToTransform = InBlendToTransform;
	Parms.InBlendInTime = InBlendInTime;
	Parms.InBlendInCameraTime = InBlendInCameraTime;
	Parms.bInShouldUncrouch = bInShouldUncrouch;
	Parms.bInNoInputCam = bInNoInputCam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.TextWithEmbeddedImages
// (None)

class UClass* UTextWithEmbeddedImages::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextWithEmbeddedImages");

	return Clss;
}


// TextWithEmbeddedImages ChernobylGame.Default__TextWithEmbeddedImages
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextWithEmbeddedImages* UTextWithEmbeddedImages::GetDefaultObj()
{
	static class UTextWithEmbeddedImages* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextWithEmbeddedImages*>(UTextWithEmbeddedImages::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.TimedGodmodeBuff
// (None)

class UClass* UTimedGodmodeBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TimedGodmodeBuff");

	return Clss;
}


// TimedGodmodeBuff ChernobylGame.Default__TimedGodmodeBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UTimedGodmodeBuff* UTimedGodmodeBuff::GetDefaultObj()
{
	static class UTimedGodmodeBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UTimedGodmodeBuff*>(UTimedGodmodeBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.TimedSlowmoBuff
// (None)

class UClass* UTimedSlowmoBuff::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TimedSlowmoBuff");

	return Clss;
}


// TimedSlowmoBuff ChernobylGame.Default__TimedSlowmoBuff
// (Public, ClassDefaultObject, ArchetypeObject)

class UTimedSlowmoBuff* UTimedSlowmoBuff::GetDefaultObj()
{
	static class UTimedSlowmoBuff* Default = nullptr;

	if (!Default)
		Default = static_cast<UTimedSlowmoBuff*>(UTimedSlowmoBuff::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.TrainingPromptInput
// (None)

class UClass* ITrainingPromptInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TrainingPromptInput");

	return Clss;
}


// TrainingPromptInput ChernobylGame.Default__TrainingPromptInput
// (Public, ClassDefaultObject, ArchetypeObject)

class ITrainingPromptInput* ITrainingPromptInput::GetDefaultObj()
{
	static class ITrainingPromptInput* Default = nullptr;

	if (!Default)
		Default = static_cast<ITrainingPromptInput*>(ITrainingPromptInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.TrainingPromptInput.Up
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITrainingPromptInput::Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TrainingPromptInput", "Up");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.TrainingPromptInput.Select
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITrainingPromptInput::Select()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TrainingPromptInput", "Select");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.TrainingPromptInput.Down
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITrainingPromptInput::Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TrainingPromptInput", "Down");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.TutorialInput
// (None)

class UClass* ITutorialInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TutorialInput");

	return Clss;
}


// TutorialInput ChernobylGame.Default__TutorialInput
// (Public, ClassDefaultObject, ArchetypeObject)

class ITutorialInput* ITutorialInput::GetDefaultObj()
{
	static class ITutorialInput* Default = nullptr;

	if (!Default)
		Default = static_cast<ITutorialInput*>(ITutorialInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.TutorialInput.InputBackPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITutorialInput::InputBackPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialInput", "InputBackPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.TutorialInput.InputAcceptReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITutorialInput::InputAcceptReleased()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialInput", "InputAcceptReleased");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.TutorialInput.InputAcceptPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITutorialInput::InputAcceptPressed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialInput", "InputAcceptPressed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.TutorialInput.InputAccept
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void ITutorialInput::InputAccept()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TutorialInput", "InputAccept");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.UBlueprintInput
// (None)

class UClass* IUBlueprintInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UBlueprintInput");

	return Clss;
}


// UBlueprintInput ChernobylGame.Default__UBlueprintInput
// (Public, ClassDefaultObject, ArchetypeObject)

class IUBlueprintInput* IUBlueprintInput::GetDefaultObj()
{
	static class IUBlueprintInput* Default = nullptr;

	if (!Default)
		Default = static_cast<IUBlueprintInput*>(IUBlueprintInput::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.UBlueprintInput.InputOpenPDA
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IUBlueprintInput::InputOpenPDA()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UBlueprintInput", "InputOpenPDA");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function ChernobylGame.UBlueprintInput.InputActivateTutorial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:

void IUBlueprintInput::InputActivateTutorial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UBlueprintInput", "InputActivateTutorial");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.UpgradeComponent
// (None)

class UClass* UUpgradeComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UpgradeComponent");

	return Clss;
}


// UpgradeComponent ChernobylGame.Default__UpgradeComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UUpgradeComponent* UUpgradeComponent::GetDefaultObj()
{
	static class UUpgradeComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UUpgradeComponent*>(UUpgradeComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.UpgradeComponent.LearnBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BlueprintID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradeComponent::LearnBlueprint(enum class EUpgradeType Type, class FName BlueprintID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "LearnBlueprint");

	Params::UUpgradeComponent_LearnBlueprint_Params Parms{};

	Parms.Type = Type;
	Parms.BlueprintID = BlueprintID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.HasUpgrades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradeComponent::HasUpgrades(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "HasUpgrades");

	Params::UUpgradeComponent_HasUpgrades_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.HasAvailableUpgrades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradeComponent::HasAvailableUpgrades(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "HasAvailableUpgrades");

	Params::UUpgradeComponent_HasAvailableUpgrades_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetUpgrades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UUpgradeComponent::GetUpgrades(enum class EUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetUpgrades");

	Params::UUpgradeComponent_GetUpgrades_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetUpgradeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpradeID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsVaid                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUpgradeEntry               ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FUpgradeEntry UUpgradeComponent::GetUpgradeInfo(enum class EUpgradeType Type, class FName UpradeID, bool* IsVaid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetUpgradeInfo");

	Params::UUpgradeComponent_GetUpgradeInfo_Params Parms{};

	Parms.Type = Type;
	Parms.UpradeID = UpradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsVaid != nullptr)
		*IsVaid = Parms.IsVaid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetTriggerAdditionalInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGTriggerProperties        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGTriggerProperties UUpgradeComponent::GetTriggerAdditionalInfo(enum class EUpgradeType Type, class FName UpgradeID, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetTriggerAdditionalInfo");

	Params::UUpgradeComponent_GetTriggerAdditionalInfo_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, int32>           ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UUpgradeComponent::GetStats(enum class EUpgradeType Type, class FName UpgradeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetStats");

	Params::UUpgradeComponent_GetStats_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeName = UpgradeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetStaticMeshForAnUpgrade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UUpgradeComponent::GetStaticMeshForAnUpgrade(enum class EUpgradeType Type, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetStaticMeshForAnUpgrade");

	Params::UUpgradeComponent_GetStaticMeshForAnUpgrade_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetScopeAdditionalInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGScopeProperties          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGScopeProperties UUpgradeComponent::GetScopeAdditionalInfo(enum class EUpgradeType Type, class FName UpgradeID, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetScopeAdditionalInfo");

	Params::UUpgradeComponent_GetScopeAdditionalInfo_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetHandleAdditionalInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGHandleProperties         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGHandleProperties UUpgradeComponent::GetHandleAdditionalInfo(enum class EUpgradeType Type, class FName UpgradeID, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetHandleAdditionalInfo");

	Params::UUpgradeComponent_GetHandleAdditionalInfo_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetCraftedUpgrades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UUpgradeComponent::GetCraftedUpgrades(enum class EUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetCraftedUpgrades");

	Params::UUpgradeComponent_GetCraftedUpgrades_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetCategories
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ItemId                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FUpgradeCategory>    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FUpgradeCategory> UUpgradeComponent::GetCategories(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetCategories");

	Params::UUpgradeComponent_GetCategories_Params Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetBarrelAdditionalInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeID                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCGBarrelProperties         ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCGBarrelProperties UUpgradeComponent::GetBarrelAdditionalInfo(enum class EUpgradeType Type, class FName UpgradeID, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetBarrelAdditionalInfo");

	Params::UUpgradeComponent_GetBarrelAdditionalInfo_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetAvailableUpgrades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UUpgradeComponent::GetAvailableUpgrades(enum class EUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetAvailableUpgrades");

	Params::UUpgradeComponent_GetAvailableUpgrades_Params Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.GetAttachmentPointForUpgrade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        UpgradeName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UUpgradeComponent::GetAttachmentPointForUpgrade(class FName UpgradeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "GetAttachmentPointForUpgrade");

	Params::UUpgradeComponent_GetAttachmentPointForUpgrade_Params Parms{};

	Parms.UpgradeName = UpgradeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.ForgetBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BlueprintID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradeComponent::ForgetBlueprint(enum class EUpgradeType Type, class FName BlueprintID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "ForgetBlueprint");

	Params::UUpgradeComponent_ForgetBlueprint_Params Parms{};

	Parms.Type = Type;
	Parms.BlueprintID = BlueprintID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.UpgradeComponent.AddCraftedUpgrades
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// enum class EUpgradeType            Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        UpgradeName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUpgradeComponent::AddCraftedUpgrades(enum class EUpgradeType Type, class FName UpgradeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("UpgradeComponent", "AddCraftedUpgrades");

	Params::UUpgradeComponent_AddCraftedUpgrades_Params Parms{};

	Parms.Type = Type;
	Parms.UpgradeName = UpgradeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.WaitForLevelUnloadedAsyncNode
// (None)

class UClass* UWaitForLevelUnloadedAsyncNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WaitForLevelUnloadedAsyncNode");

	return Clss;
}


// WaitForLevelUnloadedAsyncNode ChernobylGame.Default__WaitForLevelUnloadedAsyncNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UWaitForLevelUnloadedAsyncNode* UWaitForLevelUnloadedAsyncNode::GetDefaultObj()
{
	static class UWaitForLevelUnloadedAsyncNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UWaitForLevelUnloadedAsyncNode*>(UWaitForLevelUnloadedAsyncNode::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.WaitForLevelUnloadedAsyncNode.WaitForLevelUnloadedAsyncNode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LevelName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CheckInterval                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Timeout                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaitForLevelUnloadedAsyncNode*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaitForLevelUnloadedAsyncNode* UWaitForLevelUnloadedAsyncNode::WaitForLevelUnloadedAsyncNode(class UObject* WorldContextObject, const class FString& LevelName, float CheckInterval, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WaitForLevelUnloadedAsyncNode", "WaitForLevelUnloadedAsyncNode");

	Params::UWaitForLevelUnloadedAsyncNode_WaitForLevelUnloadedAsyncNode_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.CheckInterval = CheckInterval;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function ChernobylGame.WaitForLevelUnloadedAsyncNode.CheckIsUnloaded
// (Final, Native, Private)
// Parameters:

void UWaitForLevelUnloadedAsyncNode::CheckIsUnloaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WaitForLevelUnloadedAsyncNode", "CheckIsUnloaded");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class ChernobylGame.CrystalGeneratorProperties
// (None)

class UClass* UCrystalGeneratorProperties::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CrystalGeneratorProperties");

	return Clss;
}


// CrystalGeneratorProperties ChernobylGame.Default__CrystalGeneratorProperties
// (Public, ClassDefaultObject, ArchetypeObject)

class UCrystalGeneratorProperties* UCrystalGeneratorProperties::GetDefaultObj()
{
	static class UCrystalGeneratorProperties* Default = nullptr;

	if (!Default)
		Default = static_cast<UCrystalGeneratorProperties*>(UCrystalGeneratorProperties::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.WallCrystalGeneratorComponent
// (None)

class UClass* UWallCrystalGeneratorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WallCrystalGeneratorComponent");

	return Clss;
}


// WallCrystalGeneratorComponent ChernobylGame.Default__WallCrystalGeneratorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UWallCrystalGeneratorComponent* UWallCrystalGeneratorComponent::GetDefaultObj()
{
	static class UWallCrystalGeneratorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UWallCrystalGeneratorComponent*>(UWallCrystalGeneratorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.WallCrystalGenerator
// (Actor)

class UClass* AWallCrystalGenerator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WallCrystalGenerator");

	return Clss;
}


// WallCrystalGenerator ChernobylGame.Default__WallCrystalGenerator
// (Public, ClassDefaultObject, ArchetypeObject)

class AWallCrystalGenerator* AWallCrystalGenerator::GetDefaultObj()
{
	static class AWallCrystalGenerator* Default = nullptr;

	if (!Default)
		Default = static_cast<AWallCrystalGenerator*>(AWallCrystalGenerator::StaticClass()->DefaultObject);

	return Default;
}


// Class ChernobylGame.WidgetFunctionLibrary
// (None)

class UClass* UWidgetFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WidgetFunctionLibrary");

	return Clss;
}


// WidgetFunctionLibrary ChernobylGame.Default__WidgetFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UWidgetFunctionLibrary* UWidgetFunctionLibrary::GetDefaultObj()
{
	static class UWidgetFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UWidgetFunctionLibrary*>(UWidgetFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function ChernobylGame.WidgetFunctionLibrary.ScalePositionByDPI
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetFunctionLibrary::ScalePositionByDPI(const struct FVector2D& Position)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WidgetFunctionLibrary", "ScalePositionByDPI");

	Params::UWidgetFunctionLibrary_ScalePositionByDPI_Params Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class ChernobylGame.WW3AimAssistCapsuleComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UWW3AimAssistCapsuleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WW3AimAssistCapsuleComponent");

	return Clss;
}


// WW3AimAssistCapsuleComponent ChernobylGame.Default__WW3AimAssistCapsuleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UWW3AimAssistCapsuleComponent* UWW3AimAssistCapsuleComponent::GetDefaultObj()
{
	static class UWW3AimAssistCapsuleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UWW3AimAssistCapsuleComponent*>(UWW3AimAssistCapsuleComponent::StaticClass()->DefaultObject);

	return Default;
}

}


